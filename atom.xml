<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>个人博客</title>
  
  <subtitle>博观而约取 厚积而薄发</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zofun.github.io/"/>
  <updated>2020-05-11T09:36:19.458Z</updated>
  <id>https://zofun.github.io/</id>
  
  <author>
    <name>zofun</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Dubbo集群容错</title>
    <link href="https://zofun.github.io/2020/05/11/Dubbo%E9%9B%86%E7%BE%A4%E5%AE%B9%E9%94%99/"/>
    <id>https://zofun.github.io/2020/05/11/Dubbo集群容错/</id>
    <published>2020-05-11T09:36:00.000Z</published>
    <updated>2020-05-11T09:36:19.458Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="简介">简介</span></h2><p>Dubbo集群容错方面的源码包括四个部分，分别式服务目录Directory、服务路由Router、集群Cluster和负载均衡LoadBalance。</p><p>它们之间的关系是这样的：</p><p><img src="https://s1.ax1x.com/2020/05/11/YJAi1H.png" alt="YJAi1H.png"></p><a id="more"></a><h2><span id="服务目录">服务目录</span></h2><h2><span id="简介">简介</span></h2><p>服务目录中存储了服务提供者有关的信息，通过服务目录，服务消费者可以获取到服务提供者的信息，比如IP、端口、服务协议等。通过这些信息，服务消费者就可以进行远程服务调用了。服务提供者的信息是有变动的，因此服务目录中的信息也有要做相应的变更。</p><p>而服务目录中的信息，其实又是从注册中心中获取的，然后根据从注册中心中获取的信息为每条配置信息生成一个<code>Invoker</code>对象。</p><p>因此简单来讲服务目录就是一个会根据注册中心的有关信息进行相应调整的<code>Invoker</code>集合。</p><p>Dubbo中服务目录的继承体系如图：</p><p><img src="https://s1.ax1x.com/2020/05/11/YGIuMn.png" alt="YGIuMn.png"></p><h3><span id="源码分析">源码分析</span></h3><p>针对服务目录，我们主要分析一个<code>AbstractDirectory</code>和它的两个子类。</p><p>下面我们来看<code>AbstractDirectory</code>的具体实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Invoker&lt;T&gt;&gt; list(Invocation invocation) <span class="keyword">throws</span> RpcException &#123;</span><br><span class="line">    <span class="keyword">if</span> (destroyed) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Directory already destroyed..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用 doList 方法列举 Invoker，doList 是模板方法，由子类实现</span></span><br><span class="line">    List&lt;Invoker&lt;T&gt;&gt; invokers = doList(invocation);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取路由 Router 列表</span></span><br><span class="line">    List&lt;Router&gt; localRouters = <span class="keyword">this</span>.routers;</span><br><span class="line">    <span class="keyword">if</span> (localRouters != <span class="keyword">null</span> &amp;&amp; !localRouters.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Router router : localRouters) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 获取 runtime 参数，并根据参数决定是否进行路由</span></span><br><span class="line">                <span class="keyword">if</span> (router.getUrl() == <span class="keyword">null</span> || router.getUrl().getParameter(Constants.RUNTIME_KEY, <span class="keyword">false</span>)) &#123;</span><br><span class="line">                    <span class="comment">// 进行服务路由</span></span><br><span class="line">                    invokers = router.route(invokers, getConsumerUrl(), invocation);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                logger.error(<span class="string">"Failed to execute router: ..."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> invokers;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板方法，由子类实现</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">abstract</span> List&lt;Invoker&lt;T&gt;&gt; doList(Invocation invocation) <span class="keyword">throws</span> RpcException;</span><br></pre></td></tr></table></figure><p><code>AbstractDirectory</code>的<code>list</code>方法，主要完成两件事情：</p><ol><li>通过<code>doList</code>获取<code>Invoker</code>列表</li><li>根据<code>Router</code>的<code>getUrl</code>返回值为空与否，以及runtime参数决定是否进行服务路由。</li></ol><p>这里的<code>doList</code>方法其实是一个模板方法，由它的子类来负责具体的实现。</p><p>那么下面我们就来看一看它的两个子类是如何实现这个方法的。</p><h4><span id="staticdirectory">StaticDirectory</span></h4><p><code>StaticDirectory</code>即静态服务目录，它内部存放的<code>Invoker</code>集合是不会变动的。它的源码实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticDirectory</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractDirectory</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Invoker 列表</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Invoker&lt;T&gt;&gt; invokers;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略构造方法</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Class&lt;T&gt; <span class="title">getInterface</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取接口类</span></span><br><span class="line">        <span class="keyword">return</span> invokers.get(<span class="number">0</span>).getInterface();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检测服务目录是否可用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAvailable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isDestroyed()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Invoker&lt;T&gt; invoker : invokers) &#123;</span><br><span class="line">            <span class="keyword">if</span> (invoker.isAvailable()) &#123;</span><br><span class="line">                <span class="comment">// 只要有一个 Invoker 是可用的，就认为当前目录是可用的</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isDestroyed()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 调用父类销毁逻辑</span></span><br><span class="line">        <span class="keyword">super</span>.destroy();</span><br><span class="line">        <span class="comment">// 遍历 Invoker 列表，并执行相应的销毁逻辑</span></span><br><span class="line">        <span class="keyword">for</span> (Invoker&lt;T&gt; invoker : invokers) &#123;</span><br><span class="line">            invoker.destroy();</span><br><span class="line">        &#125;</span><br><span class="line">        invokers.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> List&lt;Invoker&lt;T&gt;&gt; doList(Invocation invocation) <span class="keyword">throws</span> RpcException &#123;</span><br><span class="line">        <span class="comment">// 列举 Inovker，也就是直接返回 invokers 成员变量</span></span><br><span class="line">        <span class="keyword">return</span> invokers;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的实现非常的简单。</p><h4><span id="registrydirctory">RegistryDirctory</span></h4><p><code>RegistryDirectory</code>是一种动态服务目录，它会根据注册中心中服务配置的变化而动态的变化。因此<code>RegistryDirectory</code>中比较关键的点就在于，它是如何进行<code>Invoker</code>列举的？它是如何接收服务配置信息变更的？它是如何刷新<code>Invoker</code>列表的。</p><h5><span id="列举invoker">列举Invoker</span></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Invoker&lt;T&gt;&gt; doList(Invocation invocation) &#123;</span><br><span class="line">    <span class="keyword">if</span> (forbidden) &#123;</span><br><span class="line">        <span class="comment">// 服务提供者关闭或禁用了服务，此时抛出 No provider 异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcException.FORBIDDEN_EXCEPTION,</span><br><span class="line">            <span class="string">"No provider available from registry ..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Invoker&lt;T&gt;&gt; invokers = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 获取 Invoker 本地缓存</span></span><br><span class="line">    Map&lt;String, List&lt;Invoker&lt;T&gt;&gt;&gt; localMethodInvokerMap = <span class="keyword">this</span>.methodInvokerMap;</span><br><span class="line">    <span class="keyword">if</span> (localMethodInvokerMap != <span class="keyword">null</span> &amp;&amp; localMethodInvokerMap.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取方法名和参数列表</span></span><br><span class="line">        String methodName = RpcUtils.getMethodName(invocation);</span><br><span class="line">        Object[] args = RpcUtils.getArguments(invocation);</span><br><span class="line">        <span class="comment">// 检测参数列表的第一个参数是否为 String 或 enum 类型</span></span><br><span class="line">        <span class="keyword">if</span> (args != <span class="keyword">null</span> &amp;&amp; args.length &gt; <span class="number">0</span> &amp;&amp; args[<span class="number">0</span>] != <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; (args[<span class="number">0</span>] <span class="keyword">instanceof</span> String || args[<span class="number">0</span>].getClass().isEnum())) &#123;</span><br><span class="line">            <span class="comment">// 通过 方法名 + 第一个参数名称 查询 Invoker 列表，具体的使用场景暂时没想到</span></span><br><span class="line">            invokers = localMethodInvokerMap.get(methodName + <span class="string">"."</span> + args[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (invokers == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 通过方法名获取 Invoker 列表</span></span><br><span class="line">            invokers = localMethodInvokerMap.get(methodName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (invokers == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 通过星号 * 获取 Invoker 列表</span></span><br><span class="line">            invokers = localMethodInvokerMap.get(Constants.ANY_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 冗余逻辑，pull request #2861 移除了下面的 if 分支代码</span></span><br><span class="line">        <span class="keyword">if</span> (invokers == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Iterator&lt;List&lt;Invoker&lt;T&gt;&gt;&gt; iterator = localMethodInvokerMap.values().iterator();</span><br><span class="line">            <span class="keyword">if</span> (iterator.hasNext()) &#123;</span><br><span class="line">                invokers = iterator.next();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回 Invoker 列表</span></span><br><span class="line">    <span class="keyword">return</span> invokers == <span class="keyword">null</span> ? <span class="keyword">new</span> ArrayList&lt;Invoker&lt;T&gt;&gt;(<span class="number">0</span>) : invokers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Invoker</code>的列举逻辑还是比较简单的，主要就是从<code>localMethodInvokerMap</code>中获取对应的<code>Invoker</code></p><h5><span id="接收服务变更通知">接收服务变更通知</span></h5><p><code>RegistryDirectory</code>是一个动态服务目录，会随注册中心配置的变化而进行动态调整，因此<code>RegistryDirectory</code>实现了<code>NotifyListener</code>接口，通过这个接口获取注册中心变更通知。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(List&lt;URL&gt; urls)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义三个集合，分别用于存放服务提供者 url，路由 url，配置器 url</span></span><br><span class="line">    List&lt;URL&gt; invokerUrls = <span class="keyword">new</span> ArrayList&lt;URL&gt;();</span><br><span class="line">    List&lt;URL&gt; routerUrls = <span class="keyword">new</span> ArrayList&lt;URL&gt;();</span><br><span class="line">    List&lt;URL&gt; configuratorUrls = <span class="keyword">new</span> ArrayList&lt;URL&gt;();</span><br><span class="line">    <span class="keyword">for</span> (URL url : urls) &#123;</span><br><span class="line">        String protocol = url.getProtocol();</span><br><span class="line">        <span class="comment">// 获取 category 参数</span></span><br><span class="line">        String category = url.getParameter(Constants.CATEGORY_KEY, Constants.DEFAULT_CATEGORY);</span><br><span class="line">        <span class="comment">// 根据 category 参数将 url 分别放到不同的列表中</span></span><br><span class="line">        <span class="keyword">if</span> (Constants.ROUTERS_CATEGORY.equals(category)</span><br><span class="line">                || Constants.ROUTE_PROTOCOL.equals(protocol)) &#123;</span><br><span class="line">            <span class="comment">// 添加路由器 url</span></span><br><span class="line">            routerUrls.add(url);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Constants.CONFIGURATORS_CATEGORY.equals(category)</span><br><span class="line">                || Constants.OVERRIDE_PROTOCOL.equals(protocol)) &#123;</span><br><span class="line">            <span class="comment">// 添加配置器 url</span></span><br><span class="line">            configuratorUrls.add(url);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Constants.PROVIDERS_CATEGORY.equals(category)) &#123;</span><br><span class="line">            <span class="comment">// 添加服务提供者 url</span></span><br><span class="line">            invokerUrls.add(url);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 忽略不支持的 category</span></span><br><span class="line">            logger.warn(<span class="string">"Unsupported category ..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (configuratorUrls != <span class="keyword">null</span> &amp;&amp; !configuratorUrls.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 将 url 转成 Configurator</span></span><br><span class="line">        <span class="keyword">this</span>.configurators = toConfigurators(configuratorUrls);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (routerUrls != <span class="keyword">null</span> &amp;&amp; !routerUrls.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 将 url 转成 Router</span></span><br><span class="line">        List&lt;Router&gt; routers = toRouters(routerUrls);</span><br><span class="line">        <span class="keyword">if</span> (routers != <span class="keyword">null</span>) &#123;</span><br><span class="line">            setRouters(routers);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Configurator&gt; localConfigurators = <span class="keyword">this</span>.configurators;</span><br><span class="line">    <span class="keyword">this</span>.overrideDirectoryUrl = directoryUrl;</span><br><span class="line">    <span class="keyword">if</span> (localConfigurators != <span class="keyword">null</span> &amp;&amp; !localConfigurators.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Configurator configurator : localConfigurators) &#123;</span><br><span class="line">            <span class="comment">// 配置 overrideDirectoryUrl</span></span><br><span class="line">            <span class="keyword">this</span>.overrideDirectoryUrl = configurator.configure(overrideDirectoryUrl);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 刷新 Invoker 列表</span></span><br><span class="line">    refreshInvoker(invokerUrls);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>notify</code> 方法首先是根据 <code>url</code> 的 <code>category</code> 参数对 <code>url</code> 进行分门别类存储，然后通过 <code>toRouters</code> 和 <code>toConfigurators</code> 将<code>url</code> 列表转成 <code>Router</code> 和<code>Configurator</code> 列表。最后调用 <code>refreshInvoker</code> 方法刷新 <code>Invoker</code> 列表。</p><h5><span id="刷新invoker列表">刷新Invoker列表</span></h5><p>refreshInvoker 方法是保证 RegistryDirectory 随注册中心变化而变化的关键所在。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">refreshInvoker</span><span class="params">(List&lt;URL&gt; invokerUrls)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// invokerUrls 仅有一个元素，且 url 协议头为 empty，此时表示禁用所有服务</span></span><br><span class="line">    <span class="keyword">if</span> (invokerUrls != <span class="keyword">null</span> &amp;&amp; invokerUrls.size() == <span class="number">1</span> &amp;&amp; invokerUrls.get(<span class="number">0</span>) != <span class="keyword">null</span></span><br><span class="line">            &amp;&amp; Constants.EMPTY_PROTOCOL.equals(invokerUrls.get(<span class="number">0</span>).getProtocol())) &#123;</span><br><span class="line">        <span class="comment">// 设置 forbidden 为 true</span></span><br><span class="line">        <span class="keyword">this</span>.forbidden = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">this</span>.methodInvokerMap = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 销毁所有 Invoker</span></span><br><span class="line">        destroyAllInvokers();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.forbidden = <span class="keyword">false</span>;</span><br><span class="line">        Map&lt;String, Invoker&lt;T&gt;&gt; oldUrlInvokerMap = <span class="keyword">this</span>.urlInvokerMap;</span><br><span class="line">        <span class="keyword">if</span> (invokerUrls.isEmpty() &amp;&amp; <span class="keyword">this</span>.cachedInvokerUrls != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 添加缓存 url 到 invokerUrls 中</span></span><br><span class="line">            invokerUrls.addAll(<span class="keyword">this</span>.cachedInvokerUrls);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.cachedInvokerUrls = <span class="keyword">new</span> HashSet&lt;URL&gt;();</span><br><span class="line">            <span class="comment">// 缓存 invokerUrls</span></span><br><span class="line">            <span class="keyword">this</span>.cachedInvokerUrls.addAll(invokerUrls);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (invokerUrls.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将 url 转成 Invoker</span></span><br><span class="line">        Map&lt;String, Invoker&lt;T&gt;&gt; newUrlInvokerMap = toInvokers(invokerUrls);</span><br><span class="line">        <span class="comment">// 将 newUrlInvokerMap 转成方法名到 Invoker 列表的映射</span></span><br><span class="line">        Map&lt;String, List&lt;Invoker&lt;T&gt;&gt;&gt; newMethodInvokerMap = toMethodInvokers(newUrlInvokerMap);</span><br><span class="line">        <span class="comment">// 转换出错，直接打印异常，并返回</span></span><br><span class="line">        <span class="keyword">if</span> (newUrlInvokerMap == <span class="keyword">null</span> || newUrlInvokerMap.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            logger.error(<span class="keyword">new</span> IllegalStateException(<span class="string">"urls to invokers error ..."</span>));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 合并多个组的 Invoker</span></span><br><span class="line">        <span class="keyword">this</span>.methodInvokerMap = multiGroup ? toMergeMethodInvokerMap(newMethodInvokerMap) : newMethodInvokerMap;</span><br><span class="line">        <span class="keyword">this</span>.urlInvokerMap = newUrlInvokerMap;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 销毁无用 Invoker</span></span><br><span class="line">            destroyUnusedInvokers(oldUrlInvokerMap, newUrlInvokerMap);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.warn(<span class="string">"destroyUnusedInvokers error. "</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>refreshInvoker</code> 方法首先会根据入参 <code>invokerUrls</code> 的数量和协议头判断是否禁用所有的服务，如果禁用，则将  <code>forbidden</code>设为 <code>true</code>，并销毁所有的 <code>Invoker</code>。若不禁用，则将 <code>url</code> 转成 <code>Invoker</code>，得到 <code>&lt;url,  Invoker&gt;</code> 的映射关系。然后进一步进行转换，得到 <code>&lt;methodName, Invoker 列表&gt;</code>映射关系。之后进行多组 <code>Invoker</code>合并操作，并将合并结果赋值给 <code>methodInvokerMap</code>。<code>methodInvokerMap</code> 变量在 <code>doList</code> 方法中会被用到，<code>doList</code> 会对该变量进行读操作，在这里是写操作。当新的 <code>Invoker</code>  列表生成后，还要一个重要的工作要做，就是销毁无用的 <code>Invoker</code>，避免服务消费者调用已下线的服务的服务。</p><p>到此就实现了<code>Invoker</code>的刷新。</p><h2><span id="服务路由">服务路由</span></h2><h3><span id="简介">简介</span></h3><p>服务路由就是包含一条路由规则，路由规则决定了服务消费者的调用目标，即规定了服务消费者可调用可调用哪些服务提供者。Dubbo目前提供了三种服务路由实现，分别是条件路<code>ConditionRouter</code>、脚本路由<code>ScriptRounter</code>和标签路路由<code>TagRounter</code>。其中条件路由是我们最常用的。</p><h2><span id="源码分析">源码分析</span></h2><p>下面我们就以条件路由为例进行源码分析。</p><p>条件路由规则有两个条件组成，分别用于对服务消费者和提供者进行匹配。比如有这样一条规则：</p><p><code>host=10.20.153.10 =&gt; host=12.20.153.11</code></p><p>这条规则表明IP<code>10.20.153.10</code>的服务消费者只能调用IP为10.20.153.11机器上的服务，不可调用其它机器上的服务。条件路由规则的格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[服务消费者匹配条件] =&gt; [服务提供者匹配条件]</span><br></pre></td></tr></table></figure><h4><span id="表达式解析">表达式解析</span></h4><p>路由规则是一条字符串表达式，在进行路由之前会先进行条件表达式解析，具体的解析过程这里就不看源码了。</p><p>只需要知道通过解之后，得到一个<code>Map&lt;String, MatchPair&gt; condition</code>.解析后的信息，以这样的格式进行表示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"host"</span>: &#123;</span><br><span class="line">        <span class="string">"matches"</span>: [<span class="string">"2.2.2.2"</span>],</span><br><span class="line">        <span class="string">"mismatches"</span>: [<span class="string">"1.1.1.1"</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"method"</span>: &#123;</span><br><span class="line">        <span class="string">"matches"</span>: [<span class="string">"hello"</span>],</span><br><span class="line">        <span class="string">"mismatches"</span>: []</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="路由服务">路由服务</span></h4><p>服务路由的入口方法是<code>ConditionRouter</code>的<code>route</code>方法，该方法定义在<code>Router</code>接口中，实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; List&lt;Invoker&lt;T&gt;&gt; route(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation) <span class="keyword">throws</span> RpcException &#123;</span><br><span class="line">    <span class="keyword">if</span> (invokers == <span class="keyword">null</span> || invokers.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> invokers;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 先对服务消费者条件进行匹配，如果匹配失败，表明服务消费者 url 不符合匹配规则，</span></span><br><span class="line">        <span class="comment">// 无需进行后续匹配，直接返回 Invoker 列表即可。比如下面的规则：</span></span><br><span class="line">        <span class="comment">//     host = 10.20.153.10 =&gt; host = 10.0.0.10</span></span><br><span class="line">        <span class="comment">// 这条路由规则希望 IP 为 10.20.153.10 的服务消费者调用 IP 为 10.0.0.10 机器上的服务。</span></span><br><span class="line">        <span class="comment">// 当消费者 ip 为 10.20.153.11 时，matchWhen 返回 false，表明当前这条路由规则不适用于</span></span><br><span class="line">        <span class="comment">// 当前的服务消费者，此时无需再进行后续匹配，直接返回即可。</span></span><br><span class="line">        <span class="keyword">if</span> (!matchWhen(url, invocation)) &#123;</span><br><span class="line">            <span class="keyword">return</span> invokers;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Invoker&lt;T&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;Invoker&lt;T&gt;&gt;();</span><br><span class="line">        <span class="comment">// 服务提供者匹配条件未配置，表明对指定的服务消费者禁用服务，也就是服务消费者在黑名单中</span></span><br><span class="line">        <span class="keyword">if</span> (thenCondition == <span class="keyword">null</span>) &#123;</span><br><span class="line">            logger.warn(<span class="string">"The current consumer in the service blacklist..."</span>);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里可以简单的把 Invoker 理解为服务提供者，现在使用服务提供者匹配规则对 </span></span><br><span class="line">        <span class="comment">// Invoker 列表进行匹配</span></span><br><span class="line">        <span class="keyword">for</span> (Invoker&lt;T&gt; invoker : invokers) &#123;</span><br><span class="line">            <span class="comment">// 若匹配成功，表明当前 Invoker 符合服务提供者匹配规则。</span></span><br><span class="line">            <span class="comment">// 此时将 Invoker 添加到 result 列表中</span></span><br><span class="line">            <span class="keyword">if</span> (matchThen(invoker.getUrl(), url)) &#123;</span><br><span class="line">                result.add(invoker);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 返回匹配结果，如果 result 为空列表，且 force = true，表示强制返回空列表，</span></span><br><span class="line">        <span class="comment">// 否则路由结果为空的路由规则将自动失效</span></span><br><span class="line">        <span class="keyword">if</span> (!result.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (force) &#123;</span><br><span class="line">            logger.warn(<span class="string">"The route result is empty and force execute ..."</span>);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        logger.error(<span class="string">"Failed to execute condition router rule: ..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 原样返回，此时 force = false，表示该条路由规则失效</span></span><br><span class="line">    <span class="keyword">return</span> invokers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>route</code> 方法先是调用 <code>matchWhen</code> 对服务消费者进行匹配，如果匹配失败，直接返回 <code>Invoker</code> 列表。如果匹配成功，再对服务提供者进行匹配，匹配逻辑封装在了 <code>matchThen</code> 方法中。</p><h2><span id="集群">集群</span></h2><h3><span id="简介">简介</span></h3><p>为了避免单点故障，现在应用通常至少会部署在两台服务器上。对于一些负载比较高的服务，会部署更多的服务器。对于服务消费者来说，同一环境下出现了多个服务提供者。这时会出现一个问题，服务消费者需要决定选择哪个服务提供者进行调用。另外服务调用失败时的处理措施也是需要考虑的。为了处理这些问题，Dubbo定义了集群接口<code>Cluster</code>以及<code>Cluster Invoker</code>.集群<code>Cluster</code> 用途是将多个服务提供者合并为一个 <code>Cluster Invoker</code>，并将这个 <code>Invoker</code>  暴露给服务消费者。这样一来，服务消费者只需通过这个 <code>Invoker</code>  进行远程调用即可，至于具体调用哪个服务提供者，以及调用失败后如何处理等问题，现在都交给集群模块去处理。集群模块是服务提供者和服务消费者的中间层，为服务消费者屏蔽了服务提供者的情况，这样服务消费者就可以专心处理远程调用相关事宜。</p><p><img src="https://s1.ax1x.com/2020/05/11/YJAi1H.png" alt="YJAi1H.png"></p><p>集群工作过程可分为两个阶段，第一个阶段是在服务消费者初始化期间，集群 <code>Cluster</code> 实现类为服务消费者创建 <code>Cluster Invoker</code> 实例，即上图中的<code>merge</code> 操作。</p><p>第二个阶段是在服务消费者进行远程调用时。以 <code>FailoverClusterInvoker</code> 为例，该类型  <code>Cluster Invoker</code> 首先会调用<code>Directory</code> 的<code>list</code> 方法列举 <code>Invoker</code> 列表（可将 <code>Invoker</code>  简单理解为服务提供者）。<code>Directory</code>的用途是保存 <code>Invoker</code>，可简单类比为 <code>List&lt;Invoker&gt;</code>。其实现类 <code>RegistryDirectory</code> 是一个动态服务目录，可感知注册中心配置的变化，它所持有的 <code>Invoker</code>  列表会随着注册中心内容的变化而变化。每次变化后，<code>RegistryDirectory</code> 会动态增删 <code>Invoker</code>，并调用 <code>Router</code> 的 <code>route</code>方法进行路由，过滤掉不符合路由规则的 <code>Invoker</code>。当 <code>FailoverClusterInvoker</code> 拿到<code>Directory</code>  返回的 <code>Invoker</code> 列表后，它会通过<code>LoadBalance</code>从 <code>Invoker</code> 列表中选择一个 <code>Invoker</code>。最后  <code>FailoverClusterInvoker</code> 会将参数传给 <code>LoadBalance</code> 选择出的 <code>Invoker</code> 实例的 <code>invoke</code>  方法，进行真正的远程调用。</p><p>Dubbo集群提供了以下几种容错机制：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Failover Cluster - 失败自动切换</span><br><span class="line">Failfast Cluster - 快速失败</span><br><span class="line">Failsafe Cluster - 失败安全</span><br><span class="line">Failback Cluster - 失败自动恢复</span><br><span class="line">Forking Cluster - 并行调用多个服务提供者</span><br></pre></td></tr></table></figure><h3><span id="源码分析">源码分析</span></h3><h4><span id="cluster实现类分析">Cluster实现类分析</span></h4><p><code>Cluster</code>的实现类负责生成<code>Cluster Invoker</code>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FailoverCluster</span> <span class="keyword">implements</span> <span class="title">Cluster</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String NAME = <span class="string">"failover"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">join</span><span class="params">(Directory&lt;T&gt; directory)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建并返回 FailoverClusterInvoker 对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FailoverClusterInvoker&lt;T&gt;(directory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的实现类的逻辑比较简单.</p><h4><span id="cluster-invoker分析">Cluster Invoker分析</span></h4><p>我们首先从各种 <code>Cluster Invoker</code>的父类 <code>AbstractClusterInvoker</code> 源码开始说起。前面说过，集群工作过程可分为两个阶段，第一个阶段是在服务消费者初始化期间，即服务引出。第二个阶段是在服务消费者进行远程调用时，此时<code>AbstractClusterInvoker</code>的 <code>invoke</code> 方法会被调用。列举 <code>Invoker</code>，负载均衡等操作均会在此阶段被执行。因此下面先来看一下 <code>invoke</code>方法的逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(<span class="keyword">final</span> Invocation invocation)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">    checkWhetherDestroyed();</span><br><span class="line">    LoadBalance loadbalance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定 attachments 到 invocation 中.</span></span><br><span class="line">    Map&lt;String, String&gt; contextAttachments = RpcContext.getContext().getAttachments();</span><br><span class="line">    <span class="keyword">if</span> (contextAttachments != <span class="keyword">null</span> &amp;&amp; contextAttachments.size() != <span class="number">0</span>) &#123;</span><br><span class="line">        ((RpcInvocation) invocation).addAttachments(contextAttachments);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 列举 Invoker</span></span><br><span class="line">    List&lt;Invoker&lt;T&gt;&gt; invokers = list(invocation);</span><br><span class="line">    <span class="keyword">if</span> (invokers != <span class="keyword">null</span> &amp;&amp; !invokers.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 加载 LoadBalance</span></span><br><span class="line">        loadbalance = ExtensionLoader.getExtensionLoader(LoadBalance.class).getExtension(invokers.get(<span class="number">0</span>).getUrl()</span><br><span class="line">                .getMethodParameter(RpcUtils.getMethodName(invocation), Constants.LOADBALANCE_KEY, Constants.DEFAULT_LOADBALANCE));</span><br><span class="line">    &#125;</span><br><span class="line">    RpcUtils.attachInvocationIdIfAsync(getUrl(), invocation);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用 doInvoke 进行后续操作</span></span><br><span class="line">    <span class="keyword">return</span> doInvoke(invocation, invokers, loadbalance);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象方法，由子类实现</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Result <span class="title">doInvoke</span><span class="params">(Invocation invocation, List&lt;Invoker&lt;T&gt;&gt; invokers,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       LoadBalance loadbalance)</span> <span class="keyword">throws</span> RpcException</span>;</span><br></pre></td></tr></table></figure><p><code>AbstractClusterInvoker</code> 的 <code>invoke</code> 方法主要用于列举<code>Invoker</code>，以及加载<code>LoadBalance</code>，最后在调用模板方法<code>doInvoke</code>进行后序操作。</p><p>下面我们来看<code>FailoverClusterInvoker</code>是如何实现<code>doInvoke</code>的，它在调用失败后，会自动切换<code>Invoke</code>进行重试。它是缺省的<code>Cluster Invoker</code>实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FailoverClusterInvoker</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractClusterInvoker</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略部分代码</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">doInvoke</span><span class="params">(Invocation invocation, <span class="keyword">final</span> List&lt;Invoker&lt;T&gt;&gt; invokers, LoadBalance loadbalance)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        List&lt;Invoker&lt;T&gt;&gt; copyinvokers = invokers;</span><br><span class="line">        checkInvokers(copyinvokers, invocation);</span><br><span class="line">        <span class="comment">// 获取重试次数</span></span><br><span class="line">        <span class="keyword">int</span> len = getUrl().getMethodParameter(invocation.getMethodName(), Constants.RETRIES_KEY, Constants.DEFAULT_RETRIES) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            len = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        RpcException le = <span class="keyword">null</span>;</span><br><span class="line">        List&lt;Invoker&lt;T&gt;&gt; invoked = <span class="keyword">new</span> ArrayList&lt;Invoker&lt;T&gt;&gt;(copyinvokers.size());</span><br><span class="line">        Set&lt;String&gt; providers = <span class="keyword">new</span> HashSet&lt;String&gt;(len);</span><br><span class="line">        <span class="comment">// 循环调用，失败重试</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                checkWhetherDestroyed();</span><br><span class="line">                <span class="comment">// 在进行重试前重新列举 Invoker，这样做的好处是，如果某个服务挂了，</span></span><br><span class="line">                <span class="comment">// 通过调用 list 可得到最新可用的 Invoker 列表</span></span><br><span class="line">                copyinvokers = list(invocation);</span><br><span class="line">                <span class="comment">// 对 copyinvokers 进行判空检查</span></span><br><span class="line">                checkInvokers(copyinvokers, invocation);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 通过负载均衡选择 Invoker</span></span><br><span class="line">            Invoker&lt;T&gt; invoker = select(loadbalance, invocation, copyinvokers, invoked);</span><br><span class="line">            <span class="comment">// 添加到 invoker 到 invoked 列表中</span></span><br><span class="line">            invoked.add(invoker);</span><br><span class="line">            <span class="comment">// 设置 invoked 到 RPC 上下文中</span></span><br><span class="line">            RpcContext.getContext().setInvokers((List) invoked);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 调用目标 Invoker 的 invoke 方法</span></span><br><span class="line">                Result result = invoker.invoke(invocation);</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RpcException e) &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.isBiz()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> e;</span><br><span class="line">                &#125;</span><br><span class="line">                le = e;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                le = <span class="keyword">new</span> RpcException(e.getMessage(), e);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                providers.add(invoker.getUrl().getAddress());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 若重试失败，则抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(..., <span class="string">"Failed to invoke the method ..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>FailoverClusterInvoker</code> 的 <code>doInvoke</code> 方法首先是获取重试次数，然后根据重试次数进行循环调用，失败后进行重试。在  for 循环内，首先是通过负载均衡组件选择一个 <code>Invoker</code>，然后再通过这个 <code>Invoker</code> 的 <code>invoke</code>方法进行远程调用。如果失败了，记录下异常，并进行重试。重试时会再次调用父类的<code>list</code> 方法列举 <code>Invoker</code>。</p><p>在选择<code>Invoker</code>的时候，使用了<code>select</code>方法主要就是对<strong>粘滞连接特性</strong>的处理。它的实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Invoker&lt;T&gt; <span class="title">select</span><span class="params">(LoadBalance loadbalance, Invocation invocation, List&lt;Invoker&lt;T&gt;&gt; invokers, List&lt;Invoker&lt;T&gt;&gt; selected)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (invokers == <span class="keyword">null</span> || invokers.isEmpty())</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 获取调用方法名</span></span><br><span class="line">    String methodName = invocation == <span class="keyword">null</span> ? <span class="string">""</span> : invocation.getMethodName();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 sticky 配置，sticky 表示粘滞连接。所谓粘滞连接是指让服务消费者尽可能的</span></span><br><span class="line">    <span class="comment">// 调用同一个服务提供者，除非该提供者挂了再进行切换</span></span><br><span class="line">    <span class="keyword">boolean</span> sticky = invokers.get(<span class="number">0</span>).getUrl().getMethodParameter(methodName, Constants.CLUSTER_STICKY_KEY, Constants.DEFAULT_CLUSTER_STICKY);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 检测 invokers 列表是否包含 stickyInvoker，如果不包含，</span></span><br><span class="line">        <span class="comment">// 说明 stickyInvoker 代表的服务提供者挂了，此时需要将其置空</span></span><br><span class="line">        <span class="keyword">if</span> (stickyInvoker != <span class="keyword">null</span> &amp;&amp; !invokers.contains(stickyInvoker)) &#123;</span><br><span class="line">            stickyInvoker = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 在 sticky 为 true，且 stickyInvoker != null 的情况下。如果 selected 包含 </span></span><br><span class="line">        <span class="comment">// stickyInvoker，表明 stickyInvoker 对应的服务提供者可能因网络原因未能成功提供服务。</span></span><br><span class="line">        <span class="comment">// 但是该提供者并没挂，此时 invokers 列表中仍存在该服务提供者对应的 Invoker。</span></span><br><span class="line">        <span class="keyword">if</span> (sticky &amp;&amp; stickyInvoker != <span class="keyword">null</span> &amp;&amp; (selected == <span class="keyword">null</span> || !selected.contains(stickyInvoker))) &#123;</span><br><span class="line">            <span class="comment">// availablecheck 表示是否开启了可用性检查，如果开启了，则调用 stickyInvoker 的 </span></span><br><span class="line">            <span class="comment">// isAvailable 方法进行检查，如果检查通过，则直接返回 stickyInvoker。</span></span><br><span class="line">            <span class="keyword">if</span> (availablecheck &amp;&amp; stickyInvoker.isAvailable()) &#123;</span><br><span class="line">                <span class="keyword">return</span> stickyInvoker;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果线程走到当前代码处，说明前面的 stickyInvoker 为空，或者不可用。</span></span><br><span class="line">    <span class="comment">// 此时继续调用 doSelect 选择 Invoker</span></span><br><span class="line">    Invoker&lt;T&gt; invoker = doSelect(loadbalance, invocation, invokers, selected);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 sticky 为 true，则将负载均衡组件选出的 Invoker 赋值给 stickyInvoker</span></span><br><span class="line">    <span class="keyword">if</span> (sticky) &#123;</span><br><span class="line">        stickyInvoker = invoker;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> invoker;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这段代码我们也可以轻松的明白什么是粘滞连接。</p><p>在这个方法中又调用了<code>doSelect</code>方法，这个方法的作用就是根据负载均衡策略选择合适的<code>Invoker</code>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Invoker&lt;T&gt; <span class="title">doSelect</span><span class="params">(LoadBalance loadbalance, Invocation invocation, List&lt;Invoker&lt;T&gt;&gt; invokers, List&lt;Invoker&lt;T&gt;&gt; selected)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (invokers == <span class="keyword">null</span> || invokers.isEmpty())</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (invokers.size() == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> invokers.get(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (loadbalance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果 loadbalance 为空，这里通过 SPI 加载 Loadbalance，默认为 RandomLoadBalance</span></span><br><span class="line">        loadbalance = ExtensionLoader.getExtensionLoader(LoadBalance.class).getExtension(Constants.DEFAULT_LOADBALANCE);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通过负载均衡组件选择 Invoker</span></span><br><span class="line">    Invoker&lt;T&gt; invoker = loadbalance.select(invokers, getUrl(), invocation);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果 selected 包含负载均衡选择出的 Invoker，或者该 Invoker 无法经过可用性检查，此时进行重选</span></span><br><span class="line">    <span class="keyword">if</span> ((selected != <span class="keyword">null</span> &amp;&amp; selected.contains(invoker))</span><br><span class="line">            || (!invoker.isAvailable() &amp;&amp; getUrl() != <span class="keyword">null</span> &amp;&amp; availablecheck)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 进行重选</span></span><br><span class="line">            Invoker&lt;T&gt; rinvoker = reselect(loadbalance, invocation, invokers, selected, availablecheck);</span><br><span class="line">            <span class="keyword">if</span> (rinvoker != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果 rinvoker 不为空，则将其赋值给 invoker</span></span><br><span class="line">                invoker = rinvoker;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// rinvoker 为空，定位 invoker 在 invokers 中的位置</span></span><br><span class="line">                <span class="keyword">int</span> index = invokers.indexOf(invoker);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 获取 index + 1 位置处的 Invoker，以下代码等价于：</span></span><br><span class="line">                    <span class="comment">//     invoker = invokers.get((index + 1) % invokers.size());</span></span><br><span class="line">                    invoker = index &lt; invokers.size() - <span class="number">1</span> ? invokers.get(index + <span class="number">1</span>) : invokers.get(<span class="number">0</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    logger.warn(<span class="string">"... may because invokers list dynamic change, ignore."</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            logger.error(<span class="string">"cluster reselect fail reason is : ..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> invoker;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>doSelect</code> 主要做了两件事，第一是通过负载均衡组件选择 <code>Invoker</code>。第二是，如果选出来的 <code>Invoker</code>  不稳定，或不可用，此时需要调用 <code>reselect</code> 方法进行重选。若 <code>reselect</code> 选出来的 <code>Invoker</code>为空，此时定位 <code>invoker</code> 在<code>invokers</code> 列表中的位置 <code>index</code>，然后获取<code>index + 1</code> 处的 invoker，这也可以看做是重选逻辑的一部分。</p><p>负责重选的<code>reselect</code>方法的实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Invoker&lt;T&gt; <span class="title">reselect</span><span class="params">(LoadBalance loadbalance, Invocation invocation,</span></span></span><br><span class="line"><span class="function"><span class="params">    List&lt;Invoker&lt;T&gt;&gt; invokers, List&lt;Invoker&lt;T&gt;&gt; selected, <span class="keyword">boolean</span> availablecheck)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line"></span><br><span class="line">    List&lt;Invoker&lt;T&gt;&gt; reselectInvokers = <span class="keyword">new</span> ArrayList&lt;Invoker&lt;T&gt;&gt;(invokers.size() &gt; <span class="number">1</span> ? (invokers.size() - <span class="number">1</span>) : invokers.size());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面的 if-else 分支逻辑有些冗余，pull request #2826 对这段代码进行了简化，可以参考一下</span></span><br><span class="line">    <span class="comment">// 根据 availablecheck 进行不同的处理</span></span><br><span class="line">    <span class="keyword">if</span> (availablecheck) &#123;</span><br><span class="line">        <span class="comment">// 遍历 invokers 列表</span></span><br><span class="line">        <span class="keyword">for</span> (Invoker&lt;T&gt; invoker : invokers) &#123;</span><br><span class="line">            <span class="comment">// 检测可用性</span></span><br><span class="line">            <span class="keyword">if</span> (invoker.isAvailable()) &#123;</span><br><span class="line">                <span class="comment">// 如果 selected 列表不包含当前 invoker，则将其添加到 reselectInvokers 中</span></span><br><span class="line">                <span class="keyword">if</span> (selected == <span class="keyword">null</span> || !selected.contains(invoker)) &#123;</span><br><span class="line">                    reselectInvokers.add(invoker);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// reselectInvokers 不为空，此时通过负载均衡组件进行选择</span></span><br><span class="line">        <span class="keyword">if</span> (!reselectInvokers.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> loadbalance.select(reselectInvokers, getUrl(), invocation);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不检查 Invoker 可用性</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Invoker&lt;T&gt; invoker : invokers) &#123;</span><br><span class="line">            <span class="comment">// 如果 selected 列表不包含当前 invoker，则将其添加到 reselectInvokers 中</span></span><br><span class="line">            <span class="keyword">if</span> (selected == <span class="keyword">null</span> || !selected.contains(invoker)) &#123;</span><br><span class="line">                reselectInvokers.add(invoker);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!reselectInvokers.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 通过负载均衡组件进行选择</span></span><br><span class="line">            <span class="keyword">return</span> loadbalance.select(reselectInvokers, getUrl(), invocation);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 若线程走到此处，说明 reselectInvokers 集合为空，此时不会调用负载均衡组件进行筛选。</span></span><br><span class="line">        <span class="comment">// 这里从 selected 列表中查找可用的 Invoker，并将其添加到 reselectInvokers 集合中</span></span><br><span class="line">        <span class="keyword">if</span> (selected != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Invoker&lt;T&gt; invoker : selected) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((invoker.isAvailable())</span><br><span class="line">                        &amp;&amp; !reselectInvokers.contains(invoker)) &#123;</span><br><span class="line">                    reselectInvokers.add(invoker);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!reselectInvokers.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 再次进行选择，并返回选择结果</span></span><br><span class="line">            <span class="keyword">return</span> loadbalance.select(reselectInvokers, getUrl(), invocation);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>reselect</code> 方法总结下来其实只做了两件事情，第一是查找可用的 <code>Invoker</code>，并将其添加到 <code>reselectInvokers</code> 集合中。第二，如果 <code>reselectInvokers</code> 不为空，则通过负载均衡组件再次进行选择.</p><p>还有一些容错处理的实现类，这里就不分析了。</p><h2><span id="负载均衡">负载均衡</span></h2><h3><span id="简介">简介</span></h3><p><code>LoadBalance</code> 中文意思为负载均衡，它的职责是将网络请求，或者其他形式的负载“均摊”到不同的机器上。避免集群中部分服务器压力过大，而另一些服务器比较空闲的情况。通过负载均衡，可以让每台服务器获取到适合自己处理能力的负载。</p><p>Dubbo提供了4种负载均衡的实现：</p><ul><li><code>RandomLoadBalance</code>:基于权重随机算法</li><li><code>LeastActiveLoadBalance</code>：基于最少活跃连接数算法</li><li><code>ConsistentHashLoadBalance</code>：基于一致性hash算法</li><li><code>RoundRobinLoadBalance</code>：基于加权轮询算法</li></ul><h3><span id="源码分析">源码分析</span></h3><p>在Dubbo种所有的负载均衡策略均是<code>AbstractLoadBalance</code>的子类，该类实现了<code>LoadBalance</code>接口，并封装了一些公共逻辑。</p><p>下面我们来分析一下<code>AbstractLoadBalance</code>中的公共逻辑。</p><p>整个负载均衡的入口方法<code>select</code>的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">select</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (invokers == <span class="keyword">null</span> || invokers.isEmpty())</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 如果 invokers 列表中仅有一个 Invoker，直接返回即可，无需进行负载均衡</span></span><br><span class="line">    <span class="keyword">if</span> (invokers.size() == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> invokers.get(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用 doSelect 方法进行负载均衡，该方法为抽象方法，由子类实现</span></span><br><span class="line">    <span class="keyword">return</span> doSelect(invokers, url, invocation);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">abstract</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">doSelect</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span></span>;</span><br></pre></td></tr></table></figure><p>它还提供了计算服务提供者权重的计算方法<code>getWeight</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getWeight</span><span class="params">(Invoker&lt;?&gt; invoker, Invocation invocation)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从 url 中获取权重 weight 配置值</span></span><br><span class="line">    <span class="keyword">int</span> weight = invoker.getUrl().getMethodParameter(invocation.getMethodName(), Constants.WEIGHT_KEY, Constants.DEFAULT_WEIGHT);</span><br><span class="line">    <span class="keyword">if</span> (weight &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取服务提供者启动时间戳</span></span><br><span class="line">        <span class="keyword">long</span> timestamp = invoker.getUrl().getParameter(Constants.REMOTE_TIMESTAMP_KEY, <span class="number">0L</span>);</span><br><span class="line">        <span class="keyword">if</span> (timestamp &gt; <span class="number">0L</span>) &#123;</span><br><span class="line">            <span class="comment">// 计算服务提供者运行时长</span></span><br><span class="line">            <span class="keyword">int</span> uptime = (<span class="keyword">int</span>) (System.currentTimeMillis() - timestamp);</span><br><span class="line">            <span class="comment">// 获取服务预热时间，默认为10分钟</span></span><br><span class="line">            <span class="keyword">int</span> warmup = invoker.getUrl().getParameter(Constants.WARMUP_KEY, Constants.DEFAULT_WARMUP);</span><br><span class="line">            <span class="comment">// 如果服务运行时间小于预热时间，则重新计算服务权重，即降权</span></span><br><span class="line">            <span class="keyword">if</span> (uptime &gt; <span class="number">0</span> &amp;&amp; uptime &lt; warmup) &#123;</span><br><span class="line">                <span class="comment">// 重新计算服务权重</span></span><br><span class="line">                weight = calculateWarmupWeight(uptime, warmup, weight);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> weight;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateWarmupWeight</span><span class="params">(<span class="keyword">int</span> uptime, <span class="keyword">int</span> warmup, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 计算权重，下面代码逻辑上形似于 (uptime / warmup) * weight。</span></span><br><span class="line">    <span class="comment">// 随着服务运行时间 uptime 增大，权重计算值 ww 会慢慢接近配置值 weight</span></span><br><span class="line">    <span class="keyword">int</span> ww = (<span class="keyword">int</span>) ((<span class="keyword">float</span>) uptime / ((<span class="keyword">float</span>) warmup / (<span class="keyword">float</span>) weight));</span><br><span class="line">    <span class="keyword">return</span> ww &lt; <span class="number">1</span> ? <span class="number">1</span> : (ww &gt; weight ? weight : ww);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是权重的计算过程，该过程主要用于保证当服务运行时长小于服务预热时间时，对服务进行降权，避免让服务在启动之初就处于高负载状态。服务预热是一个优化手段，与此类似的还有 JVM 预热。主要目的是让服务启动后“低功率”运行一段时间，使其效率慢慢提升至最佳状态。</p><p>下面我们就以Dubbo的默认负载均衡策略<code>RandomLoadBalance</code>的实现为例来分析这些负载均衡策略是如何实现的。</p><p><code>RandomLoadBalance</code>是加权随机算法的具体实现，它的算法思想很简单。假设我们有一组服务器 <code>servers = [A, B,  C]</code>，他们对应的权重为 <code>weights = [5, 3, 2]</code>，权重总和为10。现在把这些权重值平铺在一维坐标值上，<code>[0, 5)</code>区间属于服务器 <code>A</code>，<code>[5, 8)</code>区间属于服务器 <code>B</code>，<code>[8, 10)</code> 区间属于服务器 <code>C</code>。接下来通过随机数生成器生成一个范围在<code>[0, 10)</code> 之间的随机数，然后计算这个随机数会落到哪个区间上.基于这个思路，它的代码实现也是非常简单的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomLoadBalance</span> <span class="keyword">extends</span> <span class="title">AbstractLoadBalance</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NAME = <span class="string">"random"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Random random = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">doSelect</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = invokers.size();</span><br><span class="line">        <span class="keyword">int</span> totalWeight = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> sameWeight = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 下面这个循环有两个作用，第一是计算总权重 totalWeight，</span></span><br><span class="line">        <span class="comment">// 第二是检测每个服务提供者的权重是否相同</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> weight = getWeight(invokers.get(i), invocation);</span><br><span class="line">            <span class="comment">// 累加权重</span></span><br><span class="line">            totalWeight += weight;</span><br><span class="line">            <span class="comment">// 检测当前服务提供者的权重与上一个服务提供者的权重是否相同，</span></span><br><span class="line">            <span class="comment">// 不相同的话，则将 sameWeight 置为 false。</span></span><br><span class="line">            <span class="keyword">if</span> (sameWeight &amp;&amp; i &gt; <span class="number">0</span></span><br><span class="line">                    &amp;&amp; weight != getWeight(invokers.get(i - <span class="number">1</span>), invocation)) &#123;</span><br><span class="line">                sameWeight = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 下面的 if 分支主要用于获取随机数，并计算随机数落在哪个区间上</span></span><br><span class="line">        <span class="keyword">if</span> (totalWeight &gt; <span class="number">0</span> &amp;&amp; !sameWeight) &#123;</span><br><span class="line">            <span class="comment">// 随机获取一个 [0, totalWeight) 区间内的数字</span></span><br><span class="line">            <span class="keyword">int</span> offset = random.nextInt(totalWeight);</span><br><span class="line">            <span class="comment">// 循环让 offset 数减去服务提供者权重值，当 offset 小于0时，返回相应的 Invoker。</span></span><br><span class="line">            <span class="comment">// 举例说明一下，我们有 servers = [A, B, C]，weights = [5, 3, 2]，offset = 7。</span></span><br><span class="line">            <span class="comment">// 第一次循环，offset - 5 = 2 &gt; 0，即 offset &gt; 5，</span></span><br><span class="line">            <span class="comment">// 表明其不会落在服务器 A 对应的区间上。</span></span><br><span class="line">            <span class="comment">// 第二次循环，offset - 3 = -1 &lt; 0，即 5 &lt; offset &lt; 8，</span></span><br><span class="line">            <span class="comment">// 表明其会落在服务器 B 对应的区间上</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">                <span class="comment">// 让随机值 offset 减去权重值</span></span><br><span class="line">                offset -= getWeight(invokers.get(i), invocation);</span><br><span class="line">                <span class="keyword">if</span> (offset &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 返回相应的 Invoker</span></span><br><span class="line">                    <span class="keyword">return</span> invokers.get(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果所有服务提供者权重值相同，此时直接随机返回一个即可</span></span><br><span class="line">        <span class="keyword">return</span> invokers.get(random.nextInt(length));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此这个Dubbo集群的源码就分析完毕了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Dubbo集群容错方面的源码包括四个部分，分别式服务目录Directory、服务路由Router、集群Cluster和负载均衡LoadBalance。&lt;/p&gt;
&lt;p&gt;它们之间的关系是这样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/05/11/YJAi1H.png&quot; alt=&quot;YJAi1H.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="https://zofun.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Dubbo" scheme="https://zofun.github.io/tags/Dubbo/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo服务调用过程</title>
    <link href="https://zofun.github.io/2020/05/10/Dubbo%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B/"/>
    <id>https://zofun.github.io/2020/05/10/Dubbo服务调用过程/</id>
    <published>2020-05-10T13:44:00.000Z</published>
    <updated>2020-05-10T13:44:44.948Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="简介">简介</span></h2><p>Dubbo服务调用的基本过程如图：</p><p><img src="https://s1.ax1x.com/2020/05/10/Y33nc8.png" alt="Y33nc8.png"></p><p>首先服务消费者通过代理对象Proxy发起远程调用，接着通过网络客户端将编码后的请求发送给服务提供方的网络层上。Server收到请求之后，首先要做的就是对数据包进行解码。然后将解码后的请求发送至分发器，再由分发器将请求发送到指定的线程池上，最后由线程池调用具体的服务。这就是一个远程调用请求的发送过程。</p><a id="more"></a><h2><span id="服务调用过程源码分析">服务调用过程源码分析</span></h2><h3><span id="服务消费端进行服务调用过程">服务消费端进行服务调用过程</span></h3><p>我们知道服务消费端是通过为接口生成的代理对象进行服务调用的，他的代理对象的实现如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">proxy0</span> <span class="keyword">implements</span> <span class="title">ClassGenerator</span>.<span class="title">DC</span>, <span class="title">EchoService</span>, <span class="title">DemoService</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 方法数组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Method[] methods;</span><br><span class="line">    <span class="keyword">private</span> InvocationHandler handler;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">proxy0</span><span class="params">(InvocationHandler invocationHandler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.handler = invocationHandler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">proxy0</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String string)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将参数存储到 Object 数组中</span></span><br><span class="line">        Object[] arrobject = <span class="keyword">new</span> Object[]&#123;string&#125;;</span><br><span class="line">        <span class="comment">// 调用 InvocationHandler 实现类的 invoke 方法得到调用结果</span></span><br><span class="line">        Object object = <span class="keyword">this</span>.handler.invoke(<span class="keyword">this</span>, methods[<span class="number">0</span>], arrobject);</span><br><span class="line">        <span class="comment">// 返回调用结果</span></span><br><span class="line">        <span class="keyword">return</span> (String)object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 回声测试方法 */</span></span><br><span class="line">    <span class="keyword">public</span> Object $echo(Object object) &#123;</span><br><span class="line">        Object[] arrobject = <span class="keyword">new</span> Object[]&#123;object&#125;;</span><br><span class="line">        Object object2 = <span class="keyword">this</span>.handler.invoke(<span class="keyword">this</span>, methods[<span class="number">1</span>], arrobject);</span><br><span class="line">        <span class="keyword">return</span> object2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个代理类的实现逻辑比较简单，首先将参数存储到数组中，然后调用<code>InvocationHandler</code>的实现类的<code>invoke</code>方法，然后得到一个调用结果，最后将这个结果返回给调用端。</p><p>也就是说这个代理类只做了三件事情：</p><ol><li>将参数进行封装</li><li>调用<code>invoke</code>方法，进行服务调用</li><li>返回结果</li></ol><p>下面我们来分析这个<code>InvocationHandler</code>的实现类的代码实现；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InvokerInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Invoker&lt;?&gt; invoker;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InvokerInvocationHandler</span><span class="params">(Invoker&lt;?&gt; handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.invoker = handler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        String methodName = method.getName();</span><br><span class="line">        Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 拦截定义在 Object 类中的方法（未被子类重写），比如 wait/notify</span></span><br><span class="line">        <span class="keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">            <span class="keyword">return</span> method.invoke(invoker, args);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果 toString、hashCode 和 equals 等方法被子类重写了，这里也直接调用</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"toString"</span>.equals(methodName) &amp;&amp; parameterTypes.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> invoker.toString();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"hashCode"</span>.equals(methodName) &amp;&amp; parameterTypes.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> invoker.hashCode();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"equals"</span>.equals(methodName) &amp;&amp; parameterTypes.length == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> invoker.equals(args[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将 method 和 args 封装到 RpcInvocation 中，并执行后续的调用</span></span><br><span class="line">        <span class="keyword">return</span> invoker.invoke(<span class="keyword">new</span> RpcInvocation(method, args)).recreate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类的<code>invoke</code>的实现逻辑非常的简单，如果调用的是Object中的一些方法，那么直接进行处理即可（这些方法根本不需要远程调用），否则通过<code>Invoker</code>接口的实现类的<code>invoke</code>方法进行远程调用。</p><p>这里的<code>Invoker</code>的实现类其实是<code>MockClusterInvoker</code>,它的内部封装了服务降级的逻辑，下面我们来看它的具体实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MockClusterInvoker</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Invoker</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Invoker&lt;T&gt; invoker;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        Result result = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 mock 配置值</span></span><br><span class="line">        String value = directory.getUrl().getMethodParameter(invocation.getMethodName(), Constants.MOCK_KEY, Boolean.FALSE.toString()).trim();</span><br><span class="line">        <span class="keyword">if</span> (value.length() == <span class="number">0</span> || value.equalsIgnoreCase(<span class="string">"false"</span>)) &#123;</span><br><span class="line">            <span class="comment">// 无 mock 逻辑，直接调用其他 Invoker 对象的 invoke 方法，</span></span><br><span class="line">            <span class="comment">// 比如 FailoverClusterInvoker</span></span><br><span class="line">            result = <span class="keyword">this</span>.invoker.invoke(invocation);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value.startsWith(<span class="string">"force"</span>)) &#123;</span><br><span class="line">            <span class="comment">// force:xxx 直接执行 mock 逻辑，不发起远程调用</span></span><br><span class="line">            result = doMockInvoke(invocation, <span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// fail:xxx 表示消费方对调用服务失败后，再执行 mock 逻辑，不抛出异常</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 调用其他 Invoker 对象的 invoke 方法</span></span><br><span class="line">                result = <span class="keyword">this</span>.invoker.invoke(invocation);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RpcException e) &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.isBiz()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> e;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 调用失败，执行 mock 逻辑</span></span><br><span class="line">                    result = doMockInvoke(invocation, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略其他方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里主要是对服务降级的处理，如果没有配置服务降级的逻辑，那么直接进行远程调用；如果服务降级信息配置为<code>force</code>那么直接降级，不发起远程调用；如果服务降级信息配置为<code>fail</code>，那么会尝试进行远程调用，如果失败那么就进行服务降级逻辑。</p><p>在这里我们就不深究这个服务降级的实现了，主要来看一看远程调用。在这个类中进行远程调用使用的是实现了<code>Invoker</code>接口的<code>AbstractInvoker</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractInvoker</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Invoker</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(Invocation inv)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (destroyed.get()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Rpc invoker for service ..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        RpcInvocation invocation = (RpcInvocation) inv;</span><br><span class="line">        <span class="comment">// 设置 Invoker</span></span><br><span class="line">        invocation.setInvoker(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (attachment != <span class="keyword">null</span> &amp;&amp; attachment.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 设置 attachment</span></span><br><span class="line">            invocation.addAttachmentsIfAbsent(attachment);</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;String, String&gt; contextAttachments = RpcContext.getContext().getAttachments();</span><br><span class="line">        <span class="keyword">if</span> (contextAttachments != <span class="keyword">null</span> &amp;&amp; contextAttachments.size() != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 添加 contextAttachments 到 RpcInvocation#attachment 变量中</span></span><br><span class="line">            invocation.addAttachments(contextAttachments);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (getUrl().getMethodParameter(invocation.getMethodName(), Constants.ASYNC_KEY, <span class="keyword">false</span>)) &#123;</span><br><span class="line">            <span class="comment">// 设置异步信息到 RpcInvocation#attachment 中</span></span><br><span class="line">            invocation.setAttachment(Constants.ASYNC_KEY, Boolean.TRUE.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        RpcUtils.attachInvocationIdIfAsync(getUrl(), invocation);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 抽象方法，由子类实现</span></span><br><span class="line">            <span class="keyword">return</span> doInvoke(invocation);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (RpcException e) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> RpcResult(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Result <span class="title">doInvoke</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略其他方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码的主要逻辑就是将信息添加到<code>RpcInvocation#attachment</code>,然后调用<code>doInvoke</code>执行后序逻辑。<code>doInvoke</code>是一个抽象方法，由子类<code>DubboInvoker</code>实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboInvoker</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractInvoker</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExchangeClient[] clients;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Result <span class="title">doInvoke</span><span class="params">(<span class="keyword">final</span> Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        RpcInvocation inv = (RpcInvocation) invocation;</span><br><span class="line">        <span class="keyword">final</span> String methodName = RpcUtils.getMethodName(invocation);</span><br><span class="line">        <span class="comment">// 设置 path 和 version 到 attachment 中</span></span><br><span class="line">        inv.setAttachment(Constants.PATH_KEY, getUrl().getPath());</span><br><span class="line">        inv.setAttachment(Constants.VERSION_KEY, version);</span><br><span class="line"></span><br><span class="line">        ExchangeClient currentClient;</span><br><span class="line">        <span class="keyword">if</span> (clients.length == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 从 clients 数组中获取 ExchangeClient</span></span><br><span class="line">            currentClient = clients[<span class="number">0</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            currentClient = clients[index.getAndIncrement() % clients.length];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取异步配置</span></span><br><span class="line">            <span class="keyword">boolean</span> isAsync = RpcUtils.isAsync(getUrl(), invocation);</span><br><span class="line">            <span class="comment">// isOneway 为 true，表示“单向”通信</span></span><br><span class="line">            <span class="keyword">boolean</span> isOneway = RpcUtils.isOneway(getUrl(), invocation);</span><br><span class="line">            <span class="keyword">int</span> timeout = getUrl().getMethodParameter(methodName, Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 异步无返回值</span></span><br><span class="line">            <span class="keyword">if</span> (isOneway) &#123;</span><br><span class="line">                <span class="keyword">boolean</span> isSent = getUrl().getMethodParameter(methodName, Constants.SENT_KEY, <span class="keyword">false</span>);</span><br><span class="line">                <span class="comment">// 发送请求</span></span><br><span class="line">                currentClient.send(inv, isSent);</span><br><span class="line">                <span class="comment">// 设置上下文中的 future 字段为 null</span></span><br><span class="line">                RpcContext.getContext().setFuture(<span class="keyword">null</span>);</span><br><span class="line">                <span class="comment">// 返回一个空的 RpcResult</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> RpcResult();</span><br><span class="line">            &#125; </span><br><span class="line"></span><br><span class="line">            <span class="comment">// 异步有返回值</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (isAsync) &#123;</span><br><span class="line">                <span class="comment">// 发送请求，并得到一个 ResponseFuture 实例</span></span><br><span class="line">                ResponseFuture future = currentClient.request(inv, timeout);</span><br><span class="line">                <span class="comment">// 设置 future 到上下文中</span></span><br><span class="line">                RpcContext.getContext().setFuture(<span class="keyword">new</span> FutureAdapter&lt;Object&gt;(future));</span><br><span class="line">                <span class="comment">// 暂时返回一个空结果</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> RpcResult();</span><br><span class="line">            &#125; </span><br><span class="line"></span><br><span class="line">            <span class="comment">// 同步调用</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                RpcContext.getContext().setFuture(<span class="keyword">null</span>);</span><br><span class="line">                <span class="comment">// 发送请求，得到一个 ResponseFuture 实例，并调用该实例的 get 方法进行等待</span></span><br><span class="line">                <span class="keyword">return</span> (Result) currentClient.request(inv, timeout).get();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(..., <span class="string">"Invoke remote method timeout...."</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemotingException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(..., <span class="string">"Failed to invoke remote method: ..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略其他方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码包含了Dubbo对同步调用和一步调用的处理逻辑。Dubbo实现同步调用和异步调用比较关键的点是由谁负责调用<code>ResponseFuture</code> 的<code>get</code>方法，同步调用模式下是由框架来调用<code>get</code>方法的，而异步调用是由用户来调用<code>get</code>方法的。</p><p>这个方法主要完成的就是利用<code>client</code>进行远程调用，并处理同步调用和异步调用的细节。</p><p>下面我们来看一看<code>ResponseFuture</code>的一个默认实现<code>DefaultFuture</code>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultFuture</span> <span class="keyword">implements</span> <span class="title">ResponseFuture</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Long, Channel&gt; CHANNELS = </span><br><span class="line">        <span class="keyword">new</span> ConcurrentHashMap&lt;Long, Channel&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Long, DefaultFuture&gt; FUTURES = </span><br><span class="line">        <span class="keyword">new</span> ConcurrentHashMap&lt;Long, DefaultFuture&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Channel channel;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Request request;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> timeout;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition done = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Response response;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultFuture</span><span class="params">(Channel channel, Request request, <span class="keyword">int</span> timeout)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.channel = channel;</span><br><span class="line">        <span class="keyword">this</span>.request = request;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取请求 id，这个 id 很重要，后面还会见到</span></span><br><span class="line">        <span class="keyword">this</span>.id = request.getId();</span><br><span class="line">        <span class="keyword">this</span>.timeout = timeout &gt; <span class="number">0</span> ? timeout : channel.getUrl().getPositiveParameter(Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT);</span><br><span class="line">        <span class="comment">// 存储 &lt;requestId, DefaultFuture&gt; 映射关系到 FUTURES 中</span></span><br><span class="line">        FUTURES.put(id, <span class="keyword">this</span>);</span><br><span class="line">        CHANNELS.put(id, channel);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> get(timeout);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(<span class="keyword">int</span> timeout)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (timeout &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            timeout = Constants.DEFAULT_TIMEOUT;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 检测服务提供方是否成功返回了调用结果</span></span><br><span class="line">        <span class="keyword">if</span> (!isDone()) &#123;</span><br><span class="line">            <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 循环检测服务提供方是否成功返回了调用结果</span></span><br><span class="line">                <span class="keyword">while</span> (!isDone()) &#123;</span><br><span class="line">                    <span class="comment">// 如果调用结果尚未返回，这里等待一段时间</span></span><br><span class="line">                    done.await(timeout, TimeUnit.MILLISECONDS);</span><br><span class="line">                    <span class="comment">// 如果调用结果成功返回，或等待超时，此时跳出 while 循环，执行后续的逻辑</span></span><br><span class="line">                    <span class="keyword">if</span> (isDone() || System.currentTimeMillis() - start &gt; timeout) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果调用结果仍未返回，则抛出超时异常</span></span><br><span class="line">            <span class="keyword">if</span> (!isDone()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException(sent &gt; <span class="number">0</span>, channel, getTimeoutMessage(<span class="keyword">false</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 返回调用结果</span></span><br><span class="line">        <span class="keyword">return</span> returnFromResponse();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 通过检测 response 字段为空与否，判断是否收到了调用结果</span></span><br><span class="line">        <span class="keyword">return</span> response != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">returnFromResponse</span><span class="params">()</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        Response res = response;</span><br><span class="line">        <span class="keyword">if</span> (res == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"response cannot be null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果调用结果的状态为 Response.OK，则表示调用过程正常，服务提供方成功返回了调用结果</span></span><br><span class="line">        <span class="keyword">if</span> (res.getStatus() == Response.OK) &#123;</span><br><span class="line">            <span class="keyword">return</span> res.getResult();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (res.getStatus() == Response.CLIENT_TIMEOUT || res.getStatus() == Response.SERVER_TIMEOUT) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException(res.getStatus() == Response.SERVER_TIMEOUT, channel, res.getErrorMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RemotingException(channel, res.getErrorMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略其他方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实这段代码非常逻辑非常的简单，如果服务消费者还没有收到结果时，那么调用<code>get</code>方法，就会被阻塞。同步调用模式下，是由框架来执行<code>get</code>方法的，它会阻塞直至收到结果。而异步模式下将该对象封装到<code>FutureAdapter</code>对象中，然后设置到<code>RpcContext</code>中，供用户使用。这个适配器的主要作用就是将<code>Dubbo</code>的<code>ResponseFuture</code>和<code>JDK</code>中的<code>Future</code>进行适配，这样用户可以调用<code>Future</code>的<code>get</code>方法的时候经过了<code>FutureAdapter</code>的适配，最终调用<code>ResponseFuture</code>的<code>get</code>方法。</p><p>到此，整个执行的流程如下：</p><p><img src="https://s1.ax1x.com/2020/05/10/Y3yed1.png" alt="Y3yed1.png"></p><h3><span id="服务消费端发送请求">服务消费端发送请求</span></h3><p>通过之前的源码分析，我们可以看出服务调用是通过<code>client</code>发送请求完成的，下面我们就来分析，这个请求发送的具体流程。</p><p>在之前提到的<code>client</code>其实就是实现<code>ExchangeClient</code>接口的<code>ReferenceCountExchangeClient</code>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceCountExchangeClient</span> <span class="keyword">implements</span> <span class="title">ExchangeClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> URL url;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger referenceCount = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReferenceCountExchangeClient</span><span class="params">(ExchangeClient client, ConcurrentMap&lt;String, LazyConnectExchangeClient&gt; ghostClientMap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.client = client;</span><br><span class="line">        <span class="comment">// 引用计数自增</span></span><br><span class="line">        referenceCount.incrementAndGet();</span><br><span class="line">        <span class="keyword">this</span>.url = client.getUrl();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseFuture <span class="title">request</span><span class="params">(Object request)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="comment">// 直接调用被装饰对象的同签名方法</span></span><br><span class="line">        <span class="keyword">return</span> client.request(request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseFuture <span class="title">request</span><span class="params">(Object request, <span class="keyword">int</span> timeout)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="comment">// 直接调用被装饰对象的同签名方法</span></span><br><span class="line">        <span class="keyword">return</span> client.request(request, timeout);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 引用计数自增，该方法由外部调用 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">incrementAndGetCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// referenceCount 自增</span></span><br><span class="line">        referenceCount.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> timeout)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// referenceCount 自减</span></span><br><span class="line">        <span class="keyword">if</span> (referenceCount.decrementAndGet() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (timeout == <span class="number">0</span>) &#123;</span><br><span class="line">                client.close();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                client.close(timeout);</span><br><span class="line">            &#125;</span><br><span class="line">            client = replaceWithLazyClient();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略部分方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ReferenceCountExchangeClient</code>内部主要进行的是引用计数的处理，其它均调用的是被装饰对象的相关方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeaderExchangeClient</span> <span class="keyword">implements</span> <span class="title">ExchangeClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ScheduledThreadPoolExecutor scheduled = <span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">2</span>, <span class="keyword">new</span> NamedThreadFactory(<span class="string">"dubbo-remoting-client-heartbeat"</span>, <span class="keyword">true</span>));</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Client client;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExchangeChannel channel;</span><br><span class="line">    <span class="keyword">private</span> ScheduledFuture&lt;?&gt; heartbeatTimer;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> heartbeat;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> heartbeatTimeout;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeaderExchangeClient</span><span class="params">(Client client, <span class="keyword">boolean</span> needHeartbeat)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (client == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"client == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.client = client;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建 HeaderExchangeChannel 对象</span></span><br><span class="line">        <span class="keyword">this</span>.channel = <span class="keyword">new</span> HeaderExchangeChannel(client);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 以下代码均与心跳检测逻辑有关</span></span><br><span class="line">        String dubbo = client.getUrl().getParameter(Constants.DUBBO_VERSION_KEY);</span><br><span class="line">        <span class="keyword">this</span>.heartbeat = client.getUrl().getParameter(Constants.HEARTBEAT_KEY, dubbo != <span class="keyword">null</span> &amp;&amp; dubbo.startsWith(<span class="string">"1.0."</span>) ? Constants.DEFAULT_HEARTBEAT : <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">this</span>.heartbeatTimeout = client.getUrl().getParameter(Constants.HEARTBEAT_TIMEOUT_KEY, heartbeat * <span class="number">3</span>);</span><br><span class="line">        <span class="keyword">if</span> (heartbeatTimeout &lt; heartbeat * <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"heartbeatTimeout &lt; heartbeatInterval * 2"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (needHeartbeat) &#123;</span><br><span class="line">            <span class="comment">// 开启心跳检测定时器</span></span><br><span class="line">            startHeartbeatTimer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseFuture <span class="title">request</span><span class="params">(Object request)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="comment">// 直接 HeaderExchangeChannel 对象的同签名方法</span></span><br><span class="line">        <span class="keyword">return</span> channel.request(request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseFuture <span class="title">request</span><span class="params">(Object request, <span class="keyword">int</span> timeout)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="comment">// 直接 HeaderExchangeChannel 对象的同签名方法</span></span><br><span class="line">        <span class="keyword">return</span> channel.request(request, timeout);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        doClose();</span><br><span class="line">        channel.close();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doClose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 停止心跳检测定时器</span></span><br><span class="line">        stopHeartbeatTimer();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startHeartbeatTimer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stopHeartbeatTimer();</span><br><span class="line">        <span class="keyword">if</span> (heartbeat &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            heartbeatTimer = scheduled.scheduleWithFixedDelay(</span><br><span class="line">                    <span class="keyword">new</span> HeartBeatTask(<span class="keyword">new</span> HeartBeatTask.ChannelProvider() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> Collection&lt;Channel&gt; <span class="title">getChannels</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                            <span class="keyword">return</span> Collections.&lt;Channel&gt;singletonList(HeaderExchangeClient.<span class="keyword">this</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;, heartbeat, heartbeatTimeout),</span><br><span class="line">                    heartbeat, heartbeat, TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">stopHeartbeatTimer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (heartbeatTimer != <span class="keyword">null</span> &amp;&amp; !heartbeatTimer.isCancelled()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                heartbeatTimer.cancel(<span class="keyword">true</span>);</span><br><span class="line">                scheduled.purge();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                    logger.warn(e.getMessage(), e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        heartbeatTimer = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略部分方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>HeaderExchangeClient</code>封装了心跳检测逻辑，然后通过调用<code>HeaderExchangeChannel</code>对象的同签名方法。下面我们来分析<code>HeaderExchangeChannel</code>的代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HeaderExchangeChannel</span> <span class="keyword">implements</span> <span class="title">ExchangeChannel</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Channel channel;</span><br><span class="line">    </span><br><span class="line">    HeaderExchangeChannel(Channel channel) &#123;</span><br><span class="line">        <span class="keyword">if</span> (channel == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"channel == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 这里的 channel 指向的是 NettyClient</span></span><br><span class="line">        <span class="keyword">this</span>.channel = channel;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseFuture <span class="title">request</span><span class="params">(Object request)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> request(request, channel.getUrl().getPositiveParameter(Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseFuture <span class="title">request</span><span class="params">(Object request, <span class="keyword">int</span> timeout)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RemotingException(..., <span class="string">"Failed to send request ...);</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        // 创建 Request 对象</span></span><br><span class="line"><span class="string">        Request req = new Request();</span></span><br><span class="line"><span class="string">        req.setVersion(Version.getProtocolVersion());</span></span><br><span class="line"><span class="string">        // 设置双向通信标志为 true</span></span><br><span class="line"><span class="string">        req.setTwoWay(true);</span></span><br><span class="line"><span class="string">        // 这里的 request 变量类型为 RpcInvocation</span></span><br><span class="line"><span class="string">        req.setData(request);</span></span><br><span class="line"><span class="string">                                        </span></span><br><span class="line"><span class="string">        // 创建 DefaultFuture 对象</span></span><br><span class="line"><span class="string">        DefaultFuture future = new DefaultFuture(channel, req, timeout);</span></span><br><span class="line"><span class="string">        try &#123;</span></span><br><span class="line"><span class="string">            // 调用 NettyClient 的 send 方法发送请求</span></span><br><span class="line"><span class="string">            channel.send(req);</span></span><br><span class="line"><span class="string">        &#125; catch (RemotingException e) &#123;</span></span><br><span class="line"><span class="string">            future.cancel();</span></span><br><span class="line"><span class="string">            throw e;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        // 返回 DefaultFuture 对象</span></span><br><span class="line"><span class="string">        return future;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>这个类的<code>request</code>方法，首先定义了一个<code>Request</code>对象，然后再将该对象传给<code>NettyClient</code>的<code>send</code>方法，进行后序的调用。而<code>NettyClient</code>本身并没有实现<code>send</code>方法，这个方法是通过继承<code>AbstractPeer</code>得到得。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractPeer</span> <span class="keyword">implements</span> <span class="title">Endpoint</span>, <span class="title">ChannelHandler</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(Object message)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="comment">// 该方法由 AbstractClient 类实现</span></span><br><span class="line">        send(message, url.getParameter(Constants.SENT_KEY, <span class="keyword">false</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略其他方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractClient</span> <span class="keyword">extends</span> <span class="title">AbstractEndpoint</span> <span class="keyword">implements</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(Object message, <span class="keyword">boolean</span> sent)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (send_reconnect &amp;&amp; !isConnected()) &#123;</span><br><span class="line">            connect();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取 Channel，getChannel 是一个抽象方法，具体由子类实现</span></span><br><span class="line">        Channel channel = getChannel();</span><br><span class="line">        <span class="keyword">if</span> (channel == <span class="keyword">null</span> || !channel.isConnected()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RemotingException(<span class="keyword">this</span>, <span class="string">"message can not send ..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 继续向下调用</span></span><br><span class="line">        channel.send(message, sent);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Channel <span class="title">getChannel</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略其他方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再默认得情况下，<code>Dubbo</code>使用得是<code>Netty作为底层得通信框架，下面我们来分析一下</code>NettyClient<code>类中</code>getChannel`方法得实现逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClient</span> <span class="keyword">extends</span> <span class="title">AbstractClient</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这里的 Channel 全限定名称为 org.jboss.netty.channel.Channel</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Channel channel;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> com.alibaba.dubbo.remoting.<span class="function">Channel <span class="title">getChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Channel c = channel;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span> || !c.isConnected())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 获取一个 NettyChannel 类型对象</span></span><br><span class="line">        <span class="keyword">return</span> NettyChannel.getOrAddChannel(c, getUrl(), <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyChannel</span> <span class="keyword">extends</span> <span class="title">AbstractChannel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentMap&lt;org.jboss.netty.channel.Channel, NettyChannel&gt; channelMap = </span><br><span class="line">        <span class="keyword">new</span> ConcurrentHashMap&lt;org.jboss.netty.channel.Channel, NettyChannel&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> org.jboss.netty.channel.Channel channel;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 私有构造方法 */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">NettyChannel</span><span class="params">(org.jboss.netty.channel.Channel channel, URL url, ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(url, handler);</span><br><span class="line">        <span class="keyword">if</span> (channel == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"netty channel == null;"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.channel = channel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> NettyChannel <span class="title">getOrAddChannel</span><span class="params">(org.jboss.netty.channel.Channel ch, URL url, ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 尝试从集合中获取 NettyChannel 实例</span></span><br><span class="line">        NettyChannel ret = channelMap.get(ch);</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果 ret = null，则创建一个新的 NettyChannel 实例</span></span><br><span class="line">            NettyChannel nc = <span class="keyword">new</span> NettyChannel(ch, url, handler);</span><br><span class="line">            <span class="keyword">if</span> (ch.isConnected()) &#123;</span><br><span class="line">                <span class="comment">// 将 &lt;Channel, NettyChannel&gt; 键值对存入 channelMap 集合中</span></span><br><span class="line">                ret = channelMap.putIfAbsent(ch, nc);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ret == <span class="keyword">null</span>) &#123;</span><br><span class="line">                ret = nc;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拿到<code>NettyChannel</code>实例之后，就可以进行后序的调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(Object message, <span class="keyword">boolean</span> sent)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.send(message, sent);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> success = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">int</span> timeout = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 发送消息(包含请求和响应消息)</span></span><br><span class="line">        ChannelFuture future = channel.write(message);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// sent 的值源于 &lt;dubbo:method sent="true/false" /&gt; 中 sent 的配置值，有两种配置值：</span></span><br><span class="line">        <span class="comment">//   1. true: 等待消息发出，消息发送失败将抛出异常</span></span><br><span class="line">        <span class="comment">//   2. false: 不等待消息发出，将消息放入 IO 队列，即刻返回</span></span><br><span class="line">        <span class="comment">// 默认情况下 sent = false；</span></span><br><span class="line">        <span class="keyword">if</span> (sent) &#123;</span><br><span class="line">            timeout = getUrl().getPositiveParameter(Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT);</span><br><span class="line">            <span class="comment">// 等待消息发出，若在规定时间没能发出，success 会被置为 false</span></span><br><span class="line">            success = future.await(timeout);</span><br><span class="line">        &#125;</span><br><span class="line">        Throwable cause = future.getCause();</span><br><span class="line">        <span class="keyword">if</span> (cause != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> cause;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RemotingException(<span class="keyword">this</span>, <span class="string">"Failed to send message ..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若 success 为 false，这里抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RemotingException(<span class="keyword">this</span>, <span class="string">"Failed to send message ..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此调用请求就发出去了，当然再Netty中还有出站数据的编码操作，这里就不分析了。</p><p>整个调用路径是这个样子的：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">proxy0#sayHello(String)</span><br><span class="line">  —&gt; InvokerInvocationHandler#invoke(Object, Method, Object[])</span><br><span class="line">    —&gt; MockClusterInvoker#invoke(Invocation)</span><br><span class="line">      —&gt; AbstractClusterInvoker#invoke(Invocation)</span><br><span class="line">        —&gt; FailoverClusterInvoker#doInvoke(Invocation, List&lt;Invoker&lt;T&gt;&gt;, LoadBalance)</span><br><span class="line">          —&gt; Filter#invoke(Invoker, Invocation)  // 包含多个 Filter 调用</span><br><span class="line">            —&gt; ListenerInvokerWrapper#invoke(Invocation) </span><br><span class="line">              —&gt; AbstractInvoker#invoke(Invocation) </span><br><span class="line">                —&gt; DubboInvoker#doInvoke(Invocation)</span><br><span class="line">                  —&gt; ReferenceCountExchangeClient#request(Object, int)</span><br><span class="line">                    —&gt; HeaderExchangeClient#request(Object, int)</span><br><span class="line">                      —&gt; HeaderExchangeChannel#request(Object, int)</span><br><span class="line">                        —&gt; AbstractPeer#send(Object)</span><br><span class="line">                          —&gt; AbstractClient#send(Object, boolean)</span><br><span class="line">                            —&gt; NettyChannel#send(Object, boolean)</span><br><span class="line">                              —&gt; NioClientSocketChannel#write(Object)</span><br></pre></td></tr></table></figure><h2><span id="服务提供方处理逻辑">服务提供方处理逻辑</span></h2><h3><span id="接收请求">接收请求</span></h3><p>前面说过，默认情况下 Dubbo 使用 Netty 作为底层的通信框架。Netty 检测到有数据入站后，首先会通过解码器对数据进行解码，并将解码后的数据传递给下一个入站处理器的指定方法。</p><p>这里直接分析请求数据的解码逻辑，忽略中间过程.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExchangeCodec</span> <span class="keyword">extends</span> <span class="title">TelnetCodec</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">decode</span><span class="params">(Channel channel, ChannelBuffer buffer)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> readable = buffer.readableBytes();</span><br><span class="line">        <span class="comment">// 创建消息头字节数组</span></span><br><span class="line">        <span class="keyword">byte</span>[] header = <span class="keyword">new</span> <span class="keyword">byte</span>[Math.min(readable, HEADER_LENGTH)];</span><br><span class="line">        <span class="comment">// 读取消息头数据</span></span><br><span class="line">        buffer.readBytes(header);</span><br><span class="line">        <span class="comment">// 调用重载方法进行后续解码工作</span></span><br><span class="line">        <span class="keyword">return</span> decode(channel, buffer, readable, header);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">decode</span><span class="params">(Channel channel, ChannelBuffer buffer, <span class="keyword">int</span> readable, <span class="keyword">byte</span>[] header)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 检查魔数是否相等</span></span><br><span class="line">        <span class="keyword">if</span> (readable &gt; <span class="number">0</span> &amp;&amp; header[<span class="number">0</span>] != MAGIC_HIGH</span><br><span class="line">                || readable &gt; <span class="number">1</span> &amp;&amp; header[<span class="number">1</span>] != MAGIC_LOW) &#123;</span><br><span class="line">            <span class="keyword">int</span> length = header.length;</span><br><span class="line">            <span class="keyword">if</span> (header.length &lt; readable) &#123;</span><br><span class="line">                header = Bytes.copyOf(header, readable);</span><br><span class="line">                buffer.readBytes(header, length, readable - length);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; header.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (header[i] == MAGIC_HIGH &amp;&amp; header[i + <span class="number">1</span>] == MAGIC_LOW) &#123;</span><br><span class="line">                    buffer.readerIndex(buffer.readerIndex() - header.length + i);</span><br><span class="line">                    header = Bytes.copyOf(header, i);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 通过 telnet 命令行发送的数据包不包含消息头，所以这里</span></span><br><span class="line">            <span class="comment">// 调用 TelnetCodec 的 decode 方法对数据包进行解码</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.decode(channel, buffer, readable, header);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 检测可读数据量是否少于消息头长度，若小于则立即返回 DecodeResult.NEED_MORE_INPUT</span></span><br><span class="line">        <span class="keyword">if</span> (readable &lt; HEADER_LENGTH) &#123;</span><br><span class="line">            <span class="keyword">return</span> DecodeResult.NEED_MORE_INPUT;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从消息头中获取消息体长度</span></span><br><span class="line">        <span class="keyword">int</span> len = Bytes.bytes2int(header, <span class="number">12</span>);</span><br><span class="line">        <span class="comment">// 检测消息体长度是否超出限制，超出则抛出异常</span></span><br><span class="line">        checkPayload(channel, len);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> tt = len + HEADER_LENGTH;</span><br><span class="line">        <span class="comment">// 检测可读的字节数是否小于实际的字节数</span></span><br><span class="line">        <span class="keyword">if</span> (readable &lt; tt) &#123;</span><br><span class="line">            <span class="keyword">return</span> DecodeResult.NEED_MORE_INPUT;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ChannelBufferInputStream is = <span class="keyword">new</span> ChannelBufferInputStream(buffer, len);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 继续进行解码工作</span></span><br><span class="line">            <span class="keyword">return</span> decodeBody(channel, is, header);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (is.available() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    StreamUtils.skipUnusedStream(is);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    logger.warn(e.getMessage(), e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面方法通过检测消息头中的魔数是否与规定的魔数相等，提前拦截掉非常规数据包，比如通过 telnet  命令行发出的数据包。接着再对消息体长度，以及可读字节数进行检测。最后调用 decodeBody  方法进行后续的解码工作，ExchangeCodec 中实现了 decodeBody 方法，但因其子类 DubboCodec  覆写了该方法，所以在运行时 DubboCodec 中的 decodeBody 方法会被调用。下面我们来看一下该方法的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboCodec</span> <span class="keyword">extends</span> <span class="title">ExchangeCodec</span> <span class="keyword">implements</span> <span class="title">Codec2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">decodeBody</span><span class="params">(Channel channel, InputStream is, <span class="keyword">byte</span>[] header)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 获取消息头中的第三个字节，并通过逻辑与运算得到序列化器编号</span></span><br><span class="line">        <span class="keyword">byte</span> flag = header[<span class="number">2</span>], proto = (<span class="keyword">byte</span>) (flag &amp; SERIALIZATION_MASK);</span><br><span class="line">        Serialization s = CodecSupport.getSerialization(channel.getUrl(), proto);</span><br><span class="line">        <span class="comment">// 获取调用编号</span></span><br><span class="line">        <span class="keyword">long</span> id = Bytes.bytes2long(header, <span class="number">4</span>);</span><br><span class="line">        <span class="comment">// 通过逻辑与运算得到调用类型，0 - Response，1 - Request</span></span><br><span class="line">        <span class="keyword">if</span> ((flag &amp; FLAG_REQUEST) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 对响应结果进行解码，得到 Response 对象。这个非本节内容，后面再分析</span></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 创建 Request 对象</span></span><br><span class="line">            Request req = <span class="keyword">new</span> Request(id);</span><br><span class="line">            req.setVersion(Version.getProtocolVersion());</span><br><span class="line">            <span class="comment">// 通过逻辑与运算得到通信方式，并设置到 Request 对象中</span></span><br><span class="line">            req.setTwoWay((flag &amp; FLAG_TWOWAY) != <span class="number">0</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 通过位运算检测数据包是否为事件类型</span></span><br><span class="line">            <span class="keyword">if</span> ((flag &amp; FLAG_EVENT) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 设置心跳事件到 Request 对象中</span></span><br><span class="line">                req.setEvent(Request.HEARTBEAT_EVENT);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Object data;</span><br><span class="line">                <span class="keyword">if</span> (req.isHeartbeat()) &#123;</span><br><span class="line">                    <span class="comment">// 对心跳包进行解码，该方法已被标注为废弃</span></span><br><span class="line">                    data = decodeHeartbeatData(channel, deserialize(s, channel.getUrl(), is));</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (req.isEvent()) &#123;</span><br><span class="line">                    <span class="comment">// 对事件数据进行解码</span></span><br><span class="line">                    data = decodeEventData(channel, deserialize(s, channel.getUrl(), is));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    DecodeableRpcInvocation inv;</span><br><span class="line">                    <span class="comment">// 根据 url 参数判断是否在 IO 线程上对消息体进行解码</span></span><br><span class="line">                    <span class="keyword">if</span> (channel.getUrl().getParameter(</span><br><span class="line">                            Constants.DECODE_IN_IO_THREAD_KEY,</span><br><span class="line">                            Constants.DEFAULT_DECODE_IN_IO_THREAD)) &#123;</span><br><span class="line">                        inv = <span class="keyword">new</span> DecodeableRpcInvocation(channel, req, is, proto);</span><br><span class="line">                        <span class="comment">// 在当前线程，也就是 IO 线程上进行后续的解码工作。此工作完成后，可将</span></span><br><span class="line">                        <span class="comment">// 调用方法名、attachment、以及调用参数解析出来</span></span><br><span class="line">                        inv.decode();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 仅创建 DecodeableRpcInvocation 对象，但不在当前线程上执行解码逻辑</span></span><br><span class="line">                        inv = <span class="keyword">new</span> DecodeableRpcInvocation(channel, req,</span><br><span class="line">                                <span class="keyword">new</span> UnsafeByteArrayInputStream(readMessageData(is)), proto);</span><br><span class="line">                    &#125;</span><br><span class="line">                    data = inv;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 设置 data 到 Request 对象中</span></span><br><span class="line">                req.setData(data);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                <span class="comment">// 若解码过程中出现异常，则将 broken 字段设为 true，</span></span><br><span class="line">                <span class="comment">// 并将异常对象设置到 Reqeust 对象中</span></span><br><span class="line">                req.setBroken(<span class="keyword">true</span>);</span><br><span class="line">                req.setData(t);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> req;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，decodeBody 对部分字段进行了解码，并将解码得到的字段封装到 Request 中。随后会调用  DecodeableRpcInvocation 的 decode  方法进行后续的解码工作。此工作完成后，可将调用方法名、attachment、以及调用参数解析出来。下面我们来看一下  DecodeableRpcInvocation 的 decode 方法逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DecodeableRpcInvocation</span> <span class="keyword">extends</span> <span class="title">RpcInvocation</span> <span class="keyword">implements</span> <span class="title">Codec</span>, <span class="title">Decodeable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">decode</span><span class="params">(Channel channel, InputStream input)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ObjectInput in = CodecSupport.getSerialization(channel.getUrl(), serializationType)</span><br><span class="line">                .deserialize(channel.getUrl(), input);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过反序列化得到 dubbo version，并保存到 attachments 变量中</span></span><br><span class="line">        String dubboVersion = in.readUTF();</span><br><span class="line">        request.setVersion(dubboVersion);</span><br><span class="line">        setAttachment(Constants.DUBBO_VERSION_KEY, dubboVersion);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过反序列化得到 path，version，并保存到 attachments 变量中</span></span><br><span class="line">        setAttachment(Constants.PATH_KEY, in.readUTF());</span><br><span class="line">        setAttachment(Constants.VERSION_KEY, in.readUTF());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过反序列化得到调用方法名</span></span><br><span class="line">        setMethodName(in.readUTF());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object[] args;</span><br><span class="line">            Class&lt;?&gt;[] pts;</span><br><span class="line">            <span class="comment">// 通过反序列化得到参数类型字符串，比如 Ljava/lang/String;</span></span><br><span class="line">            String desc = in.readUTF();</span><br><span class="line">            <span class="keyword">if</span> (desc.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                pts = DubboCodec.EMPTY_CLASS_ARRAY;</span><br><span class="line">                args = DubboCodec.EMPTY_OBJECT_ARRAY;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 将 desc 解析为参数类型数组</span></span><br><span class="line">                pts = ReflectUtils.desc2classArray(desc);</span><br><span class="line">                args = <span class="keyword">new</span> Object[pts.length];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 解析运行时参数</span></span><br><span class="line">                        args[i] = in.readObject(pts[i]);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (log.isWarnEnabled()) &#123;</span><br><span class="line">                            log.warn(<span class="string">"Decode argument failed: "</span> + e.getMessage(), e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 设置参数类型数组</span></span><br><span class="line">            setParameterTypes(pts);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 通过反序列化得到原 attachment 的内容</span></span><br><span class="line">            Map&lt;String, String&gt; map = (Map&lt;String, String&gt;) in.readObject(Map.class);</span><br><span class="line">            <span class="keyword">if</span> (map != <span class="keyword">null</span> &amp;&amp; map.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                Map&lt;String, String&gt; attachment = getAttachments();</span><br><span class="line">                <span class="keyword">if</span> (attachment == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    attachment = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 将 map 与当前对象中的 attachment 集合进行融合</span></span><br><span class="line">                attachment.putAll(map);</span><br><span class="line">                setAttachments(attachment);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 对 callback 类型的参数进行处理</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">                args[i] = decodeInvocationArgument(channel, <span class="keyword">this</span>, pts, i, args[i]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置参数列表</span></span><br><span class="line">            setArguments(args);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(StringUtils.toString(<span class="string">"Read invocation data failed."</span>, e));</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (in <span class="keyword">instanceof</span> Cleanable) &#123;</span><br><span class="line">                ((Cleanable) in).cleanup();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的方法通过反序列化将诸如 path、version、调用方法名、参数列表等信息依次解析出来，并设置到相应的字段中，最终得到一个具有完整调用信息的 DecodeableRpcInvocation 对象。</p><p>到这里，请求数据解码的过程就分析完了。</p><h3><span id="调用服务">调用服务</span></h3><p>解码器将数据包解析成 Request 对象后，NettyHandler 的 messageReceived  方法紧接着会收到这个对象，并将这个对象继续向下传递。这期间该对象会被依次传递给  NettyServer、MultiMessageHandler、HeartbeatHandler 以及  AllChannelHandler。最后由 AllChannelHandler 将该对象封装到 Runnable 实现类对象中，并将  Runnable 放入线程池中执行后续的调用逻辑。整个调用栈如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NettyHandler#messageReceived(ChannelHandlerContext, MessageEvent)</span><br><span class="line">  —&gt; AbstractPeer#received(Channel, Object)</span><br><span class="line">    —&gt; MultiMessageHandler#received(Channel, Object)</span><br><span class="line">      —&gt; HeartbeatHandler#received(Channel, Object)</span><br><span class="line">        —&gt; AllChannelHandler#received(Channel, Object)</span><br><span class="line">          —&gt; ExecutorService#execute(Runnable)    // 由线程池执行后续的调用逻辑</span><br></pre></td></tr></table></figure><h3><span id="线程派发模型">线程派发模型</span></h3><p>Dubbo将底层通信框架中接收请求的线程称为IO线程。如果一些事件处理逻辑可以很快执行完，比如只再内存打一个标记，此时直接在IO线程上执行该段逻辑即可。但如果事件的处理逻辑比较耗时，比如该段逻辑发起数据库查询或者HTTP请求。此时我就不应该让事件处理逻辑在IO线程上执行，而是应该派发到线程池中执行。原因也很简单，IO线程主要用于接收请求，如果IO线程被占满，将导致它请求接收新的请求。</p><p>在前文提到的原理图中，<code>Dispatcher</code>就是线程派发器。它的真实职责是创建具有线程派发能力的<code>Channelhandler</code>,比如<code>AllChannelHandler</code>,<code>MessageOnlyChannelHandler</code>和<code>ExecutionChannelHandler</code>等，其本身并不具有线程派发能力。</p><p><strong>Dubbo支持的不同线程派发策略</strong></p><table><thead><tr><th>策略</th><th>用途</th></tr></thead><tbody><tr><td>all（默认）</td><td>所有消息都派发到线程池，包括请求，响应，连接事件，断开事件等。</td></tr><tr><td>direct</td><td>所有消息都不派发的线程池，全部在IO线程上直接执行。</td></tr><tr><td>message</td><td>只是请求和响应消息派发到线程池，其它消息均在IO线程上执行</td></tr><tr><td>execution</td><td>只有请求派发到线程池，不含响应。其它消息均在IO线程上执行。</td></tr><tr><td>connection</td><td>在IO线程上，将连接断开事件放入队列，有序逐个执行，其它消息派发到线程池。</td></tr></tbody></table><p>在默认配置下，Dubbo使用<code>all</code>派发策略，即将所有的消息都派发到线程池中。下面我们来分析一下<code>AllChannelHandler</code>的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AllChannelHandler</span> <span class="keyword">extends</span> <span class="title">WrappedChannelHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AllChannelHandler</span><span class="params">(ChannelHandler handler, URL url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(handler, url);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 处理连接事件 */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connected</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="comment">// 获取线程池</span></span><br><span class="line">        ExecutorService cexecutor = getExecutorService();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 将连接事件派发到线程池中处理</span></span><br><span class="line">            cexecutor.execute(<span class="keyword">new</span> ChannelEventRunnable(channel, handler, ChannelState.CONNECTED));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ExecutionException(..., <span class="string">" error when process connected event ."</span>, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 处理断开事件 */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">disconnected</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        ExecutorService cexecutor = getExecutorService();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            cexecutor.execute(<span class="keyword">new</span> ChannelEventRunnable(channel, handler, ChannelState.DISCONNECTED));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ExecutionException(..., <span class="string">"error when process disconnected event ."</span>, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 处理请求和响应消息，这里的 message 变量类型可能是 Request，也可能是 Response */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">received</span><span class="params">(Channel channel, Object message)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        ExecutorService cexecutor = getExecutorService();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 将请求和响应消息派发到线程池中处理</span></span><br><span class="line">            cexecutor.execute(<span class="keyword">new</span> ChannelEventRunnable(channel, handler, ChannelState.RECEIVED, message));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="keyword">if</span>(message <span class="keyword">instanceof</span> Request &amp;&amp; t <span class="keyword">instanceof</span> RejectedExecutionException)&#123;</span><br><span class="line">                Request request = (Request)message;</span><br><span class="line">                <span class="comment">// 如果通信方式为双向通信，此时将 Server side ... threadpool is exhausted </span></span><br><span class="line">                <span class="comment">// 错误信息封装到 Response 中，并返回给服务消费方。</span></span><br><span class="line">                <span class="keyword">if</span>(request.isTwoWay())&#123;</span><br><span class="line">                    String msg = <span class="string">"Server side("</span> + url.getIp() + <span class="string">","</span> + url.getPort() </span><br><span class="line">                        + <span class="string">") threadpool is exhausted ,detail msg:"</span> + t.getMessage();</span><br><span class="line">                    Response response = <span class="keyword">new</span> Response(request.getId(), request.getVersion());</span><br><span class="line">                    response.setStatus(Response.SERVER_THREADPOOL_EXHAUSTED_ERROR);</span><br><span class="line">                    response.setErrorMessage(msg);</span><br><span class="line">                    <span class="comment">// 返回包含错误信息的 Response 对象</span></span><br><span class="line">                    channel.send(response);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ExecutionException(..., <span class="string">" error when process received event ."</span>, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 处理异常信息 */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">caught</span><span class="params">(Channel channel, Throwable exception)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        ExecutorService cexecutor = getExecutorService();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            cexecutor.execute(<span class="keyword">new</span> ChannelEventRunnable(channel, handler, ChannelState.CAUGHT, exception));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ExecutionException(..., <span class="string">"error when process caught event ..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请求对象会被封装 ChannelEventRunnable 中，ChannelEventRunnable 将会是服务调用过程的新起点。所以接下来我们以 ChannelEventRunnable 为起点向下探索。</p><h3><span id="调用服务">调用服务</span></h3><p>我们从<code>ChannelEventRunnable</code>开始分析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChannelEventRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ChannelHandler handler;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Channel channel;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ChannelState state;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Throwable exception;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object message;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 检测通道状态，对于请求或响应消息，此时 state = RECEIVED</span></span><br><span class="line">        <span class="keyword">if</span> (state == ChannelState.RECEIVED) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 将 channel 和 message 传给 ChannelHandler 对象，进行后续的调用</span></span><br><span class="line">                handler.received(channel, message);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                logger.warn(<span class="string">"... operation error, channel is ... message is ..."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 其他消息类型通过 switch 进行处理</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">switch</span> (state) &#123;</span><br><span class="line">            <span class="keyword">case</span> CONNECTED:</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    handler.connected(channel);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    logger.warn(<span class="string">"... operation error, channel is ..."</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> DISCONNECTED:</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">case</span> SENT:</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">case</span> CAUGHT:</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                logger.warn(<span class="string">"unknown state: "</span> + state + <span class="string">", message is "</span> + message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ChannelEventRunnable</code>仅仅是一个中转站，它的run方法中并不包含具体的调用逻辑，仅用于将参数传给其它的<code>ChannelHandler</code>对象进行处理，该对象类型为<code>DecodeHandler</code>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DecodeHandler</span> <span class="keyword">extends</span> <span class="title">AbstractChannelHandlerDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DecodeHandler</span><span class="params">(ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">received</span><span class="params">(Channel channel, Object message)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (message <span class="keyword">instanceof</span> Decodeable) &#123;</span><br><span class="line">            <span class="comment">// 对 Decodeable 接口实现类对象进行解码</span></span><br><span class="line">            decode(message);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (message <span class="keyword">instanceof</span> Request) &#123;</span><br><span class="line">            <span class="comment">// 对 Request 的 data 字段进行解码</span></span><br><span class="line">            decode(((Request) message).getData());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (message <span class="keyword">instanceof</span> Response) &#123;</span><br><span class="line">            <span class="comment">// 对 Request 的 result 字段进行解码</span></span><br><span class="line">            decode(((Response) message).getResult());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行后续逻辑</span></span><br><span class="line">        handler.received(channel, message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(Object message)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Decodeable 接口目前有两个实现类，</span></span><br><span class="line">        <span class="comment">// 分别为 DecodeableRpcInvocation 和 DecodeableRpcResult</span></span><br><span class="line">        <span class="keyword">if</span> (message != <span class="keyword">null</span> &amp;&amp; message <span class="keyword">instanceof</span> Decodeable) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 执行解码逻辑</span></span><br><span class="line">                ((Decodeable) message).decode();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                <span class="keyword">if</span> (log.isWarnEnabled()) &#123;</span><br><span class="line">                    log.warn(<span class="string">"Call Decodeable.decode failed: "</span> + e.getMessage(), e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>DecodeHandler</code>主要是包含了一些解码逻辑。之前提到请求解码可以在IO线程上执行，也可以在线程池中执行，这取决于运行时配置。<code>DecodeHandler</code>存在意义就是保证请求或响应对象可在线程池中被解码。解码完毕后，完全解码后的<code>Request</code>对象会继续先后传递，下一站是<code>HeaderExchangeHandler</code>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeaderExchangeHandler</span> <span class="keyword">implements</span> <span class="title">ChannelHandlerDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExchangeHandler handler;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeaderExchangeHandler</span><span class="params">(ExchangeHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"handler == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.handler = handler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">received</span><span class="params">(Channel channel, Object message)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        channel.setAttribute(KEY_READ_TIMESTAMP, System.currentTimeMillis());</span><br><span class="line">        ExchangeChannel exchangeChannel = HeaderExchangeChannel.getOrAddChannel(channel);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 处理请求对象</span></span><br><span class="line">            <span class="keyword">if</span> (message <span class="keyword">instanceof</span> Request) &#123;</span><br><span class="line">                Request request = (Request) message;</span><br><span class="line">                <span class="keyword">if</span> (request.isEvent()) &#123;</span><br><span class="line">                    <span class="comment">// 处理事件</span></span><br><span class="line">                    handlerEvent(channel, request);</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="comment">// 处理普通的请求</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 双向通信</span></span><br><span class="line">                    <span class="keyword">if</span> (request.isTwoWay()) &#123;</span><br><span class="line">                        <span class="comment">// 向后调用服务，并得到调用结果</span></span><br><span class="line">                        Response response = handleRequest(exchangeChannel, request);</span><br><span class="line">                        <span class="comment">// 将调用结果返回给服务消费端</span></span><br><span class="line">                        channel.send(response);</span><br><span class="line">                    &#125; </span><br><span class="line">                    <span class="comment">// 如果是单向通信，仅向后调用指定服务即可，无需返回调用结果</span></span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        handler.received(exchangeChannel, request.getData());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;      </span><br><span class="line">            <span class="comment">// 处理响应对象，服务消费方会执行此处逻辑，后面分析</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (message <span class="keyword">instanceof</span> Response) &#123;</span><br><span class="line">                handleResponse(channel, (Response) message);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (message <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">                <span class="comment">// telnet 相关，忽略</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                handler.received(exchangeChannel, message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            HeaderExchangeChannel.removeChannelIfDisconnected(channel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Response <span class="title">handleRequest</span><span class="params">(ExchangeChannel channel, Request req)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        Response res = <span class="keyword">new</span> Response(req.getId(), req.getVersion());</span><br><span class="line">        <span class="comment">// 检测请求是否合法，不合法则返回状态码为 BAD_REQUEST 的响应</span></span><br><span class="line">        <span class="keyword">if</span> (req.isBroken()) &#123;</span><br><span class="line">            Object data = req.getData();</span><br><span class="line"></span><br><span class="line">            String msg;</span><br><span class="line">            <span class="keyword">if</span> (data == <span class="keyword">null</span>)</span><br><span class="line">                msg = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span></span><br><span class="line">                (data <span class="keyword">instanceof</span> Throwable) msg = StringUtils.toString((Throwable) data);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                msg = data.toString();</span><br><span class="line">            res.setErrorMessage(<span class="string">"Fail to decode request due to: "</span> + msg);</span><br><span class="line">            <span class="comment">// 设置 BAD_REQUEST 状态</span></span><br><span class="line">            res.setStatus(Response.BAD_REQUEST);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取 data 字段值，也就是 RpcInvocation 对象</span></span><br><span class="line">        Object msg = req.getData();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 继续向下调用</span></span><br><span class="line">            Object result = handler.reply(channel, msg);</span><br><span class="line">            <span class="comment">// 设置 OK 状态码</span></span><br><span class="line">            res.setStatus(Response.OK);</span><br><span class="line">            <span class="comment">// 设置调用结果</span></span><br><span class="line">            res.setResult(result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="comment">// 若调用过程出现异常，则设置 SERVICE_ERROR，表示服务端异常</span></span><br><span class="line">            res.setStatus(Response.SERVICE_ERROR);</span><br><span class="line">            res.setErrorMessage(StringUtils.toString(e));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，我们看到了比较清晰的请求和响应逻辑。对于双向通信，HeaderExchangeHandler  首先向后进行调用，得到调用结果。然后将调用结果封装到 Response  对象中，最后再将该对象返回给服务消费方。如果请求不合法，或者调用失败，则将错误信息封装到 Response  对象中，并返回给服务消费方。接下来我们继续向后分析，把剩余的调用过程分析完。下面分析定义在 DubboProtocol  类中的匿名类对象逻辑，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboProtocol</span> <span class="keyword">extends</span> <span class="title">AbstractProtocol</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NAME = <span class="string">"dubbo"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> ExchangeHandler requestHandler = <span class="keyword">new</span> ExchangeHandlerAdapter() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">reply</span><span class="params">(ExchangeChannel channel, Object message)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (message <span class="keyword">instanceof</span> Invocation) &#123;</span><br><span class="line">                Invocation inv = (Invocation) message;</span><br><span class="line">                <span class="comment">// 获取 Invoker 实例</span></span><br><span class="line">                Invoker&lt;?&gt; invoker = getInvoker(channel, inv);</span><br><span class="line">                <span class="keyword">if</span> (Boolean.TRUE.toString().equals(inv.getAttachments().get(IS_CALLBACK_SERVICE_INVOKE))) &#123;</span><br><span class="line">                    <span class="comment">// 回调相关，忽略</span></span><br><span class="line">                &#125;</span><br><span class="line">                RpcContext.getContext().setRemoteAddress(channel.getRemoteAddress());</span><br><span class="line">                <span class="comment">// 通过 Invoker 调用具体的服务</span></span><br><span class="line">                <span class="keyword">return</span> invoker.invoke(inv);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RemotingException(channel, <span class="string">"Unsupported request: ..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 忽略其他方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Invoker&lt;?&gt; getInvoker(Channel channel, Invocation inv) <span class="keyword">throws</span> RemotingException &#123;</span><br><span class="line">        <span class="comment">// 忽略回调和本地存根相关逻辑</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> port = channel.getLocalAddress().getPort();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 计算 service key，格式为 groupName/serviceName:serviceVersion:port。比如：</span></span><br><span class="line">        <span class="comment">//   dubbo/com.alibaba.dubbo.demo.DemoService:1.0.0:20880</span></span><br><span class="line">        String serviceKey = serviceKey(port, path, inv.getAttachments().get(Constants.VERSION_KEY), inv.getAttachments().get(Constants.GROUP_KEY));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从 exporterMap 查找与 serviceKey 相对应的 DubboExporter 对象，</span></span><br><span class="line">        <span class="comment">// 服务导出过程中会将 &lt;serviceKey, DubboExporter&gt; 映射关系存储到 exporterMap 集合中</span></span><br><span class="line">        DubboExporter&lt;?&gt; exporter = (DubboExporter&lt;?&gt;) exporterMap.get(serviceKey);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (exporter == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RemotingException(channel, <span class="string">"Not found exported service ..."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 Invoker 对象，并返回</span></span><br><span class="line">        <span class="keyword">return</span> exporter.getInvoker();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 忽略其他方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上逻辑用于获取与指定服务对应的 Invoker 实例，并通过 Invoker 的 invoke 方法调用服务逻辑。invoke 方法定义在 AbstractProxyInvoker 中，代码如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractProxyInvoker</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Invoker</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 调用 doInvoke 执行后续的调用，并将调用结果封装到 RpcResult 中，并</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> RpcResult(doInvoke(proxy, invocation.getMethodName(), invocation.getParameterTypes(), invocation.getArguments()));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> RpcResult(e.getTargetException());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Failed to invoke remote proxy method ..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Object <span class="title">doInvoke</span><span class="params">(T proxy, String methodName, Class&lt;?&gt;[] parameterTypes, Object[] arguments)</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，doInvoke 是一个抽象方法，这个需要由具体的 Invoker 实例实现。Invoker 实例是在运行时通过 JavassistProxyFactory 创建的，创建逻辑如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavassistProxyFactory</span> <span class="keyword">extends</span> <span class="title">AbstractProxyFactory</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略其他方法</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">getInvoker</span><span class="params">(T proxy, Class&lt;T&gt; type, URL url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Wrapper wrapper = Wrapper.getWrapper(proxy.getClass().getName().indexOf(<span class="string">'$'</span>) &lt; <span class="number">0</span> ? proxy.getClass() : type);</span><br><span class="line">        <span class="comment">// 创建匿名类对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AbstractProxyInvoker&lt;T&gt;(proxy, type, url) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> Object <span class="title">doInvoke</span><span class="params">(T proxy, String methodName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      Class&lt;?&gt;[] parameterTypes,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      Object[] arguments)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                <span class="comment">// 调用 invokeMethod 方法进行后续的调用</span></span><br><span class="line">                <span class="keyword">return</span> wrapper.invokeMethod(proxy, methodName, parameterTypes, arguments);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Wrapper 是一个抽象类，其中 invokeMethod 是一个抽象方法。Dubbo 会在运行时通过 Javassist 框架为  Wrapper 生成实现类，并实现 invokeMethod 方法，该方法最终会根据调用信息调用具体的服务。以 DemoServiceImpl  为例，Javassist 为其生成的代理类如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/** Wrapper0 是在运行时生成的，大家可使用 Arthas 进行反编译 */</span><br><span class="line">public class Wrapper0 extends Wrapper implements ClassGenerator.DC &#123;</span><br><span class="line">    public static String[] pns;</span><br><span class="line">    public static Map pts;</span><br><span class="line">    public static String[] mns;</span><br><span class="line">    public static String[] dmns;</span><br><span class="line">    public static Class[] mts0;</span><br><span class="line"></span><br><span class="line">    // 省略其他方法</span><br><span class="line"></span><br><span class="line">    public Object invokeMethod(Object object, String string, Class[] arrclass, Object[] arrobject) throws InvocationTargetException &#123;</span><br><span class="line">        DemoService demoService;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 类型转换</span><br><span class="line">            demoService = (DemoService)object;</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Throwable throwable) &#123;</span><br><span class="line">            throw new IllegalArgumentException(throwable);</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 根据方法名调用指定的方法</span><br><span class="line">            if (&quot;sayHello&quot;.equals(string) &amp;&amp; arrclass.length == 1) &#123;</span><br><span class="line">                return demoService.sayHello((String)arrobject[0]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Throwable throwable) &#123;</span><br><span class="line">            throw new InvocationTargetException(throwable);</span><br><span class="line">        &#125;</span><br><span class="line">        throw new NoSuchMethodException(new StringBuffer().append(&quot;Not found method \&quot;&quot;).append(string).append(&quot;\&quot; in class com.alibaba.dubbo.demo.DemoService.&quot;).toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，整个服务调用过程就分析完了。最后把调用过程贴出来，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ChannelEventRunnable#run()</span><br><span class="line">  —&gt; DecodeHandler#received(Channel, Object)</span><br><span class="line">    —&gt; HeaderExchangeHandler#received(Channel, Object)</span><br><span class="line">      —&gt; HeaderExchangeHandler#handleRequest(ExchangeChannel, Request)</span><br><span class="line">        —&gt; DubboProtocol.requestHandler#reply(ExchangeChannel, Object)</span><br><span class="line">          —&gt; Filter#invoke(Invoker, Invocation)</span><br><span class="line">            —&gt; AbstractProxyInvoker#invoke(Invocation)</span><br><span class="line">              —&gt; Wrapper0#invokeMethod(Object, String, Class[], Object[])</span><br><span class="line">                —&gt; DemoServiceImpl#sayHello(String)</span><br></pre></td></tr></table></figure><h3><span id="服务提供方返回调用结果">服务提供方返回调用结果</span></h3><p>服务提供方调用指定服务后，会将调用结果封装到 Response 对象中，并将该对象返回给服务消费方。服务提供方也是通过 NettyChannel 的 send 方法将 Response 对象返回。具体的就不再分析了。</p><h2><span id="服务消费方接收调用结果">服务消费方接收调用结果</span></h2><p>服务消费方在收到响应数据后，首先要做的事情是对响应数据进行解码，得到 Response  对象。然后再将该对象传递给下一个入站处理器，这个入站处理器就是 NettyHandler。接下来 NettyHandler  会将这个对象继续向下传递，最后 AllChannelHandler 的 received  方法会收到这个对象，并将这个对象派发到线程池中。这个过程和服务提供方接收请求的过程是一样的，因此这里就不重复分析了。本节我们重点分析两个方面的内容，一是响应数据的解码过程，二是 Dubbo 如何将调用结果传递给用户线程的。下面先来分析响应数据的解码过程。</p><h3><span id="响应数据解码">响应数据解码</span></h3><p>响应数据解码的逻辑主要封装在<code>DubboCodec</code>中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboCodec</span> <span class="keyword">extends</span> <span class="title">ExchangeCodec</span> <span class="keyword">implements</span> <span class="title">Codec2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">decodeBody</span><span class="params">(Channel channel, InputStream is, <span class="keyword">byte</span>[] header)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span> flag = header[<span class="number">2</span>], proto = (<span class="keyword">byte</span>) (flag &amp; SERIALIZATION_MASK);</span><br><span class="line">        Serialization s = CodecSupport.getSerialization(channel.getUrl(), proto);</span><br><span class="line">        <span class="comment">// 获取请求编号</span></span><br><span class="line">        <span class="keyword">long</span> id = Bytes.bytes2long(header, <span class="number">4</span>);</span><br><span class="line">        <span class="comment">// 检测消息类型，若下面的条件成立，表明消息类型为 Response</span></span><br><span class="line">        <span class="keyword">if</span> ((flag &amp; FLAG_REQUEST) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 创建 Response 对象</span></span><br><span class="line">            Response res = <span class="keyword">new</span> Response(id);</span><br><span class="line">            <span class="comment">// 检测事件标志位</span></span><br><span class="line">            <span class="keyword">if</span> ((flag &amp; FLAG_EVENT) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 设置心跳事件</span></span><br><span class="line">                res.setEvent(Response.HEARTBEAT_EVENT);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 获取响应状态</span></span><br><span class="line">            <span class="keyword">byte</span> status = header[<span class="number">3</span>];</span><br><span class="line">            <span class="comment">// 设置响应状态</span></span><br><span class="line">            res.setStatus(status);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果响应状态为 OK，表明调用过程正常</span></span><br><span class="line">            <span class="keyword">if</span> (status == Response.OK) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Object data;</span><br><span class="line">                    <span class="keyword">if</span> (res.isHeartbeat()) &#123;</span><br><span class="line">                        <span class="comment">// 反序列化心跳数据，已废弃</span></span><br><span class="line">                        data = decodeHeartbeatData(channel, deserialize(s, channel.getUrl(), is));</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (res.isEvent()) &#123;</span><br><span class="line">                        <span class="comment">// 反序列化事件数据</span></span><br><span class="line">                        data = decodeEventData(channel, deserialize(s, channel.getUrl(), is));</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        DecodeableRpcResult result;</span><br><span class="line">                        <span class="comment">// 根据 url 参数决定是否在 IO 线程上执行解码逻辑</span></span><br><span class="line">                        <span class="keyword">if</span> (channel.getUrl().getParameter(</span><br><span class="line">                                Constants.DECODE_IN_IO_THREAD_KEY,</span><br><span class="line">                                Constants.DEFAULT_DECODE_IN_IO_THREAD)) &#123;</span><br><span class="line">                            <span class="comment">// 创建 DecodeableRpcResult 对象</span></span><br><span class="line">                            result = <span class="keyword">new</span> DecodeableRpcResult(channel, res, is,</span><br><span class="line">                                    (Invocation) getRequestData(id), proto);</span><br><span class="line">                            <span class="comment">// 进行后续的解码工作</span></span><br><span class="line">                            result.decode();</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">// 创建 DecodeableRpcResult 对象</span></span><br><span class="line">                            result = <span class="keyword">new</span> DecodeableRpcResult(channel, res,</span><br><span class="line">                                    <span class="keyword">new</span> UnsafeByteArrayInputStream(readMessageData(is)),</span><br><span class="line">                                    (Invocation) getRequestData(id), proto);</span><br><span class="line">                        &#125;</span><br><span class="line">                        data = result;</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 设置 DecodeableRpcResult 对象到 Response 对象中</span></span><br><span class="line">                    res.setResult(data);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    <span class="comment">// 解码过程中出现了错误，此时设置 CLIENT_ERROR 状态码到 Response 对象中</span></span><br><span class="line">                    res.setStatus(Response.CLIENT_ERROR);</span><br><span class="line">                    res.setErrorMessage(StringUtils.toString(t));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">// 响应状态非 OK，表明调用过程出现了异常</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 反序列化异常信息，并设置到 Response 对象中</span></span><br><span class="line">                res.setErrorMessage(deserialize(s, channel.getUrl(), is).readUTF());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 对请求数据进行解码，前面已分析过，此处忽略</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解码之后，通过<code>DecodeableRpcResult</code>进行调用结果的反序列化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DecodeableRpcResult</span> <span class="keyword">extends</span> <span class="title">RpcResult</span> <span class="keyword">implements</span> <span class="title">Codec</span>, <span class="title">Decodeable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Invocation invocation;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasDecoded &amp;&amp; channel != <span class="keyword">null</span> &amp;&amp; inputStream != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 执行反序列化操作</span></span><br><span class="line">                decode(channel, inputStream);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                <span class="comment">// 反序列化失败，设置 CLIENT_ERROR 状态到 Response 对象中</span></span><br><span class="line">                response.setStatus(Response.CLIENT_ERROR);</span><br><span class="line">                <span class="comment">// 设置异常信息</span></span><br><span class="line">                response.setErrorMessage(StringUtils.toString(e));</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                hasDecoded = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">decode</span><span class="params">(Channel channel, InputStream input)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ObjectInput in = CodecSupport.getSerialization(channel.getUrl(), serializationType)</span><br><span class="line">                .deserialize(channel.getUrl(), input);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 反序列化响应类型</span></span><br><span class="line">        <span class="keyword">byte</span> flag = in.readByte();</span><br><span class="line">        <span class="keyword">switch</span> (flag) &#123;</span><br><span class="line">            <span class="keyword">case</span> DubboCodec.RESPONSE_NULL_VALUE:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> DubboCodec.RESPONSE_VALUE:</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> DubboCodec.RESPONSE_WITH_EXCEPTION:</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">                </span><br><span class="line">            <span class="comment">// 返回值为空，且携带了 attachments 集合</span></span><br><span class="line">            <span class="keyword">case</span> DubboCodec.RESPONSE_NULL_VALUE_WITH_ATTACHMENTS:</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 反序列化 attachments 集合，并存储起来 </span></span><br><span class="line">                    setAttachments((Map&lt;String, String&gt;) in.readObject(Map.class));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IOException(StringUtils.toString(<span class="string">"Read response data failed."</span>, e));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">                </span><br><span class="line">            <span class="comment">// 返回值不为空，且携带了 attachments 集合</span></span><br><span class="line">            <span class="keyword">case</span> DubboCodec.RESPONSE_VALUE_WITH_ATTACHMENTS:</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 获取返回值类型</span></span><br><span class="line">                    Type[] returnType = RpcUtils.getReturnTypes(invocation);</span><br><span class="line">                    <span class="comment">// 反序列化调用结果，并保存起来</span></span><br><span class="line">                    setValue(returnType == <span class="keyword">null</span> || returnType.length == <span class="number">0</span> ? in.readObject() :</span><br><span class="line">                            (returnType.length == <span class="number">1</span> ? in.readObject((Class&lt;?&gt;) returnType[<span class="number">0</span>])</span><br><span class="line">                                    : in.readObject((Class&lt;?&gt;) returnType[<span class="number">0</span>], returnType[<span class="number">1</span>])));</span><br><span class="line">                    <span class="comment">// 反序列化 attachments 集合，并存储起来</span></span><br><span class="line">                    setAttachments((Map&lt;String, String&gt;) in.readObject(Map.class));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IOException(StringUtils.toString(<span class="string">"Read response data failed."</span>, e));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">                </span><br><span class="line">            <span class="comment">// 异常对象不为空，且携带了 attachments 集合</span></span><br><span class="line">            <span class="keyword">case</span> DubboCodec.RESPONSE_WITH_EXCEPTION_WITH_ATTACHMENTS:</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 反序列化异常对象</span></span><br><span class="line">                    Object obj = in.readObject();</span><br><span class="line">                    <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Throwable == <span class="keyword">false</span>)</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Response data error, expect Throwable, but get "</span> + obj);</span><br><span class="line">                    <span class="comment">// 设置异常对象</span></span><br><span class="line">                    setException((Throwable) obj);</span><br><span class="line">                    <span class="comment">// 反序列化 attachments 集合，并存储起来</span></span><br><span class="line">                    setAttachments((Map&lt;String, String&gt;) in.readObject(Map.class));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IOException(StringUtils.toString(<span class="string">"Read response data failed."</span>, e));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Unknown result flag, expect '0' '1' '2', get "</span> + flag);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (in <span class="keyword">instanceof</span> Cleanable) &#123;</span><br><span class="line">            ((Cleanable) in).cleanup();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="向用户线程传递调用结果">向用户线程传递调用结果</span></h3><p>响应数据解码完成后，Dubbo  会将响应对象派发到线程池上。要注意的是，线程池中的线程并非用户的调用线程，所以要想办法将响应对象从线程池线程传递到用户线程上。我们之前分析过用户线程在发送完请求后的动作，即调用 DefaultFuture 的 get  方法等待响应对象的到来。当响应对象到来后，用户线程会被唤醒，并通过<strong>调用编号</strong>获取属于自己的响应对象。下面我们来看一下整个过程对应的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeaderExchangeHandler</span> <span class="keyword">implements</span> <span class="title">ChannelHandlerDelegate</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">received</span><span class="params">(Channel channel, Object message)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        channel.setAttribute(KEY_READ_TIMESTAMP, System.currentTimeMillis());</span><br><span class="line">        ExchangeChannel exchangeChannel = HeaderExchangeChannel.getOrAddChannel(channel);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (message <span class="keyword">instanceof</span> Request) &#123;</span><br><span class="line">                <span class="comment">// 处理请求，前面已分析过，省略</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (message <span class="keyword">instanceof</span> Response) &#123;</span><br><span class="line">                <span class="comment">// 处理响应</span></span><br><span class="line">                handleResponse(channel, (Response) message);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (message <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">                <span class="comment">// telnet 相关，忽略</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                handler.received(exchangeChannel, message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            HeaderExchangeChannel.removeChannelIfDisconnected(channel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleResponse</span><span class="params">(Channel channel, Response response)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (response != <span class="keyword">null</span> &amp;&amp; !response.isHeartbeat()) &#123;</span><br><span class="line">            <span class="comment">// 继续向下调用</span></span><br><span class="line">            DefaultFuture.received(channel, response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultFuture</span> <span class="keyword">implements</span> <span class="title">ResponseFuture</span> </span>&#123;  </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition done = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Response response;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">received</span><span class="params">(Channel channel, Response response)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 根据调用编号从 FUTURES 集合中查找指定的 DefaultFuture 对象</span></span><br><span class="line">            DefaultFuture future = FUTURES.remove(response.getId());</span><br><span class="line">            <span class="keyword">if</span> (future != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 继续向下调用</span></span><br><span class="line">                future.doReceived(response);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                logger.warn(<span class="string">"The timeout response finally returned at ..."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            CHANNELS.remove(response.getId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReceived</span><span class="params">(Response res)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 保存响应对象</span></span><br><span class="line">            response = res;</span><br><span class="line">            <span class="keyword">if</span> (done != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 唤醒用户线程</span></span><br><span class="line">                done.signal();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">            invokeCallback(callback);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上逻辑是将响应对象保存到相应的 DefaultFuture 实例中，然后再唤醒用户线程，随后用户线程即可从 DefaultFuture 实例中获取到相应结果。</p><p><strong>为什么要有调用编号？</strong></p><p>一般情况下，服务消费方会并发调用多个服务，每个用户线程发送请求后，会调用不同 DefaultFuture 对象的 get 方法进行等待。  一段时间后，服务消费方的线程池会收到多个响应对象。这个时候要考虑一个问题，如何将每个响应对象传递给相应的 DefaultFuture  对象，且不出错。答案是通过调用编号。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Dubbo服务调用的基本过程如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/05/10/Y33nc8.png&quot; alt=&quot;Y33nc8.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;首先服务消费者通过代理对象Proxy发起远程调用，接着通过网络客户端将编码后的请求发送给服务提供方的网络层上。Server收到请求之后，首先要做的就是对数据包进行解码。然后将解码后的请求发送至分发器，再由分发器将请求发送到指定的线程池上，最后由线程池调用具体的服务。这就是一个远程调用请求的发送过程。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="https://zofun.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Dubbo" scheme="https://zofun.github.io/tags/Dubbo/"/>
    
  </entry>
  
  <entry>
    <title>InnoDB的锁</title>
    <link href="https://zofun.github.io/2020/05/04/InnoDB%E7%9A%84%E9%94%81/"/>
    <id>https://zofun.github.io/2020/05/04/InnoDB的锁/</id>
    <published>2020-05-04T14:20:00.000Z</published>
    <updated>2020-05-04T14:20:28.155Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="什么是锁">什么是锁？</span></h2><p>锁是数据库系统区别于文件系统的一个关键特性，锁机制用于管理对共享资源的并发访问。</p><h2><span id="lock和latch">lock和latch</span></h2><p>latch一般称为闩锁，因为其要求锁定的时间必须非常短，则应用的性能会非常的差。在InnoDB存储引擎中，latch由可以分为matuex（互斥量）和rwlock（读写锁）。其目的是用来保证并发线程操作临界资源的正确性，并且通常没有死锁检查机制。</p><p>lock的对象是事务，用来锁定的是数据库中的对象，如表、页、行。并且一般lock的对象仅在事务commit或rollback后进行释放。此外lock是有死锁检查机制的。</p><a id="more"></a><p><img src="https://s1.ax1x.com/2020/05/04/YCT7f1.png" alt="YCT7f1.png"></p><h2><span id="innodb存储引擎中的锁">InnoDB存储引擎中的锁</span></h2><h3><span id="锁的类型">锁的类型</span></h3><p>InnoDB存储引擎实现了两种标准的行级锁：</p><ul><li>共享锁（S Lock），允许事务读一行数据</li><li>排他锁（X Lock），允许事务删除或更新一行数据</li></ul><p><img src="https://s1.ax1x.com/2020/05/04/YC7NN9.png" alt="YC7NN9.png"></p><p>InnoDB存储引擎支持多粒度锁定，这种锁定允许事务在行级锁和标记锁上的锁定同时存在。为了支持不同粒度上进行加锁操作，InnoDB存储引擎支持一个额外的锁方式，称为意向锁。意向锁是将锁定的对象分为多个层次，意向锁意味着事务希望在更细粒度上进行加锁。</p><p>InnoDB存储引擎支持意向锁设计比较简练，其意向锁即为表级别的锁。设计目的主要是为了在一个事务中揭示下一行将被请求的锁类型。其支持两种意向锁：</p><ol><li>意向共享锁（IS Lock），事务想要获得一张表中某几行的共享锁。</li><li>意向排他锁（IX Lock），事务想要获得一张表中某几行的排他锁。</li></ol><p><img src="https://s1.ax1x.com/2020/05/04/YCXFcn.png" alt="YCXFcn.png"></p><h3><span id="一致性非锁定读">一致性非锁定读</span></h3><p>一致性非锁定读是指InnoDB存储引擎通过多版本控制的方式来读取当前执行时间数据库中行的数据。如果读取的行正在执行DELETE或UPDATE操作，这式读取操作不会因此区等待行上锁的释放。相反的，InnoDB存储引擎会区读取行的一个快照数据。快照数据是只该行的之前版本的数据，该实现是通过indo断来完成，而undo用来在事务中回滚数据，因此快照数据本身是没有额外的开销。此外，读取快照数据是不需要上锁的，因为没有事务需要对历史的数据进行修改操作。这种并发控制，其实就是多版本并发控制MVCC。</p><h3><span id="一致性锁定读">一致性锁定读</span></h3><p>在默认的配置下，事务的隔离级别为可重复读，innoDB存储引擎的select操作使用一致性非锁定读，但是在某些情况下，用户需要显示地对数据库读取操作进行加锁一保证数据逻辑地一致性。而这个时候就需要数据库支持加锁语句。InnoDB存储引擎对于select语句支持两种一致性地锁定读操作。</p><ul><li><p>select … for update(对读取地行加一个X锁)</p></li><li><p>select …lock in share mode（对读取地行加一个S锁）</p></li></ul><h3><span id="自增长与锁">自增长与锁</span></h3><p>在InnoDB存储引擎地内存结构中，对每个含有自镇长只地表都有一个自增长计数器。档含有自增长计数器地表进行插入操作时，这个计数器会被初始化。插入操作会根据这个自增长地计数器加一赋予自增长列。这个实现方式叫 <code>AUTO-INC Locking</code>.这种锁其实是采用一种特殊地表锁机制，为了提高插入地性能，锁不是在一个事务完成后才释放，而是在完成对自增长值插入地SQL语句后立即释放。</p><p>​    </p><h3><span id="外键和锁">外键和锁</span></h3><p>外键的主要用于引用完整性的约束检查，在InnoDB存储引擎中，对于一个外键列，如果没有显示地对这个列加索引，InnoDB存储引擎自动对其加一个索引，因为这样可以避免表锁。</p><p>对于外键值地插入或更新，首先要查询父表中地记录，即select父表，但是对于父表的select操作，不是使用一致性非锁定读的方式，因为这样会发生数据不一致的问题，因此这时使用的时select … lock in share mode方式，即主动对父表加一个s锁。如果这时父表上已经加了x锁，子表上的操作会被阻塞。</p><h2><span id="锁的算法">锁的算法</span></h2><h3><span id="行锁的三种算法">行锁的三种算法</span></h3><p>InnoDB存储引擎有三种行锁的算法，其分别是：</p><ul><li>Record Lock：单个行记录上的锁</li><li>Gap Lock：间隙锁，锁定一个范围，但不包含记录本身</li><li>Next-Key Lock：Gap Lock+record Lock，锁定一个范围，并且锁定记录本身。</li></ul><p>record lock总是会区锁定索引记录，如果innodb存储引擎表在建立的时候没有设置任何一个索引，那么这时InnoDB存储引擎会使用隐式的主键来进行锁定。</p><h3><span id="解决幻读问题">解决幻读问题</span></h3><p>幻读问题是指在同一事务中，连续两次同样的sql语句可能导致不同的结果，第二次的sql语句可能会返回之前不存在的行。InnoDB存储引擎采用Next-Key Locking的算法来避免幻读问题。</p><h2><span id="死锁">死锁</span></h2><h3><span id="死锁的概念">死锁的概念</span></h3><p>死锁是指两个或两个以上的事务在执行过程中，因争夺资源而造成的一种互相等待的现象。</p><h3><span id="解决方案">解决方案</span></h3><p>解决死锁的一种方案是超时，即当两个事务互相等待时，当一个等待时间超过设置的某一阈值时，其中一个事务进行回滚，另一个继续进行。</p><p>这种超时机制虽然简单，但是其仅通过超时后对事务进行回滚的方式来处理，或者说其时根据FIFO的顺序选择回滚对象。当若超时的事务所占的权重较大，如果事务操作更新了很多行，占用了较多的undo log，这时FIFO的方式，就显得不合适了，因为回滚这个事务的时间相对于另一个事务所占用的时间可能会很多。</p><p>因此除了超时机制之外，当前数据库还普遍采用了等待图的方式来进行死锁检测。较之超时的解决方案，这是一种更为主动的死锁检测方式。InnoDB存储引擎也采用这种方式。等待图要求数据库保存以下两种信息。</p><ul><li>锁的信息链表</li><li>事务等待链表</li></ul><p>通过上述信息可以够着出一张图，而在这个图种若存在回路，就代表存在死锁，因此资源间互相发生等待。</p><h2><span id="锁升级">锁升级</span></h2><p>锁升级时至当前锁粒度降低，举例来说，数据库可以把一个表的1000个行锁升级未页锁，或者间页锁升级未表锁。如果在数据库的设计中，认为锁是一种稀有资源，而且想要避免锁的开销，那数据库中会频繁出现锁升级现象。</p><p>InnoDB存储引擎不存在锁升级这个问题，因为其不是根据每个记录来产生行锁的，相反，其根据每个事务访问的每个页对锁进行管理的，采用的是位图的方式，因此不管一个事务锁住页中一个记录还是多个记录，其开销都是一致的。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是锁？&quot;&gt;&lt;a href=&quot;#什么是锁？&quot; class=&quot;headerlink&quot; title=&quot;什么是锁？&quot;&gt;&lt;/a&gt;什么是锁？&lt;/h2&gt;&lt;p&gt;锁是数据库系统区别于文件系统的一个关键特性，锁机制用于管理对共享资源的并发访问。&lt;/p&gt;
&lt;h2 id=&quot;lock和latch&quot;&gt;&lt;a href=&quot;#lock和latch&quot; class=&quot;headerlink&quot; title=&quot;lock和latch&quot;&gt;&lt;/a&gt;lock和latch&lt;/h2&gt;&lt;p&gt;latch一般称为闩锁，因为其要求锁定的时间必须非常短，则应用的性能会非常的差。在InnoDB存储引擎中，latch由可以分为matuex（互斥量）和rwlock（读写锁）。其目的是用来保证并发线程操作临界资源的正确性，并且通常没有死锁检查机制。&lt;/p&gt;
&lt;p&gt;lock的对象是事务，用来锁定的是数据库中的对象，如表、页、行。并且一般lock的对象仅在事务commit或rollback后进行释放。此外lock是有死锁检查机制的。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="https://zofun.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="InnoDB" scheme="https://zofun.github.io/tags/InnoDB/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot启动原理</title>
    <link href="https://zofun.github.io/2020/05/03/SpringBoot%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86/"/>
    <id>https://zofun.github.io/2020/05/03/SpringBoot启动原理/</id>
    <published>2020-05-03T06:25:00.000Z</published>
    <updated>2020-05-03T12:03:38.484Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="springboot启动">SpringBoot启动</span></h2><p>SpringBoot因为内置了tomcat或jetty服务器，不需要直接部署War文件，所以SpringBoot的程序起点是一个普通的主函数。主函数如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringbootStudyApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SpringbootStudyApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个SpringBoot的启动过程其实都是通过<code>@SpringBootApplication</code>注解和<code>SpringApplication.run</code>方法来实现的。</p><p>整个启动的过程可以概括为：</p><ol><li>读取所有依赖的<code>META-INF/spring.factories</code>文件，该文件指明了哪些依赖可以被自动加载。</li><li>根据<code>importSelector</code>类选择加载哪些依赖，使用<code>conditionOn</code>系列注解排除掉不需要的配置文件</li><li>将剩余的配置文件所代表的bean加载到IOC容器中。</li></ol><a id="more"></a><p>比如<code>spring-boot-2.1.8RELEASE.jar</code>中的<code>spring.factories</code>文件的内容是整个样子的(节选)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># PropertySource Loaders</span><br><span class="line">org.springframework.boot.env.PropertySourceLoader=\</span><br><span class="line">org.springframework.boot.env.PropertiesPropertySourceLoader,\</span><br><span class="line">org.springframework.boot.env.YamlPropertySourceLoader</span><br><span class="line"></span><br><span class="line"># Run Listeners</span><br><span class="line">org.springframework.boot.SpringApplicationRunListener=\</span><br><span class="line">org.springframework.boot.context.event.EventPublishingRunListener</span><br><span class="line"></span><br><span class="line"># Error Reporters</span><br><span class="line">org.springframework.boot.SpringBootExceptionReporter=\</span><br><span class="line">org.springframework.boot.diagnostics.FailureAnalyzers</span><br><span class="line"></span><br><span class="line"># Application Context Initializers</span><br><span class="line">org.springframework.context.ApplicationContextInitializer=\</span><br><span class="line">org.springframework.boot.context.ConfigurationWarningsApplicationContextInitializer,\</span><br><span class="line">org.springframework.boot.context.ContextIdApplicationContextInitializer,\</span><br><span class="line">org.springframework.boot.context.config.DelegatingApplicationContextInitializer,\</span><br><span class="line">org.springframework.boot.web.context.ServerPortInfoApplicationContextInitializer</span><br></pre></td></tr></table></figure><p>这个文件中的内容最终会被解析为<code>Map&lt;K,List&lt;V&gt;&gt;</code>这种格式。键和值都是一个类的全限定名。</p><h2><span id="跟踪源码探索原理">跟踪源码，探索原理</span></h2><p>我们从这段代码开始跟踪<code>SpringApplication.run(SpringbootStudyApplication.class, args);</code></p><p>这段代码经过重重调用最终来到了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(Class&lt;?&gt;[] primarySources, String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> SpringApplication(primarySources).run(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法完成了<code>SpringApplication</code>的实例化。具体的实例化过程如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SpringApplication</span><span class="params">(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">Assert.notNull(primarySources, <span class="string">"PrimarySources must not be null"</span>);</span><br><span class="line"><span class="keyword">this</span>.primarySources = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(Arrays.asList(primarySources));</span><br><span class="line"><span class="keyword">this</span>.webApplicationType = WebApplicationType.deduceFromClasspath();</span><br><span class="line">           <span class="comment">//将初始化器放到数组中</span></span><br><span class="line">setInitializers((Collection) </span><br><span class="line">                       getSpringFactoriesInstances(ApplicationContextInitializer.class));</span><br><span class="line">       <span class="comment">//把初始化的监听器加入到数组中</span></span><br><span class="line">setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));</span><br><span class="line">       <span class="comment">//获得主类</span></span><br><span class="line"><span class="keyword">this</span>.mainApplicationClass = deduceMainApplicationClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个<code>Application</code>的实例化过程中，下面这两行代码比较关键。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));</span><br><span class="line">setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));</span><br></pre></td></tr></table></figure><p>方法的具体实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">Collection&lt;T&gt; <span class="title">getSpringFactoriesInstances</span><span class="params">(Class&lt;T&gt; type, Class&lt;?&gt;[] parameterTypes, Object... args)</span> </span>&#123;</span><br><span class="line">ClassLoader classLoader = getClassLoader();</span><br><span class="line"><span class="comment">// Use names and ensure unique to protect against duplicates</span></span><br><span class="line">       <span class="comment">//获取FactoryClass的全限定名</span></span><br><span class="line">Set&lt;String&gt; names = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(SpringFactoriesLoader.loadFactoryNames(type, classLoader));</span><br><span class="line">       <span class="comment">//直接利用反射实例化对象</span></span><br><span class="line">List&lt;T&gt; instances = createSpringFactoriesInstances(type, parameterTypes, classLoader, args, names);</span><br><span class="line">AnnotationAwareOrderComparator.sort(instances);</span><br><span class="line"><span class="keyword">return</span> instances;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>loadFactoryNames</code>方法，其实就是从我们之前提到的<code></code>spring.factories<code>读取数据，然后以</code>Map<code>的形式进行存储的，</code>loadFactoryNames<code>就是从这个</code>Map`中取数据（类的全限定名）。</p><p>读取<code>spring.factories</code>的具体实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(<span class="meta">@Nullable</span> ClassLoader classLoader) &#123;</span><br><span class="line">    MultiValueMap&lt;String, String&gt; result = cache.get(classLoader);</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">try</span> &#123;</span><br><span class="line">        Enumeration&lt;URL&gt; urls = (classLoader != <span class="keyword">null</span> ?</span><br><span class="line">            <span class="comment">// FACTORIES_RESOURCE_LOCATION = "META-INF/spring.factories"    classLoader.getResources(FACTORIES_RESOURCE_LOCATION) :</span></span><br><span class="line">                ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));</span><br><span class="line">        result = <span class="keyword">new</span> LinkedMultiValueMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (urls.hasMoreElements()) &#123;</span><br><span class="line">            URL url = urls.nextElement();</span><br><span class="line">            UrlResource resource = <span class="keyword">new</span> UrlResource(url);</span><br><span class="line">            Properties properties = PropertiesLoaderUtils.loadProperties(resource);</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) &#123;</span><br><span class="line">                String factoryClassName = ((String) entry.getKey()).trim();</span><br><span class="line">                    <span class="keyword">for</span> (String factoryName : StringUtils.commaDelimitedListToStringArray((String) entry.getValue())) &#123;</span><br><span class="line">                    result.add(factoryClassName, factoryName.trim());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cache.put(classLoader, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unable to load factories from location ["</span> +</span><br><span class="line">                FACTORIES_RESOURCE_LOCATION + <span class="string">"]"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="comment">// like:</span></span><br><span class="line">    <span class="comment">// org.springframework.boot.autoconfigure.EnableAutoConfiguration -&gt; &#123;LinkedList@1446&#125; size = 118</span></span><br><span class="line">    <span class="comment">//   |</span></span><br><span class="line">    <span class="comment">//   |- org.springframework.boot.autoconfigure.EnableAutoConfiguration</span></span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拿到需要加载的类的全限定名之后，就通过反射进行实例化，然后返回。在<code>Application</code>的构造器中，拿到这些对象后，存入到List中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">private List&lt;ApplicationContextInitializer&lt;?&gt;&gt; initializers;</span><br><span class="line">private List&lt;ApplicationListener&lt;?&gt;&gt; listeners;</span><br></pre></td></tr></table></figure><p>到这个地方，我们已经拿到了所有的依赖类，那么SpringBoot是如何进行自动配置的呢？</p><p>其实前面我们看到的源码都是<code>SpingApplication</code>的实例化，整个实例化过程就完成了依赖类信息，而<code>run</code>方法其实就是完成装配的。具体的看下面的分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">StopWatch stopWatch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">stopWatch.start();</span><br><span class="line">ConfigurableApplicationContext context = <span class="keyword">null</span>;</span><br><span class="line">Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">configureHeadlessProperty();</span><br><span class="line">SpringApplicationRunListeners listeners = getRunListeners(args);</span><br><span class="line">listeners.starting();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">ApplicationArguments applicationArguments = <span class="keyword">new</span> DefaultApplicationArguments(args);</span><br><span class="line">ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments);</span><br><span class="line">configureIgnoreBeanInfo(environment);</span><br><span class="line">Banner printedBanner = printBanner(environment);</span><br><span class="line">context = createApplicationContext();</span><br><span class="line">exceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter.class,</span><br><span class="line"><span class="keyword">new</span> Class[] &#123; ConfigurableApplicationContext.class &#125;, context);</span><br><span class="line">prepareContext(context, environment, listeners, applicationArguments, printedBanner);</span><br><span class="line">           <span class="comment">//关键代码</span></span><br><span class="line">refreshContext(context);</span><br><span class="line">afterRefresh(context, applicationArguments);</span><br><span class="line">stopWatch.stop();</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</span><br><span class="line"><span class="keyword">new</span> StartupInfoLogger(<span class="keyword">this</span>.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);</span><br><span class="line">&#125;</span><br><span class="line">listeners.started(context);</span><br><span class="line">callRunners(context, applicationArguments);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">handleRunFailure(context, ex, exceptionReporters, listeners);</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">listeners.running(context);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">handleRunFailure(context, ex, exceptionReporters, <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>run</code>方法中最关键的就是<code>refreshContext(context);</code>。它实际上是调用了<code>refresh</code>方法，这个方法对应读过Spring源码的同学不会陌生。而我们bean的装配过程实际上就是由它完成的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line"><span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">prepareRefresh();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize message source for this context.</span></span><br><span class="line">initMessageSource();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">onRefresh();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">registerListeners();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">finishRefresh();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">logger.warn(<span class="string">"Exception encountered during context initialization - "</span> +</span><br><span class="line"><span class="string">"cancelling refresh attempt: "</span> + ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">destroyBeans();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reset 'active' flag.</span></span><br><span class="line">cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Propagate exception to caller.</span></span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">// Reset common introspection caches in Spring's core, since we</span></span><br><span class="line"><span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">resetCommonCaches();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>invokeBeanFactoryPostProcessors</code>会解析<code>@import</code>注解，并根据<code>@import</code>的属性进行下一步操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">invokeBeanFactoryPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());</span><br><span class="line"><span class="comment">// 省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeBeanFactoryPostProcessors</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            ConfigurableListableBeanFactory beanFactory, List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Invoke BeanDefinitionRegistryPostProcessors first, if any.</span></span><br><span class="line">    Set&lt;String&gt; processedBeans = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (beanFactory <span class="keyword">instanceof</span> BeanDefinitionRegistry) &#123;</span><br><span class="line">        BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;</span><br><span class="line">        List&lt;BeanFactoryPostProcessor&gt; regularPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;BeanDefinitionRegistryPostProcessor&gt; registryProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录是否是定义类的 Processor 或者普通的 Processor</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span></span><br><span class="line">        <span class="comment">// uninitialized to let the bean factory post-processors apply to them!</span></span><br><span class="line">        <span class="comment">// Separate between BeanDefinitionRegistryPostProcessors that implement</span></span><br><span class="line">        <span class="comment">// PriorityOrdered, Ordered, and the rest.</span></span><br><span class="line">        List&lt;BeanDefinitionRegistryPostProcessor&gt; currentRegistryProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="comment">// 应用 Bean 定义类的后置处理器</span></span><br><span class="line">        invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeBeanDefinitionRegistryPostProcessors</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            Collection&lt;? extends BeanDefinitionRegistryPostProcessor&gt; postProcessors, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (BeanDefinitionRegistryPostProcessor postProcessor : postProcessors) &#123;</span><br><span class="line">        postProcessor.postProcessBeanDefinitionRegistry(registry);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>invokerBeandefintionRegistryPostProcessors</code>函数对每一个定义类的后置处理器分别进行应用，<code>@Configure</code>的解析就在这个函数中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从注册表中的配置类派生更多的bean定义</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">this</span>.registriesPostProcessed.add(registryId);</span><br><span class="line">    <span class="comment">// Build and validate a configuration model based on the registry of Configuration classes.</span></span><br><span class="line">    processConfigBeanDefinitions(registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入最关键的类<code>ConfigurationClassPostProcessor</code>，这个类用户来注册所有的<code>@Configure</code>和<code>@Bean</code>, 它的<code>processConfigbeanDefinitions</code>函数如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processConfigBeanDefinitions</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">    List&lt;BeanDefinitionHolder&gt; configCandidates = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    String[] candidateNames = registry.getBeanDefinitionNames();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录所有候选的未加载的配置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return immediately if no @Configuration classes were found</span></span><br><span class="line">    <span class="keyword">if</span> (configCandidates.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按照 Ordered 对配置进行排序</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载自定义 bean 名命策略</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.environment == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.environment = <span class="keyword">new</span> StandardEnvironment();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Parse each @Configuration class</span></span><br><span class="line">    ConfigurationClassParser parser = <span class="keyword">new</span> ConfigurationClassParser(</span><br><span class="line">            <span class="keyword">this</span>.metadataReaderFactory, <span class="keyword">this</span>.problemReporter, <span class="keyword">this</span>.environment,</span><br><span class="line">            <span class="keyword">this</span>.resourceLoader, <span class="keyword">this</span>.componentScanBeanNameGenerator, registry);</span><br><span class="line"></span><br><span class="line">    Set&lt;BeanDefinitionHolder&gt; candidates = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(configCandidates);</span><br><span class="line">    Set&lt;ConfigurationClass&gt; alreadyParsed = <span class="keyword">new</span> HashSet&lt;&gt;(configCandidates.size());</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 解译候选集</span></span><br><span class="line">        parser.parse(candidates);</span><br><span class="line">        parser.validate();</span><br><span class="line"></span><br><span class="line">        Set&lt;ConfigurationClass&gt; configClasses = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(parser.getConfigurationClasses());</span><br><span class="line">        configClasses.removeAll(alreadyParsed);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Read the model and create bean definitions based on its content</span></span><br><span class="line">        <span class="keyword">this</span>.reader.loadBeanDefinitions(configClasses);</span><br><span class="line">        alreadyParsed.addAll(configClasses);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (!candidates.isEmpty());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes</span></span><br><span class="line">    <span class="keyword">if</span> (sbr != <span class="keyword">null</span> &amp;&amp; !sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) &#123;</span><br><span class="line">        sbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.metadataReaderFactory <span class="keyword">instanceof</span> CachingMetadataReaderFactory) &#123;</span><br><span class="line">        <span class="comment">// Clear cache in externally provided MetadataReaderFactory; this is a no-op</span></span><br><span class="line">        <span class="comment">// for a shared cache since it'll be cleared by the ApplicationContext.</span></span><br><span class="line">        ((CachingMetadataReaderFactory) <span class="keyword">this</span>.metadataReaderFactory).clearCache();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在解释候选集<code>parser.parse(candidates)</code>中，会调用<code>suorceClass=doProcessConfigurationClass(configClass,sourceClass)</code>方法依次解析注解，得到所有的候选集。该方法顺次解析<code>@PropertySource</code>，<code>@componentScan</code>,<code>@Import</code>,<code>@importResource</code>,<code>@Bean</code>父类。</p><p>解析完成之后，会找到所有以 <code>@PropertySource</code>、<code>@ComponentScan</code>、<code>@Import</code>、<code>@ImportResource</code>、<code>@Bean</code> 注解的类及其对象，如果有 <code>DeferredImportSelector</code>，会将其加入到 <code>deferredImportSelectorHandler</code> 中，并调用 <code>this.deferredImportSelectorHandler.process()</code> 对这些 <code>DeferredImportSelector</code> 进行处理。</p><p>实际上，在 spring boot 中，容器初始化的时候，主要就是对 <code>AutoConfigurationImportSelector</code> 进行处理。</p><p>Spring 会将 <code>AutoConfigurationImportSelector</code> 封装成一个 <code>AutoConfigurationGroup</code>，用于处理。最终会调用 <code>AutoConfigurationGroup</code> 的 <code>process</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(AnnotationMetadata annotationMetadata, DeferredImportSelector deferredImportSelector)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 主要通过该函数找到所有需要自动配置的类</span></span><br><span class="line">            AutoConfigurationEntry autoConfigurationEntry = ((AutoConfigurationImportSelector) deferredImportSelector)</span><br><span class="line">                    .getAutoConfigurationEntry(getAutoConfigurationMetadata(), annotationMetadata);</span><br><span class="line">            <span class="keyword">this</span>.autoConfigurationEntries.add(autoConfigurationEntry);</span><br><span class="line">            <span class="keyword">for</span> (String importClassName : autoConfigurationEntry.getConfigurations()) &#123;</span><br><span class="line">                <span class="keyword">this</span>.entries.putIfAbsent(importClassName, annotationMetadata);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">protected</span> AutoConfigurationEntry <span class="title">getAutoConfigurationEntry</span><span class="params">(AutoConfigurationMetadata autoConfigurationMetadata,</span></span></span><br><span class="line"><span class="function"><span class="params">    AnnotationMetadata annotationMetadata)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isEnabled(annotationMetadata)) &#123;</span><br><span class="line">        <span class="keyword">return</span> EMPTY_ENTRY;</span><br><span class="line">    &#125;</span><br><span class="line">    AnnotationAttributes attributes = getAttributes(annotationMetadata);</span><br><span class="line">    List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes);</span><br><span class="line">    configurations = removeDuplicates(configurations);</span><br><span class="line">    Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);</span><br><span class="line">    checkExcludedClasses(configurations, exclusions);</span><br><span class="line">    configurations.removeAll(exclusions);</span><br><span class="line">    configurations = filter(configurations, autoConfigurationMetadata);</span><br><span class="line">    fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AutoConfigurationEntry(configurations, exclusions);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;String&gt; <span class="title">getCandidateConfigurations</span><span class="params">(AnnotationMetadata metadata, AnnotationAttributes attributes)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(),</span><br><span class="line">            getBeanClassLoader());</span><br><span class="line">    <span class="keyword">return</span> configurations;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，我们可以看到 <code>process</code> 最终调用了我们非常熟悉的函数 <code>SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(), getBeanClassLoader());</code>，该方法以 <code>EnableAutoConfiguration</code> 类为键（<code>org.springframework.boot.autoconfigure.EnableAutoConfiguration</code>），取得所有的值。</p><p>在该函数中，还会调用 <code>configurations = filter(configurations, autoConfigurationMetadata)</code> 方法，将不需要的候选集全部排除。（该方法内部使用 <code>AutoConfigurationImportFilter</code> 的实现类排除）。</p><p>我们看一个常见的 <code>configuration</code>，即 <code>org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration</code>，这个类中有大量的 <code>@Bean</code> 注解的方法，用来产生 bean，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RequestMappingHandlerAdapter <span class="title">requestMappingHandlerAdapter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RequestMappingHandlerAdapter adapter = <span class="keyword">super</span>.requestMappingHandlerAdapter();</span><br><span class="line">    adapter.setIgnoreDefaultModelOnRedirect(</span><br><span class="line">            <span class="keyword">this</span>.mvcProperties == <span class="keyword">null</span> || <span class="keyword">this</span>.mvcProperties.isIgnoreDefaultModelOnRedirect());</span><br><span class="line">    <span class="keyword">return</span> adapter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>spring 通过读取所有所需要的 <code>AutoConfiguration</code>，就可以加载默认的上下文容器，实现自动注入。</strong></p><h2><span id="springboot常用注解简介">SpringBoot常用注解简介</span></h2><ol><li><p><code>@Configuration</code></p><p> 作用于类，用于定义配置类，可替换xml配置文件，被注解的类内部包含有一个或多个被<code>@Bean</code>注解的方法，这些方法会被<code>AnnotationConfigApplicationContext</code>或<code>AnncationConfigWebApplicationContext</code>类进行扫描，并用于构建bean定义，初始化spring容器。</p></li><li><p><code>@ComponentScan</code></p><p> 该注解会扫描<code>@Controller</code>,<code>@Service</code>,<code>@Repository</code>,<code>@component</code>注解到类到spring容器中。</p></li><li><p><code>@SpringBootApplication</code></p><p> 该注解包含了<code>@ComponentScan</code>注解，所以在使用中我们可以通过<code>@SpringBootApplication</code>注解的scanBasepackages属性进行配置。</p></li><li><p><code>@Conditional</code></p><p> 该注解作用于类，它可以根据代码中的条件装载不同的bean，在设置注解之前类需要实现<code>Condition</code>接口，然后对该实现接口的类设置是否装载条件。</p></li><li><p><code>@Import</code></p><p> 通过导入的方式实现吧实例加入spring容器中，可以在需要时间没有被spring管理的类导入至Spring容器中。</p></li><li><p><code>@ImportResource</code></p><p> 和<code>@Import</code>类似，区别就是该注解导入的是配置文件。</p></li><li><p><code>Component</code></p><p> 该注解是一个元注解，意思是可以注解其它类注解，如<code>@Controller</code> <code>@Service</code> <code>@Repository</code>。带此注解的类被看作组件，当使用基于注解的配置和类路径扫描的时候，这些类就会被实例化。</p></li><li><p><code>@SpringBootApplication</code></p><p> 这个注解是Spring Boot最核心的注解，用在SpringBoot的主类上，标识这是一个Spring Boot应用。用来开启Spring Boot的各项能力，实际上这个注解<code>@Configuration</code>,<code>@EnableAutoConfiguration</code>,<code>@ComponentScan</code>三个注解的组合.由于这些注解一般都是一起使用的。</p></li><li><p><code>@EnableAutoConfiguration</code></p><p> 允许Spring Boot自动配置注解，开启这个注解之后，Spring Boot就能根据当前类路径下的包或者类来配置Spring Bean。配置信息是从<code>META-INF/spring.factories</code>加载的。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;SpringBoot启动&quot;&gt;&lt;a href=&quot;#SpringBoot启动&quot; class=&quot;headerlink&quot; title=&quot;SpringBoot启动&quot;&gt;&lt;/a&gt;SpringBoot启动&lt;/h2&gt;&lt;p&gt;SpringBoot因为内置了tomcat或jetty服务器，不需要直接部署War文件，所以SpringBoot的程序起点是一个普通的主函数。主函数如下：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@SpringBootApplication&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SpringbootStudyApplication&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        SpringApplication.run(SpringbootStudyApplication.class, args);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;整个SpringBoot的启动过程其实都是通过&lt;code&gt;@SpringBootApplication&lt;/code&gt;注解和&lt;code&gt;SpringApplication.run&lt;/code&gt;方法来实现的。&lt;/p&gt;
&lt;p&gt;整个启动的过程可以概括为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;读取所有依赖的&lt;code&gt;META-INF/spring.factories&lt;/code&gt;文件，该文件指明了哪些依赖可以被自动加载。&lt;/li&gt;
&lt;li&gt;根据&lt;code&gt;importSelector&lt;/code&gt;类选择加载哪些依赖，使用&lt;code&gt;conditionOn&lt;/code&gt;系列注解排除掉不需要的配置文件&lt;/li&gt;
&lt;li&gt;将剩余的配置文件所代表的bean加载到IOC容器中。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="https://zofun.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="SpringBoot" scheme="https://zofun.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Maven和Git命令的一些总结</title>
    <link href="https://zofun.github.io/2020/05/02/Maven%E5%92%8CGit%E5%91%BD%E4%BB%A4%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93/"/>
    <id>https://zofun.github.io/2020/05/02/Maven和Git命令的一些总结/</id>
    <published>2020-05-02T08:26:00.000Z</published>
    <updated>2020-05-02T08:27:18.810Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="maven命令">Maven命令</span></h2><ol><li><p>创建Maven的普通Java项目</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mvn archetype:create</span><br><span class="line">-DgroupId=packageName</span><br><span class="line">- DartifactId=projectName</span><br></pre></td></tr></table></figure></li><li><p>创建Maven的Web项目：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mvn archetype:create</span><br><span class="line">    -DgroupId=packageName</span><br><span class="line">    -DartifactId=webappName</span><br><span class="line">    -DarchetypeArtifactId=maven-archetype-webapp</span><br></pre></td></tr></table></figure></li><li><p>编译源代码</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvc compile</span><br></pre></td></tr></table></figure> <a id="more"></a></li><li><p>编译测试代码</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn test-compile</span><br></pre></td></tr></table></figure></li><li><p>运行测试</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvc test</span><br></pre></td></tr></table></figure></li><li><p>产生site</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn site</span><br></pre></td></tr></table></figure></li><li><p>打包</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn package</span><br></pre></td></tr></table></figure></li><li><p>在本地的仓库中安装jar</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvc install</span><br></pre></td></tr></table></figure></li><li><p>清除产生的项目</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean</span><br></pre></td></tr></table></figure></li><li><p>上传到私服</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn deploy</span><br></pre></td></tr></table></figure></li></ol><p><code>mvn compile</code>与<code>mvn install</code>,<code>mvn deloy</code>的区别</p><ol><li><code>mvn compile</code>编译类文件</li><li><code>mvn install</code>包含<code>mvn compile</code>,<code>mvn  package</code>然后上传到本地仓库</li><li><code>mvn deploy</code>包含<code>mvn install</code>然后上传到私服</li></ol><h2><span id="git命令">Git命令</span></h2><ol><li><p>新建代码库</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git init # 在当前目录生成一个git代码库</span><br><span class="line">git init [project-name] # 新建一个目录，将其初始化为git代码库</span><br><span class="line">git clone [url] # 下载一个项目和它的整个代码历史</span><br></pre></td></tr></table></figure></li><li><p>增加/删除文件</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git add [file] # 添加指定文件到暂存区</span><br><span class="line">git add [dir] # 添加指定目录到暂存区</span><br><span class="line">git add . # 添加当前目录的所有文件到暂存区</span><br><span class="line">git rm [file] # 删除工作区文件，并且将这次删除放入暂存区</span><br><span class="line">git mv [file-original][fule-renamed] # 改名文件</span><br></pre></td></tr></table></figure></li><li><p>代码提交</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m [message] # 提交暂存区到仓库区</span><br></pre></td></tr></table></figure></li><li><p>分支管理</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git branch # 列出所有的本地分支</span><br><span class="line">git branch -r # 列出所有的远程分支</span><br><span class="line">git branch -a # 列出所有本地分支和远程分支</span><br><span class="line">git branch [branch-name] # 新建一个分支，但依然停留在当前分支</span><br><span class="line">git chechout -b [branch] # 新建一个分支，并切换到该分支</span><br></pre></td></tr></table></figure></li><li><p>标签</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git tag # 列出所有tag</span><br><span class="line">git tag [tag] # 新建一个tag在指定commit</span><br><span class="line">git tag -d [tag] # 删除本地tag</span><br><span class="line">git push origin :refs/tags/[tagName] # 删除远程分支</span><br><span class="line">git show [tag] # 查看tag信息</span><br><span class="line">git push [remote][tag] # 提交指定tag</span><br><span class="line">git checkout -b [branch][tag] # 新建一个分支，指向某个tag</span><br></pre></td></tr></table></figure></li><li><p>查看信息</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git status # 显示有变更的文件</span><br><span class="line">git log # 显示当前分支的版本历史</span><br><span class="line">git diff # 显示暂存区和工作区的代码差异</span><br><span class="line">git reflog # 显示当前分支的最近几次提价</span><br></pre></td></tr></table></figure></li><li><p>远程同步</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git remore update # 更新远程仓库</span><br><span class="line">git fetch [remote] # 下载远程仓库的所有变动</span><br><span class="line">git remote -v # 显示所有远程仓库</span><br><span class="line">git pull [remote][branch] #取回远程仓库的变换，并与本地分支合并</span><br><span class="line">git push [remote][branch] # 上传本地指定分支到远程仓库</span><br></pre></td></tr></table></figure></li><li><p>撤销</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git checkout [file] #恢复缓冲区的指定文件到工作区</span><br><span class="line">git checkout [commit][file] # 恢复某个commit的指定文件到暂存区和工作区</span><br><span class="line">git reset [file] # 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span><br><span class="line">git reset --hard # 重置暂存区与工作区，与上一次commit保持一致</span><br><span class="line">git reset [commit] #重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span><br><span class="line">git reset --hard [commit] # 重置当前分支的head为指定commit，同时重置暂存区和工作区，与指定commit一致</span><br><span class="line"></span><br><span class="line">git revert [commit] # 新建一个commit，用于册小指定commit，后置的所有变换都会被前者抵消，并且应用当前分支</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Maven命令&quot;&gt;&lt;a href=&quot;#Maven命令&quot; class=&quot;headerlink&quot; title=&quot;Maven命令&quot;&gt;&lt;/a&gt;Maven命令&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;创建Maven的普通Java项目&lt;/p&gt;
 &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;mvn archetype:create&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	-DgroupId=packageName&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	- DartifactId=projectName&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;创建Maven的Web项目：&lt;/p&gt;
 &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;mvn archetype:create&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    -DgroupId=packageName&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    -DartifactId=webappName&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    -DarchetypeArtifactId=maven-archetype-webapp&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;编译源代码&lt;/p&gt;
 &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;mvc compile&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="https://zofun.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Maven" scheme="https://zofun.github.io/tags/Maven/"/>
    
      <category term="Git" scheme="https://zofun.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>高可用Redis：Redis Cluster</title>
    <link href="https://zofun.github.io/2020/05/01/%E9%AB%98%E5%8F%AF%E7%94%A8Redis%EF%BC%9ARedis%20Cluster/"/>
    <id>https://zofun.github.io/2020/05/01/高可用Redis：Redis Cluster/</id>
    <published>2020-05-01T14:20:00.000Z</published>
    <updated>2020-05-01T14:23:03.286Z</updated>
    
    <content type="html"><![CDATA[<p>Redis Cluster是Redis官方提供的Redis集群功能。</p><h2><span id="为什么现需要redis-cluster">为什么现需要Redis Cluster</span></h2><ol><li>主从复制不能满足高可用的要求</li><li>随着业务的发展，需要更高的QPS</li><li>数据量的增长导致服务器内存不足以存储</li><li>网络流量的增长，业务的流量已经超过了服务器的网卡的上限值，可以考虑使用分布式技术来进行分流。</li><li>离线计算，需要中间环节缓冲等别的需求。</li></ol><h2><span id="数据分布">数据分布</span></h2><p>当单机的redis节点无法满足要求，按照分区规则把数据分到若干个子集中。<br><a id="more"></a></p><h3><span id="常见的数据分布方法">常见的数据分布方法</span></h3><h4><span id="顺序分布">顺序分布</span></h4><p>比如有1-100个数据，要保存的三个节点上，那么1-33号数据放在第一个节点上，34-66号数据放在第二个节点上，依此类推。</p><h4><span id="哈希分布">哈希分布</span></h4><p>对键进行hash后，根据哈希码，来进行分区。</p><p>常见的分区方式有：</p><ol><li>节点取余分区：对key进行hash之后，与节点数进行取余运算，根据余数不同保存在不同的节点上。该分区方式的问题就是不利于节点数量的调整。但节点数量变动时，大量的数据需要迁移。</li><li>一致性哈希分区：将所有的数据当作一个token环，token环中的数据范围时0到2的32次方，然后为每一个数据节点分配一个token范围值，这个节点就负责保存这个节点范围的数据。对每一个key进行hash运算，将哈希后的结果在哪个token范围内，则按照顺时针去找最近的节点，这个key就会被保存在这个节点上。</li><li>虚拟槽分区：虚拟槽分区时Redis Cluster采用的分区方式，预设虚拟槽，每个槽就相当于一个数字，有一定的范围。每个槽映射一个数据子集，一般比节点数大。Redis cluster中预设的虚拟槽的范围为0到16383</li></ol><p>虚拟槽分区的步骤：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.把16384槽按照节点数量进行平均分配，由节点进行管理</span><br><span class="line">2.对每个key按照CRC16规则进行hash运算</span><br><span class="line">3.把hash结果对16383进行取余</span><br><span class="line">4.把余数发送给Redis节点</span><br><span class="line">5.节点接收到数据，验证是否在自己管理的槽编号的范围</span><br><span class="line">    如果在自己管理的槽编号范围内，则把数据保存到数据槽中，然后返回执行结果</span><br><span class="line">    如果在自己管理的槽编号范围外，则会把数据发送给正确的节点，由正确的节点来把数据保存在对应的槽中</span><br></pre></td></tr></table></figure><p>虚拟槽分区的特点：<br>使用服务器端话管理节点，槽，数据<br>可以对数据进行打散，又可以保证数据分布均匀。</p><h2><span id="redis-cluster基本架构">Redis Cluster基本架构</span></h2><h3><span id="节点">节点</span></h3><p>Redis Cluster是分布式架构，即Redis Cluster中有多个节点，每个节点购汇负责数据读写操作，每个节点之间会进行通信，</p><h3><span id="meet操作">meet操作</span></h3><p>节点之间会互相通信<br>meet操作时节点之间完成相互通信的基础，meet操作有一定的频率和规则。</p><h3><span id="分配槽">分配槽</span></h3><p>把16384个槽平均分配给节点进行管理，每个节点只能对自己负责的槽进行读写。由于每个节点之间都彼此通信，每个节点都知道另外节点负责管理的槽范围。<br>客户端访问任意任意节点时，对数据key按照CRC16规则进行hash运算，然后对运算结果对16383进行取余，如果余数在当前访问的节点管理的槽的范围内，则直接返回对应的数据，否则会告诉客户端去哪个节点获取数据，由客户端去正确的节点获取数据。</p><h3><span id="复制">复制</span></h3><p>保证高可用，每个主节点都有一个从节点，当主节点故障，cluster会按照规则实现主备的高可用</p><h3><span id="客户端路由">客户端路由</span></h3><h4><span id="moved重定向">moved重定向</span></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 每个节点通过通信都会共享redis cluster中槽和集群中对应节点的关系</span><br><span class="line">2. 客户端向redis cluster的任意节点发送命令，接收命令的节点会根据CRC16规则进行hash算法与16383取余，计算自己的槽和对应节点</span><br><span class="line">3. 如果保存数据槽被分配给当前节点，则去槽中执行命令，并把命令执行结果返回给客户端</span><br><span class="line">4. 如果保存数据的槽不再当前节点的管理范围内，则向客户端返回moved重定向异常</span><br><span class="line">5. 客户端接收到节点返回的节点，如果时moved异常，则从moved异常中获取目标节点的信息</span><br><span class="line">6. 客户端向目标节点发送命令，获取命令执行命令。</span><br></pre></td></tr></table></figure><h3><span id="ask重定向">ask重定向</span></h3><p>对集群进行扩容和缩容时，需要对槽及槽中的数据进行迁移。<br>当客户端向某个节点发送命令，节点向客户端返回moved异常，告诉客户端数据对应的槽节点信息。如果此时正在进行集群拓展或者缩空操作，当客户端向正确的节点发送命令时，槽及槽中数据已经被迁移到被的节点了，就会返回ask。<br>步骤：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 客户端向目标节点发送命令，目标节点中的槽已经迁移到别的节点上，此时目标节点会返回ask转向给客户端</span><br><span class="line">2. 客户端向新的节点发送asking命令给新的节点，然后再次给新节点发送命令</span><br><span class="line">3. 新节点执行命令，把命令执行结果返回给客户端。</span><br></pre></td></tr></table></figure><h2><span id="故障发现">故障发现</span></h2><p>Redis cluster通过pin/pong消息实现故障发现，不需要sentinel。<br>ping/pong不仅能传递节点与槽的对应消息，也能传递其它状态，比如：节点主从状态，节点故障等。</p><h3><span id="主观下线">主观下线</span></h3><p>主观下线只代表一个节点对另一个节点的判断，不代表所有节点的认知。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 节点1定期发送ping消息给节点2</span><br><span class="line">2. 如果发送成功，代表节点2正常运行，节点2会响应pong消息给节点1，节点1更新与节点2的最后通信时间</span><br><span class="line">3. 如果发送失败，则节点1和节点2之间的通信异常判断连接，在下一个定时任务周期时，仍然会与节点2发送ping消息。</span><br><span class="line">4. 如果节点1发送与节点2最后通信时间超过node-timeout，则把节点2标识为pfail状态</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2020/05/01/JXzyVJ.png" alt="JXzyVJ.png"></p><h4><span id="客观下线">客观下线</span></h4><p>当半数以上持有槽的主节点都标记某节点主观下线时，可以保证判断的公平性。<br>客观下线流程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 某个节点接收到其它节点发送的ping信息，如果接收到的ping消息中包含了其它pfail节点，这个节点会将主观下线消息添加到自身的故障列表中，故障列表中包含了当前节点接收到的每一个节点对其它节点的状态信息。</span><br><span class="line">2. 当前节点把主观下线的消息内容添加到故障列表之后，会尝试对故障节点进行客观下线操作。</span><br></pre></td></tr></table></figure><h2><span id="故障恢复">故障恢复</span></h2><h3><span id="资格检查">资格检查</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">对从节点的资格进行检查，只有难过检查的从节点才可以开始进行故障恢复</span><br><span class="line">每个从节点检查与故障主节点的断线时间</span><br><span class="line">超过cluster-node-timeout * cluster-slave-validity-factor数字，则取消资格</span><br><span class="line">cluster-node-timeout默认为15秒，cluster-slave-validity-factor默认值为10</span><br><span class="line">如果这两个参数都使用默认值，则每个节点都检查与故障主节点的断线时间，如果超过150秒，则这个节点就没有成为替换主节点的可能性</span><br></pre></td></tr></table></figure><h3><span id="准备选举时间">准备选举时间</span></h3><p>使偏移量最大的从节点具备优先级成为主节点的条件。<br><img src="https://s1.ax1x.com/2020/05/01/Jjpo4A.png" alt="Jjpo4A.png"></p><h3><span id="选举投票">选举投票</span></h3><p>对选举出来的多个从节点进行投票，选出新的主节点<br><img src="https://s1.ax1x.com/2020/05/01/Jjpqjf.png" alt="Jjpqjf.png"></p><h3><span id="替换主节点">替换主节点</span></h3><p>当前从节点取消复制变成离节点。执行cluster del slot撤销故障主节点负责的槽，并执行cluster add slot把这些槽分配给自己<br>向集群广播自己的pong消息，表明已经替换了故障从节点</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redis Cluster是Redis官方提供的Redis集群功能。&lt;/p&gt;
&lt;h2 id=&quot;为什么现需要Redis-Cluster&quot;&gt;&lt;a href=&quot;#为什么现需要Redis-Cluster&quot; class=&quot;headerlink&quot; title=&quot;为什么现需要Redis Cluster&quot;&gt;&lt;/a&gt;为什么现需要Redis Cluster&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;主从复制不能满足高可用的要求&lt;/li&gt;
&lt;li&gt;随着业务的发展，需要更高的QPS&lt;/li&gt;
&lt;li&gt;数据量的增长导致服务器内存不足以存储&lt;/li&gt;
&lt;li&gt;网络流量的增长，业务的流量已经超过了服务器的网卡的上限值，可以考虑使用分布式技术来进行分流。&lt;/li&gt;
&lt;li&gt;离线计算，需要中间环节缓冲等别的需求。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;数据分布&quot;&gt;&lt;a href=&quot;#数据分布&quot; class=&quot;headerlink&quot; title=&quot;数据分布&quot;&gt;&lt;/a&gt;数据分布&lt;/h2&gt;&lt;p&gt;当单机的redis节点无法满足要求，按照分区规则把数据分到若干个子集中。&lt;br&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="https://zofun.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Redis" scheme="https://zofun.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>JVM是如何实现多态的</title>
    <link href="https://zofun.github.io/2020/04/23/JVM%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%A4%9A%E6%80%81%E7%9A%84/"/>
    <id>https://zofun.github.io/2020/04/23/JVM是如何实现多态的/</id>
    <published>2020-04-23T14:04:00.000Z</published>
    <updated>2020-04-23T14:05:59.393Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="java中的多态">Java中的多态</span></h2><p>多态是面向对象的三大核心概念之一。多态简单来讲就是父类引用指向子类对象。</p><p>在Java中要实现多态需要满足三个必要条件：<strong>继承、重写、父类引用指向子类对象</strong>。</p><p><code>Parent p=new Child();</code></p><p>多态的引入带来了这写好处：</p><ul><li>消除类型之间的耦合关系</li><li>可替换性</li><li>可扩充性</li><li>接口性</li><li>灵活性</li><li>简化性</li></ul><a id="more"></a><h2><span id="jvm是如何实现多态的">JVM是如何实现多态的</span></h2><h3><span id="jvm方法调用的背景知识">JVM方法调用的背景知识</span></h3><h4><span id="java的方法调用">Java的方法调用</span></h4><p>Java的class文件的编译过程中并不包含传统编译过程的链接阶段。class文件中的方法都是以符号引用的形式存储的，而不是方法的入口地址。这个特性使得Java具有强大的动态拓展的能力，但同时也增加了Java方法调用过程的复杂性。Java的方法需要在类加载期间或者运行期间才能确定真正的入口地址，即符号引用转换为直接引用。</p><p>JVM中提供了5种方法调用的字节码指令：</p><ul><li><code>invokestatic</code>:调用静态方法</li><li><code>invokespecial</code>:调用实例构造器<code>&lt;init&gt;</code>方法、私有方法和父类方法</li><li><code>invokevirtual</code>:调用虚方法</li><li><code>invokeinterface</code>：调用接口方法，会在运行是再确定一个实现此接口的对象</li><li><code>invokedynamic</code>：先在运行时动态解析处调用点限定符所用的方法，然后再执行该方法。</li></ul><p>只要能被<code>invokestatic</code>和<code>invokespecial</code>指令调用的方法，都可以在类加载过程中的解析阶段确定唯一的调用版本，符合这个条件的方法有：静态方法、私有方法、实例构造器和父类方法，它们在类加载过程中的解析阶段就会将符号引用解析为该方法的直接引用。这些方法可被称为非虚方法（也就是不涉及多态的方法）。</p><p>因此方法调用可以分为两种，一种是类加载过程中的解析阶段完成的，另一种要在运行时完成，叫作<strong>分派</strong>。</p><h3><span id="分派">分派</span></h3><p>正是因为多态的存在，使得在判断方法调用的版本的时候会存在选择的问题，这也是分派阶段存在的原因。</p><h4><span id="静态分派">静态分派</span></h4><p>编译器会根据变量的静态类型作为判断的依据选择合适的重载版本。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticDispatch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义三个静态内部类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Human</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Human human)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"human"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Man man)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"man"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Woman woman)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"woman"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//这两个对象的静态类型就是Human</span></span><br><span class="line">        Human man=<span class="keyword">new</span> Man();</span><br><span class="line">        Human woman=<span class="keyword">new</span> Woman();</span><br><span class="line">        </span><br><span class="line">        sayHello(man);</span><br><span class="line">        sayHello(woman);</span><br><span class="line"><span class="comment">//修改静态类型</span></span><br><span class="line">        sayHello((Man) man);</span><br><span class="line">        sayHello((Woman) woman);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">human</span></span><br><span class="line"><span class="comment">human</span></span><br><span class="line"><span class="comment">man</span></span><br><span class="line"><span class="comment">woman</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>静态分派就是Java语言是心啊重载的本质。jvm通过静态类型来选择具体的方法，完成符号引用到直接引用的转换。</p><h4><span id="动态分派">动态分派</span></h4><p>动态分派与多态的重写有关。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicDispatch</span>  </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义三个静态内部类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"human"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"man"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Human</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"woman"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Human man=<span class="keyword">new</span> Man();</span><br><span class="line">        Human woman=<span class="keyword">new</span> Woman();</span><br><span class="line">        man.sayHello();</span><br><span class="line">        woman.sayHello();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">运行结果：</span></span><br><span class="line"><span class="comment">man</span></span><br><span class="line"><span class="comment">woman</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>查看字节码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=3, args_size=1</span><br><span class="line">         0: new           #2                  // class test/DynamicDispatch$Man</span><br><span class="line">         3: dup</span><br><span class="line">         4: invokespecial #3                  // Method test/DynamicDispatch$Man.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         7: astore_1</span><br><span class="line">         8: new           #4                  // class test/DynamicDispatch$Woman</span><br><span class="line">        11: dup</span><br><span class="line">        12: invokespecial #5                  // Method test/DynamicDispatch$Woman.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">        15: astore_2</span><br><span class="line">        16: aload_1</span><br><span class="line">        17: invokevirtual #6                  // Method test/DynamicDispatch$Human.sayHello:()V</span><br><span class="line">        20: aload_2</span><br><span class="line">        21: invokevirtual #6                  // Method test/DynamicDispatch$Human.sayHello:()V</span><br><span class="line">        24: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 33: 0</span><br><span class="line">        line 34: 8</span><br><span class="line">        line 35: 16</span><br><span class="line">        line 36: 20</span><br><span class="line">        line 38: 24</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0      25     0  args   [Ljava/lang/String;</span><br><span class="line">            8      17     1   man   Ltest/DynamicDispatch$Human;</span><br><span class="line">           16       9     2 woman   Ltest/DynamicDispatch$Human;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从字节码中我们可以看出在完成man和woman两个对象的创建之后，它将创建的对象压入栈中。</p><p>然后通过<code>invokevirtual</code>进行方法调用。</p><p><code>invokevirtual</code>指令的运行时解析过程大致分为以下几个步骤：</p><ul><li>找到操作数栈顶的第一个元素所指向的对象的实际类型，记为C。</li><li>如果在类型C中找到与常量池中描述符和简单名称一样的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，返回<code>java.lang.IllegalAccessError</code>异常。</li><li>否则，按照继承关系从下到上依次对C的各个父类进行搜索和验证。</li><li>如果还没有找到合适的方法，则抛出<code>java.lang.AbstractMethodError</code>异常。</li></ul><p>由于<code>invokevirtual</code>指令执行的第一步就是在运行期间确定接收者的实际类型，所以两次调用中的<code>invokevirtual</code>指令把常量池中的类方法符号引用解析到了不同的直接引用上，这个过程就是Java语言中方法重写的本质。这种在运行期根据实际类型确定方法执行版本的分派过程叫做动态分派。</p><h3><span id="虚拟机是如何实现动态分配的">虚拟机是如何实现动态分配的</span></h3><p>由于动态分派是非常频繁的操作，而且动态分派的方法版本选择过程需要运行时在类的方法元数据中搜索合适的目标方法，因此虚拟机会进行优化。常用的方法就是为类在方法区中建立一个虚方法表（Virtual Method Table，在<code>invokeinterface</code>执行时也会用到接口方法表，Interface Method Table），使用虚方法表索引来替代元数据查找以提升性能。</p><p>虚方法表中存放着各个方法的实际入口地址。如果某个方法在子类中没有被重写，那子类的虚方法表里面的地址入口和父类相同方法的地址入口是一致的，都指向父类的实现入口。如果子类重写了父类的方法，子类方法表中的地址会替换为指向子类实现版本的入口地址。</p><p>为了程序实现上的方便，具有相同签名的方法，在父类和子类的虚方法表中都应该具有一样的索引号，这样当类型变换时，仅仅需要变更查找的方法表，就可以从不同的虚方法表中按索引转换出所需的入口地址。</p><p>方法表一般在类加载的连接阶段进行初始化，准备了类的变量初始值后，虚拟机会把该类的方法表也初始化完毕。</p><p><a href="https://blog.csdn.net/q982151756/article/details/81588284" target="_blank" rel="noopener">参考博客地址</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Java中的多态&quot;&gt;&lt;a href=&quot;#Java中的多态&quot; class=&quot;headerlink&quot; title=&quot;Java中的多态&quot;&gt;&lt;/a&gt;Java中的多态&lt;/h2&gt;&lt;p&gt;多态是面向对象的三大核心概念之一。多态简单来讲就是父类引用指向子类对象。&lt;/p&gt;
&lt;p&gt;在Java中要实现多态需要满足三个必要条件：&lt;strong&gt;继承、重写、父类引用指向子类对象&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Parent p=new Child();&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;多态的引入带来了这写好处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;消除类型之间的耦合关系&lt;/li&gt;
&lt;li&gt;可替换性&lt;/li&gt;
&lt;li&gt;可扩充性&lt;/li&gt;
&lt;li&gt;接口性&lt;/li&gt;
&lt;li&gt;灵活性&lt;/li&gt;
&lt;li&gt;简化性&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="https://zofun.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Java" scheme="https://zofun.github.io/tags/Java/"/>
    
      <category term="JVM" scheme="https://zofun.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>MySQL主从复制</title>
    <link href="https://zofun.github.io/2020/04/16/MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
    <id>https://zofun.github.io/2020/04/16/MySQL主从复制/</id>
    <published>2020-04-16T09:28:00.000Z</published>
    <updated>2020-04-16T09:29:03.571Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="前言">前言</span></h2><p>随着业务的增长，一台数据服务器已经满足不了需求了，负载过重。这个时候就需要减压了，实现负载均衡读写分离，一主一丛或一主多从。</p><p>主服务器只负责写，而从服务器只负责写，从而提高了效率减轻压力。</p><p>主从复制有可以分为：</p><ul><li>主从同步：当用户写数据主服务器必须和从服务器同步了才告诉用户写入成功，等待时间比较长。</li><li>主从异步：只要用户访问写数据主服务器，立即返回给用户。</li><li>主从半同步：当用户访问写数据主服务器写入并同步<strong>其中一个从服务器</strong>就返回给用户成功</li></ul><a id="more"></a><h2><span id="主从复制的形式">主从复制的形式</span></h2><ol><li><p>一主一从</p><p> <img src="https://s1.ax1x.com/2020/04/16/Jk7ZVI.png" alt="Jk7ZVI.png"></p></li><li><p>一主多从</p></li></ol><p><img src="https://s1.ax1x.com/2020/04/16/Jk7mIP.png" alt="Jk7mIP.png"></p><ol start="3"><li>多主一从</li></ol><p><img src="https://s1.ax1x.com/2020/04/16/Jk71MQ.png" alt="Jk71MQ.png"></p><ol start="4"><li>双主复制</li></ol><p><img src="https://s1.ax1x.com/2020/04/16/Jk7UiV.png" alt="Jk7UiV.png"></p><ol start="5"><li>级联复制</li></ol><p><img src="https://pic4.zhimg.com/v2-be1bf038ce647dc46bf5abe5b4c48ad7_b.jpg" alt="img"></p><h2><span id="主从复制的基本原理">主从复制的基本原理</span></h2><p>MySQL复制是基于主服务器在二进制日志跟踪所有对数据库的更改。因此，要进行复制，必须在主服务器上启用二进制日志。每个从服务器从主服务器接收已经记录到日志的数据。当一个从服务器连接到主服务器时，它通知主服务器从服务器日志重读取最后一个更新成功的位置。从服务器接收从那时发生起的任何更新，并在主机上执行相同的更新。然后封锁等待主服务器通知的更新。从服务器执行备份不会干扰主服务器，在备份过程重主服务器可以继续处理更新。</p><h2><span id="主从复制的好处">主从复制的好处</span></h2><ol><li>主服务器出现问题，可以切换到从服务器</li><li>可以进行数据库层面的读写分离</li><li>可以在从数据库上进行日常备份</li></ol><h2><span id="复制过程">复制过程</span></h2><p><img src="https://s1.ax1x.com/2020/04/16/Jk7xyQ.png" alt="Jk7xyQ.png"></p><p>其中binary log是主服务器的二进制日志</p><p>relay log：从服务器的中继日志</p><p><strong>第一步：</strong>master在每个事务更新数据完成之前，将该记录串行的写入到binlog文件中。</p><p><strong>第二步：</strong>salve开启一个IO线程，该线程在master上打开一个普通连接，主要工作是处理binlog。如果读取进入已经跟上master，就进入睡眠状态等待master产生新的事件。IO线程的最终目的是将这些事件写入到中继日志中。</p><p><strong>第三步：</strong>SQL Thread会读取中继日志，并顺序执行该日志中的SQL事件，从而与主服务器中的数据保持一致。</p><h3><span id="建立请求的主从的详细流程">建立请求的主从的详细流程</span></h3><ol><li>当从服务器连接主服务器是，主服务器会创建一个log dump线程，用于发送binlog的内容。在读取binlog的内容的操作中，会对象主节点上的binlog加锁，当读取完成并发送给从服务器后解锁。</li><li>当从节点上执行<code>start slave</code>命令之后，从节点会创建一个IO线程用来连接主节点，请求主库中更新binlog。IO线程接收主节点binlog dump进程发来的更新之后，保持到relay-log中。</li><li>从节点SQL线程负责读取realy-log中的内容，解析成具体的操作执行，最终保证主从数据的一致性。</li></ol><h2><span id="两种不同的复制方式">两种不同的复制方式</span></h2><p>MySQL支持两种不同的日志格式，这两种日志格式也体现了各自的复制方式。</p><h3><span id="基于语句的复制">基于语句的复制</span></h3><p>基于语句的复制相当于逻辑复制，即二进制日志中记录了操作的语句，通过这些语句在从数据库中重放来实现复制。这种方式简单，二进制文件小，传输带宽占用小。但是基于语句更新依赖于其它因素，比如插入数据时利用了时间戳。因此在开发当中，我们应该尽量将业务逻辑逻辑放在代码层，而不应该放在MySQL中，不易拓展。</p><h3><span id="基于行数据">基于行数据</span></h3><p>基于行的复制相当于物理复制，即二进制日志中记录的时实际更新数据的每一行，这样导致复制的压力比较大，日志占用的空间大，传输带宽占用大。但是这种方式比基于语句的复制根据精确。</p><h2><span id="延迟问题">延迟问题</span></h2><p>当主库的TPS并发较高的时候，由于主库上面时多线程写入的，而从库的SQL线程是单线程的，导致从库SQL可能会跟不上主库的处理速度。</p><h3><span id="解决方案">解决方案</span></h3><ul><li>网络方面：尽量 保证主库和从库直接的网络稳定，延迟较小。</li><li>硬件方面：从库配置更好的硬件，提升随机写的性能。</li><li>配置方面：尽量使MySQL的操作在内存中完成，减少磁盘操作。或升级MySQL5.7版本使用并行复制。</li><li>建构方面：在事务中尽量对主库读写，其它非事务的读在从库。消除一部分延迟带来的数据库不一致。增加缓存降低一些从库的负载。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;随着业务的增长，一台数据服务器已经满足不了需求了，负载过重。这个时候就需要减压了，实现负载均衡读写分离，一主一丛或一主多从。&lt;/p&gt;
&lt;p&gt;主服务器只负责写，而从服务器只负责写，从而提高了效率减轻压力。&lt;/p&gt;
&lt;p&gt;主从复制有可以分为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主从同步：当用户写数据主服务器必须和从服务器同步了才告诉用户写入成功，等待时间比较长。&lt;/li&gt;
&lt;li&gt;主从异步：只要用户访问写数据主服务器，立即返回给用户。&lt;/li&gt;
&lt;li&gt;主从半同步：当用户访问写数据主服务器写入并同步&lt;strong&gt;其中一个从服务器&lt;/strong&gt;就返回给用户成功&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="https://zofun.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="MySQL" scheme="https://zofun.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>再读线程池源码</title>
    <link href="https://zofun.github.io/2020/04/13/%E5%86%8D%E8%AF%BB%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%BA%90%E7%A0%81/"/>
    <id>https://zofun.github.io/2020/04/13/再读线程池源码/</id>
    <published>2020-04-13T09:36:00.000Z</published>
    <updated>2020-04-13T09:36:39.779Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="概述">概述</span></h2><p>线程池故名思意就是存放线程的池子。线程是JVM的稀缺资源，使用线程池可以减少线程的创建和销毁的次数，<strong>降低系统的资源消耗</strong>。当有任务到达的时候，无效等待创建新的线程便能立即执行，<strong>提高了响应速度</strong>。使用线程池还可以<strong>方便对线程进行管理</strong>。</p><p><code>ThreadPoolExecuter</code>是线程池框架的一个核心类，下面就对<code>ThreadPoolExecuter</code>进行分析。</p><a id="more"></a><h2><span id="属性">属性</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程池的控制状态,用高3位来表示线程池的运行状态,低29位来表示线程池中工作线程的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line">    <span class="comment">//值为29,用来表示偏移量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line">    <span class="comment">//线程池的最大容量,其值的二进制为:00011111111111111111111111111111（29个1）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程池的运行状态，总共有5个状态，用高3位来表示</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//任务缓存队列，用来存放等待执行的任务</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//全局锁，对线程池状态等属性修改时需要使用这个锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程池中工作线程的集合，访问和修改需要持有全局锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> HashSet&lt;Worker&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition termination = mainLock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程池中曾经出现过的最大线程数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> largestPoolSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//已完成任务的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> completedTaskCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程工厂</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> ThreadFactory threadFactory;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//任务拒绝策略</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> RejectedExecutionHandler handler;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程存活时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> keepAliveTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//是否允许核心线程超时</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> allowCoreThreadTimeOut;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//核心池大小，若allowCoreThreadTimeOut被设置，核心线程全部空闲超时被回收的情况下会为0</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> corePoolSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最大池大小，不得超过CAPACITY</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> maximumPoolSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//默认的任务拒绝策略</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> RejectedExecutionHandler defaultHandler =</span><br><span class="line">        <span class="keyword">new</span> AbortPolicy();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> RuntimePermission shutdownPerm =</span><br><span class="line">        <span class="keyword">new</span> RuntimePermission(<span class="string">"modifyThread"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AccessControlContext acc;</span><br></pre></td></tr></table></figure><h3><span id="线程池的状态">线程池的状态</span></h3><p>通过<code>ThreadPoolExecutor</code>中的属性，我们可以知道线程池一共有五种状态。</p><ul><li>RUNNING: 当线程池处于当前状态时，能够接收新任务，并且能够对已添加的任务进行处理。</li><li>SHUTDOWN:当线程池处于当前状态，不能够接收新任务，但是能够处理已经添加的任务。</li><li>STOP：处于当前状态的线程池，不能接收新任务，不能处理已经收的任务，并且会中断正在处理的任务。</li><li>TIDYING：当所有任务已经终止，且<code>ctl</code>记录的任务数量为0时，线程池处于DIDYING状态。处于该状态的线程池会执行钩子函数<code>terminated()</code></li><li>TERMINATED：线程池彻底终止。</li></ul><p>线程池中<code>ctl</code>变量的高3位用来记录线程池的状态，低29位用来表示线程池中工作线程的个数。</p><h3><span id="拒绝策略">拒绝策略</span></h3><ul><li><code>AbortPolicy</code>：丢弃任务，并抛出<code>RejectedExecutionException</code>异常。</li><li><code>DiscardPolicy</code>:丢弃任务，不会抛出任务</li><li><code>DiscardOldestPolicy</code>：丢弃队列最前面的任务，然后重新提交被拒绝的任务。</li><li><code>CallerRunsPolicy</code>:由调用线程处理该任务</li></ul><p>当然我们也可以通过<code>RejectedExecutionHandler</code>接口自定义自己的拒绝策略。</p><h2><span id="核心方法">核心方法</span></h2><h3><span id="提交任务">提交任务</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="keyword">null</span>);</span><br><span class="line">        execute(ftask);</span><br><span class="line">        <span class="keyword">return</span> ftask;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>submit</code>方法中最终调用了<code>execute</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="comment">//获取线程池的状态变量</span></span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">       <span class="comment">//如果工作线程数小于核心线程数</span></span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">            <span class="comment">//创建worker</span></span><br><span class="line">            <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">           <span class="comment">//创建worker失败后再次获取线程池控制状态</span></span><br><span class="line">            c = ctl.get();</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">//如果线程池处于Running状态，就将任务加入阻塞队列</span></span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">            <span class="comment">// 再次检查，获取线程池控制状态，防止在任务入队的过程中线程池关闭了或者线程池中没有线程了</span></span><br><span class="line">            <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">            <span class="comment">//线程池不处于RUNNING状态，且将任务从workQueue移除成功</span></span><br><span class="line">            <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">                <span class="comment">//采取任务拒绝策略</span></span><br><span class="line">                reject(command);</span><br><span class="line">            <span class="comment">//worker数量等于0</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">                <span class="comment">//创建worker</span></span><br><span class="line">                addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//(3)</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))  <span class="comment">//创建worker</span></span><br><span class="line">            reject(command);  <span class="comment">//如果创建worker失败，采取任务拒绝策略</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>整个流程如下：</p><ul><li>如果线程池中的工作线程数小于corePoolSize，则创建新线程来执行任务</li><li>如果工作线程数量大于或等于corePoolSize，则将任务加入BlockingQueue</li><li>若无法将任务加入阻塞队列，且工作线程数小于最大线程数，则创建新的线程来执行任务</li><li>当工作线程数量达到最大线程数，则创建工作线程失败，采取任务拒绝策略</li></ul><p><img src="https://s1.ax1x.com/2020/04/13/GjhqSg.png" alt="GjhqSg.png"></p><h3><span id="创建线程">创建线程</span></h3><p>我们在<code>execute</code>方法的实现中可以看出、创建线程并执行任务由<code>addWorker</code>方法来负责，代码实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//addWorker有两个参数:Runnable类型的firstTask,用于指定新增的线程执行的第一个任务;boolean类型的core,表示是否创建核心线程</span></span><br><span class="line"><span class="comment">//该方法的返回值代表是否成功新增一个线程</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">        retry:</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">            <span class="comment">//获取线程池的当前运行状态</span></span><br><span class="line">            <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// (1)</span></span><br><span class="line">            <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">                ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">                   firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                   ! workQueue.isEmpty()))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">                <span class="comment">//线程数超标，不能再创建线程，直接返回</span></span><br><span class="line">                <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                    wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">//CAS操作递增workCount</span></span><br><span class="line">                <span class="comment">//如果成功，那么创建线程前的所有条件校验都满足了，准备创建线程执行任务，退出retry循环</span></span><br><span class="line">                <span class="comment">//如果失败，说明有其他线程也在尝试往线程池中创建线程(往线程池提交任务可以是并发的)，则继续往下执行</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                    <span class="keyword">break</span> retry;</span><br><span class="line">                <span class="comment">//重新获取线程池控制状态</span></span><br><span class="line">                c = ctl.get();</span><br><span class="line">                <span class="comment">// 如果线程池的状态发生了变更,如有其他线程关闭了这个线程池,那么需要回到外层的for循环</span></span><br><span class="line">                <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                    <span class="keyword">continue</span> retry;</span><br><span class="line">                <span class="comment">//如果只是CAS操作失败的话，进入内层的for循环就可以了</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//到这里，创建线程前的所有条件校验都满足了，可以开始创建线程来执行任务</span></span><br><span class="line">        <span class="comment">//worker是否已经启动</span></span><br><span class="line">        <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//是否已将这个worker添加到workers这个HashSet中</span></span><br><span class="line">        <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">        Worker w = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建一个worker，从这里可以看出对线程的包装</span></span><br><span class="line">            w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">            <span class="comment">//取出worker中的线程对象,Worker的构造方法会调用ThreadFactory来创建一个新的线程</span></span><br><span class="line">            <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">            <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//获取全局锁, 并发的访问线程池workers对象必须加锁,持有锁的期间线程池也不会被关闭</span></span><br><span class="line">                <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">                <span class="comment">//加锁</span></span><br><span class="line">                mainLock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//重新获取线程池的运行状态</span></span><br><span class="line">                    <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//小于SHUTTDOWN即RUNNING</span></span><br><span class="line">                    <span class="comment">//等于SHUTDOWN并且firstTask为null,不接受新的任务,但是会继续执行等待队列中的任务</span></span><br><span class="line">                    <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                        (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                        <span class="comment">//worker里面的thread不能是已启动的</span></span><br><span class="line">                        <span class="keyword">if</span> (t.isAlive())</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                       <span class="comment">//将新创建的线程加入到线程池中</span></span><br><span class="line">                        workers.add(w);</span><br><span class="line">                        <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                        <span class="comment">// 更新largestPoolSize</span></span><br><span class="line">                        <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                            largestPoolSize = s;</span><br><span class="line">                        workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    mainLock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//线程添加线程池成功，则启动新创建的线程</span></span><br><span class="line">                <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                    t.start();</span><br><span class="line">                    workerStarted = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//若线程启动失败,做一些清理工作,例如从workers中移除新添加的worker并递减wokerCount</span></span><br><span class="line">            <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">                addWorkerFailed(w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回线程是否启动成功</span></span><br><span class="line">        <span class="keyword">return</span> workerStarted;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>该方法主要完成这几件事情：</p><ul><li>原子性的增加workerCount</li><li>将用户给定的任务封装成为一个worker，并将此worker添加进workers集合中</li><li>启动worker对应的线程</li><li>若线程启动失败，回滚worker的创建动作，即从worker中溢出新添加的worker，并原子性的减少workerCount。</li></ul><h3><span id="工作线程">工作线程</span></h3><p>从之前的代码中，我们可以发现，线程池中正在执行任务的是worker对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span></span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br></pre></td></tr></table></figure><p>worker的属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用来封装worker的线程，线程池中真正运行的线程,通过线程工厂创建而来</span></span><br><span class="line">      <span class="keyword">final</span> Thread thread;</span><br><span class="line">      <span class="comment">//worker所对应的第一个任务，可能为空</span></span><br><span class="line">      Runnable firstTask;</span><br><span class="line">      <span class="comment">//记录当前线程完成的任务数</span></span><br><span class="line">      <span class="keyword">volatile</span> <span class="keyword">long</span> completedTasks;</span><br></pre></td></tr></table></figure><p>worker的构造器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Worker(Runnable firstTask) &#123;</span><br><span class="line">            <span class="comment">//设置AQS的state为-1，在执行runWorker()方法之前阻止线程中断</span></span><br><span class="line">            setState(-<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//初始化第一个任务</span></span><br><span class="line">            <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">            <span class="comment">//利用指定的线程工厂创建一个线程，注意，参数是Worker实例本身this</span></span><br><span class="line">            <span class="comment">//也就是当执行start方法启动线程thread时，真正执行的是Worker类的run方法</span></span><br><span class="line">            <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>worker类继承了AQS类，重写了其相应的方法，是实现了一个自定义的同步器，实现了不可重入锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//是否持有独占锁</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getState() != <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//尝试获取锁</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">//设置独占线程</span></span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//尝试释放锁</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//设置独占线程为null</span></span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">            setState(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取锁</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span>        </span>&#123; acquire(<span class="number">1</span>); &#125;</span><br><span class="line">        <span class="comment">//尝试获取锁</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span>  </span>&#123; <span class="keyword">return</span> tryAcquire(<span class="number">1</span>); &#125;</span><br><span class="line">        <span class="comment">//释放锁</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span>      </span>&#123; release(<span class="number">1</span>); &#125;</span><br><span class="line">        <span class="comment">//是否持有锁</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> isHeldExclusively(); &#125;</span><br></pre></td></tr></table></figure><p>worker类还提供了一个中断线程thread的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">interruptIfStarted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Thread t;</span><br><span class="line">            <span class="comment">//AQS状态大于等于0，worker对应的线程不为null，且该线程没有被中断</span></span><br><span class="line">            <span class="keyword">if</span> (getState() &gt;= <span class="number">0</span> &amp;&amp; (t = thread) != <span class="keyword">null</span> &amp;&amp; !t.isInterrupted()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    t.interrupt();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3><span id="线程复用机制">线程复用机制</span></h3><p>worker中的线程start后，实际上是调用的<code>runWorker</code>方法。 该方法实现了线程池中的线程复用机制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取当前线程</span></span><br><span class="line">        Thread wt = Thread.currentThread();</span><br><span class="line">        <span class="comment">//获取w的firstTask</span></span><br><span class="line">        Runnable task = w.firstTask;</span><br><span class="line">        <span class="comment">//设置w的firstTask为null</span></span><br><span class="line">        w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 释放锁，设置AQS的state为0，允许中断</span></span><br><span class="line">        w.unlock();</span><br><span class="line">        <span class="comment">//用于标识线程是否异常终止，finally中processWorkerExit()方法会有不同逻辑</span></span><br><span class="line">        <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//循环调用getTask()获取任务,不断从任务缓存队列获取任务并执行</span></span><br><span class="line">            <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//进入循环内部，代表已经获取到可执行的任务，则对worker对象加锁，保证线程在执行任务过程中不会被中断</span></span><br><span class="line">                w.lock();</span><br><span class="line">                <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||  <span class="comment">//若线程池状态大于等于STOP，那么意味着该线程要中断</span></span><br><span class="line">                     (Thread.interrupted() &amp;&amp;      <span class="comment">//线程被中断</span></span><br><span class="line">                      runStateAtLeast(ctl.get(), STOP))) &amp;&amp;  <span class="comment">//且是因为线程池内部状态变化而被中断</span></span><br><span class="line">                    !wt.isInterrupted())           <span class="comment">//确保该线程未被中断</span></span><br><span class="line">                    <span class="comment">//发出中断请求</span></span><br><span class="line">                    wt.interrupt();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//开始执行任务前的Hook方法</span></span><br><span class="line">                    beforeExecute(wt, task);</span><br><span class="line">                    Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//到这里正式开始执行任务</span></span><br><span class="line">                        task.run();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                        thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                        thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                        thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="comment">//执行任务后的Hook方法</span></span><br><span class="line">                        afterExecute(task, thrown);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//置空task，准备通过getTask()获取下一个任务</span></span><br><span class="line">                    task = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="comment">//completedTasks递增</span></span><br><span class="line">                    w.completedTasks++;</span><br><span class="line">                    <span class="comment">//释放掉worker持有的独占锁</span></span><br><span class="line">                    w.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//到这里，线程执行结束，需要执行结束线程的一些清理工作</span></span><br><span class="line">            <span class="comment">//线程执行结束可能有两种情况：</span></span><br><span class="line">            <span class="comment">//1.getTask()返回null，也就是说，这个worker的使命结束了，线程执行结束</span></span><br><span class="line">            <span class="comment">//2.任务执行过程中发生了异常</span></span><br><span class="line">            <span class="comment">//第一种情况，getTask()返回null，那么getTask()中会将workerCount递减</span></span><br><span class="line">            <span class="comment">//第二种情况，workerCount没有进行处理，这个递减操作会在processWorkerExit()中处理</span></span><br><span class="line">            processWorkerExit(w, completedAbruptly);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>该方法主要完成了这些事情：</p><ul><li>运行第一个任务<code>firstTask</code>之后，循环调用<code>getTask</code>方法从同步队列中获取任务并执行。</li><li>获取到任务就对worker对象加锁，保证线程在执行任务的过程中不会被中断，任务执行完会释放锁。</li><li>在执行任务的前后，可以根据业务场景重写<code>beforeExecute</code>和<code>afterExecute</code>等钩子函数。</li><li>线程执行结束后，调用<code>processWorkerExit</code>方法执行结束的一些清理工作。</li></ul><h3><span id="从队列中取任务">从队列中取任务</span></h3><p>从之前的源码中我们可以看出 <code>getTask</code>方法用来不断地从任务缓存队列中获取任务并交给线程执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//标识当前线程是否超时未能获取到task对象</span></span><br><span class="line">        <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//获取线程池的控制状态</span></span><br><span class="line">            <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">            <span class="comment">//获取线程池的运行状态</span></span><br><span class="line">            <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果线程池状态大于等于STOP，或者处于SHUTDOWN状态，并且阻塞队列为空，线程池工作线程数量递减，方法返回null，回收线程</span></span><br><span class="line">            <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">                decrementWorkerCount();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取worker数量</span></span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//标识当前线程在空闲时，是否应该超时回收</span></span><br><span class="line">            <span class="comment">// 如果allowCoreThreadTimeOut为ture，或当前线程数大于核心池大小，则需要超时回收</span></span><br><span class="line">            <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果worker数量大于maximumPoolSize(有可能调用了 setMaximumPoolSize(),导致worker数量大于maximumPoolSize)</span></span><br><span class="line">            <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))  <span class="comment">//或者获取任务超时</span></span><br><span class="line">                &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;  <span class="comment">//workerCount大于1或者阻塞队列为空（在阻塞队列不为空时，需要保证至少有一个工作线程）</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                    <span class="comment">//线程池工作线程数量递减，方法返回null，回收线程</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">//线程池工作线程数量递减失败，跳过剩余部分，继续循环</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//如果允许超时回收，则调用阻塞队列的poll()，只在keepAliveTime时间内等待获取任务，一旦超过则返回null</span></span><br><span class="line">                <span class="comment">//否则调用take()，如果队列为空，线程进入阻塞状态，无限时等待任务，直到队列中有可取任务或者响应中断信号退出</span></span><br><span class="line">                Runnable r = timed ?</span><br><span class="line">                    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                    workQueue.take();</span><br><span class="line">                <span class="comment">//若task不为null，则返回成功获取的task对象</span></span><br><span class="line">                <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> r;</span><br><span class="line">                <span class="comment">// 若返回task为null，表示线程空闲时间超时，则设置timeOut为true</span></span><br><span class="line">                timedOut = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">                <span class="comment">//如果此worker发生了中断，采取的方案是重试，没有超时</span></span><br><span class="line">                <span class="comment">//在哪些情况下会发生中断？调用setMaximumPoolSize()，shutDown()，shutDownNow()</span></span><br><span class="line">                timedOut = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>该方法在不同地情况下有不同地返回：</p><ol><li>线程池处于running状态，阻塞队列不为空，该方法返回task对象。</li><li>线程池处于shutdown状态，阻塞队列不为空，返回空间获取地task对象。</li><li>线程池状态大于等于stop状态，返回null，回收线程</li><li>线程池处于shutdown状态，阻塞队列位空，返回null，回收线程</li><li>worker数量大于最大线程数，返回null，回收线程。</li><li>线程空闲时间超时，返回null，回收线程。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;线程池故名思意就是存放线程的池子。线程是JVM的稀缺资源，使用线程池可以减少线程的创建和销毁的次数，&lt;strong&gt;降低系统的资源消耗&lt;/strong&gt;。当有任务到达的时候，无效等待创建新的线程便能立即执行，&lt;strong&gt;提高了响应速度&lt;/strong&gt;。使用线程池还可以&lt;strong&gt;方便对线程进行管理&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ThreadPoolExecuter&lt;/code&gt;是线程池框架的一个核心类，下面就对&lt;code&gt;ThreadPoolExecuter&lt;/code&gt;进行分析。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="https://zofun.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="源码" scheme="https://zofun.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="Java" scheme="https://zofun.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JVM之分代收集算法</title>
    <link href="https://zofun.github.io/2020/04/12/JVM%E4%B9%8B%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95/"/>
    <id>https://zofun.github.io/2020/04/12/JVM之分代收集算法/</id>
    <published>2020-04-12T11:52:00.000Z</published>
    <updated>2020-04-12T12:58:20.090Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="对象分类">对象分类</span></h2><p>JVM将对象分成不同的分代，然后根据每个分代的特点采取不同的垃圾回收算法。</p><ul><li>新生代：朝生夕灭的对象，比如方法的局部变量。</li><li>老年代：存活的比较久，但是还是要死的对象。比如缓存对象，单例对象等。</li><li>永久代：对象生成后几乎不灭的对象，例如加载过的类对象。</li></ul><p>永久代是在方法区/元空间。新生代和老年代是在堆区。</p><a id="more"></a><h2><span id="新生代的垃圾回收">新生代的垃圾回收</span></h2><p>新生代采用的是复制算法，因为新生代对象的存活率比价低，因此可以不使用50%的内存作为空闲。一般的，使用两块10%的内存作为空闲和活动空间，而另外80%的内存，则是用来分配给新建的对象的。一旦发生GC，就将10%的活动区间与另外的80%中内存转移到10%的空闲区间中，接下来90%的内存会被释放，以此类推。</p><p><img src="https://s1.ax1x.com/2020/04/11/GHH8fg.png" alt="GHH8fg.png"></p><h3><span id="hotspot实现的复制算法流程">HotSpot实现的复制算法流程</span></h3><ol><li>当Eden区满的时候，会触发第一次Minor gc，把还存活的对象复制到Survivor From区；当Eden区再次触发Minor gc的时候，会扫描Eden 区和Survivor From区，将存活的对象复制到Survivor To区，然后将Eden区和From区清空。</li><li>当后续Eden区又发生了Minor gc的时候，会堆Eden和To区域进行垃圾回收，存活的对象复制到From区域，并将Eden区和To区域清空。</li><li>部分对象会在From和To区域中复制来复制去，如此交换15次（可配置），最终如果还是存活，就存入到老年代。</li></ol><h3><span id="一个对象的内存分配过程">一个对象的内存分配过程</span></h3><p><img src="https://s1.ax1x.com/2020/04/12/GLtsG4.png" alt="GLtsG4.png"></p><h3><span id="什么是空间分配担保机制">什么是空间分配担保机制</span></h3><p>当发生minor gc的时候，JVM会首先检查老年代最大的可用连续空间是否运行大于最大新生代所有对象的总和，如果大于，那么这次YGC是安全的，如果不大于的话，JVM就需要判断HandlerpromotionFailure是否运行空间分配担保。</p><p>新生代采用的是复制算法，S0和S1始终只使用其中一块内存，当出现YGC后大部分的对象仍然存活的话，就需要老年代进行分配担保，把Survior区无法容纳的对象直接晋升到老年代。</p><p>那么这种空间分配担保的前提是老年代还有容纳的空间，一共有多少对象会活下来，再实际完成内存回收之前是无法明确知道的，所以只好取之前每次回收晋升到老年代对象容量的平均值最为经验值，与老年代的剩余空间做比较，决定是否进行Major GC来让老年代腾出更多的空间。</p><h3><span id="新生代收集器">新生代收集器</span></h3><h4><span id="serial收集器">Serial收集器</span></h4><p>它是一个单线程收集器，并且在工作的时候，需要暂停所有的工作线程（STW)，直到它收集结束。</p><p>优点：简单而高效，对于限定单个CPU的环境来说，Serial收集器由于没有线程切换的开销，效率较高。</p><p>缺点：需要停止用户线程。</p><p>适用环境：client模式下的默认新生代收集器。</p><h4><span id="parnew收集器">ParNew收集器</span></h4><p>它其实是Serial收集器的多线程版本，只能在新生代中使用。该收集器的并行度和CPU数量相同。</p><p>适用环境：Server模式下的默认新生代收集器。</p><h4><span id="parallel-scavenge收集器">Parallel Scavenge收集器</span></h4><p>它也是一种并行的新生代垃圾收集器。采用的是复制算法。</p><p>它的特点是可以达成一个可控的吞吐量。</p><h2><span id="老年代">老年代</span></h2><p>老年代一般采用的标记清除算法。标记清除算法可以分为两个步骤：</p><ul><li>标记过程：找到所有的可能访问的对象，做个指定的标记。</li><li>清除过程：遍历堆内存，把未标记的对象进行回收。</li></ul><h3><span id="老年代收集器">老年代收集器</span></h3><h4><span id="serial-old收集器">Serial Old收集器</span></h4><p>它是一个单线程的收集器，采用的标记整理算法，。</p><h4><span id="parallel-old收集器">Parallel Old收集器</span></h4><p>Pareller Old收集器的老年代版本，使用多线程和“标记-整理”算法。</p><p>在注重吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge加Paralllel Old收集器。</p><h4><span id="cms收集器">CMS收集器</span></h4><p>CMS是老年代收集器，在收集过程中可以与用户线程并发操作。CMS牺牲了系统的吞吐量来追求收集速度，适合追求垃圾收集速度的服务器上。</p><p>CMS处理过程有七个步骤：</p><ul><li>初始标记，会导致STW</li><li>并发标记，与用户线程同时运行</li><li>预清理，与用户线程同时运行</li><li>可被终止的预清理，与用户线程同时运行</li><li>重新标记，会导致STW</li><li>并发清除，与用户线程同时运行</li><li>并发重置状态等待下次CMS的触发，与用户线程同时运行。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;对象分类&quot;&gt;&lt;a href=&quot;#对象分类&quot; class=&quot;headerlink&quot; title=&quot;对象分类&quot;&gt;&lt;/a&gt;对象分类&lt;/h2&gt;&lt;p&gt;JVM将对象分成不同的分代，然后根据每个分代的特点采取不同的垃圾回收算法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;新生代：朝生夕灭的对象，比如方法的局部变量。&lt;/li&gt;
&lt;li&gt;老年代：存活的比较久，但是还是要死的对象。比如缓存对象，单例对象等。&lt;/li&gt;
&lt;li&gt;永久代：对象生成后几乎不灭的对象，例如加载过的类对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;永久代是在方法区/元空间。新生代和老年代是在堆区。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="https://zofun.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Java" scheme="https://zofun.github.io/tags/Java/"/>
    
      <category term="JVM" scheme="https://zofun.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>并发编程之volatile</title>
    <link href="https://zofun.github.io/2020/04/10/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8Bvolatile/"/>
    <id>https://zofun.github.io/2020/04/10/并发编程之volatile/</id>
    <published>2020-04-10T11:52:00.000Z</published>
    <updated>2020-04-10T11:52:36.541Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="volatile的定义和实现原理">volatile的定义和实现原理</span></h2><p>在Java语言规范中将volatile定义如下：Java编程语言允许线程访问共享变量，为了确保共享变量能被准确和一致的更新，线程应该通过排他锁单独获得这个变量。Java语言提供了volatile，在某型情况下比使用锁更加方便。如果一个字段被声明为volatile，Java线程内存模型确保所有线程看到这个变量的值是一致的。</p><a id="more"></a><p>当我们对有volatile修饰的变量进行写操作的时候，会在下一行汇编加一个<code>Lock</code>指令。</p><p><code>Lock</code>前缀的指令在多核处理器下会引起两件事情；</p><ol><li>将当前处理器缓存行写回到系统内存</li><li>这个写回的操作会使其它CPU里缓存了该内存地址的数据无效。</li></ol><h2><span id="volatile的内存语义">volatile的内存语义</span></h2><p><strong>锁的happens-before规则保证释放锁和获取锁的两个线程之间的内存可见性</strong>，这意味着对一个volatile变量的读，总是能看到对这个volatile变量最后的写入。</p><p><strong>锁的语义决定了临界区代码的执行具有原子性。</strong>这意味着，即使使64位的long型和double型变量，只要它使volatile变量，最该变量的读/写具有原子性。</p><p>volatile变量自身具有以下特性：</p><ul><li>可见性。对一个volatile变量的读，总是能看到对这个volatile变量最后的写入。</li><li>原子性：对任意单个volatile变量的读/写具有原子性，当类似于volatile++这种复合操作不具有原子性。</li></ul><p><strong>volatile写的内存语义</strong>如下：</p><ul><li>当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存。</li></ul><p><strong>volatile读的内存语义</strong>如下：</p><ul><li>当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效。</li></ul><h3><span id="volatile内存语义的实现">volatile内存语义的实现</span></h3><p>为了实现volatile内存语义，JMM会分别限制这两种类型的重排序。为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。</p><ul><li>在每个volatile写操作之前插入一个StoreStore屏障</li><li>在每个volatile写操作的后面插入一个StoreLoad屏障</li><li>在每个volatile读操作的后面插入一个LoadLoad屏障</li><li>在每个volatile读操作的后面插入一个LoadStore屏障。</li></ul><h2><span id="volatile的使用优化">volatile的使用优化</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 队列中的头部节点 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> f?inal PaddedAtomicReference&lt;QNode&gt; head;</span><br><span class="line"><span class="comment">/** 队列中的尾部节点 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> f?inal PaddedAtomicReference&lt;QNode&gt; tail;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PaddedAtomicReference</span> &lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AtomicReference</span> <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"><span class="comment">// 使用很多4个字节的引用追加到64个字节</span></span><br><span class="line">Object p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, pa, pb, pc, pd, pe;</span><br><span class="line">PaddedAtomicReference(T r) &#123;</span><br><span class="line"><span class="keyword">super</span>(r);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicReference</span> &lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> V value;</span><br><span class="line"><span class="comment">// 省略其他代码</span></span><br><span class="line">｝</span><br></pre></td></tr></table></figure><p>在上面这段代码中，通过追加字节来优化系统的性能。这是因为在目前多少的CPU中，缓存行的宽度为64字节，如果队列头节点和尾节点都不足64字节的话，那么处理器就会将头接点和尾节点读入同一个缓存行中，当一个处理器试图修改头节点的时候，将会把整个缓存行锁定，在缓存一致性的机制的作用下，会导致其它处理器不能访问自己高速缓存中的尾节点。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;volatile的定义和实现原理&quot;&gt;&lt;a href=&quot;#volatile的定义和实现原理&quot; class=&quot;headerlink&quot; title=&quot;volatile的定义和实现原理&quot;&gt;&lt;/a&gt;volatile的定义和实现原理&lt;/h2&gt;&lt;p&gt;在Java语言规范中将volatile定义如下：Java编程语言允许线程访问共享变量，为了确保共享变量能被准确和一致的更新，线程应该通过排他锁单独获得这个变量。Java语言提供了volatile，在某型情况下比使用锁更加方便。如果一个字段被声明为volatile，Java线程内存模型确保所有线程看到这个变量的值是一致的。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="https://zofun.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Java" scheme="https://zofun.github.io/tags/Java/"/>
    
      <category term="多线程" scheme="https://zofun.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>多线程之连续打印ABC</title>
    <link href="https://zofun.github.io/2020/04/07/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E8%BF%9E%E7%BB%AD%E6%89%93%E5%8D%B0ABC/"/>
    <id>https://zofun.github.io/2020/04/07/多线程之连续打印ABC/</id>
    <published>2020-04-07T02:50:00.000Z</published>
    <updated>2020-04-07T02:50:10.239Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="题目">题目</span></h2><p>实例化三个线程，一个线程打印a，一个线程打印b，一个线程打印c，三个线程同时执行，要求打印出10个连着的abc。</p><p>问题为三线程间的同步唤醒操作，主要的目的就是使程序按ThreadA-&gt;ThreadB-&gt;ThreadC-&gt;ThreadA循环执行三个线程</p><a id="more"></a><h3><span id="使用两个锁来实现">使用两个锁来实现</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RcSyncPrinter</span>  </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Printer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Object preLock;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Object lock;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> printChar;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Printer</span><span class="params">(Object preLock, Object lock, <span class="keyword">char</span> printChar)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.preLock = preLock;</span><br><span class="line">            <span class="keyword">this</span>.lock = lock;</span><br><span class="line">            <span class="keyword">this</span>.printChar = printChar;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (preLock)&#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">                        System.out.println(printChar);</span><br><span class="line">                        lock.notifyAll();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(i &lt; <span class="number">10</span> - <span class="number">1</span>)&#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="comment">// 通过preLock等待被唤醒</span></span><br><span class="line">                            preLock.wait();</span><br><span class="line"></span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Object lockA = <span class="keyword">new</span> Object();</span><br><span class="line">        <span class="keyword">final</span> Object lockB = <span class="keyword">new</span> Object();</span><br><span class="line">        <span class="keyword">final</span> Object lockC = <span class="keyword">new</span> Object();</span><br><span class="line">        Printer printerA = <span class="keyword">new</span> Printer(lockC, lockA,  <span class="string">'A'</span>);</span><br><span class="line">        Printer printerB = <span class="keyword">new</span> Printer(lockA, lockB, <span class="string">'B'</span>);</span><br><span class="line">        Printer printerC = <span class="keyword">new</span> Printer(lockB, lockC, <span class="string">'C'</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(printerA).start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(printerB).start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(printerC).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> RcSyncPrinter syncPrinter = <span class="keyword">new</span> RcSyncPrinter();</span><br><span class="line">        syncPrinter.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="使用一个锁和状态变量实现推荐写法">使用一个锁和状态变量实现(推荐写法)</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RcSyncPrinter</span>  </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//状态变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Printer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//打印锁</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Object lock;</span><br><span class="line">        <span class="comment">//打印状态</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> printState;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> nextPrintState;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> printChar;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Printer</span><span class="params">(Object lock, <span class="keyword">int</span> printState, <span class="keyword">int</span> nextPrintState, <span class="keyword">char</span> printChar)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.lock = lock;</span><br><span class="line">            <span class="keyword">this</span>.printState = printState;</span><br><span class="line">            <span class="keyword">this</span>.nextPrintState = nextPrintState;</span><br><span class="line">            <span class="keyword">this</span>.printChar = printChar;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">                    <span class="keyword">while</span> (state!=printState)&#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            lock.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(printChar);</span><br><span class="line">                    state=nextPrintState;</span><br><span class="line">                    lock.notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">        Printer printerA = <span class="keyword">new</span> Printer(lock, <span class="number">1</span>, <span class="number">2</span>, <span class="string">'A'</span>);</span><br><span class="line">        Printer printerB = <span class="keyword">new</span> Printer(lock, <span class="number">2</span>, <span class="number">3</span>, <span class="string">'B'</span>);</span><br><span class="line">        Printer printerC = <span class="keyword">new</span> Printer(lock, <span class="number">3</span>, <span class="number">1</span>, <span class="string">'C'</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(printerA).start();</span><br><span class="line">        <span class="comment">//Thread.sleep(1000);</span></span><br><span class="line">        <span class="keyword">new</span> Thread(printerB).start();</span><br><span class="line">        <span class="comment">//Thread.sleep(1000);</span></span><br><span class="line">        <span class="keyword">new</span> Thread(printerC).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> RcSyncPrinter syncPrinter = <span class="keyword">new</span> RcSyncPrinter();</span><br><span class="line">        syncPrinter.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="通过一个reentrantlock和三个conditon实现推荐">通过一个ReentrantLock和三个conditon实现(推荐)</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RcSyncPrinter</span>  </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Printer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">private</span> ReentrantLock lock;</span><br><span class="line">       <span class="keyword">private</span> Condition thisCondition;</span><br><span class="line">       <span class="keyword">private</span> Condition  nextCondition;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> printChar;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Printer</span><span class="params">(ReentrantLock lock, Condition thisCondition, Condition nextCondition, <span class="keyword">char</span> printChar)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.lock = lock;</span><br><span class="line">            <span class="keyword">this</span>.thisCondition = thisCondition;</span><br><span class="line">            <span class="keyword">this</span>.nextCondition = nextCondition;</span><br><span class="line">            <span class="keyword">this</span>.printChar = printChar;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                    System.out.println(printChar);</span><br><span class="line">                    nextCondition.signalAll();</span><br><span class="line">                    <span class="keyword">if</span> (i &lt; <span class="number">9</span>) &#123;</span><br><span class="line">                        thisCondition.await();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        <span class="keyword">final</span> Condition conditionA = lock.newCondition();</span><br><span class="line">        <span class="keyword">final</span> Condition conditionB = lock.newCondition();</span><br><span class="line">        <span class="keyword">final</span> Condition conditionC = lock.newCondition();</span><br><span class="line">        <span class="keyword">final</span> Object lockA = <span class="keyword">new</span> Object();</span><br><span class="line">        <span class="keyword">final</span> Object lockB = <span class="keyword">new</span> Object();</span><br><span class="line">        <span class="keyword">final</span> Object lockC = <span class="keyword">new</span> Object();</span><br><span class="line">        Printer printerA = <span class="keyword">new</span> Printer(lock, conditionA,conditionB,<span class="string">'A'</span>);</span><br><span class="line">        Printer printerB = <span class="keyword">new</span> Printer(lock, conditionB, conditionC,<span class="string">'B'</span>);</span><br><span class="line">        Printer printerC = <span class="keyword">new</span> Printer(lock, conditionC, conditionA,<span class="string">'C'</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(printerA).start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(printerB).start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(printerC).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> RcSyncPrinter syncPrinter = <span class="keyword">new</span> RcSyncPrinter();</span><br><span class="line">        syncPrinter.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;实例化三个线程，一个线程打印a，一个线程打印b，一个线程打印c，三个线程同时执行，要求打印出10个连着的abc。&lt;/p&gt;
&lt;p&gt;问题为三线程间的同步唤醒操作，主要的目的就是使程序按ThreadA-&amp;gt;ThreadB-&amp;gt;ThreadC-&amp;gt;ThreadA循环执行三个线程&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="https://zofun.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Java" scheme="https://zofun.github.io/tags/Java/"/>
    
      <category term="多线程" scheme="https://zofun.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>算法之DFS</title>
    <link href="https://zofun.github.io/2020/04/05/%E7%AE%97%E6%B3%95%E4%B9%8BDFS/"/>
    <id>https://zofun.github.io/2020/04/05/算法之DFS/</id>
    <published>2020-04-05T12:06:00.000Z</published>
    <updated>2020-04-05T12:07:03.122Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="dfs">DFS</span></h2><p>深度优先搜索是在得到一个新节点时立即堆新节点进行遍历。DFS常用来求解这种可达性问题。</p><p>在实现DFS时需要考虑以下两个问题：</p><ul><li>栈，使用栈来保存当前节点信息，当遍历新节点返回时能够继续遍历当前节点。可以使用递归栈。</li><li>标记：需要记录那些节点已经遍历过了。</li></ul><h3><span id="695-岛屿的最大面积">695. 岛屿的最大面积</span></h3><p>给定一个包含了一些 0 和 1 的非空二维数组 grid 。</p><p>一个 岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在水平或者竖直方向上相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。</p><p>找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为 0 。)</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[[0,0,1,0,0,0,0,1,0,0,0,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,1,1,1,0,0,0],</span><br><span class="line"> [0,1,1,0,1,0,0,0,0,0,0,0,0],</span><br><span class="line"> [0,1,0,0,1,1,0,0,1,0,1,0,0],</span><br><span class="line"> [0,1,0,0,1,1,0,0,1,1,1,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,0,0,0,1,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,1,1,1,0,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,1,1,0,0,0,0]]</span><br></pre></td></tr></table></figure><p>对于上面这个给定矩阵应返回 6。注意答案不应该是 11 ，因为岛屿只能包含水平或垂直的四个方向的 1 。</p><h4><span id="解法">解法</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[][] direction=&#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">  <span class="keyword">int</span> m,n;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(grid.length==<span class="number">0</span>||grid[<span class="number">0</span>].length==<span class="number">0</span>)&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      m=grid.length;</span><br><span class="line">      n=grid[<span class="number">0</span>].length;</span><br><span class="line">      <span class="keyword">int</span> maxArea=<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">              maxArea=Math.max(maxArea,dfs(grid,i,j));</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> maxArea;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] grid,<span class="keyword">int</span> r,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(r&lt;<span class="number">0</span>||r&gt;m||c&lt;<span class="number">0</span>||c&gt;n||grid[r][c]==<span class="number">0</span>)&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">int</span> area=<span class="number">1</span>; <span class="comment">//（r，c）为陆地</span></span><br><span class="line">      grid[r][c]=<span class="number">0</span>;<span class="comment">//标记为已经遍历</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span>[] d : direction) &#123;</span><br><span class="line">        area+=dfs(grid, r+d[<span class="number">0</span>], c+d[<span class="number">1</span>]);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> area;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/max-area-of-island/" target="_blank" rel="noopener">leetcode原题地址</a></p><a id="more"></a><h3><span id="200-岛屿的数量">200. 岛屿的数量</span></h3><p>给定一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">11000</span><br><span class="line">11000</span><br><span class="line">00100</span><br><span class="line">00011</span><br><span class="line"></span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/number-of-islands/" target="_blank" rel="noopener">leetcode原题地址</a></p><h4><span id="解法">解法</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[][] direction=&#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">  <span class="keyword">int</span> m,n;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(grid.length==<span class="number">0</span>||grid[<span class="number">0</span>].length==<span class="number">0</span>)&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      m=grid.length;</span><br><span class="line">      n=grid[<span class="number">0</span>].length;</span><br><span class="line">      <span class="keyword">int</span> isLand=<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">              <span class="keyword">if</span> (grid[i][j]!=<span class="string">'0'</span>)&#123;</span><br><span class="line">                  dfs(grid,i,j);</span><br><span class="line">              &#125;</span><br><span class="line">              isLand++;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> isLand;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] grid,<span class="keyword">int</span> r,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(r&lt;<span class="number">0</span>||r&gt;=m||c&lt;<span class="number">0</span>||c&gt;=n||grid[r][c]==<span class="string">'0'</span>)&#123;</span><br><span class="line">          <span class="keyword">return</span> ;</span><br><span class="line">      &#125;</span><br><span class="line">      grid[r][c]=<span class="string">'0'</span>;<span class="comment">//标记为已经遍历</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span>[] d : direction) &#123;</span><br><span class="line">        dfs(grid, r+d[<span class="number">0</span>], c+d[<span class="number">1</span>]);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3><span id="朋友圈">朋友圈</span></h3><p>班上有 N 名学生。其中有些人是朋友，有些则不是。他们的友谊具有是传递性。如果已知 A 是 B 的朋友，B 是 C 的朋友，那么我们可以认为 A 也是 C 的朋友。所谓的朋友圈，是指所有朋友的集合。</p><p>给定一个 N * N 的矩阵 M，表示班级中学生之间的朋友关系。如果M[i][j] = 1，表示已知第 i 个和 j 个学生互为朋友关系，否则为不知道。你必须输出所有学生中的已知的朋友圈总数。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">[[1,1,0],</span><br><span class="line"> [1,1,0],</span><br><span class="line"> [0,0,1]]</span><br><span class="line">输出: 2 </span><br><span class="line">说明：已知学生0和学生1互为朋友，他们在一个朋友圈。</span><br><span class="line">第2个学生自己在一个朋友圈。所以返回2.</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/friend-circles/" target="_blank" rel="noopener">leetcode原题地址</a></p><h4><span id="解法">解法</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="keyword">int</span>[][] M)</span> </span>&#123;</span><br><span class="line">    n=M.length;</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span>[] hasVisited=<span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!hasVisited[i])&#123;</span><br><span class="line">            dfs(M,hasVisited,i);</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] arr,<span class="keyword">boolean</span>[] hasVisited,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    hasVisited[i]=<span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;n;k++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i][k]==<span class="number">1</span>&amp;&amp;!hasVisited[k])&#123;</span><br><span class="line"></span><br><span class="line">            dfs(arr,hasVisited,k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="130-被围绕的区域">130. 被围绕的区域</span></h3><p>给定一个二维的矩阵，包含 ‘X’ 和 ‘O’（字母 O）。</p><p>找到所有被 ‘X’ 围绕的区域，并将这些区域里所有的 ‘O’ 用 ‘X’ 填充。</p><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X X X X</span><br><span class="line">X O O X</span><br><span class="line">X X O X</span><br><span class="line">X O X X</span><br></pre></td></tr></table></figure><p>运行你的函数后，矩阵变为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X X X X</span><br><span class="line">X X X X</span><br><span class="line">X X X X</span><br><span class="line">X O X X</span><br></pre></td></tr></table></figure><p>解释:</p><p>被围绕的区间不会存在于边界上，换句话说，任何边界上的 ‘O’ 都不会被填充为 ‘X’。 任何不在边界上，或不与边界上的 ‘O’ 相连的 ‘O’ 最终都会被填充为 ‘X’。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。</p><p><a href="https://leetcode-cn.com/problems/surrounded-regions/" target="_blank" rel="noopener">leetcode原题地址</a></p><h4><span id="解法">解法</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> m;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span>[][] direction=&#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (board == <span class="keyword">null</span> || board.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        m = board.length;</span><br><span class="line">        n = board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            dfs(board, i, <span class="number">0</span>);</span><br><span class="line">            dfs(board, i, n - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dfs(board, <span class="number">0</span>, i);</span><br><span class="line">            dfs(board, m - <span class="number">1</span>, i);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">'T'</span>) &#123;</span><br><span class="line">                    board[i][j] = <span class="string">'O'</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (board[i][j] == <span class="string">'O'</span>) &#123;</span><br><span class="line">                    board[i][j] = <span class="string">'X'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (r &lt; <span class="number">0</span> || r &gt;= m || c &lt; <span class="number">0</span> || c &gt;= n || board[r][c] != <span class="string">'O'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;board[r][c] = <span class="string">'T'</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] d : direction) &#123;</span><br><span class="line">            dfs(board, r + d[<span class="number">0</span>], c + d[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3><span id="417-太平洋大西洋水流问题">417. 太平洋大西洋水流问题</span></h3><p>给定一个 m x n 的非负整数矩阵来表示一片大陆上各个单元格的高度。“太平洋”处于大陆的左边界和上边界，而“大西洋”处于大陆的右边界和下边界。</p><p>规定水流只能按照上、下、左、右四个方向流动，且只能从高到低或者在同等高度上流动。</p><p>请找出那些水流既可以流动到“太平洋”，又能流动到“大西洋”的陆地单元的坐标。</p><p>提示：</p><pre><code>输出坐标的顺序不重要m 和 n 都小于150</code></pre><p>示例：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">给定下面的 5x5 矩阵:</span><br><span class="line"></span><br><span class="line">  太平洋 ~   ~   ~   ~   ~ </span><br><span class="line">       ~  1   2   2   3  (5) *</span><br><span class="line">       ~  3   2   3  (4) (4) *</span><br><span class="line">       ~  2   4  (5)  3   1  *</span><br><span class="line">       ~ (6) (7)  1   4   5  *</span><br><span class="line">       ~ (5)  1   1   2   4  *</span><br><span class="line">          *   *   *   *   * 大西洋</span><br><span class="line"></span><br><span class="line">返回:</span><br><span class="line"></span><br><span class="line">[[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] (上图中带括号的单元).</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/pacific-atlantic-water-flow/" target="_blank" rel="noopener">leetcode原题地址</a></p><h4><span id="解法">解法</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> m, n;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[][] matrix;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[][] direction = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pacificAtlantic(<span class="keyword">int</span>[][] matrix) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ret = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    m = matrix.length;</span><br><span class="line">    n = matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">this</span>.matrix = matrix;</span><br><span class="line">    <span class="keyword">boolean</span>[][] canReachP = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">    <span class="keyword">boolean</span>[][] canReachA = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        dfs(i, <span class="number">0</span>, canReachP);</span><br><span class="line">        dfs(i, n - <span class="number">1</span>, canReachA);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        dfs(<span class="number">0</span>, i, canReachP);</span><br><span class="line">        dfs(m - <span class="number">1</span>, i, canReachA);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (canReachP[i][j] &amp;&amp; canReachA[i][j]) &#123;</span><br><span class="line">                ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                list.add(i);</span><br><span class="line">                list.add(j);</span><br><span class="line">                ret.add(list);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> c, <span class="keyword">boolean</span>[][] canReach)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (canReach[r][c]) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    canReach[r][c] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] d : direction) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextR = d[<span class="number">0</span>] + r;</span><br><span class="line">        <span class="keyword">int</span> nextC = d[<span class="number">1</span>] + c;</span><br><span class="line">        <span class="keyword">if</span> (nextR &lt; <span class="number">0</span> || nextR &gt;= m || nextC &lt; <span class="number">0</span> || nextC &gt;= n</span><br><span class="line">                || matrix[r][c] &gt; matrix[nextR][nextC]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(nextR, nextC, canReach);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;DFS&quot;&gt;&lt;a href=&quot;#DFS&quot; class=&quot;headerlink&quot; title=&quot;DFS&quot;&gt;&lt;/a&gt;DFS&lt;/h2&gt;&lt;p&gt;深度优先搜索是在得到一个新节点时立即堆新节点进行遍历。DFS常用来求解这种可达性问题。&lt;/p&gt;
&lt;p&gt;在实现DFS时需要考虑以下两个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;栈，使用栈来保存当前节点信息，当遍历新节点返回时能够继续遍历当前节点。可以使用递归栈。&lt;/li&gt;
&lt;li&gt;标记：需要记录那些节点已经遍历过了。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;695-岛屿的最大面积&quot;&gt;&lt;a href=&quot;#695-岛屿的最大面积&quot; class=&quot;headerlink&quot; title=&quot;695. 岛屿的最大面积&quot;&gt;&lt;/a&gt;695. 岛屿的最大面积&lt;/h3&gt;&lt;p&gt;给定一个包含了一些 0 和 1 的非空二维数组 grid 。&lt;/p&gt;
&lt;p&gt;一个 岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在水平或者竖直方向上相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。&lt;/p&gt;
&lt;p&gt;找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为 0 。)&lt;/p&gt;
&lt;p&gt;示例 1:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[[0,0,1,0,0,0,0,1,0,0,0,0,0],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; [0,0,0,0,0,0,0,1,1,1,0,0,0],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; [0,1,1,0,1,0,0,0,0,0,0,0,0],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; [0,1,0,0,1,1,0,0,1,0,1,0,0],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; [0,1,0,0,1,1,0,0,1,1,1,0,0],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; [0,0,0,0,0,0,0,0,0,0,1,0,0],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; [0,0,0,0,0,0,0,1,1,1,0,0,0],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; [0,0,0,0,0,0,0,1,1,0,0,0,0]]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;对于上面这个给定矩阵应返回 6。注意答案不应该是 11 ，因为岛屿只能包含水平或垂直的四个方向的 1 。&lt;/p&gt;
&lt;h4 id=&quot;解法&quot;&gt;&lt;a href=&quot;#解法&quot; class=&quot;headerlink&quot; title=&quot;解法&quot;&gt;&lt;/a&gt;解法&lt;/h4&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[][] direction=&amp;#123;&amp;#123;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&amp;#125;,&amp;#123;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&amp;#125;,&amp;#123;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&amp;#125;,&amp;#123;-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&amp;#125;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; m,n;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;maxAreaOfIsland&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[][] grid)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(grid.length==&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;||grid[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;].length==&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      m=grid.length;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      n=grid[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;].length;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; maxArea=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;i&amp;lt;m;i++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;j&amp;lt;n;j++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              maxArea=Math.max(maxArea,dfs(grid,i,j));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; maxArea;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;dfs&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[][] grid,&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; r,&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; c)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(r&amp;lt;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;||r&amp;gt;m||c&amp;lt;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;||c&amp;gt;n||grid[r][c]==&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; area=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;//（r，c）为陆地&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      grid[r][c]=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;//标记为已经遍历&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[] d : direction) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        area+=dfs(grid, r+d[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;], c+d[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; area;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/max-area-of-island/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;leetcode原题地址&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="https://zofun.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Java" scheme="https://zofun.github.io/tags/Java/"/>
    
      <category term="算法" scheme="https://zofun.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法之栈和队列</title>
    <link href="https://zofun.github.io/2020/04/04/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    <id>https://zofun.github.io/2020/04/04/算法之栈和队列/</id>
    <published>2020-04-04T13:29:00.000Z</published>
    <updated>2020-04-04T12:53:26.089Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="栈和队列">栈和队列</span></h2><h3><span id="232用栈实现队列">232.用栈实现队列</span></h3><p>使用栈实现队列的下列操作：</p><pre><code>push(x) -- 将一个元素放入队列的尾部。pop() -- 从队列首部移除元素。peek() -- 返回队列首部的元素。empty() -- 返回队列是否为空。</code></pre><p>示例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MyQueue queue = <span class="keyword">new</span> MyQueue();</span><br><span class="line"></span><br><span class="line">queue.push(<span class="number">1</span>);</span><br><span class="line">queue.push(<span class="number">2</span>);  </span><br><span class="line">queue.peek();  <span class="comment">// 返回 1</span></span><br><span class="line">queue.pop();   <span class="comment">// 返回 1</span></span><br><span class="line">queue.empty(); <span class="comment">// 返回 false</span></span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/implement-queue-using-stacks/" target="_blank" rel="noopener">leetcode原题地址</a></p><a id="more"></a><h4><span id="解法">解法</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; in;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; out;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Initialize your data structure here.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            in=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">            out=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Push element x to the back of queue.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        in.push(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Removes the element from in front of queue and returns that element.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(out.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span> (!in.isEmpty())&#123;</span><br><span class="line">                out.push(in.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> out.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get the front element.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(out.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span> (!in.isEmpty())&#123;</span><br><span class="line">                out.push(in.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> out.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns whether the queue is empty.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> in.isEmpty()&amp;&amp;out.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="225-用队列实现栈">225. 用队列实现栈</span></h3><p>使用队列实现栈的下列操作：</p><pre><code>push(x) -- 元素 x 入栈pop() -- 移除栈顶元素top() -- 获取栈顶元素empty() -- 返回栈是否为空</code></pre><p>注意:</p><pre><code>你只能使用队列的基本操作-- 也就是 push to back, peek/pop from front, size, 和 is empty 这些操作是合法的。你所使用的语言也许不支持队列。 你可以使用 list 或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。你可以假设所有操作都是有效的（例如, 对一个空的栈不会调用 pop 或者 top 操作）。</code></pre><p><a href="https://leetcode-cn.com/problems/implement-stack-using-queues/" target="_blank" rel="noopener">leetcode原题地址</a></p><h4><span id="解法">解法</span></h4><p>在将一个元素 x 插入队列时，为了维护原来的后进先出顺序，需要让 x 插入队列首部。而队列的默认插入顺序是队列<br>尾部，因此在将 x 插入队列尾部之后，需要让除了 x 之外的所有元素出队列，再入队列。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Queue&lt;Integer&gt; queue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        queue=<span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Push element x onto stack. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        queue.add(x);</span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size-<span class="number">1</span>;i++ )&#123;</span><br><span class="line">            queue.add(queue.poll());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Removes the element on top of the stack and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> queue.poll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Get the top element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> queue.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns whether the stack is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> queue.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="155-最小栈">155. 最小栈</span></h3><p>设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。</p><pre><code>push(x) -- 将元素 x 推入栈中。pop() -- 删除栈顶的元素。top() -- 获取栈顶元素。getMin() -- 检索栈中的最小元素。</code></pre><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MinStack minStack = new MinStack();</span><br><span class="line">minStack.push(-2);</span><br><span class="line">minStack.push(0);</span><br><span class="line">minStack.push(-3);</span><br><span class="line">minStack.getMin();   --&gt; 返回 -3.</span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();      --&gt; 返回 0.</span><br><span class="line">minStack.getMin();   --&gt; 返回 -2.</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/min-stack/" target="_blank" rel="noopener">leetcode原题地址</a></p><h4><span id="解法">解法</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stack;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; minStack;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> min;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        minStack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        min=Integer.MAX_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        stack.push(x);</span><br><span class="line">        min=Math.min(min,x);</span><br><span class="line">        minStack.push(min);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        minStack.pop();</span><br><span class="line">        stack.pop();</span><br><span class="line">        min=minStack.isEmpty()?Integer.MAX_VALUE:minStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="20-有效的括号">20. 有效的括号</span></h3><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</p><p>有效字符串需满足：</p><pre><code>左括号必须用相同类型的右括号闭合。左括号必须以正确的顺序闭合。</code></pre><p>注意空字符串可被认为是有效字符串。</p><p><a href="https://leetcode-cn.com/problems/valid-parentheses/" target="_blank" rel="noopener">leetcode原题地址</a></p><h4><span id="解法">解法</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">       </span><br><span class="line">       Stack&lt;Character&gt; stack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;chars.length;i++)&#123;</span><br><span class="line">           <span class="keyword">char</span> ch=chars[i];</span><br><span class="line">           <span class="keyword">if</span>(ch==<span class="string">'('</span>||ch==<span class="string">'&#123;'</span>||ch==<span class="string">'['</span>)&#123;</span><br><span class="line">               stack.push(ch);</span><br><span class="line">           &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">if</span>(stack.isEmpty())&#123;</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">char</span> cStack = stack.pop();</span><br><span class="line">               <span class="keyword">boolean</span> b1 = ch == <span class="string">')'</span> &amp;&amp; cStack != <span class="string">'('</span>;</span><br><span class="line">               <span class="keyword">boolean</span> b2 = ch == <span class="string">']'</span> &amp;&amp; cStack != <span class="string">'['</span>;</span><br><span class="line">               <span class="keyword">boolean</span> b3 = ch == <span class="string">'&#125;'</span> &amp;&amp; cStack != <span class="string">'&#123;'</span>;</span><br><span class="line">               <span class="keyword">if</span> (b1 || b2 || b3) &#123;</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3><span id="739-每日温度">739. 每日温度</span></h3><p>根据每日 气温 列表，请重新生成一个列表，对应位置的输出是需要再等待多久温度才会升高超过该日的天数。如果之后都不会升高，请在该位置用 0 来代替。</p><p>例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。</p><p>提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。</p><p><a href="https://leetcode-cn.com/problems/daily-temperatures/" target="_blank" rel="noopener">leetcode原题地址</a></p><h4><span id="解法">解法</span></h4><p>在遍历数组时用栈把数组中的数存起来，如果当前遍历的数比栈顶元素来的大，说明栈顶元素的下一个比它大的数就是当前元素。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] dailyTemperatures(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line">    Stack&lt;Integer&gt; indexs=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] result=<span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span> (!indexs.isEmpty()&amp;&amp;arr[i]&gt;arr[indexs.peek()])&#123;</span><br><span class="line">            <span class="keyword">int</span> preIndex=indexs.pop();</span><br><span class="line">            result[preIndex]=i-preIndex;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        indexs.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="503-下一个更大的元素ii">503. 下一个更大的元素Ⅱ</span></h3><p>给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,1]</span><br><span class="line">输出: [2,-1,2]</span><br><span class="line">解释: 第一个 1 的下一个更大的数是 2；</span><br><span class="line">数字 2 找不到下一个更大的数； </span><br><span class="line">第二个 1 的下一个最大的数需要循环搜索，结果也是 2。</span><br></pre></td></tr></table></figure><p>注意: 输入数组的长度不会超过 10000。</p><p><a href="https://leetcode-cn.com/problems/next-greater-element-ii/" target="_blank" rel="noopener">leetcode原题地址</a></p><h4><span id="解法">解法</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] nextGreaterElements(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] result=<span class="keyword">new</span>  <span class="keyword">int</span>[nums.length];</span><br><span class="line">    Arrays.fill(result,-<span class="number">1</span>);</span><br><span class="line">    Stack&lt;Integer&gt; stack=<span class="keyword">new</span> Stack();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length*<span class="number">2</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> num=nums[i%nums.length];</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()&amp;&amp;num&gt;nums[stack.peek()])&#123;</span><br><span class="line">            result[stack.pop()]=num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i&lt;nums.length)&#123;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;栈和队列&quot;&gt;&lt;a href=&quot;#栈和队列&quot; class=&quot;headerlink&quot; title=&quot;栈和队列&quot;&gt;&lt;/a&gt;栈和队列&lt;/h2&gt;&lt;h3 id=&quot;232-用栈实现队列&quot;&gt;&lt;a href=&quot;#232-用栈实现队列&quot; class=&quot;headerlink&quot; title=&quot;232.用栈实现队列&quot;&gt;&lt;/a&gt;232.用栈实现队列&lt;/h3&gt;&lt;p&gt;使用栈实现队列的下列操作：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;push(x) -- 将一个元素放入队列的尾部。
pop() -- 从队列首部移除元素。
peek() -- 返回队列首部的元素。
empty() -- 返回队列是否为空。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;示例:&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;MyQueue queue = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; MyQueue();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;queue.push(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;queue.push(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;queue.peek();  &lt;span class=&quot;comment&quot;&gt;// 返回 1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;queue.pop();   &lt;span class=&quot;comment&quot;&gt;// 返回 1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;queue.empty(); &lt;span class=&quot;comment&quot;&gt;// 返回 false&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/implement-queue-using-stacks/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;leetcode原题地址&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="https://zofun.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Java" scheme="https://zofun.github.io/tags/Java/"/>
    
      <category term="算法" scheme="https://zofun.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法之链表</title>
    <link href="https://zofun.github.io/2020/04/03/%E7%AE%97%E6%B3%95%E4%B9%8B%E9%93%BE%E8%A1%A8/"/>
    <id>https://zofun.github.io/2020/04/03/算法之链表/</id>
    <published>2020-04-03T13:29:00.000Z</published>
    <updated>2020-04-03T13:29:08.270Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="链表">链表</span></h2><h3><span id="160-相交链表">160. 相交链表</span></h3><p>编写一个程序，找到两个单链表相交的起始节点。</p><p><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/" target="_blank" rel="noopener">leetcode原题地址</a></p><h4><span id="解法">解法</span></h4><p>设 A 的长度为 a + c，B 的长度为 b + c，其中 c 为尾部公共部分长度，可知 a + c + b = b + c + a。<br>当访问 A 链表的指针访问到链表尾部时，令它从链表 B 的头部开始访问链表 B；同样地，当访问 B 链表的指针访问<br>到链表尾部时，令它从链表 A 的头部开始访问链表 A。这样就能控制访问 A 和 B 两个链表的指针能同时访问到交<br>点  .</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这道题的意思是必定有相交的</span></span><br><span class="line">    ListNode curA=headA;</span><br><span class="line">    ListNode curB=headB;</span><br><span class="line">    <span class="keyword">while</span> (curA!=curB)&#123;</span><br><span class="line">        curA=(curA==<span class="keyword">null</span>)?headB:curA.next;</span><br><span class="line">        curB=(curB==<span class="keyword">null</span>)?headA:curB.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> curA;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h3><span id="206-反转链表">206. 反转链表</span></h3><p>反转一个单链表。</p><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure><p>进阶:<br>你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</p><p><a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener">leetcode原题地址</a></p><h4><span id="解法">解法</span></h4><ol><li>递归解法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="keyword">null</span>||head.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode next=head.next;</span><br><span class="line">    <span class="comment">//反转 1-&gt;2-&gt;3 就可以看成 反转（2-&gt;3）+1</span></span><br><span class="line">    ListNode node = reverseList(head.next);</span><br><span class="line">    <span class="comment">//next.next就是反转后的链表的尾节点</span></span><br><span class="line">    next.next=head;</span><br><span class="line">    <span class="comment">//head是两个链表合并后的最后一个节点，因此heae.next需要设置尾null</span></span><br><span class="line">    head.next=<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>头插法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">      ListNode tmpHead=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">while</span> (head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">          ListNode next=head.next;</span><br><span class="line">          head.next=tmpHead.next;</span><br><span class="line">          tmpHead.next=head;</span><br><span class="line">          head=next;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>  tmpHead.next;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>直接反转法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">     ListNode pre=<span class="keyword">null</span>;</span><br><span class="line">     ListNode cur=head;</span><br><span class="line">     ListNode next=<span class="keyword">null</span>;</span><br><span class="line">     <span class="keyword">while</span> (cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">         next=cur.next;</span><br><span class="line">         <span class="comment">//反转</span></span><br><span class="line">         cur.next=pre;</span><br><span class="line">         <span class="comment">//pre后移</span></span><br><span class="line">         pre=cur;</span><br><span class="line">         <span class="comment">//后移</span></span><br><span class="line">         cur=next;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> pre;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3><span id="21-合并两个有序链表">21. 合并两个有序链表</span></h3><p>将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">leetcode原题地址</a></p><h4><span id="解法">解法</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l1==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(l2==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(l1.val&lt;l2.val)&#123;</span><br><span class="line">        l1.next=mergeTwoLists(l1.next,l2);</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        l2.next=mergeTwoLists(l1,l2.next);</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上是递归解法，也可以使用非递归。</p><h3><span id="83-删除排序链表中的重复元素">83. 删除排序链表中的重复元素</span></h3><p>给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。</p><p>示例 1:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span></span><br><span class="line">输出: <span class="number">1</span>-&gt;<span class="number">2</span></span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">3</span></span><br><span class="line">输出: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span></span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/" target="_blank" rel="noopener">leetcode原题地址</a></p><h4><span id="解法">解法</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>||head.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        head.next=deleteDuplicates(head.next);</span><br><span class="line">        <span class="keyword">return</span> head.val==head.next.val?head.next:head;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3><span id="19-删除链表的倒数第n个节点">19. 删除链表的倒数第N个节点</span></h3><p>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.</span><br><span class="line"></span><br><span class="line">当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.</span><br></pre></td></tr></table></figure><p>说明：</p><p>给定的 n 保证是有效的。</p><p>进阶：</p><p>你能尝试使用一趟扫描实现吗？</p><p><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noopener">leetcode原题地址</a></p><h4><span id="解法">解法</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       ListNode fast=head;</span><br><span class="line">       ListNode slow=head;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">           fast=fast.next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(fast==<span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> head;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">while</span> (fast.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           fast=fast.next;</span><br><span class="line">           slow=slow.next;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       slow.next=slow.next.next;</span><br><span class="line">       <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3><span id="34-两两交换链表中的节点">34. 两两交换链表中的节点</span></h3><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p><p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3.</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/" target="_blank" rel="noopener">leetcode原题地址</a></p><h4><span id="解法">解法</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">       ListNode node = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">       node.next = head;</span><br><span class="line">       ListNode pre = node;</span><br><span class="line">       <span class="keyword">while</span> (pre.next != <span class="keyword">null</span> &amp;&amp; pre.next.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">           ListNode l1 = pre.next, l2 = pre.next.next;</span><br><span class="line">           ListNode next = l2.next;</span><br><span class="line">           l1.next = next;</span><br><span class="line">           l2.next = l1;</span><br><span class="line">           pre.next = l2;pre = l1;</span><br><span class="line">       &#125; </span><br><span class="line">       <span class="keyword">return</span> node.next;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3><span id="445-两数相加ii">445. 两数相加Ⅱ</span></h3><p>给定两个非空链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储单个数字。将这两数相加会返回一个新的链表。</p><p>你可以假设除了数字 0 之外，这两个数字都不会以零开头。</p><p>进阶:</p><p>如果输入链表不能修改该如何处理？换句话说，你不能对列表中的节点进行翻转。</p><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: (7 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">输出: 7 -&gt; 8 -&gt; 0 -&gt; 7</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/add-two-numbers-ii/" target="_blank" rel="noopener">leetcode原题地址</a></p><h4><span id="解法">解法</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       Stack&lt;Integer&gt; stackA = buildStack(l1);</span><br><span class="line">       Stack&lt;Integer&gt; stackB = buildStack(l2);</span><br><span class="line">       ListNode tmpHead=<span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">       <span class="keyword">int</span> carry=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span> (!stackA.isEmpty()||!stackB.isEmpty()||carry!=<span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> A =stackA.isEmpty()?<span class="number">0</span>: stackA.pop();</span><br><span class="line">            <span class="keyword">int</span> B =stackB.isEmpty()?<span class="number">0</span>: stackB.pop();</span><br><span class="line">            ListNode node = <span class="keyword">new</span> ListNode((A + B+carry) % <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">            carry=(A+B+carry)/<span class="number">10</span>;</span><br><span class="line">            node.next=tmpHead.next;</span><br><span class="line">            tmpHead.next=node;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> tmpHead.next;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> Stack&lt;Integer&gt; <span class="title">buildStack</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">       Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">       <span class="keyword">while</span> (head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           stack.push(head.val);</span><br><span class="line">           head=head.next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> stack;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3><span id="725-分隔链表">725. 分隔链表</span></h3><p>给定一个头结点为 root 的链表, 编写一个函数以将链表分隔为 k 个连续的部分。</p><p>每部分的长度应该尽可能的相等: 任意两部分的长度差距不能超过 1，也就是说可能有些部分为 null。</p><p>这k个部分应该按照在链表中出现的顺序进行输出，并且排在前面的部分的长度应该大于或等于后面的长度。</p><p>返回一个符合上述规则的链表的列表。</p><p>举例： 1-&gt;2-&gt;3-&gt;4, k = 5 // 5 结果 [ [1], [2], [3], [4], null ]</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">root = [1, 2, 3], k = 5</span><br><span class="line">输出: [[1],[2],[3],[],[]]</span><br><span class="line">解释:</span><br><span class="line">输入输出各部分都应该是链表，而不是数组。</span><br><span class="line">例如, 输入的结点 root 的 val= 1, root.next.val = 2, \root.next.next.val = 3, 且 root.next.next.next = null。</span><br><span class="line">第一个输出 output[0] 是 output[0].val = 1, output[0].next = null。</span><br><span class="line">最后一个元素 output[4] 为 null, 它代表了最后一个部分为空链表。</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">root = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], k = 3</span><br><span class="line">输出: [[1, 2, 3, 4], [5, 6, 7], [8, 9, 10]]</span><br><span class="line">解释:</span><br><span class="line">输入被分成了几个连续的部分，并且每部分的长度相差不超过1.前面部分的长度大于等于后面部分的长度。</span><br></pre></td></tr></table></figure><p>提示:</p><pre><code>root 的长度范围： [0, 1000].输入的每个节点的大小范围：[0, 999].k 的取值范围： [1, 50].</code></pre><p><a href="https://leetcode-cn.com/problems/split-linked-list-in-parts/" target="_blank" rel="noopener">leetcode原题地址</a></p><h4><span id="解法">解法</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode[] splitListToParts(ListNode root, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">int</span> N = <span class="number">0</span>;</span><br><span class="line">        ListNode cur = root;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;N++;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">int</span> mod = N % k;</span><br><span class="line">        <span class="keyword">int</span> size = N / k;</span><br><span class="line">        ListNode[] ret = <span class="keyword">new</span> ListNode[k];</span><br><span class="line">        cur = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; cur != <span class="keyword">null</span> &amp;&amp; i &lt; k; i++) &#123;</span><br><span class="line">            ret[i] = cur;</span><br><span class="line">            <span class="keyword">int</span> curSize = size + (mod-- &gt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; curSize - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">            ListNode next = cur.next;</span><br><span class="line">            cur.next = <span class="keyword">null</span>;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;链表&quot;&gt;&lt;a href=&quot;#链表&quot; class=&quot;headerlink&quot; title=&quot;链表&quot;&gt;&lt;/a&gt;链表&lt;/h2&gt;&lt;h3 id=&quot;160-相交链表&quot;&gt;&lt;a href=&quot;#160-相交链表&quot; class=&quot;headerlink&quot; title=&quot;160. 相交链表&quot;&gt;&lt;/a&gt;160. 相交链表&lt;/h3&gt;&lt;p&gt;编写一个程序，找到两个单链表相交的起始节点。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/intersection-of-two-linked-lists/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;leetcode原题地址&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;解法&quot;&gt;&lt;a href=&quot;#解法&quot; class=&quot;headerlink&quot; title=&quot;解法&quot;&gt;&lt;/a&gt;解法&lt;/h4&gt;&lt;p&gt;设 A 的长度为 a + c，B 的长度为 b + c，其中 c 为尾部公共部分长度，可知 a + c + b = b + c + a。&lt;br&gt;当访问 A 链表的指针访问到链表尾部时，令它从链表 B 的头部开始访问链表 B；同样地，当访问 B 链表的指针访问&lt;br&gt;到链表尾部时，令它从链表 A 的头部开始访问链表 A。这样就能控制访问 A 和 B 两个链表的指针能同时访问到交&lt;br&gt;点  .&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; ListNode &lt;span class=&quot;title&quot;&gt;getIntersectionNode&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(ListNode headA, ListNode headB)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//这道题的意思是必定有相交的&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ListNode curA=headA;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ListNode curB=headB;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (curA!=curB)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        curA=(curA==&lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;)?headB:curA.next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        curB=(curB==&lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;)?headA:curB.next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; curA;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="https://zofun.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Java" scheme="https://zofun.github.io/tags/Java/"/>
    
      <category term="算法" scheme="https://zofun.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法之动态规划</title>
    <link href="https://zofun.github.io/2020/03/31/%E7%AE%97%E6%B3%95%E4%B9%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>https://zofun.github.io/2020/03/31/算法之动态规划/</id>
    <published>2020-03-31T14:11:00.000Z</published>
    <updated>2020-03-31T14:11:54.392Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="动态规划">动态规划</span></h2><p>动态规划和递归都是见原问题拆成多个子问题然后求解，它们之间最本质的区别是，动态规划保存了子问题的解，避免重复计算。</p><h3><span id="70-爬楼梯">70. 爬楼梯</span></h3><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p>注意：给定 n 是一个正整数。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入： 2</span><br><span class="line">输出： 2</span><br><span class="line">解释： 有两种方法可以爬到楼顶。</span><br><span class="line"></span><br><span class="line">1.  1 阶 + 1 阶</span><br><span class="line">2.  2 阶</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入： 3</span><br><span class="line">输出： 3</span><br><span class="line">解释： 有三种方法可以爬到楼顶。</span><br><span class="line"></span><br><span class="line">1.  1 阶 + 1 阶 + 1 阶</span><br><span class="line">2.  1 阶 + 2 阶</span><br><span class="line">3.  2 阶 + 1 阶</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/climbing-stairs/" target="_blank" rel="noopener">leetcode原题地址</a></p><a id="more"></a><h4><span id="解法">解法</span></h4><p>这道题是一道非常经典的题。我们今天尝试使用动态规划来解它。<br>$$<br>dp[n]=dp[n-1]+dp[n-2]<br>$$<br>到达第n阶楼梯的走法等于到达第n-1阶然后在走一阶加上到达n-2阶的走法然后再走两步。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(n&lt;<span class="number">2</span>)&#123;</span><br><span class="line">          <span class="keyword">return</span> n;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//dp[3]=dp[2]+dp[1]</span></span><br><span class="line">      <span class="keyword">int</span> pre1=<span class="number">2</span>; <span class="comment">//dp[2]</span></span><br><span class="line">      <span class="keyword">int</span> pre2=<span class="number">1</span>; <span class="comment">//dp[1]</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;i++)&#123;</span><br><span class="line">          <span class="keyword">int</span> cur=pre1+pre2;</span><br><span class="line">          pre2=pre1;</span><br><span class="line">          pre1=cur;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> pre1;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3><span id="198-打家劫舍">198. 打家劫舍</span></h3><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,1]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。</span><br><span class="line">     偷窃到的最高金额 = 1 + 3 = 4 。</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,7,9,3,1]</span><br><span class="line">输出: 12</span><br><span class="line">解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。</span><br><span class="line">     偷窃到的最高金额 = 2 + 9 + 1 = 12 。</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/house-robber/" target="_blank" rel="noopener">leetcode原题地址</a></p><h4><span id="解法">解法</span></h4><p>$$<br>dp[n]=max(dp[n-2]+nums[n],dp[n-1])<br>$$</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//dp[n]=max(dp[n-2]+nums[n],dp[n-1])</span></span><br><span class="line">       <span class="comment">//这种写法比直接利用dp数组更节省空间</span></span><br><span class="line">       <span class="keyword">int</span> pre2=<span class="number">0</span>;<span class="comment">//dp[n-2]</span></span><br><span class="line">       <span class="keyword">int</span> pre1=<span class="number">0</span>;<span class="comment">//dp[n-1]</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">           <span class="keyword">int</span> cur=Math.max(pre2+nums[i],pre1);</span><br><span class="line">           pre2=pre1;</span><br><span class="line">           pre1=cur;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> pre1;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3><span id="213-打家劫舍">213. 打家劫舍</span></h3><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,3,2]</span><br><span class="line">输出: 3</span><br><span class="line">解释: 你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,1]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。</span><br><span class="line">     偷窃到的最高金额 = 1 + 3 = 4 。</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/house-robber-ii/" target="_blank" rel="noopener">leetcode原题地址</a></p><h4><span id="解法">解法</span></h4><p>这道题的原理和上一题类似，但是因为是环形的，所以第一家和最后一家只能选择一个偷。所以我们将这两个方案都计算一下，比较得到最佳方案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span>(nums==<span class="keyword">null</span>||nums.length==<span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(nums.length==<span class="number">1</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> Math.max(rob(nums,<span class="number">0</span>,nums.length-<span class="number">2</span>),rob(nums,<span class="number">1</span>,nums.length-<span class="number">1</span>));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">       <span class="comment">//dp[n]=max(dp[n-1],dp[n-2]+nums[n]);</span></span><br><span class="line">       <span class="keyword">int</span> pre1=<span class="number">0</span>; <span class="comment">//dp[n-1]</span></span><br><span class="line">       <span class="keyword">int</span> pre2=<span class="number">0</span>; <span class="comment">//dp[n-2]</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;=end;i++)&#123;</span><br><span class="line">           <span class="keyword">int</span> cur=Math.max(pre1,pre2+nums[i]);</span><br><span class="line">           pre2=pre1;</span><br><span class="line">           pre1=cur;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> pre1;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3><span id="64-最小路径和">64. 最小路径和</span></h3><p>给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p><p>说明：每次只能向下或者向右移动一步。</p><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  [1,3,1],</span><br><span class="line">  [1,5,1],</span><br><span class="line">  [4,2,1]</span><br><span class="line">]</span><br><span class="line">输出: 7</span><br><span class="line">解释: 因为路径 1→3→1→1→1 的总和最小。</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/minimum-path-sum/" target="_blank" rel="noopener">leetcode原题地址</a></p><h4><span id="解法">解法</span></h4><p>$$<br>dp[i,j]=grid[i,j]+min(dp[i+1,j],dp[i,j+1])<br>$$</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[grid[<span class="number">0</span>].length];</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = grid.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> j = grid[<span class="number">0</span>].length - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">              <span class="keyword">if</span>(i == grid.length - <span class="number">1</span> &amp;&amp; j != grid[<span class="number">0</span>].length - <span class="number">1</span>)</span><br><span class="line">                  dp[j] = grid[i][j] +  dp[j + <span class="number">1</span>];</span><br><span class="line">              <span class="keyword">else</span> <span class="keyword">if</span>(j == grid[<span class="number">0</span>].length - <span class="number">1</span> &amp;&amp; i != grid.length - <span class="number">1</span>)</span><br><span class="line">                  dp[j] = grid[i][j] + dp[j];</span><br><span class="line">              <span class="keyword">else</span> <span class="keyword">if</span>(j != grid[<span class="number">0</span>].length - <span class="number">1</span> &amp;&amp; i != grid.length - <span class="number">1</span>)</span><br><span class="line">                  dp[j] = grid[i][j] + Math.min(dp[j], dp[j + <span class="number">1</span>]);</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                  dp[j] = grid[i][j];</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3><span id="62-不同路径">62. 不同路径</span></h3><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角。</p><p>问总共有多少条不同的路径？</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: m = 3, n = 2</span><br><span class="line">输出: 3</span><br><span class="line">解释:</span><br><span class="line">从左上角开始，总共有 3 条路径可以到达右下角。</span><br><span class="line"></span><br><span class="line">1. 向右 -&gt; 向右 -&gt; 向下</span><br><span class="line">2. 向右 -&gt; 向下 -&gt; 向右</span><br><span class="line">3. 向下 -&gt; 向右 -&gt; 向右</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: m = 7, n = 3</span><br><span class="line">输出: 28</span><br></pre></td></tr></table></figure><p>提示：</p><pre><code>1 &lt;= m, n &lt;= 100题目数据保证答案小于等于 2 * 10 ^ 9</code></pre><p><a href="https://leetcode-cn.com/problems/unique-paths/" target="_blank" rel="noopener">leetcode原题地址</a></p><h4><span id="解法">解法</span></h4><p>$$<br>dp[i,j]=dp[i-1,j]+dp[i,j-1]<br>$$</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span>[][] dp=<span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">           dp[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">           dp[<span class="number">0</span>][j]=<span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">               dp[i][j]=dp[i-<span class="number">1</span>][j]+dp[i][j-<span class="number">1</span>];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3><span id="303-区域和检索-数组不可变">303. 区域和检索-数组不可变</span></h3><p>给定一个整数数组  nums，求出数组从索引 i 到 j  (i ≤ j) 范围内元素的总和，包含 i,  j 两点。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给定 nums = [-2, 0, 3, -5, 2, -1]，求和函数为 sumRange()</span><br><span class="line"></span><br><span class="line">sumRange(0, 2) -&gt; 1</span><br><span class="line">sumRange(2, 5) -&gt; -1</span><br><span class="line">sumRange(0, 5) -&gt; -3</span><br></pre></td></tr></table></figure><p>说明:</p><pre><code>你可以假设数组不可变。会多次调用 sumRange 方法。</code></pre><p><a href="https://leetcode-cn.com/problems/range-sum-query-immutable/" target="_blank" rel="noopener">leetcode原题地址</a></p><h4><span id="解法">解法</span></h4><p>求区间i-j的和，可以转换为sum[j+1]-sum[j]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] sums;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">NumArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       sums=<span class="keyword">new</span> <span class="keyword">int</span>[nums.length+<span class="number">1</span>];</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=nums.length;i++)&#123;</span><br><span class="line"></span><br><span class="line">           sums[i]=sums[i-<span class="number">1</span>]+nums[i-<span class="number">1</span>];</span><br><span class="line">          </span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> sums[j+<span class="number">1</span>]-sums[i];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3><span id="343-整数拆分">343. 整数拆分</span></h3><p>给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 2</span><br><span class="line">输出: 1</span><br><span class="line">解释: 2 = 1 + 1, 1 × 1 = 1。</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: 10</span><br><span class="line">输出: 36</span><br><span class="line">解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。</span><br><span class="line"></span><br><span class="line">说明: 你可以假设 n 不小于 2 且不大于 58。</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/integer-break/" target="_blank" rel="noopener">leetcode原题地址</a></p><h4><span id="解法">解法</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">integerBreak</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//dp[i]=max(dp[i],max(j*dp[i-j],j*(i-j)))</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">      dp[<span class="number">1</span>]=dp[<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=n;i++)&#123;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">              dp[i]=Math.max(dp[i],Math.max(j*dp[i-j],j*(i-j)));</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> dp[n];</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3><span id="300-最长上升子序列">300. 最长上升子序列</span></h3><p>给定一个无序的整数数组，找到其中最长上升子序列的长度。</p><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [10,9,2,5,3,7,101,18]</span><br><span class="line">输出: 4 </span><br><span class="line">解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。</span><br></pre></td></tr></table></figure><p>说明:</p><pre><code>可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。你算法的时间复杂度应该为 O(n2) 。</code></pre><p>进阶: 你能将算法的时间复杂度降低到 O(n log n) 吗?</p><p><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">leetcode原题地址</a></p><h4><span id="解法">解法</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">         <span class="keyword">int</span> max=<span class="number">1</span>;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;nums.length;j++)&#123;</span><br><span class="line">             <span class="keyword">if</span>(nums[i]&gt;nums[j])&#123;</span><br><span class="line">                 dp[i]=Math.max(max,dp[j]+<span class="number">1</span>);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         dp[i]=max;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> ret=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;dp.length;i++)&#123;</span><br><span class="line">     </span><br><span class="line">           <span class="keyword">if</span>(dp[i]&gt;ret)&#123;</span><br><span class="line">               ret =dp[i];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> ret;</span><br><span class="line">       </span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;动态规划&quot;&gt;&lt;a href=&quot;#动态规划&quot; class=&quot;headerlink&quot; title=&quot;动态规划&quot;&gt;&lt;/a&gt;动态规划&lt;/h2&gt;&lt;p&gt;动态规划和递归都是见原问题拆成多个子问题然后求解，它们之间最本质的区别是，动态规划保存了子问题的解，避免重复计算。&lt;/p&gt;
&lt;h3 id=&quot;70-爬楼梯&quot;&gt;&lt;a href=&quot;#70-爬楼梯&quot; class=&quot;headerlink&quot; title=&quot;70. 爬楼梯&quot;&gt;&lt;/a&gt;70. 爬楼梯&lt;/h3&gt;&lt;p&gt;假设你正在爬楼梯。需要 n 阶你才能到达楼顶。&lt;/p&gt;
&lt;p&gt;每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？&lt;/p&gt;
&lt;p&gt;注意：给定 n 是一个正整数。&lt;/p&gt;
&lt;p&gt;示例 1：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入： 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出： 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释： 有两种方法可以爬到楼顶。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1.  1 阶 + 1 阶&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2.  2 阶&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;示例 2：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入： 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出： 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释： 有三种方法可以爬到楼顶。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1.  1 阶 + 1 阶 + 1 阶&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2.  1 阶 + 2 阶&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3.  2 阶 + 1 阶&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/climbing-stairs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;leetcode原题地址&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="https://zofun.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Java" scheme="https://zofun.github.io/tags/Java/"/>
    
      <category term="算法" scheme="https://zofun.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法之排序</title>
    <link href="https://zofun.github.io/2020/03/30/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%8E%92%E5%BA%8F/"/>
    <id>https://zofun.github.io/2020/03/30/算法之排序/</id>
    <published>2020-03-30T01:44:00.000Z</published>
    <updated>2020-03-30T07:39:32.815Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="排序">排序</span></h2><h3><span id="215数组中的第k个最大元素">215.数组中的第k个最大元素</span></h3><p>在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,2,1,5,6,4] 和 k = 2</span><br><span class="line">输出: 5</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,2,3,1,2,4,5,5,6] 和 k = 4</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><p>说明:</p><p>你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。</p><p><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/" target="_blank" rel="noopener">leetcode原题地址</a></p><a id="more"></a><h4><span id="解法">解法</span></h4><ol><li>是用堆排序</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//小顶堆</span></span><br><span class="line">       PriorityQueue&lt;Integer&gt; pq=<span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">           pq.add(num);</span><br><span class="line">           <span class="keyword">if</span>(pq.size()&gt;k)&#123;</span><br><span class="line">               pq.poll();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> pq.poll();</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(NlogK)，空间复杂度为O(K)</p><ol start="2"><li>使用快排</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">       sort(nums);</span><br><span class="line">       <span class="keyword">return</span> nums[k-<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">       doSort(arr,<span class="number">0</span>,arr.length-<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSort</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line">           <span class="keyword">int</span> pivot = partition(arr, left, right);</span><br><span class="line">           doSort(arr,left,pivot-<span class="number">1</span>);</span><br><span class="line">           doSort(arr,pivot,right);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//寻找枢轴</span></span><br><span class="line">       <span class="keyword">int</span> mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">       <span class="keyword">int</span> pivot=arr[mid];</span><br><span class="line">       <span class="keyword">while</span> (left&lt;=right)&#123;</span><br><span class="line">           <span class="keyword">while</span> (right&gt;=<span class="number">0</span>&amp;&amp;arr[right]&lt;pivot)&#123;</span><br><span class="line">               right--;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">while</span> (left&lt;arr.length&amp;&amp;arr[left]&gt;pivot)&#123;</span><br><span class="line">               left++;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(left&lt;=right)&#123;</span><br><span class="line">               swap(arr, left, right);</span><br><span class="line">               left++;</span><br><span class="line">               right--;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> left;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> tmp=arr[a];</span><br><span class="line">       arr[a]=arr[b];</span><br><span class="line">       arr[b]=tmp;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>快速选择</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> l=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> r=nums.length-<span class="number">1</span>;</span><br><span class="line">       k=nums.length-k;</span><br><span class="line">       <span class="keyword">while</span> (l&lt;r)&#123;</span><br><span class="line">           <span class="keyword">int</span> p = partition(nums, l, r);</span><br><span class="line">           <span class="keyword">if</span>(p==k)&#123;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span>(p&gt;k)&#123;</span><br><span class="line">               r=p-<span class="number">1</span>;</span><br><span class="line">           &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">               l=p+<span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> nums[k];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> l, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = l, j = h + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (a[++i] &lt; a[l] &amp;&amp; i &lt; h) &#123;&#125;;</span><br><span class="line">            <span class="keyword">while</span> (a[--j] &gt; a[l] &amp;&amp; j &gt; l) &#123;&#125;;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= j) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(a, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">        swap(a, l, j);</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp=arr[a];</span><br><span class="line">        arr[a]=arr[b];</span><br><span class="line">        arr[b]=tmp;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3><span id="347-前k个高频元素">347. 前k个高频元素</span></h3><p>给定一个非空的整数数组，返回其中出现频率前 k 高的元素。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,1,1,2,2,3], k = 2</span><br><span class="line">输出: [1,2]</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1], k = 1</span><br><span class="line">输出: [1]</span><br></pre></td></tr></table></figure><p>说明：</p><pre><code>你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。你的算法的时间复杂度必须优于 O(n log n) , n 是数组的大小。</code></pre><p><a href="https://leetcode-cn.com/problems/top-k-frequent-elements/" target="_blank" rel="noopener">leetcode原题地址</a></p><h4><span id="解法">解法</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">topKFrequent</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用hashmap统计频率</span></span><br><span class="line">        HashMap&lt;Integer, Integer&gt; count = <span class="keyword">new</span> HashMap();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n: nums) &#123;</span><br><span class="line">            count.put(n, count.getOrDefault(n, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        PriorityQueue&lt;Integer&gt; heap =</span><br><span class="line">                <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;((n1, n2) -&gt; count.get(n1) - count.get(n2));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//建立堆</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n: count.keySet()) &#123;</span><br><span class="line">            heap.add(n);</span><br><span class="line">            <span class="keyword">if</span> (heap.size() &gt; k)&#123;</span><br><span class="line">                heap.poll();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; top_k = <span class="keyword">new</span> LinkedList();</span><br><span class="line">        <span class="keyword">while</span> (!heap.isEmpty()) &#123;</span><br><span class="line">            top_k.add(heap.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(top_k);</span><br><span class="line">        <span class="keyword">return</span> top_k;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3><span id="75-颜色分类">75. 颜色分类</span></h3><p>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p><p>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p><p>注意:<br>不能使用代码库中的排序函数来解决这道题。</p><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,0,2,1,1,0]</span><br><span class="line">输出: [0,0,1,1,2,2]</span><br></pre></td></tr></table></figure><p>进阶：</p><pre><code>一个直观的解决方案是使用计数排序的两趟扫描算法。首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。你能想出一个仅使用常数空间的一趟扫描算法吗？</code></pre><p><a href="https://leetcode-cn.com/problems/sort-colors/" target="_blank" rel="noopener">leetcode原题地址</a></p><h4><span id="解法">解法</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> zero = -<span class="number">1</span>, one = <span class="number">0</span>, two = nums.length;</span><br><span class="line">        <span class="keyword">while</span> (one &lt; two) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[one] == <span class="number">0</span>) &#123;</span><br><span class="line">                swap(nums, ++zero, one++);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[one] == <span class="number">2</span>) &#123;</span><br><span class="line">                swap(nums, --two, one);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ++one;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp=arr[a];</span><br><span class="line">    arr[a]=arr[b];</span><br><span class="line">    arr[b]=tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;排序&quot;&gt;&lt;a href=&quot;#排序&quot; class=&quot;headerlink&quot; title=&quot;排序&quot;&gt;&lt;/a&gt;排序&lt;/h2&gt;&lt;h3 id=&quot;215-数组中的第k个最大元素&quot;&gt;&lt;a href=&quot;#215-数组中的第k个最大元素&quot; class=&quot;headerlink&quot; title=&quot;215.数组中的第k个最大元素&quot;&gt;&lt;/a&gt;215.数组中的第k个最大元素&lt;/h3&gt;&lt;p&gt;在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。&lt;/p&gt;
&lt;p&gt;示例 1:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: [3,2,1,5,6,4] 和 k = 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;示例 2:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: [3,2,3,1,2,4,5,5,6] 和 k = 4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;说明:&lt;/p&gt;
&lt;p&gt;你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/kth-largest-element-in-an-array/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;leetcode原题地址&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="https://zofun.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Java" scheme="https://zofun.github.io/tags/Java/"/>
    
      <category term="算法" scheme="https://zofun.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法之双指针</title>
    <link href="https://zofun.github.io/2020/03/29/%E7%AE%97%E6%B3%95%E4%B9%8B%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    <id>https://zofun.github.io/2020/03/29/算法之双指针/</id>
    <published>2020-03-29T08:53:00.000Z</published>
    <updated>2020-03-29T08:53:22.594Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="双指针">双指针</span></h2><p>双指针主要用于遍历数组，两个指针指向不同的元素，从而协同完成任务。</p><a id="more"></a><h3><span id="167-两数之和-ii-输入有序数组">167. 两数之和 II - 输入有序数组</span></h3><p>给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。</p><p>函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。</p><p>说明:</p><pre><code>返回的下标值（index1 和 index2）不是从零开始的。你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。</code></pre><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: numbers = [2, 7, 11, 15], target = 9</span><br><span class="line">输出: [1,2]</span><br><span class="line">解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/" target="_blank" rel="noopener">leetcode原题地址</a></p><h4><span id="解答">解答</span></h4><p>我们使用两个指针，一个指针从数组的左边开始，一个指针从数组的右边开始。</p><p>如果两个指针所指数据等于target，那么就直接返回；如果小于target，那么左指针右移动；</p><p>如果大于target，则右指针左移。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line">       <span class="keyword">int</span> minIndex=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> maxIndex=numbers.length-<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">int</span>[] result=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">       <span class="keyword">while</span> (minIndex&lt;maxIndex)&#123;</span><br><span class="line">           <span class="keyword">int</span> sum=numbers[minIndex]+numbers[maxIndex];</span><br><span class="line">           <span class="keyword">if</span>(sum==target)&#123;</span><br><span class="line">               <span class="comment">//返回结果的下标不是从零开始的</span></span><br><span class="line">               result[<span class="number">0</span>]=++minIndex;</span><br><span class="line">               result[<span class="number">1</span>]=++maxIndex;</span><br><span class="line">               <span class="keyword">return</span> result;</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum&gt;target)&#123;</span><br><span class="line">               maxIndex--;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               minIndex++;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3><span id="633平方数之和">633.平方数之和</span></h3><p>给定一个非负整数 c ，你要判断是否存在两个整数 a 和 b，使得 a2 + b2 = c。</p><p>示例1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 5</span><br><span class="line">输出: True</span><br><span class="line">解释: 1 * 1 + 2 * 2 = 5</span><br></pre></td></tr></table></figure><p>示例2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 3</span><br><span class="line">输出: False</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/sum-of-square-numbers/" target="_blank" rel="noopener">leetcode原题地址</a></p><h4><span id="解答">解答</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">judgeSquareSum</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> b=(<span class="keyword">int</span>) Math.sqrt(c);</span><br><span class="line">        <span class="keyword">while</span> (a&lt;=b)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp=a*a+b*b;</span><br><span class="line">            <span class="keyword">if</span>(tmp==c)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(tmp&lt;c)&#123;</span><br><span class="line">                a++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                b--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3><span id="345-反转字符串中的元音字母">345. 反转字符串中的元音字母</span></h3><p>编写一个函数，以字符串作为输入，反转该字符串中的元音字母。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;hello&quot;</span><br><span class="line">输出: &quot;holle&quot;</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;leetcode&quot;</span><br><span class="line">输出: &quot;leotcede&quot;</span><br></pre></td></tr></table></figure><p>说明:<br>元音字母不包含字母”y”。</p><p><a href="https://leetcode-cn.com/problems/reverse-vowels-of-a-string/" target="_blank" rel="noopener">leetcode原题地址</a></p><h4><span id="解法">解法</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> HashSet&lt;Character&gt; set=<span class="keyword">new</span> HashSet&lt;&gt;(</span><br><span class="line">            Arrays.asList(<span class="string">'a'</span>,<span class="string">'e'</span>,<span class="string">'i'</span>,<span class="string">'o'</span>,<span class="string">'u'</span>,<span class="string">'A'</span>,<span class="string">'E'</span>,<span class="string">'I'</span>,<span class="string">'O'</span>,<span class="string">'U'</span>));</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseVowels</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right=chars.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left&lt;right)&#123;</span><br><span class="line">            <span class="keyword">while</span> (right&gt;=<span class="number">0</span>&amp;&amp;!set.contains(chars[right]))&#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (left&lt;chars.length&amp;&amp;!set.contains(chars[left]))&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line">                swap(chars,left,right);</span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(chars);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span>[] chars,<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> tmp=chars[a];</span><br><span class="line">        chars[a]=chars[b];</span><br><span class="line">        chars[b]=tmp;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3><span id="680-验证回文字符串ii">680 验证回文字符串Ⅱ</span></h3><p>给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;aba&quot;</span><br><span class="line">输出: True</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;abca&quot;</span><br><span class="line">输出: True</span><br><span class="line">解释: 你可以删除c字符。</span><br></pre></td></tr></table></figure><p>注意:</p><pre><code>字符串只包含从 a-z 的小写字母。字符串的最大长度是50000。</code></pre><p><a href="https://leetcode.com/problems/valid-palindrome-ii/description/" target="_blank" rel="noopener">leetcode原题地址</a></p><h4><span id="解法">解法</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end=s.length()-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (start&lt;end)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(start)!=s.charAt(end))&#123;</span><br><span class="line">               <span class="keyword">return</span> isPalinerome(s,start,end-<span class="number">1</span>)||isPalinerome(s,start+<span class="number">1</span>,end);</span><br><span class="line">            &#125;</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPalinerome</span><span class="params">(String str,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (start&lt;end)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str.charAt(start)!=str.charAt(end))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="141-环形链表">141. 环形链表</span></h3><p>给定一个链表，判断链表中是否有环。</p><p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [3,2,0,-4], pos = 1</span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2], pos = 0</span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1], pos = -1</span><br><span class="line">输出：false</span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure><p>进阶：</p><p>你能用 O(1)（即，常量）内存解决此问题吗？</p><p><a href="https://leetcode-cn.com/problems/linked-list-cycle/" target="_blank" rel="noopener">leetcode原题地址</a></p><h4><span id="解法">解法</span></h4><p>快慢指针法，一个指针一次只走一步，另一个指针一次走2步。如果链表中有环，那么它们一定会相遇。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode slow=head;</span><br><span class="line">        ListNode fast=head;</span><br><span class="line">        <span class="keyword">while</span> (fast!=<span class="keyword">null</span>&amp;&amp;fast.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            slow=slow.next;</span><br><span class="line">            fast=fast.next.next;</span><br><span class="line">            <span class="keyword">if</span>(fast==slow)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3><span id="524通过删除字母匹配到字典中最长单词">524.通过删除字母匹配到字典中最长单词</span></h3><p>给定一个字符串和一个字符串字典，找到字典里面最长的字符串，该字符串可以通过删除给定字符串的某些字符来得到。如果答案不止一个，返回长度最长且字典顺序最小的字符串。如果答案不存在，则返回空字符串。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;abpcplea&quot;, d = [&quot;ale&quot;,&quot;apple&quot;,&quot;monkey&quot;,&quot;plea&quot;]</span><br><span class="line"></span><br><span class="line">输出: </span><br><span class="line">&quot;apple&quot;</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;abpcplea&quot;, d = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</span><br><span class="line"></span><br><span class="line">输出: </span><br><span class="line">&quot;a&quot;</span><br></pre></td></tr></table></figure><p>说明:</p><pre><code>所有输入的字符串只包含小写字母。字典的大小不会超过 1000。所有输入的字符串长度不会超过 1000。</code></pre><p><a href="https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting/" target="_blank" rel="noopener">leetcode原题地址</a></p><h4><span id="解法">解法</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">findLongestWord</span><span class="params">(String s, List&lt;String&gt; d)</span> </span>&#123;</span><br><span class="line">    String longestWord = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">for</span> (String target : d) &#123;</span><br><span class="line">        <span class="keyword">int</span> l1 = longestWord.length(), l2 = target.length();</span><br><span class="line">        <span class="keyword">if</span> (l1 &gt; l2 || (l1 == l2 &amp;&amp; longestWord.compareTo(target) &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span> (isValid(s, target)) &#123;</span><br><span class="line">            longestWord = target;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> longestWord;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s,String target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; s.length() &amp;&amp; j &lt; target.length()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i) == target.charAt(j)) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> j == target.length();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;双指针&quot;&gt;&lt;a href=&quot;#双指针&quot; class=&quot;headerlink&quot; title=&quot;双指针&quot;&gt;&lt;/a&gt;双指针&lt;/h2&gt;&lt;p&gt;双指针主要用于遍历数组，两个指针指向不同的元素，从而协同完成任务。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="https://zofun.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Java" scheme="https://zofun.github.io/tags/Java/"/>
    
      <category term="算法" scheme="https://zofun.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法:矩形覆盖</title>
    <link href="https://zofun.github.io/2020/03/29/%E7%AE%97%E6%B3%95%EF%BC%9A%E7%9F%A9%E5%BD%A2%E8%A6%86%E7%9B%96/"/>
    <id>https://zofun.github.io/2020/03/29/算法：矩形覆盖/</id>
    <published>2020-03-29T03:08:00.000Z</published>
    <updated>2020-03-29T03:08:59.150Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="题目描述">题目描述</span></h2><p>我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？ </p><p><a href="https://www.nowcoder.com/practice/72a5a919508a4251859fb2cfb987a0e6?tpId=13&amp;tqId=11163&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">牛客网在线测试</a></p><a id="more"></a><h2><span id="解题思路">解题思路</span></h2><p>当n为1时，只有一种覆盖方法；当n为2 时，有两种覆盖方法；可以先覆盖 2*1 的矩形，再覆盖 2*(n-1) 的矩形；或者先覆盖 2*2 的矩形，再覆盖 2*(n-2)<br>的矩形。而覆盖 2*(n-1) 和 2*(n-2) 的矩形可以看成子问题。</p><p><img src="https://s1.ax1x.com/2020/03/29/GE4hUs.png" alt="GE4hUs.png"></p><h2><span id="解题代码">解题代码</span></h2><ol><li>递归写法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">RectCover</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target&lt;=<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> target;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> RectCover(target-<span class="number">1</span>)+RectCover(target-<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>非递归写法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">RectCover</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> pre2 = <span class="number">1</span>, pre1 = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            result = pre2 + pre1;</span><br><span class="line">            pre2 = pre1;</span><br><span class="line">            pre1 = result;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？ &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.nowcoder.com/practice/72a5a919508a4251859fb2cfb987a0e6?tpId=13&amp;amp;tqId=11163&amp;amp;tPage=1&amp;amp;rp=1&amp;amp;ru=/ta/coding-interviews&amp;amp;qru=/ta/coding-interviews/question-ranking&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;牛客网在线测试&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="https://zofun.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Java" scheme="https://zofun.github.io/tags/Java/"/>
    
      <category term="算法" scheme="https://zofun.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法:用两个栈实现队列</title>
    <link href="https://zofun.github.io/2020/03/29/%E7%AE%97%E6%B3%95%EF%BC%9A%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
    <id>https://zofun.github.io/2020/03/29/算法：用两个栈实现队列/</id>
    <published>2020-03-29T02:21:00.000Z</published>
    <updated>2020-03-29T02:22:00.576Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="题目描述">题目描述</span></h2><p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p><p><a href="https://www.nowcoder.com/practice/54275ddae22f475981afa2244dd448c6?tpId=13&amp;tqId=11158&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">牛客网在线测试</a></p><a id="more"></a><h2><span id="解题思路">解题思路</span></h2><p>我们使用两个栈，in栈用来处理入栈操作，out栈用来处理出栈操作。一个元素进入in栈之后，出栈的顺序被反转，当元素需要出栈的时候，需要先进入out栈，此时元素出栈顺序再次反转，这样就和队列出栈的顺序一致了。</p><h2><span id="解题代码">解题代码</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;Integer&gt; in = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">   Stack&lt;Integer&gt; out = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       in.push(node);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(out.isEmpty())&#123;</span><br><span class="line">           <span class="keyword">while</span> (!in.isEmpty())&#123;</span><br><span class="line">               <span class="comment">//将in栈中的数据，加入到out栈，此时out栈的顺序就是出队列顺序</span></span><br><span class="line">               out.push(in.pop());</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(out.isEmpty())&#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"队列空"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> out.pop();</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.nowcoder.com/practice/54275ddae22f475981afa2244dd448c6?tpId=13&amp;amp;tqId=11158&amp;amp;tPage=1&amp;amp;rp=1&amp;amp;ru=/ta/coding-interviews&amp;amp;qru=/ta/coding-interviews/question-ranking&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;牛客网在线测试&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="https://zofun.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Java" scheme="https://zofun.github.io/tags/Java/"/>
    
      <category term="算法" scheme="https://zofun.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
