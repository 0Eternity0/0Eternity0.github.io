<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>个人博客</title>
  
  <subtitle>博观而约取 厚积而薄发</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-03-11T13:47:52.752Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>爱写代码的小书童</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MySQL索引</title>
    <link href="http://yoursite.com/2020/03/11/MySQL%E7%B4%A2%E5%BC%95/"/>
    <id>http://yoursite.com/2020/03/11/MySQL索引/</id>
    <published>2020-03-11T13:47:00.000Z</published>
    <updated>2020-03-11T13:47:52.752Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="索引的类型">索引的类型</span></h2><p>因为索引是在存储引擎层实现的，索引并没有统一的索引标准，不同的存储引擎的索引的工作方式并不一样，也不是所有的存储引擎都支持所有类型的索引。</p><h3><span id="b-tree索引">B-Tree索引</span></h3><p>B-Tree索引底层使用的是B+树。存储引擎以不同的方式使用B-Tree索引，性能也各有不同，例如MyISAM使用前缀压缩计数使得索引更小，当InnoDB则按照原数据格式进行存储。再如MyISAM索引通过数据的物理位置引用被索引的行，而InnoDB则根据主键引用被索引的行。</p><p>B-Tree索引通常意味着所有的值都是按顺序存储的，并且每个叶子页到根的距离相同。B-Tree索引能够加快访问数据的速度，因为存储引擎不再需要进行全表扫描来获取需要的数据，取而代之的是从索引的根节点开始进行搜索。</p><a id="more"></a><h3><span id="哈希索引">哈希索引</span></h3><p>哈希索引基于哈希表实现的，只有精确匹配索引所有列的查询才有效。对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码，哈希码是一个较小的只，并且不同键值的行计算出来的哈希码也不一样。哈希索引键所有的哈希码存储在索引中，同时在哈希表中保持指向每隔个数据行的指针。</p><p>在使用哈希索引的时候也有许多的限制：</p><ul><li>哈希索引只包含哈希值和行指针，而不存储字段值，所以不能使用哦索引中的值来避免回表的。</li><li>哈希索引的数据并不是按索引值顺序排序的，所以也就无法用于排序。</li><li>哈希索引也不支持部分索引列匹配查找，因为哈希索引始终是使用索引列的全部内容来计算哈希值的。</li><li>哈希索引只支持等值比较查询。</li><li>访问哈希索引的数据非常的块，除非有很多哈希冲突。当出现哈希冲突后会遍历链表中所有的行指针，逐行进行比较。</li><li>如果哈希冲突很多的话，一些索引维护操作的代价会非常的高。</li></ul><h3><span id="空间数据索引r-tree">空间数据索引（R-Tree）</span></h3><p>MyISAM表支持空间索引，可以用作地理数据存储。这类索引无需前缀查询。</p><h3><span id="全文索引">全文索引</span></h3><p>全文索引是一种特殊类型的索引，它查找的是文本中的关键词，而不是直接比较索引中的值。</p><h2><span id="索引的优点">索引的优点</span></h2><p>总结下来索引有如下三个优点：</p><ol><li>索引大大减少了服务需要扫描的数据量</li><li>索引可以大大帮助服务器避免排序和临时表</li><li>索引可以将随机IO变为排序IO。</li></ol><h2><span id="高性能的索引策略">高性能的索引策略</span></h2><h3><span id="索引列不能是表达式的一部分也不能是函数的参数">索引列不能是表达式的一部分，也不能是函数的参数</span></h3><p>当索引列作为表达式的一部分或者函数的参数的时候，MySQL就不会使用该索引列了。</p><h3><span id="前缀索引和索引选择性">前缀索引和索引选择性</span></h3><p>前缀索引是一种使索引更小、更快的有效办法。选择足够长的前缀以保证较高的选择性，同时又不能太长，前缀应该足够长，以使得前缀索引的选择性接近于索引整个列。</p><h3><span id="多列索引">多列索引</span></h3><p>多列索引要注意设置合适的顺序，正确的顺序依赖于使用该索引的查询，并且同时需要考虑如何更好的满足排序和分组的需要。</p><h3><span id="聚簇索引">聚簇索引</span></h3><p>聚簇索引并不是一种单独的索引类型，而是一种数据存储方式。具体的细节依赖于其实现方式，但InnoDB的聚簇索引实际上在同一个结构中保持了B-Tree索引和数据行。当表又聚簇索引使，它的数据行实际上存放在索引的叶子页中。</p><h3><span id="覆盖索引">覆盖索引</span></h3><p>覆盖索引是非常有用的工具，能够极大地提高性能。合理地使用覆盖索引可以使得查询只扫描索引而无须回表。</p><p>它主要有这些好处：</p><ul><li>索引条目地大小是小于数据行地大小地，索引如果只需要读取索引，那么MySQL就回极大地减少数据访问量。</li><li>因为索引是按照列值顺序存储地，索引对于IO密集型地访问查询会比随机从磁盘读取每一行数据的IO要少得多。</li><li>一些存储引擎入MyISAM在内存中只缓存索引，数据则依赖于操作系统来缓存，因此要访问数据需要一次系统调用。</li><li>对于InnoDB的聚簇索引，覆盖索引对于InnoDB表特别有用，InnoDB的二级索引在叶子节点中保存了行的主键值，所以如果二级主键能够覆盖索引，则可以避免对主键索引的二次查询。</li></ul><h3><span id="使用索引扫描来做排序">使用索引扫描来做排序</span></h3><p>MySQL有两种方式可以生成有序的结果：通过排序操作，或者按索引顺序烧苗。扫描索引本身是很快的，因为只需要从一条索引记录移动到紧接着的下一条记录。但是如果索引不能覆盖查询所需的全部列，那就不得不每扫描一条索引记录就都回表查询一次对应的行。这基本都是随机IO，因此按索引顺序读取数据的数据通常要比顺序地全表扫描慢，尤其是在IO密集型地工作负载时。</p><p>只有当索引地列顺序和Order by子句地顺序完全一致，并且所有列地排序方式都一样时，MySQL才能够使用索引来对结果进行排序。如果查询需要关联多张表，则只有当order by子句引用地字段全部为第一个表时，才能使用索引做排序。</p><h3><span id="压缩前缀压缩索引">压缩（前缀压缩）索引</span></h3><p>MyISAM使用前缀压缩来减少索引的大小，从而让更多的索引可以放入内存，这在某些情况下能极大地提高性能。默认只压缩字符串，但通过参数设置也可以对整数进行压缩。压缩块使用更少地空间，代价时某些操作可能更慢。因为每个值得压缩前缀都依赖于前面得值，索引MyISAM查找时无法在索引块使用二分查找而只能从头开始扫描。</p><h3><span id="冗余和重复索引">冗余和重复索引</span></h3><p>MySQL运行在相同列上创建多个索引，无论是有意得还是无意得。MySQL需要单独维护重复得索引，并且优化器在优化查询得时候也需要逐个地进行考虑，这会影响性能。</p><p>重复索引是指在相同地列上按照相同的顺序创建相同类型的索引。应该避免这样创建重复索引，发现后应该立即移除。</p><p>大多数情况下都不需要冗余索引，应该尽量扩展已有的索引而不是创建新索引。但也有时候出于性能方面的考虑需要冗余索引，因为拓展已有的索引会导致其变得太大，从而影响其它使用该索引的查询的性能。</p><h3><span id="未使用的索引">未使用的索引</span></h3><p>服务器永远不用的索引，应该被删除。</p><h3><span id="索引和锁">索引和锁</span></h3><p>索引可以让查询锁定更少的行，如果查询从不访问那些不需要的行，那么就会锁定更少的行，从这两方面来看对性能都有好处。首先，虽然InnoDB的行锁效率很高，内存使用也很少，但是锁定行的时候仍然会带来额外开销；其次，锁定超过需要的行会增加锁争用并减少并发性。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;索引的类型&quot;&gt;&lt;a href=&quot;#索引的类型&quot; class=&quot;headerlink&quot; title=&quot;索引的类型&quot;&gt;&lt;/a&gt;索引的类型&lt;/h2&gt;&lt;p&gt;因为索引是在存储引擎层实现的，索引并没有统一的索引标准，不同的存储引擎的索引的工作方式并不一样，也不是所有的存储引擎都支持所有类型的索引。&lt;/p&gt;
&lt;h3 id=&quot;B-Tree索引&quot;&gt;&lt;a href=&quot;#B-Tree索引&quot; class=&quot;headerlink&quot; title=&quot;B-Tree索引&quot;&gt;&lt;/a&gt;B-Tree索引&lt;/h3&gt;&lt;p&gt;B-Tree索引底层使用的是B+树。存储引擎以不同的方式使用B-Tree索引，性能也各有不同，例如MyISAM使用前缀压缩计数使得索引更小，当InnoDB则按照原数据格式进行存储。再如MyISAM索引通过数据的物理位置引用被索引的行，而InnoDB则根据主键引用被索引的行。&lt;/p&gt;
&lt;p&gt;B-Tree索引通常意味着所有的值都是按顺序存储的，并且每个叶子页到根的距离相同。B-Tree索引能够加快访问数据的速度，因为存储引擎不再需要进行全表扫描来获取需要的数据，取而代之的是从索引的根节点开始进行搜索。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>JDK8新特性详解</title>
    <link href="http://yoursite.com/2020/03/09/JDK8%E6%96%B0%E7%89%B9%E6%80%A7%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2020/03/09/JDK8新特性详解/</id>
    <published>2020-03-09T13:37:00.000Z</published>
    <updated>2020-03-09T13:37:35.281Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="jdk8新特性详解">JDK8新特性详解</span></h2><p>JDK8主要引入了这些新特性：</p><ol><li>接口的默认实现</li><li>Lambda表达式</li><li>函数式接口</li><li>方法与构造函数引用</li><li>内置了许多函数式接口</li><li>Stream流</li></ol><a id="more"></a><h3><span id="接口的默认实现">接口的默认实现</span></h3><p>jdk8允许我们给接口添加一个非抽象的方法实现，只需要使用default关键字接口，这个特性又叫做拓展方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Formula</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">double</span> <span class="title">sqrt</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.sqrt(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个接口同时定义了两个方法<code>calculate</code>和<code>sqrt</code>.只不过<code>sqrt</code>方法拥有自己的默认实现。</p><h3><span id="lambda表达式">Lambda表达式</span></h3><p>在老版本中我们对一个list进行排序，我们一般需要这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; names = Arrays.asList(<span class="string">"peter"</span>, <span class="string">"anna"</span>, <span class="string">"mike"</span>, <span class="string">"xenia"</span>);</span><br><span class="line"></span><br><span class="line">Collections.sort(names, <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b.compareTo(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>通过JDK8之后提供的Lambda表达式，可以避免使用匿名对象，可以这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(names, (String a, String b) -&gt; b.compareTo(a));</span><br><span class="line"><span class="comment">//编译器可以自动推导参数类型，所以我们甚至不需要写参数类型</span></span><br><span class="line">Collections.sort(names, (a, b) -&gt; b.compareTo(a));</span><br></pre></td></tr></table></figure><p>Lambda的访问外层作用域与匿名对象类类似。可以直接访问标记了final的外层局部变量或者实例的字段以及静态变量。</p><h3><span id="函数式接口">函数式接口</span></h3><p>所谓的函数式接口是指有且仅有一个抽象方法的接口。</p><p>函数式接口的写法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyFunctionalInterface</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myMethod</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数式接口的典型使用场景就是作为方法的参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FunctionalInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数式接口作为方法参数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(MyFunctionalInterface inter)</span> </span>&#123;</span><br><span class="line">inter.myMethod(); <span class="comment">// 调用自定义的函数式接口方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//调用使用函数式接口的方法</span></span><br><span class="line">doSomething(() ‐&gt; System.out.println(<span class="string">"Lambda执行啦！"</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="方法与构造函数引用">方法与构造函数引用</span></h3><p>假如我们又这样一个函数式接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IConvert</span>&lt;<span class="title">F</span>,<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将F类型转换成T类型</span></span><br><span class="line"><span class="function">T <span class="title">convert</span><span class="params">(F from)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以这样使用这个新特性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IConvert&lt;String, Integer&gt; convertor = (from) -&gt; ( Integer.parseInt(from));</span><br><span class="line"><span class="comment">//简化写法</span></span><br><span class="line">IConvert&lt;String, Integer&gt; convertor = Integer::parseInt;</span><br></pre></td></tr></table></figure><p>还可以引用对象的方法；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyObject obj=<span class="keyword">new</span> MyObject();</span><br><span class="line">IConvert&lt;String,String&gt; convertor=something::startWith;</span><br></pre></td></tr></table></figure><p>还可以引用构造函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">PersonFactory</span>&lt;<span class="title">P</span> <span class="keyword">extends</span> <span class="title">Person</span>&gt;</span>&#123;</span><br><span class="line"><span class="function">P <span class="title">create</span><span class="params">(String firstName, String lastName)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以通过引用构造函数实现工厂类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PersonFactory&lt;Person&gt; factory = Person::<span class="keyword">new</span>;</span><br><span class="line">Person p = factory.create(<span class="string">"zhuge"</span>, <span class="string">"xx"</span>);</span><br></pre></td></tr></table></figure><h3><span id="内置函数式接口">内置函数式接口</span></h3><p>JDK8中内置了许多函数式接口，包括Comparator和Runnable等，它们被添加了@FunctionalNterface注解，以用来支持Lambda表示式。</p><h3><span id="stream流">Stream流</span></h3><p>Stream流提供了一种对集合Collection的方便的操作。</p><h4><span id="filter过滤">Filter过滤</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">"hello"</span>,<span class="string">"world"</span>,<span class="string">"apple"</span>,<span class="string">"people"</span>,<span class="string">"sea"</span>,</span><br><span class="line">                                  <span class="string">"watch"</span>,<span class="string">"table"</span>,<span class="string">"book"</span>,<span class="string">"school"</span>,<span class="string">"help"</span>);</span><br><span class="line">list</span><br><span class="line">    .stream() <span class="comment">//获取stream</span></span><br><span class="line">    .filter(s -&gt; s.startsWith(<span class="string">"s"</span>))  <span class="comment">//设置filter。中间操作</span></span><br><span class="line">    .forEach(System.out::println);   <span class="comment">//打印出流中的元素。终端操作</span></span><br></pre></td></tr></table></figure><h4><span id="sorted排序">Sorted排序</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list</span><br><span class="line">    .stream()</span><br><span class="line">    .sorted((a,b) -&gt; b.compareTo(a))</span><br><span class="line">    .forEach(System.out::println);</span><br></pre></td></tr></table></figure><h4><span id="map">Map</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">"10"</span>,<span class="string">"100"</span>,<span class="string">"1000"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"---- test map ----"</span>);</span><br><span class="line">list</span><br><span class="line">    .stream()</span><br><span class="line">    .map(Integer::valueOf)  <span class="comment">//转换为整数</span></span><br><span class="line">    .map(a -&gt; a + <span class="number">1</span>)        <span class="comment">//执行加一操作</span></span><br><span class="line">    .forEach(System.out::println);</span><br></pre></td></tr></table></figure><h4><span id="match匹配">Match匹配</span></h4><p>这是一种终端操作，姐u共不是stream对象，而是boolean值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">anyMatch</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">allMatch</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">noneMatch</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate)</span></span>;</span><br></pre></td></tr></table></figure><h4><span id="count计数">Count计数</span></h4><p>这是一种终端操作，用来统计stream中元素的个数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> count = </span><br><span class="line">    list</span><br><span class="line">        .stream() <span class="comment">//获取stream</span></span><br><span class="line">        .filter(s -&gt; s.startsWith(<span class="string">"s"</span>))  <span class="comment">//设置filter。中间操作</span></span><br><span class="line">        .count();</span><br></pre></td></tr></table></figure><h4><span id="reduce">Reduce</span></h4><p>list[0]和list[1]执行操作，得到的结果为result。result再和list[2]执行操作，得到的结果result。依次进行，对所有元素执行一遍.根据上述描述也可以看出，这里的“操作”必须满足两个入参、返回值是同一类型的</p><p>比如求和：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"---- test reduce ----"</span>);</span><br><span class="line">Optional&lt;Integer&gt; sum = </span><br><span class="line">    list</span><br><span class="line">        .stream()</span><br><span class="line">        .reduce((a,b) -&gt; a + b);</span><br><span class="line"></span><br><span class="line">sum.ifPresent(System.out::println);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;JDK8新特性详解&quot;&gt;&lt;a href=&quot;#JDK8新特性详解&quot; class=&quot;headerlink&quot; title=&quot;JDK8新特性详解&quot;&gt;&lt;/a&gt;JDK8新特性详解&lt;/h2&gt;&lt;p&gt;JDK8主要引入了这些新特性：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;接口的默认实现&lt;/li&gt;
&lt;li&gt;Lambda表达式&lt;/li&gt;
&lt;li&gt;函数式接口&lt;/li&gt;
&lt;li&gt;方法与构造函数引用&lt;/li&gt;
&lt;li&gt;内置了许多函数式接口&lt;/li&gt;
&lt;li&gt;Stream流&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal源码分析</title>
    <link href="http://yoursite.com/2020/03/07/ThreadLocal%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2020/03/07/ThreadLocal源码分析/</id>
    <published>2020-03-07T03:16:00.000Z</published>
    <updated>2020-03-07T03:20:58.436Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="threadlocal是什么">ThreadLocal是什么？</span></h2><p>ThreadLoal 变量，线程局部变量，同一个 ThreadLocal 所包含的对象，在不同的 Thread 中有不同的副本。这里有几点需要注意：</p><ul><li>因为每个 Thread 内有自己的实例副本，且该副本只能由当前 Thread 使用。这是也是 ThreadLocal 命名的由来。</li><li>既然每个 Thread 有自己的实例副本，且其它 Thread不可访问，那就不存在多线程间共享的问题。</li></ul><a id="more"></a><h2><span id="threadlocal实现原理">ThreadLocal实现原理</span></h2><h3><span id="set方法的实现">set方法的实现</span></h3><p>在使用ThreadLocal的时候，用的最多的就是get和set两个方法。我们就先从set入手来分析ThreadLocal的实现原理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line"><span class="comment">//获取当前线程</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">//尝试获取当前线程的threadLocals</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="comment">//如果当前线程的threadLocals不为空，就直接设值</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="comment">//否则为当前线程设置threadLocals</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法中我们首先需要注意的一点就是<code>getMap(t)</code>方法。<br>它的实现就一行代码<code>return t.threadLocals;</code>就是获取当前Thread对象的一个threadLocal属性。</p><p>在Thread类中有这么一个属性：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure></p><p>这里的<code>ThreadLocal.ThreadLocalMap</code>就是ThreadLocal中的一个静态内部类。<br>从这里我们也可以看出，<strong>ThreadLocal每个线程的变量副本并不是存在ThreadLocal中的，而是存在线程对象（Thread）中的。</strong></p><p>尝试直接从当前Thread对象中直接获取失败之后，就会执行<code>createMap(t, value);</code>方法，这个方法的具体实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line"><span class="comment">//创建一个ThreadLocalMap对象，交由Thread对象的threadLocals属性保存</span></span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里再一次印证了我们的结论。</p><p>现在我们基本清楚了ThreadLocal是如何为每个Thread维护变量副本的了，ThreadLocal实际上只充当了中间人的角色，实际上变量副本的存储是由每个线程本身完成的。</p><h3><span id="get方法的实现">get方法的实现</span></h3><p>下面我们来分析一下get方法的实现。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//拿到当前线程</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">//尝试获取线程对象中的threadLocal属性</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//尝试从该线程对象的threadLocal属性中取值</span></span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//却遇到值了，就完成类型转换，并返回</span></span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//没有取到，就返回初始值。</span></span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过代码不难看出，get方法就是简简单单的从Thread对象中取值，如果取到了就返回，没取到就返回初始值。</p><h3><span id="threadlocalmap源码分析">ThreadLocalMap源码分析</span></h3><p>通过对set、get方法的源码分析，我们可以清楚的知道，每个线程的变量副本实际上是由线程对象本身通过一个ThreadLocalMap对象存储的。而ThreadLocalMap是ThreadLocal中的一个静态内部类。想要搞清楚整个原理，这个ThreadLocalMap的实现就是绕不开的。那么下面，我们来看一下它的内部实现。</p><p>TreadLocalMap本质上也是一个Map，那么我们首先看一下它的节点类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    Object value;</span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果熟悉HashMap源码的同学可能就已经看出不同来了，这个Entry继承自WeakReference。这里的<code>WeakReference&lt;ThreadLocal&lt;?&gt;&gt;</code>,<code>ThreadLocal</code>就是弱引用对象，如果<code>ThreadLocal</code>对象没有被任何强引用指向时，一旦发生GC无论内存空间是否足够，都会被回收。</p><p>既然是Map，那么我们就从set和get方法来入手来分析一下这个Map和我们熟悉的HashMap等有什么区别。</p><p>下面我们就来看一个set方法的具体实现；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            <span class="keyword">int</span> len = tab.length;</span><br><span class="line">     <span class="comment">//计算索引</span></span><br><span class="line">            <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">                 e != <span class="keyword">null</span>;</span><br><span class="line">                 e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">                <span class="comment">//如果索引位置已被占，就往后找位置（线性探测法）</span></span><br><span class="line">                ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"><span class="comment">//如果table[i]上的key不为空，并且和当前key相同，更新value</span></span><br><span class="line">                <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">                    </span><br><span class="line">                    e.value = value;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">/*如果table[i]上的key为空，说明已经弱引用对象</span></span><br><span class="line"><span class="comment">                    ThreadLocal被回收了，这个地方就可以重新使用了</span></span><br><span class="line"><span class="comment">                    重新设置key（ThreadLocal），替换掉value</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                    replaceStaleEntry(key, value, i);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//找到为空的位置。插入节点</span></span><br><span class="line">            tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">     <span class="comment">//更新容量       </span></span><br><span class="line">     <span class="keyword">int</span> sz = ++size;</span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">     cleanSomeSlots(i, sz)用于回收那些key已经被回收了的节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">            <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">                <span class="comment">//如果负载因子达到了所定义地址，那么进行rehash</span></span><br><span class="line">                rehash();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p><code>rehash</code>是每个Map必须要分析的方法，那么我们看一下ThreadLocalMap是如何<code>rehash</code>的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//清理所有无效的entry，即key被回收了的entry</span></span><br><span class="line">           expungeStaleEntries();</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果清理后，还size依然大于掉地了的阈值，则进行扩容</span></span><br><span class="line">           <span class="keyword">if</span> (size &gt;= threshold - threshold / <span class="number">4</span>)</span><br><span class="line">               resize();</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>下面我们重点看一下，<code>resieze</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entry[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldLen = oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> newLen = oldLen * <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//新申请一个长度为原来两倍的entry数组</span></span><br><span class="line">    Entry[] newTab = <span class="keyword">new</span> Entry[newLen];</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldLen; ++j) &#123;</span><br><span class="line">        Entry e = oldTab[j];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">                e.value = <span class="keyword">null</span>; <span class="comment">// Help the GC</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (newLen - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">while</span> (newTab[h] != <span class="keyword">null</span>)</span><br><span class="line">                    h = nextIndex(h, newLen);</span><br><span class="line">                newTab[h] = e;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setThreshold(newLen);</span><br><span class="line">    size = count;</span><br><span class="line">    table = newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的逻辑还是比较清晰的。新建一个长度为原先两倍的Entry数组，然后把旧数组中的数据重新计算索引后放入新的Entry数组。</p><p>看完了ThreadLocalMap是如何存的，下面我们就来分析一下，ThreadLocalmap是如何取得。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//计算索引</span></span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">  </span><br><span class="line">    Entry e = table[i];</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">        <span class="comment">//取到了，直接返回</span></span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//通过key计算出得直接索引找到不value得时候</span></span><br><span class="line">        <span class="comment">//调用这个方法</span></span><br><span class="line">        <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>取到了直接返回，没取了就调用了<code>getEntryAfterMiss</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntryAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key, <span class="keyword">int</span> i, Entry e)</span> </span>&#123;</span><br><span class="line">           Entry[] tab = table;</span><br><span class="line">           <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">               ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">               <span class="keyword">if</span> (k == key)</span><br><span class="line">                   <span class="keyword">return</span> e;</span><br><span class="line">               <span class="keyword">if</span> (k == <span class="keyword">null</span>)</span><br><span class="line">                   <span class="comment">//清楚无效得entry</span></span><br><span class="line">                   expungeStaleEntry(i);</span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">                   <span class="comment">//基于线性探测法向后扫描</span></span><br><span class="line">                   i = nextIndex(i, len);</span><br><span class="line">               e = tab[i];</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>到此，我们清楚了ThreadLocalMap是如何工作的了。</p><h2><span id="threadlocal可能引起的内存泄露">ThreadLocal可能引起的内存泄露</span></h2><p>刚才我们分析了ThreadLocalMap，我们知道这个Map的key是一个弱引用对象，当没有强引用指向这个作为key的弱引用对象之后，它会被下一次gc回收掉，失去了key，我们就无法再访问Map中的value了，但是value却不会被回收，因为存在一条current thread连接过来的强引用，只有当前thread结束以后，强引用才会断开，这个时候Current Thread，Map，value才会被GC回收。</p><p><img src="F:\学习资料\笔记\ThreadLocal源码分析.assets\3OHz7V.png" alt="示意图"></p><p>在之前的源码分析的时候，我们也看到了在get，set等方法中都清除了ThreadLocalMap中所有key为null的value。一定程度上缓解了内存泄漏的风险，但是这些被动的预防措施不能确保不发生内存泄漏。</p><p>而且很多时候使用static修饰ThreadLocal延长ThreadLocal的生命周期，可能导致内存泄漏。但是我们也不能说用static修饰ThreadLocal就不好，其实用static修饰还是有好处的，它可以避免重复创建等同的对象。</p><p>我们在使用的时候，一定要注意调用remove方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;ThreadLocal是什么？&quot;&gt;&lt;a href=&quot;#ThreadLocal是什么？&quot; class=&quot;headerlink&quot; title=&quot;ThreadLocal是什么？&quot;&gt;&lt;/a&gt;ThreadLocal是什么？&lt;/h2&gt;&lt;p&gt;ThreadLoal 变量，线程局部变量，同一个 ThreadLocal 所包含的对象，在不同的 Thread 中有不同的副本。这里有几点需要注意：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;因为每个 Thread 内有自己的实例副本，且该副本只能由当前 Thread 使用。这是也是 ThreadLocal 命名的由来。&lt;/li&gt;
&lt;li&gt;既然每个 Thread 有自己的实例副本，且其它 Thread不可访问，那就不存在多线程间共享的问题。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Netty启动流程分析</title>
    <link href="http://yoursite.com/2020/03/06/Netty%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2020/03/06/Netty启动流程分析/</id>
    <published>2020-03-06T09:46:00.000Z</published>
    <updated>2020-03-06T09:47:36.922Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="示例代码">示例代码</span></h2><p>我们就以下面这段代码为例，来分析一个Netty是如何启动的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//负责接收客户端连接</span></span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//负责网络读写</span></span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap bootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            bootstrap.group(bossGroup,workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    ChannelPipeline pipeline = socketChannel.pipeline();</span><br><span class="line">                    <span class="comment">//http编解码器</span></span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> HttpServerCodec());</span><br><span class="line">                    <span class="comment">//自定义的handler</span></span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> HttpServerHandler());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> ChannelFuture future = bootstrap.bind(<span class="number">3333</span>).sync();</span><br><span class="line">            future.channel().closeFuture().sync();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这段代码我们首先创建了两个EventLoopGroup。然后创建了<code>ServerBootstrap</code>并设置设置了一系列的属性。然后调用了<code>bind</code>方法完成了服务器的启动。所以要分析Netty服务端的启动过程就需要从<code>bind</code>方法入手。</p><a id="more"></a><h2><span id="启动流程分析">启动流程分析</span></h2><p>从<code>bind</code>方法来查看整个启动的流程：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">bind</span><span class="params">(<span class="keyword">int</span> inetPort)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bind(<span class="keyword">new</span> InetSocketAddress(inetPort));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">bind</span><span class="params">(SocketAddress localAddress)</span> </span>&#123;</span><br><span class="line"><span class="comment">/*启动前的检测，检测EventLoopGroup是否已经设置，</span></span><br><span class="line"><span class="comment">ChannelFactory是否已经设置。否则抛出异常*/</span></span><br><span class="line">    validate();</span><br><span class="line">    <span class="keyword">return</span> doBind(ObjectUtil.checkNotNull(localAddress, <span class="string">"localAddress"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>bind</code>方法，首先进行了启动前的检查，然后调用<code>doBind</code>方法开始真正的服务端启动。<br>那么，下面我们来看<code>doBind</code>方法的具体实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ChannelFuture <span class="title">doBind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始化并注册一个Channel，</span></span><br><span class="line">    <span class="keyword">final</span> ChannelFuture regFuture = initAndRegister();</span><br><span class="line">    <span class="keyword">final</span> Channel channel = regFuture.channel();</span><br><span class="line">    <span class="keyword">if</span> (regFuture.cause() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> regFuture;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//注册成功</span></span><br><span class="line">    <span class="keyword">if</span> (regFuture.isDone()) &#123;</span><br><span class="line">        <span class="comment">// At this point we know that the registration was complete and successful.</span></span><br><span class="line">        ChannelPromise promise = channel.newPromise();</span><br><span class="line">        <span class="comment">//调用doBind0进行绑定</span></span><br><span class="line">        doBind0(regFuture, channel, localAddress, promise);</span><br><span class="line">        <span class="keyword">return</span> promise;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Registration future is almost always fulfilled already, but just in case it's not.</span></span><br><span class="line">        <span class="keyword">final</span> PendingRegistrationPromise promise = <span class="keyword">new</span> PendingRegistrationPromise(channel);</span><br><span class="line">        regFuture.addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                Throwable cause = future.cause();</span><br><span class="line">                <span class="keyword">if</span> (cause != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// Registration on the EventLoop failed so fail the ChannelPromise directly to not cause an</span></span><br><span class="line">                    <span class="comment">// IllegalStateException once we try to access the EventLoop of the Channel.</span></span><br><span class="line">                    promise.setFailure(cause);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Registration was successful, so set the correct executor to use.</span></span><br><span class="line">                    <span class="comment">// See https://github.com/netty/netty/issues/2586</span></span><br><span class="line">                    promise.registered();</span><br><span class="line"></span><br><span class="line">                    doBind0(regFuture, channel, localAddress, promise);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> promise;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个方法主要做了这些事情：</p><ol><li>调用<code>initAndRegister()</code>拿到一个ChannelFuture对象regFuture</li><li>根据<code>regFuture</code>判断该对象是否抛出异常，如果是，直接返回</li><li>根据<code>regFuture</code>判断<code>initAndRegister</code>是否执行完毕，如果执行完毕，则调用<code>doBind0</code></li><li>如果<code>initAndRegister</code>没有执行完毕，就会对regFuture对象添加一个<code>ChannelFutureListener</code>来监听<code>initAndRegister</code>执行完毕的事件，一旦执行完毕，就会和2，3步骤一样进行异常判断和调用<code>doBind0</code>。</li></ol><p>看完这个方法的实现，我们有两个大大的疑问，<code>initAndRegister()</code>到底干了什么事情，<code>doBind0</code>又干了什么事情。<br>下面我们就来探究这两个问题：</p><p>我们首先来看一看<code>initAndRegister</code>方法的底层实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> ChannelFuture <span class="title">initAndRegister</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Channel channel = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//新建一个Channel</span></span><br><span class="line">        channel = channelFactory.newChannel();</span><br><span class="line">        <span class="comment">//初始化新建的Channel</span></span><br><span class="line">        init(channel);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="keyword">if</span> (channel != <span class="keyword">null</span>) &#123;</span><br><span class="line">            channel.unsafe().closeForcibly();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> DefaultChannelPromise(channel, GlobalEventExecutor.INSTANCE).setFailure(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DefaultChannelPromise(<span class="keyword">new</span> FailedChannel(), GlobalEventExecutor.INSTANCE).setFailure(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向EventLoopGroup中注册一个channel</span></span><br><span class="line">    ChannelFuture regFuture = config().group().register(channel);</span><br><span class="line">    <span class="keyword">if</span> (regFuture.cause() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (channel.isRegistered()) &#123;</span><br><span class="line">            channel.close();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            channel.unsafe().closeForcibly();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> regFuture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>整个方法主要完成两件事情：</p><ol><li>新建一个channel</li><li>向EventLoopGroup中注册channel。</li></ol><p>我们在初始化<code>ServerBootstrap</code>的时候有这么一行代码<code>.channel(NioServerSocketChannel.class)</code><br>新建channe就是利用反射实例化了我们设置的channel类。</p><p>注册channel的过程也值得我们注意：<br><code>ChannelFuture regFuture = config().group().register(channel);</code><br><code>group()</code>方法返回的是前面的<code>boss NioEvenLoopGroup</code>,它继承自<code>MultithreadEventLoopGroup</code>,这里所调用的<code>register</code>也是<code>MultithreadEventLoopGroup</code>中的方法。<br>具体实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">register</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*next方法从EventLoopGroup中获取下一个EventLoop*/</span></span><br><span class="line">    <span class="keyword">return</span> next().register(channel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">register</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> register(<span class="keyword">new</span> DefaultChannelPromise(channel, <span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">register</span><span class="params">(<span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    ObjectUtil.checkNotNull(promise, <span class="string">"promise"</span>);</span><br><span class="line">    <span class="comment">//拿到channel的unsafe对象，进行注册</span></span><br><span class="line">    promise.channel().unsafe().register(<span class="keyword">this</span>, promise);</span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(EventLoop eventLoop, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (eventLoop == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"eventLoop"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isRegistered()) &#123;</span><br><span class="line">        promise.setFailure(<span class="keyword">new</span> IllegalStateException(<span class="string">"registered to an event loop already"</span>));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//首先判断是否已经注册</span></span><br><span class="line">    <span class="keyword">if</span> (!isCompatible(eventLoop)) &#123;</span><br><span class="line">        promise.setFailure(</span><br><span class="line">                <span class="keyword">new</span> IllegalStateException(<span class="string">"incompatible event loop type: "</span> + eventLoop.getClass().getName()));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AbstractChannel.<span class="keyword">this</span>.eventLoop = eventLoop;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//确保注册是由当前的EventLoop发起的</span></span><br><span class="line">    <span class="keyword">if</span> (eventLoop.inEventLoop()) &#123;</span><br><span class="line">    <span class="comment">//注册</span></span><br><span class="line">        register0(promise);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//如果注册不是当前EventLoop发起的，</span></span><br><span class="line">    <span class="comment">//就封装成一个task异步执行</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            eventLoop.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    register0(promise);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            logger.warn(</span><br><span class="line">                    <span class="string">"Force-closing a channel whose registration task was not accepted by an event loop: &#123;&#125;"</span>,</span><br><span class="line">                    AbstractChannel.<span class="keyword">this</span>, t);</span><br><span class="line">            closeForcibly();</span><br><span class="line">            closeFuture.setClosed();</span><br><span class="line">            safeSetFailure(promise, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法的过程如下：</p><ol><li>首先判断该channel是否已经注册到EventLoop中</li><li>判断当前当前线程是否未该EventLoop发起的，如果是，则调用<code>register0</code>直接进行注册。</li><li>如果不是，则说明该EventLoop中的线程此时没有执行全，则需要新建一个线程，单独封装一个task，而这个task的主要任务也是调用<code>register0</code></li></ol><p>下面我们就来分析一下<code>register0</code>的具体实现；<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">register0</span><span class="params">(ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//确保channel处于open状态</span></span><br><span class="line">            <span class="keyword">if</span> (!promise.setUncancellable() || !ensureOpen(promise)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">boolean</span> firstRegistration = neverRegistered;</span><br><span class="line">            <span class="comment">//真正的注册</span></span><br><span class="line">            doRegister();</span><br><span class="line">            neverRegistered = <span class="keyword">false</span>;</span><br><span class="line">            registered = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            pipeline.invokeHandlerAddedIfNeeded();</span><br><span class="line">            <span class="comment">//设置注册的结果为成功</span></span><br><span class="line">            safeSetSuccess(promise);</span><br><span class="line">            <span class="comment">//如果是首次注册，发起pipeline的fireChannelActive</span></span><br><span class="line">            pipeline.fireChannelRegistered();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (isActive()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (firstRegistration) &#123;</span><br><span class="line">                    pipeline.fireChannelActive();</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (config().isAutoRead()) &#123;</span><br><span class="line">                    beginRead();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            closeForcibly();</span><br><span class="line">            closeFuture.setClosed();</span><br><span class="line">            safeSetFailure(promise, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>这个方法的工作流程如下：</p><ol><li>如果Channel处于open状态，则调用<code>doRegister</code>完成注册，然后将注册结果设置为成功</li><li>如果是首次注册且处于激活状态，则发起pipeline的<code>fireChannelActive()</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegister</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">     <span class="keyword">boolean</span> selected = <span class="keyword">false</span>;</span><br><span class="line">     <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">         </span><br><span class="line">         <span class="comment">//注册到NIOEventloop的Selector上</span></span><br><span class="line">             selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), <span class="number">0</span>, <span class="keyword">this</span>);</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">         &#125; <span class="keyword">catch</span> (CancelledKeyException e) &#123;</span><br><span class="line">             <span class="keyword">if</span> (!selected) &#123;</span><br><span class="line">                 eventLoop().selectNow();</span><br><span class="line">                 selected = <span class="keyword">true</span>;</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 <span class="keyword">throw</span> e;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>到此，我们基本清楚了<code>initAndRegister()</code>方法到底做了什么事情。<br>接下来，我们继续分析<code>doBind0</code>方法的具体实现；<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doBind0</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> ChannelFuture regFuture, <span class="keyword">final</span> Channel channel,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//新建一个任务，然后提交给EventLoop</span></span><br><span class="line">    channel.eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (regFuture.isSuccess()) &#123;</span><br><span class="line">                channel.bind(localAddress, promise).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                promise.setFailure(regFuture.cause());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个方法的主要逻辑还是非常清晰的。我们首先来分析一下<code>execute</code>的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"task"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> inEventLoop = inEventLoop();</span><br><span class="line">    <span class="comment">//添加任务到队列中，如果入队失败，则执行拒绝策略</span></span><br><span class="line">    addTask(task);</span><br><span class="line">    <span class="keyword">if</span> (!inEventLoop) &#123;</span><br><span class="line">        startThread();</span><br><span class="line">        <span class="keyword">if</span> (isShutdown()) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> reject = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (removeTask(task)) &#123;</span><br><span class="line">                    reject = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (UnsupportedOperationException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (reject) &#123;</span><br><span class="line">                reject();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!addTaskWakesUp &amp;&amp; wakesUpForTask(task)) &#123;</span><br><span class="line">        wakeup(inEventLoop);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>task添加到任务队列成功后，执行任务会调用如下方法:<br><code>channel.bind(localAddress,promise).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);</code></p><p>channel首先调用<code>bind</code>完成channel完成与端口的绑定：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">bind</span><span class="params">(SocketAddress localAddress, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pipeline.bind(localAddress, promise);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelFuture <span class="title">bind</span><span class="params">(SocketAddress localAddress, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tail.bind(localAddress, promise);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>bind</code>方法最终会调用<code>DefaultChannelPipeline</code>的<code>bind</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">bind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//进行参数校验</span></span><br><span class="line">    <span class="keyword">if</span> (localAddress == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"localAddress"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!validatePromise(promise, <span class="keyword">false</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> promise;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从 AbstractChannelHandlerContext </span></span><br><span class="line"><span class="comment">//双向链表尾部开始遍历找到第一个节点属性为outbound为true的节点</span></span><br><span class="line">    <span class="keyword">final</span> AbstractChannelHandlerContext next = findContextOutbound();</span><br><span class="line">    EventExecutor executor = next.executor();</span><br><span class="line">    <span class="keyword">if</span> (executor.inEventLoop()) &#123;</span><br><span class="line">        next.invokeBind(localAddress, promise);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        safeExecute(executor, <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                next.invokeBind(localAddress, promise);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, promise, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>invokeBind的实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeBind</span><span class="params">(SocketAddress localAddress, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (invokeHandler()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ((ChannelOutboundHandler) handler()).bind(<span class="keyword">this</span>, localAddress, promise);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            notifyOutboundHandlerException(t, promise);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        bind(localAddress, promise);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>headler()</code>返回的是HeadContext对象，然后调用<code>bind()</code>方法：<code>bind</code>方法的具体实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    unsafe.bind(localAddress, promise);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最终是调用了unsafe的<code>bind</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    assertEventLoop();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!promise.setUncancellable() || !ensureOpen(promise)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Boolean.TRUE.equals(config().getOption(ChannelOption.SO_BROADCAST)) &amp;&amp;</span><br><span class="line">        localAddress <span class="keyword">instanceof</span> InetSocketAddress &amp;&amp;</span><br><span class="line">        !((InetSocketAddress) localAddress).getAddress().isAnyLocalAddress() &amp;&amp;</span><br><span class="line">        !PlatformDependent.isWindows() &amp;&amp; !PlatformDependent.isRoot()) &#123;</span><br><span class="line"></span><br><span class="line">        logger.warn(</span><br><span class="line">                <span class="string">"A non-root user can't receive a broadcast packet if the socket "</span> +</span><br><span class="line">                <span class="string">"is not bound to a wildcard address; binding to a non-wildcard "</span> +</span><br><span class="line">                <span class="string">"address ("</span> + localAddress + <span class="string">") anyway as requested."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> wasActive = isActive();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 最核心方法</span></span><br><span class="line">        doBind(localAddress);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        safeSetFailure(promise, t);</span><br><span class="line">        closeIfClosed();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!wasActive &amp;&amp; isActive()) &#123;</span><br><span class="line">        invokeLater(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                pipeline.fireChannelActive();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    safeSetSuccess(promise);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>内部又调用了<code>doBind</code>方法，它绑定的核心方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doBind</span><span class="params">(SocketAddress localAddress)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (PlatformDependent.javaVersion() &gt;= <span class="number">7</span>) &#123;</span><br><span class="line">        javaChannel().bind(localAddress, config.getBacklog());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        javaChannel().socket().bind(localAddress, config.getBacklog());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>javaChannel</code>方法返回的是<code>NioServerSocketChannel</code> 实例初始化时所产生的 <code>Java NIO ServerSocketChannel</code>实例（<code>ServerSocketChannelImple</code>实例），然后调用其 <code>bind()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ServerSocketChannel <span class="title">bind</span><span class="params">(SocketAddress var1, <span class="keyword">int</span> var2)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Object var3 = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>.lock) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="keyword">this</span>.isOpen()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClosedChannelException();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.isBound()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AlreadyBoundException();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            InetSocketAddress var4 = var1 == <span class="keyword">null</span>?<span class="keyword">new</span> InetSocketAddress(<span class="number">0</span>):Net.checkAddress(var1);</span><br><span class="line">            SecurityManager var5 = System.getSecurityManager();</span><br><span class="line">            <span class="keyword">if</span>(var5 != <span class="keyword">null</span>) &#123;</span><br><span class="line">                var5.checkListen(var4.getPort());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            NetHooks.beforeTcpBind(<span class="keyword">this</span>.fd, var4.getAddress(), var4.getPort());</span><br><span class="line">            Net.bind(<span class="keyword">this</span>.fd, var4.getAddress(), var4.getPort());</span><br><span class="line">            Net.listen(<span class="keyword">this</span>.fd, var2 &lt; <span class="number">1</span>?<span class="number">50</span>:var2);</span><br><span class="line">            Object var6 = <span class="keyword">this</span>.stateLock;</span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="keyword">this</span>.stateLock) &#123;</span><br><span class="line">                <span class="keyword">this</span>.localAddress = Net.localAddress(<span class="keyword">this</span>.fd);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法就属于NIO层次的了。捯饬就完成了服务端端口的绑定工作。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;示例代码&quot;&gt;&lt;a href=&quot;#示例代码&quot; class=&quot;headerlink&quot; title=&quot;示例代码&quot;&gt;&lt;/a&gt;示例代码&lt;/h2&gt;&lt;p&gt;我们就以下面这段代码为例，来分析一个Netty是如何启动的。&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;HttpServer&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; InterruptedException &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//负责接收客户端连接&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        EventLoopGroup bossGroup = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; NioEventLoopGroup(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//负责网络读写&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        EventLoopGroup workerGroup = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; NioEventLoopGroup();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            ServerBootstrap bootstrap = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ServerBootstrap();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            bootstrap.group(bossGroup,workerGroup)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    .channel(NioServerSocketChannel.class)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    .childHandler(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ChannelInitializer&amp;lt;SocketChannel&amp;gt;() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;initChannel&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(SocketChannel socketChannel)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; Exception &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    ChannelPipeline pipeline = socketChannel.pipeline();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;comment&quot;&gt;//http编解码器&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    pipeline.addLast(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; HttpServerCodec());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;comment&quot;&gt;//自定义的handler&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    pipeline.addLast(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; HttpServerHandler());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; ChannelFuture future = bootstrap.bind(&lt;span class=&quot;number&quot;&gt;3333&lt;/span&gt;).sync();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            future.channel().closeFuture().sync();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;span class=&quot;keyword&quot;&gt;finally&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            bossGroup.shutdownGracefully();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            workerGroup.shutdownGracefully();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这段代码我们首先创建了两个EventLoopGroup。然后创建了&lt;code&gt;ServerBootstrap&lt;/code&gt;并设置设置了一系列的属性。然后调用了&lt;code&gt;bind&lt;/code&gt;方法完成了服务器的启动。所以要分析Netty服务端的启动过程就需要从&lt;code&gt;bind&lt;/code&gt;方法入手。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Netty" scheme="http://yoursite.com/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo之SPI</title>
    <link href="http://yoursite.com/2020/03/05/Dubbo%E4%B9%8BSPI/"/>
    <id>http://yoursite.com/2020/03/05/Dubbo之SPI/</id>
    <published>2020-03-05T13:06:00.000Z</published>
    <updated>2020-03-05T13:07:16.854Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="什么是spi">什么是SPI？</span></h2><p>SPI全称是Service Provider Interface，是一种服务发现机制。SPI的本质是将接口的实现类的全限定名配置在文件中，并由服务加载器读取配置文件，完成类的加载。这样可以在运行是，动态为接口替换实现类。通过SPI机制，可以为程序提供拓展功能。</p><a id="more"></a><h2><span id="dubbo-spi如何使用">Dubbo SPI如何使用？</span></h2><p>我们首先需要知道的是SPI机制不仅仅是Dubbo有的，Java本身也提SPI的实现了的。</p><ol><li>假如我们有这么一个接口，我们希望我们在运行时动态的选择其实现类。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Robot</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>我们准备了两个不同的实现类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OptimusPrime</span> <span class="keyword">implements</span> <span class="title">Robot</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello, I am Optimus Prime."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bumblebee</span> <span class="keyword">implements</span> <span class="title">Robot</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello, I am Bumblebee."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><p>它的实现类的全路径我们配置到<code>META-INF/dubbo</code>路径下的配置文件中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">optimusPrime = org.apache.spi.OptimusPrime</span><br><span class="line">bumblebee = org.apache.spi.Bumblebee</span><br></pre></td></tr></table></figure></li><li><p>编写测试代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboSPITest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ExtensionLoader&lt;Robot&gt; extensionLoader = </span><br><span class="line">            ExtensionLoader.getExtensionLoader(Robot.class);</span><br><span class="line">        Robot optimusPrime = extensionLoader.getExtension(<span class="string">"optimusPrime"</span>);</span><br><span class="line">        optimusPrime.sayHello();</span><br><span class="line">        Robot bumblebee = extensionLoader.getExtension(<span class="string">"bumblebee"</span>);</span><br><span class="line">        bumblebee.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2><span id="dubbo-spi源码分析">Dubbo SPI源码分析</span></h2><p>首先通过<code>getExtensionLoader</code>方法获取与拓展类对应的<code>ExtensionLoader</code>.然后通过<code>getExtension</code>获取拓展类对象。<br><code>getExtensionLoader</code>的具体实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">ExtensionLoader&lt;T&gt; <span class="title">getExtensionLoader</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (type == <span class="keyword">null</span>)</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Extension type == null"</span>);</span><br><span class="line">      <span class="keyword">if</span>(!type.isInterface()) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Extension type("</span> + type + <span class="string">") is not interface!"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(!withExtensionAnnotation(type)) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Extension type("</span> + type + </span><br><span class="line">                  <span class="string">") is not extension, because WITHOUT @"</span> + SPI.class.getSimpleName() + <span class="string">" Annotation!"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//尝试从缓存中获取ExtensionLoader</span></span><br><span class="line">      ExtensionLoader&lt;T&gt; loader = (ExtensionLoader&lt;T&gt;) EXTENSION_LOADERS.get(type);</span><br><span class="line">      <span class="keyword">if</span> (loader == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//缓存中没有就新建，并加入到缓存中区</span></span><br><span class="line">          EXTENSION_LOADERS.putIfAbsent(type, <span class="keyword">new</span> ExtensionLoader&lt;T&gt;(type));</span><br><span class="line">          loader = (ExtensionLoader&lt;T&gt;) EXTENSION_LOADERS.get(type);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> loader;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>这个方法只做一件事情，就是获取拓展类对应的<code>getExtensionLoader</code>.首先尝试从缓存中获取，如果获取到了直接返回；没有获取到就创建并加入缓存，然后返回新创建的<code>ExtensionLoader</code>.</p><p>拿到<code>ExtensionLoader</code>之后，就可以通过<code>T getExtension(String name)</code>方法获取拓展类对象了。这个方法的具体实现如下；<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">getExtension</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (name == <span class="keyword">null</span> || name.length() == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Extension name == null"</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="string">"true"</span>.equals(name)) &#123;</span><br><span class="line"><span class="comment">//如果为true，就返回设置的缺省值，否则返回null</span></span><br><span class="line">    <span class="keyword">return</span> getDefaultExtension();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*这里的Holder就是用来持有拓展类对象的一个pojo（一个保存对象的属性和get，set方法）。</span></span><br><span class="line"><span class="comment">cachedInstances就是一个ConcurrentMap，键为我们传入的name，值为持有拓展类对象的holder对象。</span></span><br><span class="line"><span class="comment">这行代码就是尝试从缓冲中获取拓展类（如果之前已经创建了）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Holder&lt;Object&gt; holder = cachedInstances.get(name);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (holder == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">/*如果缓存中没有，就创建并加入缓存。</span></span><br><span class="line"><span class="comment">注意，这里创建的仅仅是一个用于持有拓展类对象的holder对象，拓展类实际上还是没有创建*/</span></span><br><span class="line">    cachedInstances.putIfAbsent(name, <span class="keyword">new</span> Holder&lt;Object&gt;());</span><br><span class="line">    holder = cachedInstances.get(name);</span><br><span class="line">&#125;</span><br><span class="line">Object instance = holder.get();</span><br><span class="line"><span class="comment">//双从锁定机制</span></span><br><span class="line"><span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (holder) &#123;</span><br><span class="line">            instance = holder.get();</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">/*如果holder中没有持有拓展类对象，就创建一个拓展类对象，</span></span><br><span class="line"><span class="comment">            交由hodler持有*/</span></span><br><span class="line">                instance = createExtension(name);</span><br><span class="line">                holder.set(instance);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (T) instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这段代码，逻辑还是比较复杂的，主要是缓存的处理。它的流程是这样的：</p><ol><li>如果name为“true”，就返回默认拓展类，如果没有设置默认拓展类，那么就返回null</li><li>尝试从缓冲中获取拓展类，获取成功就返回</li><li>如果缓冲中，没有就创建拓展类对象，交由一个hodler对象持有后存入缓冲，并返回拓展类对象</li></ol><p>那么创建拓展类对象的这个方法就非常的关键了。即这个方法中的这行代码<br><code>instance = createExtension(name);</code></p><p>创建拓展类对象的<code>createExtension</code>方法的具体实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">createExtension</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">    getExtensionClasses拿到一个配置项名称到配置类的映射表map</span></span><br><span class="line"><span class="comment">    然后通过get方法，拿到配置类</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">    Class&lt;?&gt; clazz = getExtensionClasses().get(name);</span><br><span class="line">    <span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> findException(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    尝试从缓存中获取类所对应的实例</span></span><br><span class="line"><span class="comment">    EXTENSION_INSTANCES是一个ConcurrentMap&lt;Class&lt;?&gt;, Object&gt;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">        T instance = (T) EXTENSION_INSTANCES.get(clazz);</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//如果不存在，就通过反射创建拓展类实例，并加入缓存</span></span><br><span class="line">            EXTENSION_INSTANCES.putIfAbsent(clazz, (T) clazz.newInstance());</span><br><span class="line">            instance = (T) EXTENSION_INSTANCES.get(clazz);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//向实例中注入依赖</span></span><br><span class="line">        injectExtension(instance);</span><br><span class="line">        Set&lt;Class&lt;?&gt;&gt; wrapperClasses = cachedWrapperClasses;</span><br><span class="line">        <span class="keyword">if</span> (wrapperClasses != <span class="keyword">null</span> &amp;&amp; wrapperClasses.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="comment">// 循环创建 Wrapper 实例</span></span><br><span class="line">            <span class="keyword">for</span> (Class&lt;?&gt; wrapperClass : wrapperClasses) &#123;</span><br><span class="line">            </span><br><span class="line">             <span class="comment">// 将当前 instance 作为参数传给 Wrapper 的构造方法，并通过反射创建 Wrapper 实例。</span></span><br><span class="line">            <span class="comment">// 然后向 Wrapper 实例中注入依赖，最后将 Wrapper 实例再次赋值给 instance 变量</span></span><br><span class="line">                instance = injectExtension((T) wrapperClass.getConstructor(type).newInstance(instance));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Extension instance(name: "</span> + name + <span class="string">", class: "</span> +</span><br><span class="line">                type + <span class="string">")  could not be instantiated: "</span> + t.getMessage(), t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个方法主要完成这么几件事情：</p><ol><li>通过<code>getExtensionClasses</code>获取一个配置项名为键，拓展类类对象为值的map，然后调用get方法获取拓展类</li><li>尝试从缓存中获取拓展类实例，如果缓存中没有，就通过反射进行创建</li><li>向拓展类实例中注入依赖</li><li>将拓展类对象包裹在相应的wrapper对象中。</li></ol><p>读完这个方法的代码，我们有几个大大的问号。</p><ol><li>是如何向拓展类实例中注入依赖的？</li></ol><p>那下面，我们就来探究这个问题。</p><p>想要知道是如何向拓展类实例中注入属性的，我们要从<code>injectExtension(instance);</code>方法入手，这个方法就完成了拓展类的属性注入工作。这也被称为<strong>Duboo IOC</strong><br>它的具体实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">injectExtension</span><span class="params">(T instance)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (objectFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Method method : instance.getClass().getMethods()) &#123;</span><br><span class="line">            <span class="comment">/*遍历该实例的方法，找出set开头的方法，</span></span><br><span class="line"><span class="comment">            且仅有一个参数，且访问级别为public*/</span></span><br><span class="line">                <span class="keyword">if</span> (method.getName().startsWith(<span class="string">"set"</span>)</span><br><span class="line">                        &amp;&amp; method.getParameterTypes().length == <span class="number">1</span></span><br><span class="line">                        &amp;&amp; Modifier.isPublic(method.getModifiers())) &#123;</span><br><span class="line">                        <span class="comment">//获取setter方法的参数类型</span></span><br><span class="line">                    Class&lt;?&gt; pt = method.getParameterTypes()[<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//获取属性名，如setName的属性名为name</span></span><br><span class="line">                        String property = method.getName().length() &gt; <span class="number">3</span> ? method.getName().substring(<span class="number">3</span>, <span class="number">4</span>).toLowerCase() + method.getName().substring(<span class="number">4</span>) : <span class="string">""</span>;</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">//从ObjectFactory中获取依赖对象</span></span><br><span class="line">                        Object object = objectFactory.getExtension(pt, property);</span><br><span class="line">                        <span class="keyword">if</span> (object != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//通过反射调用setter方法设置依赖</span></span><br><span class="line">                            method.invoke(instance, object);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        logger.error(<span class="string">"fail to inject via method "</span> + method.getName()</span><br><span class="line">                                + <span class="string">" of interface "</span> + type.getName() + <span class="string">": "</span> + e.getMessage(), e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        logger.error(e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个方法的实现还是比较简单的：</p><ol><li>找出实例中的setter方法</li><li>拿到setter方法的参数类型，和字段名</li><li>从objectFactoy中拿到变量</li><li>通过反射调用setter方法，完成设值</li></ol><p>整个流程还是非常的清晰的，不过objectFactory是什么呢？<br>objectFactory 变量的类型为 AdaptiveExtensionFactory，AdaptiveExtensionFactory 内部维护了一个 ExtensionFactory 列表，用于存储其他类型的 ExtensionFactory。Dubbo 目前提供了两种 ExtensionFactory，分别是 SpiExtensionFactory 和 SpringExtensionFactory。前者用于创建自适应的拓展，后者是用于从 Spring 的 IOC 容器中获取所需的拓展。</p><p>这两个类的实现是非常简单的。以SpringExtensionFactory为了，它的<code>getExtension</code>就是直接从spring的ApplicationContext中按名字取出bean返回就完事了。这里我们就不再分析。</p><h2><span id="dubbo的自适应拓展">Dubbo的自适应拓展</span></h2><p>通过Dubbo的SPI机制，可以非常方便的加载拓展。如果我们不希望拓展在框架启动时就被加载，而是在拓展被调用时，根据运行时参数来进行加载。<br>Dubbo是这样做的：<br><strong>首先 Dubbo 会为拓展接口生成具有代理功能的代码。然后通过 javassist 或 jdk 编译这段代码，得到 Class类。最后再通过反射创建代理类，在代理类中，就可以通过URL对象的参数来确定到底调用哪个实现类。</strong></p><h2><span id="自适应拓展机制源码分析">自适应拓展机制源码分析</span></h2><p>整个自适应拓展机制的入口是<code>getAdaptiveExtension()</code>方法。<br>这个方法的具体实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">getAdaptiveExtension</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//从缓存中获取自适应拓展</span></span><br><span class="line">    Object instance = cachedAdaptiveInstance.get();</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(createAdaptiveInstanceError == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (cachedAdaptiveInstance) &#123;</span><br><span class="line">                instance = cachedAdaptiveInstance.get();</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//创建自适应拓展</span></span><br><span class="line">                        instance = createAdaptiveExtension();</span><br><span class="line">                        <span class="comment">//设置自适应拓展到缓存中</span></span><br><span class="line">                        cachedAdaptiveInstance.set(instance);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                        createAdaptiveInstanceError = t;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"fail to create adaptive instance: "</span> + t.toString(), t);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"fail to create adaptive instance: "</span> + createAdaptiveInstanceError.toString(), createAdaptiveInstanceError);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (T) instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个方法的逻辑比较简单，首先检测缓存，缓存未命中就调用<code>createAdaptiveExtension</code>创建自适应拓展。<br>我们发现创建自适应拓展的关键在于<code>createAdaptiveExtension</code>方法，它的具体实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">createAdaptiveExtension</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">/*拿到自适应拓展类，使用反射实例化，</span></span><br><span class="line"><span class="comment">       然后交由injectExtension进行属性设值*/</span></span><br><span class="line">           <span class="keyword">return</span> injectExtension((T) getAdaptiveExtensionClass().newInstance());</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Can not create adaptive extenstion "</span> + type + <span class="string">", cause: "</span> + e.getMessage(), e);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>在这个方法中，获取自适应拓展类的方法尤为重要。<br>在之前我们也提到，自适应拓展类Dubbo生成的代码编译而来的。那么我们就通过代码来探究到底是如何做的。<br><code>getAdaptiveExtensionClass</code>的具体实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Class&lt;?&gt; getAdaptiveExtensionClass() &#123;</span><br><span class="line"><span class="comment">//通过SPI获取所有的拓展类</span></span><br><span class="line">    getExtensionClasses();</span><br><span class="line">    <span class="keyword">if</span> (cachedAdaptiveClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//检测缓存，如果缓存不为空，则直接返回缓存</span></span><br><span class="line">        <span class="keyword">return</span> cachedAdaptiveClass;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建自适应拓展类</span></span><br><span class="line">    <span class="keyword">return</span> cachedAdaptiveClass = createAdaptiveExtensionClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个方法首先会尝试从缓存中取自适应拓展类，如果缓存命中则直接返回，如果缓存未命中就调用<code>createAdaptiveExtensionClass</code>方法创建。<br>它的实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Class&lt;?&gt; createAdaptiveExtensionClass() &#123;</span><br><span class="line"><span class="comment">//组装代码</span></span><br><span class="line">    String code = createAdaptiveExtensionClassCode();</span><br><span class="line">    ClassLoader classLoader = findClassLoader();</span><br><span class="line">    com.alibaba.dubbo.common.compiler.Compiler compiler = ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.common.compiler.Compiler.class).getAdaptiveExtension();</span><br><span class="line">    <span class="comment">//编译代码，得到class返回</span></span><br><span class="line">    <span class="keyword">return</span> compiler.compile(code, classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>组装代码的代码非常的复杂:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">createAdaptiveExtensionClassCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    StringBuilder codeBuidler = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    Method[] methods = type.getMethods();</span><br><span class="line">    <span class="keyword">boolean</span> hasAdaptiveAnnotation = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(Method m : methods) &#123;</span><br><span class="line">        <span class="keyword">if</span>(m.isAnnotationPresent(Adaptive.class)) &#123;</span><br><span class="line">            hasAdaptiveAnnotation = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 完全没有Adaptive方法，则不需要生成Adaptive类</span></span><br><span class="line">    <span class="keyword">if</span>(! hasAdaptiveAnnotation)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No adaptive method on extension "</span> + type.getName() + <span class="string">", refuse to create the adaptive class!"</span>);</span><br><span class="line">    </span><br><span class="line">    codeBuidler.append(<span class="string">"package "</span> + type.getPackage().getName() + <span class="string">";"</span>);</span><br><span class="line">    codeBuidler.append(<span class="string">"\nimport "</span> + ExtensionLoader.class.getName() + <span class="string">";"</span>);</span><br><span class="line">    codeBuidler.append(<span class="string">"\npublic class "</span> + type.getSimpleName() + <span class="string">"$Adpative"</span> + <span class="string">" implements "</span> + type.getCanonicalName() + <span class="string">" &#123;"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">        Class&lt;?&gt; rt = method.getReturnType();</span><br><span class="line">        Class&lt;?&gt;[] pts = method.getParameterTypes();</span><br><span class="line">        Class&lt;?&gt;[] ets = method.getExceptionTypes();</span><br><span class="line"></span><br><span class="line">        Adaptive adaptiveAnnotation = method.getAnnotation(Adaptive.class);</span><br><span class="line">        StringBuilder code = <span class="keyword">new</span> StringBuilder(<span class="number">512</span>);</span><br><span class="line">        <span class="keyword">if</span> (adaptiveAnnotation == <span class="keyword">null</span>) &#123;</span><br><span class="line">            code.append(<span class="string">"throw new UnsupportedOperationException(\"method "</span>)</span><br><span class="line">                    .append(method.toString()).append(<span class="string">" of interface "</span>)</span><br><span class="line">                    .append(type.getName()).append(<span class="string">" is not adaptive method!\");"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> urlTypeIndex = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pts.length; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pts[i].equals(URL.class)) &#123;</span><br><span class="line">                    urlTypeIndex = i;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 有类型为URL的参数</span></span><br><span class="line">            <span class="keyword">if</span> (urlTypeIndex != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// Null Point check</span></span><br><span class="line">                String s = String.format(<span class="string">"\nif (arg%d == null) throw new IllegalArgumentException(\"url == null\");"</span>,</span><br><span class="line">                                urlTypeIndex);</span><br><span class="line">                code.append(s);</span><br><span class="line">                </span><br><span class="line">                s = String.format(<span class="string">"\n%s url = arg%d;"</span>, URL.class.getName(), urlTypeIndex); </span><br><span class="line">                code.append(s);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 参数没有URL类型</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                String attribMethod = <span class="keyword">null</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 找到参数的URL属性</span></span><br><span class="line">                LBL_PTS:</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pts.length; ++i) &#123;</span><br><span class="line">                    Method[] ms = pts[i].getMethods();</span><br><span class="line">                    <span class="keyword">for</span> (Method m : ms) &#123;</span><br><span class="line">                        String name = m.getName();</span><br><span class="line">                        <span class="keyword">if</span> ((name.startsWith(<span class="string">"get"</span>) || name.length() &gt; <span class="number">3</span>)</span><br><span class="line">                                &amp;&amp; Modifier.isPublic(m.getModifiers())</span><br><span class="line">                                &amp;&amp; !Modifier.isStatic(m.getModifiers())</span><br><span class="line">                                &amp;&amp; m.getParameterTypes().length == <span class="number">0</span></span><br><span class="line">                                &amp;&amp; m.getReturnType() == URL.class) &#123;</span><br><span class="line">                            urlTypeIndex = i;</span><br><span class="line">                            attribMethod = name;</span><br><span class="line">                            <span class="keyword">break</span> LBL_PTS;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(attribMethod == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"fail to create adative class for interface "</span> + type.getName()</span><br><span class="line">                    + <span class="string">": not found url parameter or url attribute in parameters of method "</span> + method.getName());</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// Null point check</span></span><br><span class="line">                String s = String.format(<span class="string">"\nif (arg%d == null) throw new IllegalArgumentException(\"%s argument == null\");"</span>,</span><br><span class="line">                                urlTypeIndex, pts[urlTypeIndex].getName());</span><br><span class="line">                code.append(s);</span><br><span class="line">                s = String.format(<span class="string">"\nif (arg%d.%s() == null) throw new IllegalArgumentException(\"%s argument %s() == null\");"</span>,</span><br><span class="line">                                urlTypeIndex, attribMethod, pts[urlTypeIndex].getName(), attribMethod);</span><br><span class="line">                code.append(s);</span><br><span class="line"></span><br><span class="line">                s = String.format(<span class="string">"%s url = arg%d.%s();"</span>,URL.class.getName(), urlTypeIndex, attribMethod); </span><br><span class="line">                code.append(s);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            String[] value = adaptiveAnnotation.value();</span><br><span class="line">            <span class="comment">// 没有设置Key，则使用“扩展点接口名的点分隔 作为Key</span></span><br><span class="line">            <span class="keyword">if</span>(value.length == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">char</span>[] charArray = type.getSimpleName().toCharArray();</span><br><span class="line">                StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="number">128</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; charArray.length; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(Character.isUpperCase(charArray[i])) &#123;</span><br><span class="line">                        <span class="keyword">if</span>(i != <span class="number">0</span>) &#123;</span><br><span class="line">                            sb.append(<span class="string">"."</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        sb.append(Character.toLowerCase(charArray[i]));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        sb.append(charArray[i]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                value = <span class="keyword">new</span> String[] &#123;sb.toString()&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">boolean</span> hasInvocation = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pts.length; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pts[i].getName().equals(<span class="string">"com.alibaba.dubbo.rpc.Invocation"</span>)) &#123;</span><br><span class="line">                    <span class="comment">// Null Point check</span></span><br><span class="line">                    String s = String.format(<span class="string">"\nif (arg%d == null) throw new IllegalArgumentException(\"invocation == null\");"</span>, i);</span><br><span class="line">                    code.append(s);</span><br><span class="line">                    s = String.format(<span class="string">"\nString methodName = arg%d.getMethodName();"</span>, i); </span><br><span class="line">                    code.append(s);</span><br><span class="line">                    hasInvocation = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            String defaultExtName = cachedDefaultName;</span><br><span class="line">            String getNameCode = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = value.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i == value.length - <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="keyword">null</span> != defaultExtName) &#123;</span><br><span class="line">                        <span class="keyword">if</span>(!<span class="string">"protocol"</span>.equals(value[i]))</span><br><span class="line">                            <span class="keyword">if</span> (hasInvocation) </span><br><span class="line">                                getNameCode = String.format(<span class="string">"url.getMethodParameter(methodName, \"%s\", \"%s\")"</span>, value[i], defaultExtName);</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                getNameCode = String.format(<span class="string">"url.getParameter(\"%s\", \"%s\")"</span>, value[i], defaultExtName);</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            getNameCode = String.format(<span class="string">"( url.getProtocol() == null ? \"%s\" : url.getProtocol() )"</span>, defaultExtName);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span>(!<span class="string">"protocol"</span>.equals(value[i]))</span><br><span class="line">                            <span class="keyword">if</span> (hasInvocation) </span><br><span class="line">                                getNameCode = String.format(<span class="string">"url.getMethodParameter(methodName, \"%s\", \"%s\")"</span>, value[i], defaultExtName);</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                getNameCode = String.format(<span class="string">"url.getParameter(\"%s\")"</span>, value[i]);</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            getNameCode = <span class="string">"url.getProtocol()"</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span>(!<span class="string">"protocol"</span>.equals(value[i]))</span><br><span class="line">                        <span class="keyword">if</span> (hasInvocation) </span><br><span class="line">                            getNameCode = String.format(<span class="string">"url.getMethodParameter(methodName, \"%s\", \"%s\")"</span>, value[i], defaultExtName);</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            getNameCode = String.format(<span class="string">"url.getParameter(\"%s\", %s)"</span>, value[i], getNameCode);</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        getNameCode = String.format(<span class="string">"url.getProtocol() == null ? (%s) : url.getProtocol()"</span>, getNameCode);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            code.append(<span class="string">"\nString extName = "</span>).append(getNameCode).append(<span class="string">";"</span>);</span><br><span class="line">            <span class="comment">// check extName == null?</span></span><br><span class="line">            String s = String.format(<span class="string">"\nif(extName == null) "</span> +</span><br><span class="line">            <span class="string">"throw new IllegalStateException(\"Fail to get extension(%s) name from url(\" + url.toString() + \") use keys(%s)\");"</span>,</span><br><span class="line">                    type.getName(), Arrays.toString(value));</span><br><span class="line">            code.append(s);</span><br><span class="line">            </span><br><span class="line">            s = String.format(<span class="string">"\n%s extension = (%&lt;s)%s.getExtensionLoader(%s.class).getExtension(extName);"</span>,</span><br><span class="line">                    type.getName(), ExtensionLoader.class.getSimpleName(), type.getName());</span><br><span class="line">            code.append(s);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// return statement</span></span><br><span class="line">            <span class="keyword">if</span> (!rt.equals(<span class="keyword">void</span>.class)) &#123;</span><br><span class="line">                code.append(<span class="string">"\nreturn "</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            s = String.format(<span class="string">"extension.%s("</span>, method.getName());</span><br><span class="line">            code.append(s);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pts.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i != <span class="number">0</span>)</span><br><span class="line">                    code.append(<span class="string">", "</span>);</span><br><span class="line">                code.append(<span class="string">"arg"</span>).append(i);</span><br><span class="line">            &#125;</span><br><span class="line">            code.append(<span class="string">");"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        codeBuidler.append(<span class="string">"\npublic "</span> + rt.getCanonicalName() + <span class="string">" "</span> + method.getName() + <span class="string">"("</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pts.length; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                codeBuidler.append(<span class="string">", "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            codeBuidler.append(pts[i].getCanonicalName());</span><br><span class="line">            codeBuidler.append(<span class="string">" "</span>);</span><br><span class="line">            codeBuidler.append(<span class="string">"arg"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        codeBuidler.append(<span class="string">")"</span>);</span><br><span class="line">        <span class="keyword">if</span> (ets.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            codeBuidler.append(<span class="string">" throws "</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ets.length; i ++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    codeBuidler.append(<span class="string">", "</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                codeBuidler.append(pts[i].getCanonicalName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        codeBuidler.append(<span class="string">" &#123;"</span>);</span><br><span class="line">        codeBuidler.append(code.toString());</span><br><span class="line">        codeBuidler.append(<span class="string">"\n&#125;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    codeBuidler.append(<span class="string">"\n&#125;"</span>);</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(codeBuidler.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> codeBuidler.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是SPI？&quot;&gt;&lt;a href=&quot;#什么是SPI？&quot; class=&quot;headerlink&quot; title=&quot;什么是SPI？&quot;&gt;&lt;/a&gt;什么是SPI？&lt;/h2&gt;&lt;p&gt;SPI全称是Service Provider Interface，是一种服务发现机制。SPI的本质是将接口的实现类的全限定名配置在文件中，并由服务加载器读取配置文件，完成类的加载。这样可以在运行是，动态为接口替换实现类。通过SPI机制，可以为程序提供拓展功能。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Dubbo" scheme="http://yoursite.com/tags/Dubbo/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo基础</title>
    <link href="http://yoursite.com/2020/03/04/Dubbo%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2020/03/04/Dubbo基础/</id>
    <published>2020-03-04T13:01:00.000Z</published>
    <updated>2020-03-04T13:23:28.764Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="为什么需要dubbo">为什么需要Dubbo？</span></h2><p>在最初服务之间是通过配置URL地址进行调用的。通过硬件来做负载均衡。</p><ul><li>随着服务越来越多，服务URL配置管理变得非常困难。负载均衡的单点压力也越来越大。</li><li>服务之间的依赖关系也越来越复杂，描述应用的架构关系困难。</li><li>随着服务的调用的增加，管理服务的容量就变得困难。</li></ul><p>Dubbo就是为了解决这些问题而产生的。<br><a id="more"></a></p><h2><span id="dubbo的架构是怎样的">Dubbo的架构是怎样的？</span></h2><p><img src="https://s2.ax1x.com/2020/03/04/350qvF.png" alt="350qvF.png"><br>角色有：<br>服务容器，负责启动，加载运行服务提供者。<br>服务提供者：提供服务，在启动时，向注册中心注册自己提供的服务。<br>服务消费者：调用远程服务的服务消费方，在启动时向注册中心订阅自己所需的服务。<br>注册中心：服务注册与发现的注册中心。注册中心负责返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。<br>监控中心：收集服务消费者和提供者的统计信息，定时每分钟发送一次统计数据到注册中心。</p><h2><span id="dubbo架构的特点">Dubbo架构的特点</span></h2><p>连通性：</p><pre><code>注册中心负责服务地址的注册与查找，相当于目录服务，服务提供者和消费者只在启动时与注册中心交互，注册中心不转发请求，压力较小监控中心负责统计各服务调用次数，调用时间等，统计先在内存汇总后每分钟一次发送到监控中心服务器，并以报表展示服务提供者向注册中心注册其提供的服务，并汇报调用时间到监控中心，此时间不包含网络开销服务消费者向注册中心获取服务提供者地址列表，并根据负载算法直接调用提供者，同时汇报调用时间到监控中心，此时间包含网络开销注册中心，服务提供者，服务消费者三者之间均为长连接，监控中心除外注册中心通过长连接感知服务提供者的存在，服务提供者宕机，注册中心将立即推送事件通知消费者注册中心和监控中心全部宕机，不影响已运行的提供者和消费者，消费者在本地缓存了提供者列表注册中心和监控中心都是可选的，服务消费者可以直连服务提供者</code></pre><p>健壮性：</p><pre><code>监控中心宕掉不影响使用，只是丢失部分采样数据数据库宕掉后，注册中心仍能通过缓存提供服务列表查询，但不能注册新服务注册中心对等集群，任意一台宕掉后，将自动切换到另一台注册中心全部宕掉后，服务提供者和服务消费者仍能通过本地缓存通讯服务提供者无状态，任意一台宕掉后，不影响使用服务提供者全部宕掉后，服务消费者应用将无法使用，并无限次重连等待服务提供者恢复</code></pre><p>伸缩性</p><pre><code>注册中心为对等集群，可动态增加机器部署实例，所有客户端将自动发现新的注册中心服务提供者无状态，可动态增加机器部署实例，注册中心将推送新的服务提供者信息给消费者</code></pre><p>升级性</p><h2><span id="dubbo是如何进行服务导出的">Dubbo是如何进行服务导出的？</span></h2><p>Dubbo的服务导出的入口是<code>ServiceBean</code>的<code>onApplicationEvent</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*该方法是利用的了Spring的ApplicationContext事件机制，在</span></span><br><span class="line"><span class="comment">ContextRefreshedEvent事件（ApplicationContext被初始化或刷新）的时候触发该方法。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationEvent event)</span> </span>&#123;</span><br><span class="line"><span class="comment">//判断是否是延迟导出&amp;&amp;是否已经导出&amp;&amp;是否取消导出</span></span><br><span class="line">    <span class="keyword">if</span> (isDelay() &amp;&amp; ! isExported() &amp;&amp; ! isUnexported()) &#123;</span><br><span class="line">            export();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过一系列的判断之后，会调用<code>export()</code>方法进行服务导出。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">export</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (provider != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 获取export和delay配置</span></span><br><span class="line">        <span class="keyword">if</span> (export == <span class="keyword">null</span>) &#123;</span><br><span class="line">            export = provider.getExport();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (delay == <span class="keyword">null</span>) &#123;</span><br><span class="line">            delay = provider.getDelay();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果export为false，则不导出服务</span></span><br><span class="line">    <span class="keyword">if</span> (export != <span class="keyword">null</span> &amp;&amp; ! export.booleanValue()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果需要延时导出</span></span><br><span class="line">    <span class="keyword">if</span> (delay != <span class="keyword">null</span> &amp;&amp; delay &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//创建一个延时导出线程</span></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(delay);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">                doExport();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        thread.setName(<span class="string">"DelayExportServiceThread"</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//立即导出</span></span><br><span class="line">        doExport();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们可以看出<code>export()</code>主要处理的是禁止导出和延迟导出，最终都是调用的<code>doExport()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doExport</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (unexported) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already unexported!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (exported) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//标记为已导出</span></span><br><span class="line">    exported = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//检测接口名称的合法性</span></span><br><span class="line">    <span class="keyword">if</span> (interfaceName == <span class="keyword">null</span> || interfaceName.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"&lt;dubbo:service interface=\"\" /&gt; interface not allow null!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">// 检测 provider是否为空，为空则新建一个，并通过系统变量为其初始化</span></span><br><span class="line">    checkDefault();</span><br><span class="line">    </span><br><span class="line">   <span class="comment">// 下面几个 if 语句用于检测 provider、application 等核心配置类对象是否为空，</span></span><br><span class="line"><span class="comment">// 若为空，则尝试从其他配置类对象中获取相应的实例。</span></span><br><span class="line">    <span class="keyword">if</span> (provider != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (application == <span class="keyword">null</span>) &#123;</span><br><span class="line">            application = provider.getApplication();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">module</span> == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">module</span> = provider.getModule();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (registries == <span class="keyword">null</span>) &#123;</span><br><span class="line">            registries = provider.getRegistries();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (monitor == <span class="keyword">null</span>) &#123;</span><br><span class="line">            monitor = provider.getMonitor();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (protocols == <span class="keyword">null</span>) &#123;</span><br><span class="line">            protocols = provider.getProtocols();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">module</span> != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (registries == <span class="keyword">null</span>) &#123;</span><br><span class="line">            registries = <span class="keyword">module</span>.getRegistries();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (monitor == <span class="keyword">null</span>) &#123;</span><br><span class="line">            monitor = <span class="keyword">module</span>.getMonitor();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (application != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (registries == <span class="keyword">null</span>) &#123;</span><br><span class="line">            registries = application.getRegistries();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (monitor == <span class="keyword">null</span>) &#123;</span><br><span class="line">            monitor = application.getMonitor();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">// 检测 ref 是否为泛化服务类型</span></span><br><span class="line">    <span class="keyword">if</span> (ref <span class="keyword">instanceof</span> GenericService) &#123;</span><br><span class="line">    <span class="comment">// 设置 interfaceClass 为 GenericService.class</span></span><br><span class="line">        interfaceClass = GenericService.class;</span><br><span class="line">         <span class="comment">// 设置 generic = "true"</span></span><br><span class="line">        generic = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            interfaceClass = Class.forName(interfaceName, <span class="keyword">true</span>, Thread.currentThread()</span><br><span class="line">                    .getContextClassLoader());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="comment">// 对 interfaceClass，以及 &lt;dubbo:method&gt; 标签中的必要字段进行检查</span></span><br><span class="line">        checkInterfaceAndMethods(interfaceClass, methods);</span><br><span class="line">        <span class="comment">// 对 ref 合法性进行检测</span></span><br><span class="line">        checkRef();</span><br><span class="line">        <span class="comment">// 设置 generic = "false"</span></span><br><span class="line">        generic = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//local和stub在功能上应该是一致的，用于配置本地存根</span></span><br><span class="line">    <span class="keyword">if</span>(local !=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(local==<span class="string">"true"</span>)&#123;</span><br><span class="line">            local=interfaceName+<span class="string">"Local"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Class&lt;?&gt; localClass;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取本地存根类</span></span><br><span class="line">            localClass = ClassHelper.forNameWithThreadContextClassLoader(local);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//检测本地存根类是否可赋值给接口类，若不可赋值就会抛出异常，提醒使用者本地存根类型不合法</span></span><br><span class="line">        <span class="keyword">if</span>(!interfaceClass.isAssignableFrom(localClass))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The local implemention class "</span> + localClass.getName() + <span class="string">" not implement interface "</span> + interfaceName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(stub !=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(stub==<span class="string">"true"</span>)&#123;</span><br><span class="line">            stub=interfaceName+<span class="string">"Stub"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Class&lt;?&gt; stubClass;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            stubClass = ClassHelper.forNameWithThreadContextClassLoader(stub);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!interfaceClass.isAssignableFrom(stubClass))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The stub implemention class "</span> + stubClass.getName() + <span class="string">" not implement interface "</span> + interfaceName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//检测各种对象是否为空，为空则新建，或者抛出异常</span></span><br><span class="line">    checkApplication();</span><br><span class="line">    checkRegistry();</span><br><span class="line">    checkProtocol();</span><br><span class="line">    appendProperties(<span class="keyword">this</span>);</span><br><span class="line">    checkStubAndMock(interfaceClass);</span><br><span class="line">    <span class="keyword">if</span> (path == <span class="keyword">null</span> || path.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        path = interfaceName;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//导出服务</span></span><br><span class="line">    doExportUrls();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后导出服务来到了<code>doExportUrls()</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doExportUrls</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//加载注册中心链接</span></span><br><span class="line">    List&lt;URL&gt; registryURLs = loadRegistries(<span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">//遍历protocols，并在每个协议下导出服务</span></span><br><span class="line">    <span class="keyword">for</span> (ProtocolConfig protocolConfig : protocols) &#123;</span><br><span class="line">        doExportUrlsFor1Protocol(protocolConfig, registryURLs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>oadRegistries</code>方法主要完成下面这些方法：</p><ol><li>检测是否存在注册中心配置类，不存在则抛出异常</li><li>构建参数映射集合，也就是map</li><li>构建注册中心链接列表</li><li>遍历链接列表，并根据条件决定是否添加到registryList中</li></ol><p>拿到注册中心URL列表后，然后通过<code>doExportUrlsFor1Protocol</code>方法导出服务。</p><p>具体实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doExportUrlsFor1Protocol</span><span class="params">(ProtocolConfig protocolConfig, List&lt;URL&gt; registryURLs)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取协议名</span></span><br><span class="line">        String name = protocolConfig.getName();</span><br><span class="line">        <span class="keyword">if</span> (name == <span class="keyword">null</span> || name.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//如果协议名为空，或者为空串，就将协议名设置为dubbo</span></span><br><span class="line">            name = <span class="string">"dubbo"</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String host = protocolConfig.getHost();</span><br><span class="line">        <span class="keyword">if</span> (provider != <span class="keyword">null</span> &amp;&amp; (host == <span class="keyword">null</span> || host.length() == <span class="number">0</span>)) &#123;</span><br><span class="line">            host = provider.getHost();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> anyhost = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (NetUtils.isInvalidLocalHost(host)) &#123;</span><br><span class="line">            anyhost = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                host = InetAddress.getLocalHost().getHostAddress();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">                logger.warn(e.getMessage(), e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (NetUtils.isInvalidLocalHost(host)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (registryURLs != <span class="keyword">null</span> &amp;&amp; registryURLs.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (URL registryURL : registryURLs) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            Socket socket = <span class="keyword">new</span> Socket();</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                SocketAddress addr = <span class="keyword">new</span> InetSocketAddress(registryURL.getHost(), registryURL.getPort());</span><br><span class="line">                                socket.connect(addr, <span class="number">1000</span>);</span><br><span class="line">                                host = socket.getLocalAddress().getHostAddress();</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                                <span class="keyword">try</span> &#123;</span><br><span class="line">                                    socket.close();</span><br><span class="line">                                &#125; <span class="keyword">catch</span> (Throwable e) &#123;&#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                            logger.warn(e.getMessage(), e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (NetUtils.isInvalidLocalHost(host)) &#123;</span><br><span class="line">                    host = NetUtils.getLocalHost();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Integer port = protocolConfig.getPort();</span><br><span class="line">        <span class="keyword">if</span> (provider != <span class="keyword">null</span> &amp;&amp; (port == <span class="keyword">null</span> || port == <span class="number">0</span>)) &#123;</span><br><span class="line">            port = provider.getPort();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> defaultPort = ExtensionLoader.getExtensionLoader(Protocol.class).getExtension(name).getDefaultPort();</span><br><span class="line">        <span class="keyword">if</span> (port == <span class="keyword">null</span> || port == <span class="number">0</span>) &#123;</span><br><span class="line">            port = defaultPort;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (port == <span class="keyword">null</span> || port &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            port = getRandomPort(name);</span><br><span class="line">            <span class="keyword">if</span> (port == <span class="keyword">null</span> || port &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                port = NetUtils.getAvailablePort(defaultPort);</span><br><span class="line">                putRandomPort(name, port);</span><br><span class="line">            &#125;</span><br><span class="line">            logger.warn(<span class="string">"Use random available port("</span> + port + <span class="string">") for protocol "</span> + name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">        <span class="keyword">if</span> (anyhost) &#123;</span><br><span class="line">            map.put(Constants.ANYHOST_KEY, <span class="string">"true"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//添加side、版本、时间戳以及进程号等信息到map中</span></span><br><span class="line">        map.put(Constants.SIDE_KEY, Constants.PROVIDER_SIDE);</span><br><span class="line">        map.put(Constants.DUBBO_VERSION_KEY, Version.getVersion());</span><br><span class="line">        map.put(Constants.TIMESTAMP_KEY, String.valueOf(System.currentTimeMillis()));</span><br><span class="line">        <span class="keyword">if</span> (ConfigUtils.getPid() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            map.put(Constants.PID_KEY, String.valueOf(ConfigUtils.getPid()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//添加反射将对象的字段信息添加到map中</span></span><br><span class="line">        appendParameters(map, application);</span><br><span class="line">        appendParameters(map, <span class="keyword">module</span>);</span><br><span class="line">        appendParameters(map, provider, Constants.DEFAULT_KEY);</span><br><span class="line">        appendParameters(map, protocolConfig);</span><br><span class="line">        appendParameters(map, <span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (methods != <span class="keyword">null</span> &amp;&amp; methods.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (MethodConfig method : methods) &#123;</span><br><span class="line">                appendParameters(map, method, method.getName());</span><br><span class="line">                String retryKey = method.getName() + <span class="string">".retry"</span>;</span><br><span class="line">                <span class="keyword">if</span> (map.containsKey(retryKey)) &#123;</span><br><span class="line">                    String retryValue = map.remove(retryKey);</span><br><span class="line">                    <span class="keyword">if</span> (<span class="string">"false"</span>.equals(retryValue)) &#123;</span><br><span class="line">                        map.put(method.getName() + <span class="string">".retries"</span>, <span class="string">"0"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                List&lt;ArgumentConfig&gt; arguments = method.getArguments();</span><br><span class="line">                <span class="keyword">if</span> (arguments != <span class="keyword">null</span> &amp;&amp; arguments.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (ArgumentConfig argument : arguments) &#123;</span><br><span class="line">                        <span class="comment">//类型自动转换.</span></span><br><span class="line">                        <span class="keyword">if</span>(argument.getType() != <span class="keyword">null</span> &amp;&amp; argument.getType().length() &gt;<span class="number">0</span>)&#123;</span><br><span class="line">                            Method[] methods = interfaceClass.getMethods();</span><br><span class="line">                            <span class="comment">//遍历所有方法</span></span><br><span class="line">                            <span class="keyword">if</span>(methods != <span class="keyword">null</span> &amp;&amp; methods.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; methods.length; i++) &#123;</span><br><span class="line">                                    String methodName = methods[i].getName();</span><br><span class="line">                                    <span class="comment">//匹配方法名称，获取方法签名.</span></span><br><span class="line">                                    <span class="keyword">if</span>(methodName.equals(method.getName()))&#123;</span><br><span class="line">                                        Class&lt;?&gt;[] argtypes = methods[i].getParameterTypes();</span><br><span class="line">                                        <span class="comment">//一个方法中单个callback</span></span><br><span class="line">                                        <span class="keyword">if</span> (argument.getIndex() != -<span class="number">1</span> )&#123;</span><br><span class="line">                                            <span class="keyword">if</span> (argtypes[argument.getIndex()].getName().equals(argument.getType()))&#123;</span><br><span class="line">                                                appendParameters(map, argument, method.getName() + <span class="string">"."</span> + argument.getIndex());</span><br><span class="line">                                            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                                                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"argument config error : the index attribute and type attirbute not match :index :"</span>+argument.getIndex() + <span class="string">", type:"</span> + argument.getType());</span><br><span class="line">                                            &#125;</span><br><span class="line">                                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                            <span class="comment">//一个方法中多个callback</span></span><br><span class="line">                                            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ;j&lt;argtypes.length ;j++) &#123;</span><br><span class="line">                                                Class&lt;?&gt; argclazz = argtypes[j];</span><br><span class="line">                                                <span class="keyword">if</span> (argclazz.getName().equals(argument.getType()))&#123;</span><br><span class="line">                                                    appendParameters(map, argument, method.getName() + <span class="string">"."</span> + j);</span><br><span class="line">                                                    <span class="keyword">if</span> (argument.getIndex() != -<span class="number">1</span> &amp;&amp; argument.getIndex() != j)&#123;</span><br><span class="line">                                                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"argument config error : the index attribute and type attirbute not match :index :"</span>+argument.getIndex() + <span class="string">", type:"</span> + argument.getType());</span><br><span class="line">                                                    &#125;</span><br><span class="line">                                                &#125;</span><br><span class="line">                                            &#125;</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(argument.getIndex() != -<span class="number">1</span>)&#123;</span><br><span class="line">                            appendParameters(map, argument, method.getName() + <span class="string">"."</span> + argument.getIndex());</span><br><span class="line">                        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"argument config must set index or type attribute.eg: &lt;dubbo:argument index='0' .../&gt; or &lt;dubbo:argument type=xxx .../&gt;"</span>);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="comment">// end of methods for</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (generic) &#123;</span><br><span class="line">            map.put(<span class="string">"generic"</span>, String.valueOf(<span class="keyword">true</span>));</span><br><span class="line">            map.put(<span class="string">"methods"</span>, Constants.ANY_VALUE);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            String revision = Version.getVersion(interfaceClass, version);</span><br><span class="line">            <span class="keyword">if</span> (revision != <span class="keyword">null</span> &amp;&amp; revision.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                map.put(<span class="string">"revision"</span>, revision);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为接口生成包裹类wrapper，wrapper中包含了接口的详细信息，比如接口方法名数据，字段信息等</span></span><br><span class="line">            String[] methods = Wrapper.getWrapper(interfaceClass).getMethodNames();</span><br><span class="line">            <span class="keyword">if</span>(methods.length == <span class="number">0</span>) &#123;</span><br><span class="line">                logger.warn(<span class="string">"NO method found in service interface "</span> + interfaceClass.getName());</span><br><span class="line">                <span class="comment">//添加方法名到map中，如果包含多个方法名，则用逗号隔开</span></span><br><span class="line">                map.put(<span class="string">"methods"</span>, Constants.ANY_VALUE);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(<span class="string">"methods"</span>, StringUtils.join(<span class="keyword">new</span> HashSet&lt;String&gt;(Arrays.asList(methods)), <span class="string">","</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (! ConfigUtils.isEmpty(token)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ConfigUtils.isDefault(token)) &#123;</span><br><span class="line">            <span class="comment">//添加token到map中</span></span><br><span class="line">                map.put(<span class="string">"token"</span>, UUID.randomUUID().toString());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(<span class="string">"token"</span>, token);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"injvm"</span>.equals(protocolConfig.getName())) &#123;</span><br><span class="line">            protocolConfig.setRegister(<span class="keyword">false</span>);</span><br><span class="line">            map.put(<span class="string">"notify"</span>, <span class="string">"false"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 导出服务</span></span><br><span class="line">        String contextPath = protocolConfig.getContextpath();</span><br><span class="line">        <span class="keyword">if</span> ((contextPath == <span class="keyword">null</span> || contextPath.length() == <span class="number">0</span>) &amp;&amp; provider != <span class="keyword">null</span>) &#123;</span><br><span class="line">            contextPath = provider.getContextpath();</span><br><span class="line">        &#125;</span><br><span class="line">        URL url = <span class="keyword">new</span> URL(name, host, port, (contextPath == <span class="keyword">null</span> || contextPath.length() == <span class="number">0</span> ? <span class="string">""</span> : contextPath + <span class="string">"/"</span>) + path, map);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//进行服务导出</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>真正意义上的导出服务的代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ExtensionLoader.getExtensionLoader(ConfiguratorFactory.class)</span><br><span class="line">               .hasExtension(url.getProtocol())) &#123;</span><br><span class="line">               <span class="comment">//加载ConfiguratiorFactory，并生成Configurator实例，然后通过实例配置url</span></span><br><span class="line">           url = ExtensionLoader.getExtensionLoader(ConfiguratorFactory.class)</span><br><span class="line">                   .getExtension(url.getProtocol()).getConfigurator(url).configure(url);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       String scope = url.getParameter(Constants.SCOPE_KEY);</span><br><span class="line">       <span class="comment">//配置为none不暴露</span></span><br><span class="line">       <span class="keyword">if</span> (! Constants.SCOPE_NONE.toString().equalsIgnoreCase(scope)) &#123;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//配置不是remote的情况下做本地暴露 (配置为remote，则表示只暴露远程服务)</span></span><br><span class="line">           <span class="keyword">if</span> (!Constants.SCOPE_REMOTE.toString().equalsIgnoreCase(scope)) &#123;</span><br><span class="line">               exportLocal(url);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//如果配置不是local则暴露为远程服务.(配置为local，则表示只暴露远程服务)</span></span><br><span class="line">           <span class="keyword">if</span> (! Constants.SCOPE_LOCAL.toString().equalsIgnoreCase(scope) )&#123;</span><br><span class="line">               <span class="keyword">if</span> (registryURLs != <span class="keyword">null</span> &amp;&amp; registryURLs.size() &gt; <span class="number">0</span></span><br><span class="line">                       &amp;&amp; url.getParameter(<span class="string">"register"</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">                   <span class="keyword">for</span> (URL registryURL : registryURLs) &#123;</span><br><span class="line">                       url = url.addParameterIfAbsent(<span class="string">"dynamic"</span>, registryURL.getParameter(<span class="string">"dynamic"</span>));</span><br><span class="line">                       <span class="comment">//加载监视器链接</span></span><br><span class="line">                       URL monitorUrl = loadMonitor(registryURL);</span><br><span class="line">                       <span class="keyword">if</span> (monitorUrl != <span class="keyword">null</span>) &#123;</span><br><span class="line">                       <span class="comment">//将监视器链接作为参数添加到url中</span></span><br><span class="line">                           url = url.addParameterAndEncoded(Constants.MONITOR_KEY, monitorUrl.toFullString());</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="comment">//</span></span><br><span class="line">                       Invoker&lt;?&gt; invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, registryURL.addParameterAndEncoded(Constants.EXPORT_KEY, url.toFullString()));</span><br><span class="line">                       <span class="comment">//导出服务，并生成Exparter</span></span><br><span class="line">                       Exporter&lt;?&gt; exporter = protocol.export(invoker);</span><br><span class="line">                       exporters.add(exporter);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">//不存在注册中心，仅仅导出服务。</span></span><br><span class="line">                   Invoker&lt;?&gt; invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, url);</span><br><span class="line"></span><br><span class="line">                   Exporter&lt;?&gt; exporter = protocol.export(invoker);</span><br><span class="line">                   exporters.add(exporter);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">this</span>.urls.add(url);</span><br></pre></td></tr></table></figure></p><p>在进行服务导出的过程中，多次出现了创建Invoker。Invoker是Dubbo中非常重要的一个模型，<br>它的创建过程如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">getInvoker</span><span class="params">(T proxy, Class&lt;T&gt; type, URL url)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 为目标类创建 Wrapper</span></span><br><span class="line">    <span class="keyword">final</span> Wrapper wrapper = Wrapper.getWrapper(proxy.getClass().getName().indexOf(<span class="string">'$'</span>) &lt; <span class="number">0</span> ? proxy.getClass() : type);</span><br><span class="line">    <span class="comment">// 创建匿名 Invoker 类对象，并实现 doInvoke 方法。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AbstractProxyInvoker&lt;T&gt;(proxy, type, url) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Object <span class="title">doInvoke</span><span class="params">(T proxy, String methodName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  Class&lt;?&gt;[] parameterTypes,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  Object[] arguments)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"><span class="comment">// 调用 Wrapper 的 invokeMethod 方法，invokeMethod 最终会调用目标方法</span></span><br><span class="line">            <span class="keyword">return</span> wrapper.invokeMethod(proxy, methodName, parameterTypes, arguments);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>导出服务到本地的相关代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">exportLocal</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果 URL 的协议头等于 injvm，说明已经导出到本地了，无需再次导出</span></span><br><span class="line">    <span class="keyword">if</span> (!Constants.LOCAL_PROTOCOL.equalsIgnoreCase(url.getProtocol())) &#123;</span><br><span class="line">        URL local = URL.valueOf(url.toFullString())</span><br><span class="line">            .setProtocol(Constants.LOCAL_PROTOCOL)    <span class="comment">// 设置协议头为 injvm</span></span><br><span class="line">            .setHost(LOCALHOST)</span><br><span class="line">            .setPort(<span class="number">0</span>);</span><br><span class="line">        ServiceClassHolder.getInstance().pushServiceClass(getServiceClass(ref));</span><br><span class="line">        <span class="comment">// 创建 Invoker，并导出服务，这里的 protocol 会在运行时调用 InjvmProtocol 的 export 方法</span></span><br><span class="line">        Exporter&lt;?&gt; exporter = protocol.export(</span><br><span class="line">            proxyFactory.getInvoker(ref, (Class) interfaceClass, local));</span><br><span class="line">        exporters.add(exporter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>导出服务到远程：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(<span class="keyword">final</span> Invoker&lt;T&gt; originInvoker)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">    <span class="comment">// 导出服务</span></span><br><span class="line">    <span class="keyword">final</span> ExporterChangeableWrapper&lt;T&gt; exporter = doLocalExport(originInvoker);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取注册中心 URL，以 zookeeper 注册中心为例，得到的示例 URL 如下：</span></span><br><span class="line">    <span class="comment">// zookeeper://127.0.0.1:2181/com.alibaba.dubbo.registry.RegistryService?application=demo-provider&amp;dubbo=2.0.2&amp;export=dubbo%3A%2F%2F172.17.48.52%3A20880%2Fcom.alibaba.dubbo.demo.DemoService%3Fanyhost%3Dtrue%26application%3Ddemo-provider</span></span><br><span class="line">    URL registryUrl = getRegistryUrl(originInvoker);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 URL 加载 Registry 实现类，比如 ZookeeperRegistry</span></span><br><span class="line">    <span class="keyword">final</span> Registry registry = getRegistry(originInvoker);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取已注册的服务提供者 URL，比如：</span></span><br><span class="line">    <span class="comment">// dubbo://172.17.48.52:20880/com.alibaba.dubbo.demo.DemoService?anyhost=true&amp;application=demo-provider&amp;dubbo=2.0.2&amp;generic=false&amp;interface=com.alibaba.dubbo.demo.DemoService&amp;methods=sayHello</span></span><br><span class="line">    <span class="keyword">final</span> URL registeredProviderUrl = getRegisteredProviderUrl(originInvoker);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 register 参数</span></span><br><span class="line">    <span class="keyword">boolean</span> register = registeredProviderUrl.getParameter(<span class="string">"register"</span>, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向服务提供者与消费者注册表中注册服务提供者</span></span><br><span class="line">    ProviderConsumerRegTable.registerProvider(originInvoker, registryUrl, registeredProviderUrl);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 register 的值决定是否注册服务</span></span><br><span class="line">    <span class="keyword">if</span> (register) &#123;</span><br><span class="line">        <span class="comment">// 向注册中心注册服务</span></span><br><span class="line">        register(registryUrl, registeredProviderUrl);</span><br><span class="line">        ProviderConsumerRegTable.getProviderWrapper(originInvoker).setReg(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取订阅 URL，比如：</span></span><br><span class="line">    <span class="comment">// provider://172.17.48.52:20880/com.alibaba.dubbo.demo.DemoService?category=configurators&amp;check=false&amp;anyhost=true&amp;application=demo-provider&amp;dubbo=2.0.2&amp;generic=false&amp;interface=com.alibaba.dubbo.demo.DemoService&amp;methods=sayHello</span></span><br><span class="line">    <span class="keyword">final</span> URL overrideSubscribeUrl = getSubscribedOverrideUrl(registeredProviderUrl);</span><br><span class="line">    <span class="comment">// 创建监听器</span></span><br><span class="line">    <span class="keyword">final</span> OverrideListener overrideSubscribeListener = <span class="keyword">new</span> OverrideListener(overrideSubscribeUrl, originInvoker);</span><br><span class="line">    overrideListeners.put(overrideSubscribeUrl, overrideSubscribeListener);</span><br><span class="line">    <span class="comment">// 向注册中心进行订阅 override 数据</span></span><br><span class="line">    registry.subscribe(overrideSubscribeUrl, overrideSubscribeListener);</span><br><span class="line">    <span class="comment">// 创建并返回 DestroyableExporter</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DestroyableExporter&lt;T&gt;(exporter, originInvoker, overrideSubscribeUrl, registeredProviderUrl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这段代码主要做4个操作：</p><ol><li>调用doLocalExport导出服务</li><li>向注册中心注册服务</li><li>向注册中心进行订阅override数据</li><li>创建并返回DestoryableExporter</li></ol><p>其中<code>doLocalExport</code>的具体实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">ExporterChangeableWrapper&lt;T&gt; <span class="title">doLocalExport</span><span class="params">(<span class="keyword">final</span> Invoker&lt;T&gt; originInvoker)</span> </span>&#123;</span><br><span class="line">    String key = getCacheKey(originInvoker);</span><br><span class="line">    <span class="comment">// 访问缓存</span></span><br><span class="line">    ExporterChangeableWrapper&lt;T&gt; exporter = (ExporterChangeableWrapper&lt;T&gt;) bounds.get(key);</span><br><span class="line">    <span class="keyword">if</span> (exporter == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (bounds) &#123;</span><br><span class="line">            exporter = (ExporterChangeableWrapper&lt;T&gt;) bounds.get(key);</span><br><span class="line">            <span class="keyword">if</span> (exporter == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 创建 Invoker 为委托类对象</span></span><br><span class="line">                <span class="keyword">final</span> Invoker&lt;?&gt; invokerDelegete = <span class="keyword">new</span> InvokerDelegete&lt;T&gt;(originInvoker, getProviderUrl(originInvoker));</span><br><span class="line">                <span class="comment">// 调用 protocol 的 export 方法导出服务</span></span><br><span class="line">                exporter = <span class="keyword">new</span> ExporterChangeableWrapper&lt;T&gt;((Exporter&lt;T&gt;) protocol.export(invokerDelegete), originInvoker);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 写缓存</span></span><br><span class="line">                bounds.put(key, exporter);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> exporter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>比较关键的代码是<code>exporter = new ExporterChangeableWrapper&lt;T&gt;((Exporter&lt;T&gt;) protocol.export(invokerDelegete), originInvoker);</code>它的实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">    URL url = invoker.getUrl();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取服务标识，理解成服务坐标也行。由服务组名，服务名，服务版本号以及端口组成。比如：</span></span><br><span class="line">    <span class="comment">// demoGroup/com.alibaba.dubbo.demo.DemoService:1.0.1:20880</span></span><br><span class="line">    String key = serviceKey(url);</span><br><span class="line">    <span class="comment">// 创建 DubboExporter</span></span><br><span class="line">    DubboExporter&lt;T&gt; exporter = <span class="keyword">new</span> DubboExporter&lt;T&gt;(invoker, key, exporterMap);</span><br><span class="line">    <span class="comment">// 将 &lt;key, exporter&gt; 键值对放入缓存中</span></span><br><span class="line">    exporterMap.put(key, exporter);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 本地存根相关代码</span></span><br><span class="line">    Boolean isStubSupportEvent = url.getParameter(Constants.STUB_EVENT_KEY, Constants.DEFAULT_STUB_EVENT);</span><br><span class="line">    Boolean isCallbackservice = url.getParameter(Constants.IS_CALLBACK_SERVICE, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (isStubSupportEvent &amp;&amp; !isCallbackservice) &#123;</span><br><span class="line">        String stubServiceMethods = url.getParameter(Constants.STUB_EVENT_METHODS_KEY);</span><br><span class="line">        <span class="keyword">if</span> (stubServiceMethods == <span class="keyword">null</span> || stubServiceMethods.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 省略日志打印代码</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            stubServiceMethodsMap.put(url.getServiceKey(), stubServiceMethods);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动服务器</span></span><br><span class="line">    openServer(url);</span><br><span class="line">    <span class="comment">// 优化序列化</span></span><br><span class="line">    optimizeSerialization(url);</span><br><span class="line">    <span class="keyword">return</span> exporter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>openServer</code>比较关键：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">openServer</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取 host:port，并将其作为服务器实例的 key，用于标识当前的服务器实例</span></span><br><span class="line">    String key = url.getAddress();</span><br><span class="line">    <span class="keyword">boolean</span> isServer = url.getParameter(Constants.IS_SERVER_KEY, <span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (isServer) &#123;</span><br><span class="line">        <span class="comment">// 访问缓存</span></span><br><span class="line">        ExchangeServer server = serverMap.get(key);</span><br><span class="line">        <span class="keyword">if</span> (server == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 创建服务器实例</span></span><br><span class="line">            serverMap.put(key, createServer(url));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 服务器已创建，则根据 url 中的配置重置服务器</span></span><br><span class="line">            server.reset(url);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>创建服务器实例的方法是<code>createServer</code>,它的具体实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ExchangeServer <span class="title">createServer</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">    url = url.addParameterIfAbsent(Constants.CHANNEL_READONLYEVENT_SENT_KEY,</span><br><span class="line">    <span class="comment">// 添加心跳检测配置到 url 中</span></span><br><span class="line">    url = url.addParameterIfAbsent(Constants.HEARTBEAT_KEY, String.valueOf(Constants.DEFAULT_HEARTBEAT));</span><br><span class="line"><span class="comment">// 获取 server 参数，默认为 netty</span></span><br><span class="line">    String str = url.getParameter(Constants.SERVER_KEY, Constants.DEFAULT_REMOTING_SERVER);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 SPI 检测是否存在 server 参数所代表的 Transporter 拓展，不存在则抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (str != <span class="keyword">null</span> &amp;&amp; str.length() &gt; <span class="number">0</span> &amp;&amp; !ExtensionLoader.getExtensionLoader(Transporter.class).hasExtension(str))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Unsupported server type: "</span> + str + <span class="string">", url: "</span> + url);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加编码解码器参数</span></span><br><span class="line">    url = url.addParameter(Constants.CODEC_KEY, DubboCodec.NAME);</span><br><span class="line">    ExchangeServer server;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 ExchangeServer</span></span><br><span class="line">        server = Exchangers.bind(url, requestHandler);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemotingException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Fail to start server..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">                                   </span><br><span class="line"><span class="comment">// 获取 client 参数，可指定 netty，mina</span></span><br><span class="line">    str = url.getParameter(Constants.CLIENT_KEY);</span><br><span class="line">    <span class="keyword">if</span> (str != <span class="keyword">null</span> &amp;&amp; str.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取所有的 Transporter 实现类名称集合，比如 supportedTypes = [netty, mina]</span></span><br><span class="line">        Set&lt;String&gt; supportedTypes = ExtensionLoader.getExtensionLoader(Transporter.class).getSupportedExtensions();</span><br><span class="line">        <span class="comment">// 检测当前 Dubbo 所支持的 Transporter 实现类名称列表中，</span></span><br><span class="line">        <span class="comment">// 是否包含 client 所表示的 Transporter，若不包含，则抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (!supportedTypes.contains(str)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Unsupported client type..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> server;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>创建的ExchangeServer代码是<code>server = Exchangers.bind(url, requestHandler);</code></p><p>其中<code>bind</code>方法的实现如何：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExchangeServer <span class="title">bind</span><span class="params">(URL url, ExchangeHandler handler)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (url == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"url == null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"handler == null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    url = url.addParameterIfAbsent(Constants.CODEC_KEY, <span class="string">"exchange"</span>);</span><br><span class="line">    <span class="comment">// 获取 Exchanger，默认为 HeaderExchanger。</span></span><br><span class="line">    <span class="comment">// 紧接着调用 HeaderExchanger 的 bind 方法创建 ExchangeServer 实例</span></span><br><span class="line">    <span class="keyword">return</span> getExchanger(url).bind(url, handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法再深究下去就到了Netty层面去了。下次再分析。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;为什么需要Dubbo？&quot;&gt;&lt;a href=&quot;#为什么需要Dubbo？&quot; class=&quot;headerlink&quot; title=&quot;为什么需要Dubbo？&quot;&gt;&lt;/a&gt;为什么需要Dubbo？&lt;/h2&gt;&lt;p&gt;在最初服务之间是通过配置URL地址进行调用的。通过硬件来做负载均衡。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;随着服务越来越多，服务URL配置管理变得非常困难。负载均衡的单点压力也越来越大。&lt;/li&gt;
&lt;li&gt;服务之间的依赖关系也越来越复杂，描述应用的架构关系困难。&lt;/li&gt;
&lt;li&gt;随着服务的调用的增加，管理服务的容量就变得困难。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Dubbo就是为了解决这些问题而产生的。&lt;br&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Dubbo" scheme="http://yoursite.com/tags/Dubbo/"/>
    
  </entry>
  
  <entry>
    <title>深入理解TCP协议</title>
    <link href="http://yoursite.com/2020/02/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%E5%8D%8F%E8%AE%AE/"/>
    <id>http://yoursite.com/2020/02/26/深入理解TCP协议/</id>
    <published>2020-02-26T13:01:00.000Z</published>
    <updated>2020-02-26T13:02:06.119Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="什么是tcp协议">什么是TCP协议？</span></h2><p>TCP协议是一种面向连接的、可靠的字节流服务，它是一种传输层协议，它会使用网络层协议IP协议。</p><h2><span id="tcp协议是如何保证可靠传输的">TCP协议是如何保证可靠传输的</span></h2><ul><li>序列号</li><li>校验和</li><li>确认应答机制</li><li>连接管理</li><li>重发控制</li><li>流露控制</li><li>阻塞控制</li></ul><h2><span id="tcp协议的首部是怎样的">TCP协议的首部是怎样的？</span></h2><p>TCP数据被封装在一个IP数据报中。<br>由TCP传递给IP的信息单位称为报文端或段(segment)<br><img src="https://s2.ax1x.com/2020/02/25/3YQzfe.png" alt="3YQzfe.png"><br>标记比特介绍：<br>URG：紧急指针有效<br>ACK：确认需要有效<br>PSH：接收方应该尽快将这个报文段交给应用层。<br>RST：重建连接<br>SYN：同步序号用来发起一个连接。<br>FIN：发送端完成发送任务。</p><a id="more"></a><h2><span id="其它知识点">其它知识点</span></h2><ul><li>数据校验覆盖了整个TCP报文段，TCP首部和TCP数据，这是一个强制性的字段，<strong>一定是由发送端计算和存储的</strong>。</li><li>最常见的可选字段是最长报文大小，又称MSS。每个连接通常都在通信的第一个报文段中指明这个选项，它指明本端所能接收的最大长度的报文段。</li></ul><h2><span id="tcp连接是如何建立的">TCP连接是如何建立的</span></h2><ol><li>请求端发送一个SYN段指明客户打算连接的服务器的端口，以及初始序列号。</li><li>服务端收到请求端发送的报文端之后，回复客户端一个包含<strong>服务端初始序列号</strong>的<strong>SYN</strong>报文段，同时将<strong>确认序号设置为客户端的初始序列号加一</strong>。</li><li>请求端收到了服务端的回复之后，将<strong>确认序列号设置为服务端的初始序列号加一</strong>以对服务端SYN报文进行确认。</li></ol><p><img src="https://s2.ax1x.com/2020/02/25/3YJgOJ.png" alt="3YJgOJ.png"></p><h2><span id="tcp连接是如何关闭的">TCP连接是如何关闭的</span></h2><ol><li>首先进行关闭的一方，发送第一个FIN将执行主动关闭。</li><li>当被动关闭端收到这个FIN时，它发回一个ACK，确认序号为收到的序号加一。同时TCP服务器还会向应用程序传送一个文件结束符。接着这个服务器程序就关闭它的连接。</li><li>服务器程序开始关闭连接，它会向客户端发送一个FIN</li><li>客户端收到这个FIN后，客户端必须回复一个确认。</li></ol><p><img src="https://s2.ax1x.com/2020/02/25/3tnUYQ.png" alt="3tnUYQ.png"></p><p>TCP的半关闭：<br>TCP提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。<br><img src="https://s2.ax1x.com/2020/02/25/3tnUYQ.png" alt="3tnUYQ.png"></p><h2><span id="tcp的状态变迁图">TCP的状态变迁图</span></h2><p><img src="https://s2.ax1x.com/2020/02/25/3t3o2F.png" alt="3t3o2F.png"></p><h2><span id="tcp的滑动窗口与快速重传机制">TCP的滑动窗口与快速重传机制</span></h2><p>TCP协议为了确保可靠传输设计了确认应答机制，对每一个发送的数据段，都要等到接收端回复ACK之后，在发送下一个数据段。这样虽然确保了可靠传输，但是吞吐率不高。</p><p><strong>TCP的流量控制就是通过滑动窗口实现的</strong></p><p>为此TCP引入了滑动窗口协议：<br><img src="https://s2.ax1x.com/2020/02/26/3U8NQS.png" alt="3U8NQS.png"><br>窗口大小是指无需等待确认而可以继续发送数据的最大值。窗口越大，网络吞吐率就越高。</p><p>TCP采用了累计确认机制，机当接收端收到比期望序号大的报文段是，便会重复发送最近一次确认的报文段的确认信号，我们称之为冗余ACK。<br><img src="https://s2.ax1x.com/2020/02/26/3UYCqg.png" alt="3UYCqg.png"><br><em>因为seq=2的报文段丢失了，而接收端收到了比他期望的序号大的报文端3，它就会重复发送最近一次的确认的报文段ACK2，，如果在超时重传定时器溢出之前，连续收到了三个重复冗余ACK，那么发送端就知道哪个报文段丢失了，就可以重发该报文段，避免了等待超时周期，因此该机制被称为快速重传机制</em></p><p>快速重传机制解决了超时重传的什么问题？</p><ol><li>超时重传需要等待一定的超时周期才能确定是哪个报文段丢失了，才会进行重发。</li><li>当一个报文段丢失之后，在等待超时重传期间，可能会导致气候的报文段已经被接收段接收但得不到确认，发送端也会任务丢失了，从而引起不惜要得重传。</li></ol><p>为什么是3次冗余ACK？<br>因为TCP报文段是封在IP包内得，IP包在传输时乱序，意味着TCP达到得顺序也是乱序得，乱序也会造成接收端发送冗余ACK。而3次冗余ACK作为判断丢失的准则也是估计值。</p><h2><span id="tcp的拥塞控制">TCP的拥塞控制</span></h2><h3><span id="为什么要进行拥塞控制">为什么要进行拥塞控制</span></h3><p>防止过多的数据注入到网络中，这样使网络中的路由器或链路不至于过载。</p><h3><span id="tcp拥塞控制依赖于哪些机制">TCP拥塞控制依赖于哪些机制？</span></h3><ol><li>慢启动</li><li>拥塞避免</li><li>快速重传</li><li>快速恢复</li></ol><h3><span id="慢开始机制">慢开始机制</span></h3><p>发送方维持着一个叫做拥塞窗口cwnd，它会根据网络状况动态的进行调整，网络拥塞时，路由器会丢弃报文，发送方没有按时收到确认报文，那么就知道网络发生了拥堵。<br>所谓的慢开始机制就是初始的拥塞窗口为一。随着传输轮次的增加拥塞窗口逐步加大。为了防止拥塞窗口过大引起网络拥塞，我们需要设置一个慢看是门限ssthreth状态变量，但cwnd &lt; ssthreth时，使用慢开始算法，但cwnd &gt; ssthrerth时，使用拥塞控制算法。</p><h3><span id="什么是拥塞避免算法">什么是拥塞避免算法？</span></h3><p>就是让拥塞窗口缓慢的增大，机每经过一个往返时间，就将拥塞窗口cwnd+1，只要发送方判断出现网络拥堵，无论是在慢启动阶段还是在拥塞控制阶段，都会将慢开始门限值设置为拥塞时发送窗口的一半，但不能小于2，然后把拥塞窗口重置为一，执行慢开始算法。</p><h3><span id="什么是快速重传">什么是快速重传？</span></h3><p>快速重传要求接收方每收到一个失序的报文段后就立即发送重复确认，而不要等待自己发送数据时才进行捎带确认，发送方只要收到3个冗余确认报文就立即重传报文报，不必等到报文段的重传计时器到期。</p><h4><span id="什么是快恢复">什么是快恢复？</span></h4><p>一旦出现超时重传，TCP就会把慢启动门限ssthresh的值设置为cwnd值的一半，<strong>同时将cwnd设置为ssthresh。</strong></p><p><img src="https://s2.ax1x.com/2020/02/26/3aZLxs.png" alt="3aZLxs.png"><br><em>红色线条就应用了快恢复机制</em></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是TCP协议？&quot;&gt;&lt;a href=&quot;#什么是TCP协议？&quot; class=&quot;headerlink&quot; title=&quot;什么是TCP协议？&quot;&gt;&lt;/a&gt;什么是TCP协议？&lt;/h2&gt;&lt;p&gt;TCP协议是一种面向连接的、可靠的字节流服务，它是一种传输层协议，它会使用网络层协议IP协议。&lt;/p&gt;
&lt;h2 id=&quot;TCP协议是如何保证可靠传输的&quot;&gt;&lt;a href=&quot;#TCP协议是如何保证可靠传输的&quot; class=&quot;headerlink&quot; title=&quot;TCP协议是如何保证可靠传输的&quot;&gt;&lt;/a&gt;TCP协议是如何保证可靠传输的&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;序列号&lt;/li&gt;
&lt;li&gt;校验和&lt;/li&gt;
&lt;li&gt;确认应答机制&lt;/li&gt;
&lt;li&gt;连接管理&lt;/li&gt;
&lt;li&gt;重发控制&lt;/li&gt;
&lt;li&gt;流露控制&lt;/li&gt;
&lt;li&gt;阻塞控制&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;TCP协议的首部是怎样的？&quot;&gt;&lt;a href=&quot;#TCP协议的首部是怎样的？&quot; class=&quot;headerlink&quot; title=&quot;TCP协议的首部是怎样的？&quot;&gt;&lt;/a&gt;TCP协议的首部是怎样的？&lt;/h2&gt;&lt;p&gt;TCP数据被封装在一个IP数据报中。&lt;br&gt;由TCP传递给IP的信息单位称为报文端或段(segment)&lt;br&gt;&lt;img src=&quot;https://s2.ax1x.com/2020/02/25/3YQzfe.png&quot; alt=&quot;3YQzfe.png&quot;&gt;&lt;br&gt;标记比特介绍：&lt;br&gt;URG：紧急指针有效&lt;br&gt;ACK：确认需要有效&lt;br&gt;PSH：接收方应该尽快将这个报文段交给应用层。&lt;br&gt;RST：重建连接&lt;br&gt;SYN：同步序号用来发起一个连接。&lt;br&gt;FIN：发送端完成发送任务。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="TCP" scheme="http://yoursite.com/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>Netty学习笔记二</title>
    <link href="http://yoursite.com/2020/02/24/Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/"/>
    <id>http://yoursite.com/2020/02/24/Netty学习笔记二/</id>
    <published>2020-02-24T13:52:00.000Z</published>
    <updated>2020-02-25T06:28:35.864Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="什么是tcp粘包和拆包">什么是TCP粘包和拆包？</span></h2><p>TCP是一个“流”协议，所谓流就是没有界限的一串数据。TCP协议会根据TCP缓冲区的实际情况对包进行划分，所以业务上的一个包，可能被TCP拆分为多个包发送（拆包），多个小的包也可能被TCP合并为一个包进行发送（粘包）。</p><h2><span id="tcp粘包和拆包发生的原因">TCP粘包和拆包发生的原因</span></h2><p>原因有三个：</p><ol><li>应用程序write写入的字节大小大于套接字缓冲区的大小</li><li>进行MSS（maximum segment size，最大分节大小，为TCP数据包每次传输的最大数据分段大小）大小的TCP分段</li><li>以太帧的payload大于MTU（maximum transmission unit，最大传输单元，由硬件规定）进行IP分片<a id="more"></a></li></ol><h2><span id="粘包问题的解决策略">粘包问题的解决策略</span></h2><p>由于底层的TCP无法理解上层的业务数据，所以在底层是无法保证数据包不被拆分和重组，这个问题只能通过上层的应用协议栈设计来解决。<br>一些解决方案如下：</p><ol><li>消息定长，每个报文的长度固定，如果不够，空位补空格。</li><li>在包尾增加回车换行符进行分割，如FTP协议。</li><li>将消息分为消息头和消息体，消息头中包含一个表示消息总长度的字段。</li><li>更复杂的应用层协议。</li></ol><h2><span id="如何使用netty解决粘包问题">如何使用Netty解决粘包问题</span></h2><p>解决粘包问题的关键就在于要解决服务器端每次读取数据长度的问题。可以使用自定义协议+编解码器来解决。</p><p>比如使用<code>LineBasedFrameDecoder</code>和<code>StringDecoder</code>来解决TCP粘包导致的读半包问题。<br>其原理就是依次遍历ByteBuf中的可读字节，判断是否有”\n”或者“\r\n”,如果有，就以此为结束位置，从可读索引到结束位置区间的字节就组成了一行。</p><p>上面是采用分隔符的方式，我们还可以通过实现自己的编解码器利用定长包来处理粘包。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XDecoder</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//包的长度</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PACKET_SIZE = <span class="number">220</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用来临时保留没有处理过的请求报文</span></span><br><span class="line">  ByteBuf tempMsg = Unpooled.buffer();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> ctx</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> in 请求的数据</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> out 将粘在一起的报文拆分后的结果保留起来</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    System.out.println(Thread.currentThread() + <span class="string">"收到了一次数据包，长度是："</span> + in.readableBytes());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并报文</span></span><br><span class="line">    ByteBuf message = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> tmpMsgSize = tempMsg.readableBytes();</span><br><span class="line">    <span class="comment">// 如果暂存有上一次余下的请求报文，则合并</span></span><br><span class="line">    <span class="keyword">if</span> (tmpMsgSize &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      message = Unpooled.buffer();</span><br><span class="line">      message.writeBytes(tempMsg);</span><br><span class="line">      message.writeBytes(in);</span><br><span class="line">      System.out.println(<span class="string">"合并：上一数据包余下的长度为："</span> + tmpMsgSize + <span class="string">",合并后长度为:"</span> + message.readableBytes());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      message = in;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> size = message.readableBytes();</span><br><span class="line">    <span class="comment">//判断当前包含几个数据包</span></span><br><span class="line">    <span class="keyword">int</span> counter = size / PACKET_SIZE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; counter; i++) &#123;</span><br><span class="line">      <span class="keyword">byte</span>[] request = <span class="keyword">new</span> <span class="keyword">byte</span>[PACKET_SIZE];</span><br><span class="line">      <span class="comment">// 每次从总的消息中读取220个字节的数据</span></span><br><span class="line">      message.readBytes(request);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 将拆分后的结果放入out列表中，交由后面的业务逻辑去处理</span></span><br><span class="line">      out.add(Unpooled.copiedBuffer(request));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果有多余的报文则存起来</span></span><br><span class="line">    size = message.readableBytes();</span><br><span class="line">    <span class="keyword">if</span> (size != <span class="number">0</span>) &#123;</span><br><span class="line">      System.out.println(<span class="string">"多余的数据长度："</span> + size);</span><br><span class="line">      <span class="comment">// 剩下来的数据放到tempMsg暂存</span></span><br><span class="line">      tempMsg.clear();</span><br><span class="line">      tempMsg.writeBytes(message.readBytes(size));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2><span id="channelpipeline和channelhandler">ChannelPipeline和ChannelHandler</span></h2><h3><span id="channelpipeline是什么它有什么作用">ChannelPipeline是什么，它有什么作用？</span></h3><p>ChannelPipeline是ChannleHandler的容器，它负责ChannelHandler的管理和事件拦截与调度。</p><h3><span id="channlepipeline的事件处理">ChannlePipeline的事件处理</span></h3><p>下面梳理一下，一个消息被ChannelPipeline的ChannelHandler链拦截和处理的全过程。</p><ol><li>底层的SocketChannel read方法读取到ByteBuf，触发了ChannelRead事件，由IO线程NioEventLoop调用ChannelPipeline的fireChannelRead方法，将消息传输到ChannelPipeline中。</li><li>消息依次被Headhandler、ChannelHandler1，ChannelHandler2…TailHandler拦截和处理，在整个过程中，任何的ChannelHandler都可以中断当前的流程，结束消息的传递。</li><li>调用ChannelHandlerContext的write方法发送消息，消息从TailHandler开始，逆着拦截链传递，最终被添加到消息发送缓冲区中，等待刷新和发送。</li></ol><p><img src="https://s2.ax1x.com/2020/02/24/38zJnP.png" alt="38zJnP.png"></p><p>netty中的事件分为inbound事件和outbound事件。inbound事件通常由IO线程触发，例如TCP链路建立事件，链路关闭事件、读事件、异常通知事件等。而OUtbound事件通常是由用户主动发起的网络IO操作，例如用户发起的连接操作，绑定操作、消息发送等操作。</p><h3><span id="如何自定义拦截器">如何自定义拦截器</span></h3><p>ChannelPipeline通过ChannelHandler接口来实现事件的拦截和处理。因为我们往往只需要关系ChannelHandler接口中的一些事件，因此一般继承ChannelHandlerAdapter类覆盖自己关心的方法即可。</p><h3><span id="pipeline是如何构建的">pipeline是如何构建的</span></h3><p>在使用ServerBootstrap或者Bootstrap启动服务端或者客户端时，Netty会为每个Channel连接创建一个独立的pipeline。</p><h3><span id="channelpipeline的主要特性">ChannelPipeline的主要特性</span></h3><ul><li>ChannelPipeline支持运行态动态的添加或者删除ChannelHandler。</li><li>ChannelPipeline是线程安全的，这意味着N个业务线程可以并发的操作ChannelPipeline而不存在多线程并发问题。但是ChannelHandler却不是线程安全的。</li></ul><h3><span id="channelpipeline源码分析">ChannelPipeline源码分析</span></h3><h4><span id="类继承关系图">类继承关系图</span></h4><p><img src="https://s2.ax1x.com/2020/02/24/3GgEB6.png" alt="3GgEB6.png"></p><h4><span id="实现原理">实现原理</span></h4><p>我们以这行代码为例，来看一下，一个ChannelHandler是如何添加到ChannelPipeline中的。<br><code>pipeline.addLast(new MyByteToLongDecoder());</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">addLast</span><span class="params">(EventExecutorGroup executor, ChannelHandler... handlers)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (handlers == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"handlers"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (ChannelHandler h: handlers) &#123;</span><br><span class="line">        <span class="keyword">if</span> (h == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        addLast(executor, <span class="keyword">null</span>, h);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法主要做了参数校验，实际上最终是调用了<code>addLast(executor, null, h);</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">addLast</span><span class="params">(EventExecutorGroup group, String name, ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> AbstractChannelHandlerContext newCtx;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123; <span class="comment">//进行了方法同步，是线程安全的体现</span></span><br><span class="line">        <span class="comment">//判断该handler是否以及添加过了</span></span><br><span class="line">            checkMultiplicity(handler);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个新的AbstractChannelHandlerContext</span></span><br><span class="line">            newCtx = newContext(group, filterName(name, handler), handler);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将当前的Context添加到AbstractChannelHandlerContext链表尾部</span></span><br><span class="line">            addLast0(newCtx);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If the registered is false it means that the channel was not registered on an eventLoop yet.</span></span><br><span class="line">            <span class="comment">// In this case we add the context to the pipeline and add a task that will call</span></span><br><span class="line">            <span class="comment">// ChannelHandler.handlerAdded(...) once the channel is registered.</span></span><br><span class="line">            <span class="keyword">if</span> (!registered) &#123;</span><br><span class="line">                newCtx.setAddPending();</span><br><span class="line">                callHandlerCallbackLater(newCtx, <span class="keyword">true</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            EventExecutor executor = newCtx.executor();</span><br><span class="line">            <span class="keyword">if</span> (!executor.inEventLoop()) &#123;</span><br><span class="line">                callHandlerAddedInEventLoop(newCtx, executor);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        callHandlerAdded0(newCtx);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3><span id="channelhandler有什么作用">ChannelHandler有什么作用</span></h3><p>ChannelHandler类似于Servlet的Filter过滤器，负责对IO事件或者IO操作进行拦截和处理，它可以选择性的拦截和处理自己感兴趣的事件，也可以透传和终止事件的传递。<br>ChannelHandler支持注解。</p><ul><li>Sharable：多个ChannelPipeline公用一个ChannelHandler</li><li>Skip：被Skip注解的方法不会被调用，直接被忽略。</li></ul><h3><span id="channelhandleradapter有什么用">ChannelHandlerAdapter有什么用</span></h3><p>在实际开发中，ChannelHandler会选择性的拦截和处理。如果用户直接实现ChannelHandler接口就必须实现所有的方法，引入ChannelHandlerAdapter后用户只需要覆盖自己关心的方法即可。</p><h2><span id="什么是netty零拷贝">什么是Netty零拷贝</span></h2><p>Netty零拷贝主要包含三个方面：</p><ul><li>Netty的接收和发送ByteBUffer采用DIRECT BUFFERS，使用堆外的直接内存进行Socket读写，不需要进行字节缓冲区的二次拷贝。如果使用传统的堆内存进行Socket读写，JVM会将堆内存Buffer拷贝一份到直接内存中，然后才写入Socket中。</li><li>Netty提供了组合Buffer对象，可以聚合多个ByteBuffer对象，用户可以像操作一个Buffer那样方便的对组合Buffer进行操作，避免了传统的通过内存拷贝的方式将几个小Buffer合并成一个大的Buffer。</li><li>Netty的文件传输采用transferTo方法，它可以直接将文件缓冲区的数据发送到目标Channel，避免了传统通过循环write方式导致的内存拷贝问题。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是TCP粘包和拆包？&quot;&gt;&lt;a href=&quot;#什么是TCP粘包和拆包？&quot; class=&quot;headerlink&quot; title=&quot;什么是TCP粘包和拆包？&quot;&gt;&lt;/a&gt;什么是TCP粘包和拆包？&lt;/h2&gt;&lt;p&gt;TCP是一个“流”协议，所谓流就是没有界限的一串数据。TCP协议会根据TCP缓冲区的实际情况对包进行划分，所以业务上的一个包，可能被TCP拆分为多个包发送（拆包），多个小的包也可能被TCP合并为一个包进行发送（粘包）。&lt;/p&gt;
&lt;h2 id=&quot;TCP粘包和拆包发生的原因&quot;&gt;&lt;a href=&quot;#TCP粘包和拆包发生的原因&quot; class=&quot;headerlink&quot; title=&quot;TCP粘包和拆包发生的原因&quot;&gt;&lt;/a&gt;TCP粘包和拆包发生的原因&lt;/h2&gt;&lt;p&gt;原因有三个：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;应用程序write写入的字节大小大于套接字缓冲区的大小&lt;/li&gt;
&lt;li&gt;进行MSS（maximum segment size，最大分节大小，为TCP数据包每次传输的最大数据分段大小）大小的TCP分段&lt;/li&gt;
&lt;li&gt;以太帧的payload大于MTU（maximum transmission unit，最大传输单元，由硬件规定）进行IP分片
    
    </summary>
    
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="Netty" scheme="http://yoursite.com/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>Netty学习笔记一</title>
    <link href="http://yoursite.com/2020/02/21/Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/"/>
    <id>http://yoursite.com/2020/02/21/Netty学习笔记一/</id>
    <published>2020-02-21T13:30:00.000Z</published>
    <updated>2020-02-22T01:30:47.370Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="netty是是什么">Netty是是什么？</span></h2><p>Netty是基于NIO的客户，服务器端的编程框架，它提供了异步的、事件驱动的网络应用程序框架和工具，用以快速开发高性能、高可靠的网络服务器和客户端程序。</p><h2><span id="netty有什么特点">Netty有什么特点？</span></h2><p><img src="https://s2.ax1x.com/2020/02/19/3AHxQU.png" alt="3AHxQU.png"></p><a id="more"></a><h2><span id="io模型">IO模型</span></h2><h3><span id="bio">BIO</span></h3><p>同步阻塞IO，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理。适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中。<br>BIO是针对字节流和字符流的处理。</p><h3><span id="nio">NIO</span></h3><p>同步非阻塞，服务器实现模式为一个线程处理多个请求，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有IO请求就进行处理。适用于连接数目多且连接短的架构。<br>NIO是针对Channel和Buffer的处理。</p><h3><span id="aio">AIO</span></h3><p>异步非阻塞，AIO引入异步通道的概念，采用Proactor模式，简化了程序编写，有效的请求才启动线程，它的特点是由操作系统完成后才通知服务端程序启动线程去处理，一般适用于连接数较多且连接时间较长的应用。</p><h2><span id="通道channel和流有什么区别">通道（Channel）和流有什么区别？</span></h2><ul><li>通道是双向的，而流是单向的。</li><li>通道可以实现异步读写数据</li><li>通道可以从缓冲区读数据，也可以写数据到缓冲区。</li></ul><h2><span id="什么是零拷贝">什么是零拷贝？</span></h2><p>零拷贝是指计算机操作的过程中，CPU不需要为数据在内存之间的拷贝消耗资源。通常它是指计算机在网络上发送文件时，不需要将文件内容拷贝到用户空间，而直接在内核空间中传输到网络的方式，接收亦然。<br>零拷贝是网络编程的关键，许多性能优化都离不开。<br>在Java程序中常用的零拷贝有mmap（内存映射）和sendFile。<br>内存映射时间文件映射到内核缓冲区，同时用户空间可以共享内核空间的数据。<br>sendFile是linux2.1版本提供的一个新的函数，其原理是数据不经过用户态，直接从内核缓冲区直接进入到socket buffer，同时，由于和用户态完全无关，就减少了异常上下文切换。</p><p>NIO可以直接将一个通道中的数据传递（transferTo）到另一个通道，而不经过buffer实际就是零拷贝。</p><h2><span id="多路复用模式reactor和proactor是什么有什么区别">多路复用模式Reactor和Proactor是什么，有什么区别？</span></h2><p>在Reactor中，事件分离器负责等待文件描述符或者socket为读写操作准备就绪，然后将就绪事件传递给对应的处理器，最后由处理器负责完成实际的读写工作。本质就是IO事件触发时，通知我们主动去读取，也就是要我们主动将socket接收缓存中的数据读到应用进程内存中。<br>而在Proactor模式中，处理器或者事件分离器，只负责发起异步读写操作。IO操作本身由操作系统来完成。本质是当有数据包到达时，则写入到应用进程内的指定的buffer，然后通知我们接收了多少个字节。</p><p><strong>简单来讲就是Reactor关心就绪事件，比如可读了，就通知你。而Proactor关心的是完成，比如读完了，就通知你。</strong></p><h2><span id="为什么非阻塞io更快速-更经济">为什么非阻塞IO更快速、更经济？</span></h2><ul><li>非阻塞网络调用使得我们可以不比等待一个操作完成。</li><li>选择器使得我们能够使用更少的线程便可以监视许多连接上的事件。</li></ul><h2><span id="netty的核心组件">Netty的核心组件</span></h2><h3><span id="channel">Channel</span></h3><p>Channel是Java NIO的一个基本构造，它代表一个到实体的开发连接，如读操作和写操作。</p><h3><span id="回调">回调</span></h3><p>一个回调其实就是一个方法，一个指向已经被提供给另外一个方法的方法的引用。这使得后者可以在适当的时候调用前者。</p><h3><span id="future">Future</span></h3><p>Future提供了另一种子在操作完成时通知引用程序的方式。这个对象可以看作时一个异步操作的占位符；它将在未来的某个时刻完成，并提供对其结果的访问。<br>相比与jdk中的Future，Netty自己实现了ChannelFuture，用于在执行异步操作的时候使用。</p><h3><span id="事件和channelhandler">事件和Channelhandler</span></h3><p>Netty使用不同的事件来通知我们状态的改变或者是操作的状态。这使得我们能够基于已经发送的事件来触发适当的动作。</p><p>Netty是一个网络编程框架，所以事件是按照它们与入展或出站数据流的相关性进行分类的。可能由入站或相关的状态更改而触发的事件包括：</p><ul><li>连接被激活或连接失活</li><li>数据读取</li><li>用户事件</li><li>错误事件</li><li>打开或关闭到远程节点的连接</li><li>将数据写到或者冲刷到套接字</li></ul><h2><span id="channeleventloop和channelfuture">Channel，EventLoop和ChannelFuture</span></h2><p>Channel是对socket的封装，EventLoop是控制流、多线程处理、并发的封装。ChannelFuture是对异步通知的封装。</p><h3><span id="channel接口">Channel接口</span></h3><p>基本的IO操作依赖于底层的socket，而Netty的Channel提供了许多的API避免了直接使用Socket的复杂性。</p><h3><span id="eventloop接口">EventLoop接口</span></h3><p>EventLoop定义了Netty的核心抽象，用于处理连接的什么周期中所发送的事件。</p><p>Channel、EventLoop、Thread以及EventLoopGroup的关系是怎样的？</p><ul><li>EventLoopGroup可以包含多个EventLoopGroup</li><li>一个EventLoop只能与一个Thread绑定</li><li>一个Channel只能注册于一个EventLoop</li><li>一个EventLoop可能被给配给多个Channel</li></ul><h3><span id="channelfuture接口">ChannelFuture接口</span></h3><p>由于Netty中的IO操作都是异步的，因此一个操作可能不会立即返回，所以我们需要一种用于在之后的某个节点确定其结果的方法，为此Netty提供了ChannelFuture接口，其中addListener方法注册一个ChannelFutureListenerr，以便在某个操作完成时得到通知。</p><h2><span id="pipeline和channelpipeline">Pipeline和ChannelPipeline</span></h2><p>ChannelPipeline是一个Handler的集合，它负责处理和拦截inbound或者outbound的事件和操作。<br><img src="https://s2.ax1x.com/2020/02/21/3uj1Et.png" alt="3uj1Et.png"><br>入站事件和出站事件在一个双向链表中，入站事件会从链表头往后传递到最后入站的handler，出站事件会从链表尾往前传递到最前一个出站的handler。</p><h2><span id="netty所使用的io模型是什么">Netty所使用的IO模型是什么？</span></h2><p>Netty主要基于主从Reactors多线程模型。主从Reactors多线程模型有多个Reactor。<br><img src="https://s2.ax1x.com/2020/02/21/3n506f.png" alt></p><p>BossGroup和WorkerGroup是两组线程池，BoosGroup专门负责接收客户端连接，WorkerGroup专门负责网络读写操作。NIOEventloop表示一个不断循环执行处理任务的线程，每个NIOEventLoop都有一个selector，用于监听绑定在其上的socket网络通道。</p><ul><li>BossGroup线程维护Selector，只关注Accecpt</li><li>当接收到Accept事件就获取对应的SocketChannel，封装成NIOSocketChannel并注册到Worker线程（事件循环），并进行维护。</li><li>当Work而线程监听到selector中通道发送了自己该兴趣的事件后，就使用handler进行处理。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Netty是是什么？&quot;&gt;&lt;a href=&quot;#Netty是是什么？&quot; class=&quot;headerlink&quot; title=&quot;Netty是是什么？&quot;&gt;&lt;/a&gt;Netty是是什么？&lt;/h2&gt;&lt;p&gt;Netty是基于NIO的客户，服务器端的编程框架，它提供了异步的、事件驱动的网络应用程序框架和工具，用以快速开发高性能、高可靠的网络服务器和客户端程序。&lt;/p&gt;
&lt;h2 id=&quot;Netty有什么特点？&quot;&gt;&lt;a href=&quot;#Netty有什么特点？&quot; class=&quot;headerlink&quot; title=&quot;Netty有什么特点？&quot;&gt;&lt;/a&gt;Netty有什么特点？&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2020/02/19/3AHxQU.png&quot; alt=&quot;3AHxQU.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="Netty" scheme="http://yoursite.com/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>挑战面试题一</title>
    <link href="http://yoursite.com/2020/02/13/%E6%8C%91%E6%88%98%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%80/"/>
    <id>http://yoursite.com/2020/02/13/挑战面试题一/</id>
    <published>2020-02-13T13:07:00.000Z</published>
    <updated>2020-02-13T13:08:17.153Z</updated>
    
    <content type="html"><![CDATA[<p><em>所有面试题都是从网上收集的，知识面比较广，可能有重复的题目。所有的答案都是我自己查阅资料加上自己的理解所写的，难免有不详之处，希望大家不吝赐教！</em></p><h3><span id="volatile的底层如何实现怎么就能保住可见性了">volatile的底层如何实现，怎么就能保住可见性了？</span></h3><p><code>volatile</code>关键字修饰的变量可以确保内存可见性，禁止指令重排序。<br><code>volatile</code>修饰的变量不允许线程内存cache缓存和重排序，线程读取数据的时候直接读取内存，同时<code>volatile</code>不会对变量加锁，因此性能会比<code>synchronized</code>好。<br>还有一种说法是：读取一个<code>volatile</code>关键字会使相应的处理器执行刷新处理器缓存的动作，写一个<code>volatile</code>关键字会使得相应的处理器执行冲刷处理器缓存的动作。</p><p>拓展：<br>假如我们有一个使用<code>volatile</code>的变量<code>instance</code>.有如下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">instance = <span class="keyword">new</span> Singleton();</span><br></pre></td></tr></table></figure></p><p>它的汇编代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x01a3de1d: movb $0x0,0x1104800(%esi);</span><br><span class="line">0x01a3de24: lock  addl $0x0,(%esp); //使用volatile修饰的变量会多这行</span><br></pre></td></tr></table></figure></p><p>使用<code>lock</code>前缀的指令会引发两件事情：</p><ul><li>将当前处理器缓存含的数据写回到系统内存</li><li>这个写回内存的操作回引起在其它CPU里缓存了该内存地址的数据无效</li></ul><a id="more"></a><h3><span id="线程池有哪些创建方式">线程池有哪些创建方式</span></h3><p>线程池的创建方式有两种：</p><ul><li>使用<code>ThreadPoolExecutor</code>类创建。使用该方法创建时，参数比较复杂可以参考<a href="https://zofun.github.io/2020/01/17/ThreadPoolExecutor%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">ThreadPoolExecutor源码分析 </a></li><li>使用<code>Executor</code>类。具体的创建方法可参考下一个问题。</li></ul><h3><span id="有哪些线程池的类型">有哪些线程池的类型</span></h3><ul><li><code>ExecutorService fixedExecutor = Executors.newFixedThreadPool(3);</code><br>定长线程池，每当提交一个任务就创建一个线程，知道达到线程池的最大数量，这时线程数量不再变化，当线程发送错误结束时，线程池会补充一个新的线程。</li><li><code>ExecutorService cachedExecutor = Executors.newCachedThreadPool();</code><br>可缓存的线程池，如果线程池的容量超过了任务数，自动回收空闲线程，任务增加时可以自动添加新线程，线程池的容量不限制。</li><li><code>ScheduledExecutorService scheduledExecutor = Executors.newScheduledThreadPool(3);</code><br>定长线程池，可执行周期性的任务</li><li><code>ExecutorService singleExecutor = Executors.newSingleThreadExecutor();</code><br>单线程线程池，线程异常结束，会创建一个新的线程，能确保任务按提交顺序执行</li><li><code>ScheduledExecutorService singleScheduledExecutor = Executors.newSingleThreadScheduledExecutor();</code><br>单线程可执行周期性任务的线程池。</li><li><code>ExecutorService workStealingExecutor = Executors.newWorkStealingPool();</code><br>任务窃取线程池，不保证执行顺序，适合任务耗时差异较大。</li></ul><h3><span id="线程池中linkedblockingqueue满了的话线程会怎么样">线程池中LinkedBlockingQueue满了的话，线程会怎么样</span></h3><p>需要分两种情况：</p><ol><li>如果当前运行的线程数大于核心线程数且小于最大线程数，那么就会新建线程。</li><li>如果当前运行的线程数已经达到了最大线程数，那么就会执行拒绝策略。</li></ol><p>拓展：<br>JDK内置了4种拒绝策略，我们也可以继承<code>RejectedExcutionHandler</code>实现自己的拒绝策略。<br>内置的4种拒绝策略分别是：</p><ul><li><code>AbortPolicy</code>：直接抛出异常（默认）</li><li><code>CallerRunsPolicy</code>：直接在execute方法的调用线程中运行拒绝的任务；如果执行程序已关闭，则会丢弃该任务。</li><li><code>DiscardPolicy</code>：直接丢弃任务。</li><li><code>DiscardOldestPolicy</code>:丢弃队列中等待时间最长的任务（即队头），然后运行当前的任务。</li></ul><h3><span id="线程池的底层原理和实现方法">线程池的底层原理和实现方法</span></h3><p>在线程池中每个线程都被封装成为了一个<code>Worker</code>对象。在线程池内部比较重要的两个属性是一个存放所有线程的<code>workers:HashSet</code>,和阻塞队列。当有任务提交的时候，首先会判断当前线程数是否小于核心线程数，如果当前线程数小于核心线程数，那么就创建一个新的线程(将任务和线程封装为一个<code>Worker</code>)并运行线程，否则将任务添加到等待队列，等待工作线程依次从队列中取出任务执行。如果等待队列已满且工作线程数已经达到最大线程数了，那么就会执行拒绝策略。</p><h3><span id="线程之间的交互方式有哪些">线程之间的交互方式有哪些？</span></h3><p>线程之间的通信方式有4种：</p><ul><li>共享变量</li><li>wait/notify机制</li><li>Lock/Condition机制</li><li>管道</li></ul><h3><span id="java锁机制都说一下~">Java锁机制，都说一下~</span></h3><p>Java提供了两种枷锁的方法：</p><ul><li>synchronized关键字</li><li>显示Lock</li></ul><p>拓展：<br>synchronized关键字的实现原理是通过JVM进入、退出对象监视器(Monitor)来实现对方法、同步块的同步的，而对象监视器的本质是依赖于操作系统的互斥锁Mutex Lock 实现的。从jdk1.6之后，对sychronized关键字进行了优化，为了能够减少获取和释放锁的消耗引入了偏向锁和轻量级锁。</p><p>引入偏向锁是为了避免在无多线程竞争的条件下的轻量级锁的执行路径。<br><strong>偏向锁的获取过程：</strong></p><ol><li>判断对象头的Mark Word标志是否处于偏向锁状态。</li><li>如果为偏向锁状态，继续判断线程ID是否指向当前线程。如果线程ID指向当前线程ID，则跳到5）</li><li>如果线程ID没有指向当前线程，则通过CAS操作竞争锁。如果竞争成功，则将线程ID设置为当前线程ID。</li><li>如果竞争失败，则等待到达全局安全点时，得到偏向锁的线程就会挂起，偏向锁升级为轻量级锁，然后被阻塞的线程继续执行。</li><li>执行同步代码。</li></ol><p><strong>偏向锁的释放过程</strong><br>偏向锁只由在遇到其它线程竞争偏向锁时，持有偏向锁的线程才会释放锁。</p><p>提出轻量级锁的目的是在没有多少线程竞争的前提下，减少传统的重量级锁锁使用所产生的性能消耗。</p><p><strong>轻量级锁的加锁过程：</strong></p><ol><li>首先通过对象头的mark word字段判断是否是无锁状态，如果是无锁状态，那么虚拟机会在当前线程的栈帧中建立一个名为锁记录的空间，用于存储锁对象目前的Mark Word的拷贝。</li><li>拷贝对象头中的mark word到锁记录中。</li><li>虚拟机尝试通过CAS将对象的Mark Word更新为指向当前线程的锁记录指针，并将当前线程的锁记录中的owner指向mark word。</li><li>如果更新成功，表明当前线程获得了该对象的锁，并且设置对象的Mark Word的为轻量级锁锁定状态。</li><li>如果更新失败，虚拟机会检查对象的mark word是否指向当前线程的栈帧，如果是则说明当前线程已经拥有了对象的锁。否则说明存在多个线程竞争锁，轻量级锁就升级为重量级锁（使用互斥量），修改锁标志位重量级锁，mark word中存储了指向互斥量的指针，后面等待的线程进入阻塞状态，当前线程使用自旋来获取锁。</li></ol><p>并且在1.6之后，还增加了<strong>自适应自旋</strong>，减少了CAS操作时自旋的成本。即如果某个锁自旋很少就成功获得，那么下一次就会减少自旋。</p><p>编译器还会进行<strong>锁消除</strong>优化，消除没有必要的加锁。<br>我们在编写代码的时候，尽量减少同步的范围，即<strong>锁粗化</strong>。</p><p>而显示Lock都是基于AQS实现的。比如：ReentrantLock。关于AQS我在另一篇博客中有详细介绍<a href="https://zofun.github.io/2020/01/10/ReentrantLock%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">AQS</a></p><h3><span id="除了responsebodycontroller层如何标准返回给前端所要的数据类型你会怎么实现">除了@ResponseBody，controller层如何标准返回给前端所要的数据类型？你会怎么实现？</span></h3><p>还可以自定义消息转化器，通过继承<code>AbstractHttpMessageConverter</code>重写其中的方法，并注入的Spring容器即可。</p><p><em>目前只想到了这一种</em></p><h3><span id="异常捕获处理">异常捕获处理</span></h3><p>Java异常Throwable分为两类，一类是Error，一类是Exception。Error是编程时需要避免的，程序无法处理的。而Exception就是我们平常需要处理异常。除了Exception下的RunTimeException及其子类都是可查异常，即编译器要求必须捕获的异常。<br>对于异常有三种处理方案：<br>一种是通过try，catch进行捕获，一种是定义方法的时候通过throws关键字声明，表明该方法不处理该异常，交由调用方处理。最后一种就是通过throw关键字抛出异常。</p><h3><span id="redis的缓存淘汰策略有哪些">Redis的缓存淘汰策略有哪些？</span></h3><p>Redis的缓存淘汰策略有6种，它们分别是：</p><ul><li>noeviction：不删除策略，达到最大内存限制时，如果需要更多的内存，直接返回错误信息。</li><li>allkeys-lru：对于所有的key优先删除最近最少使用的key。</li><li>allkeys-random：对于所有的key，随机删除一部分。</li><li>volatile-random：只限于设置了expore的部分，删除一部分expire的key</li><li>volatile-ttl：只限于设置了expire的部分，优先删除剩余时间（TTL）短的key。</li><li>volatile-lru：只限于色湖之了expore的部分，删除最近最少使用的key。</li></ul><h3><span id="java内存模型说一下">Java内存模型说一下</span></h3><p>Java内存分为：虚拟机栈，本地方法栈，程序计数器，方法区，堆区。</p><p>在JVM启动的时候首先会分配好方法区和堆区。程序计数器，虚拟机栈，本地方法栈都是线程私有的。</p><h3><span id="mybatis如何进行类型转换">mybatis如何进行类型转换</span></h3><p>Mybatis的</p><h3><span id="mybatis的xml有什么标签">mybatis的xml有什么标签</span></h3><p>定义sql语句的：insert，delete,updata,select<br>结果集映射的：resultMap<br>动态sql：foreach，if，choose<br>格式化输出：where，set，trim<br>配置关联关系：collection，association<br>定义sql片段：sql</p><h3><span id="mysql锁机制">MySQL锁机制</span></h3><p>以我们平常经常使用的innoDB存储引擎为例，主要有七种类型的锁： 共享/排他锁，意向锁，记录锁，间隙锁，临键锁，插入意向锁，自增锁。<br><a href="https://www.cnblogs.com/volcano-liu/p/9890832.html" target="_blank" rel="noopener">https://www.cnblogs.com/volcano-liu/p/9890832.html</a></p><h3><span id="如何修改linux的文件权限">如何修改linux的文件权限</span></h3><p>修改文件的权限可以使用<code>chmod</code>命令。<br>比如：设置text.txt所有人可读<br><code>chmod ugo+r file.txt</code><br>u表示文件拥有者，g表示与文件的拥有者同一组人，o表示其它以外的人，a表示所有人。<br>+，-表示增加，取消权限，=表示唯一设定<br>r读，w写，x可执行</p><h3><span id="jvm的回收算法">jvm的回收算法</span></h3><p>标记清除算法，标记整理算法，复制算法，分代收集算法。<br>标记清除算法首先标记需要回收的对象，在标记完成后同一回收。<br>标记整理算法首先标记出需要回收的对象，然后让存活的对象向一端移动，最后清除掉边界以外的部分。<br>复制算法将内存划分为大小相等的两个部分，每次只使用其中一部分，内存回收时将存活的对象复制到另一个部分，然后再把使用过的一半内存清理掉。<br>分代收集算法根据对象不同的存活周期将内存划分为几块，一般划分为新生代和老年代。然后再根据不同分代对象的特点选用不同的回收算法。</p><h3><span id="数据库有哪些索引">数据库有哪些索引？</span></h3><p>以我们常见的mysql为例，有5种索引。它们分别是主键索引，唯一索引，普通索引，全文索引，联合索引。</p><p>拓展：<br>当我们为表设置主键的时候，则该类就是主键索引。当然也可以在建表之后添加：<br><code>alter table table_name add primary key (colum_name)</code></p><p>普通索引一般是在建表后再添加：<br><code>alter table table_name add index index_name(colum_name1,colum_name2)</code></p><p>全文索引主要针对文本文件，在mysql5.6之前只有MyISAM支持，后来InnoDB也支持全文索引。</p><p>唯一索引可以有多个空值，但是不能重复。相比于主键，主键不能重复也不能有空值。</p><h3><span id="如何防止sql注入">如何防止sql注入</span></h3><p>使用预编译语句避免拼接sql，限制数据库权限，避免直接向用户显示错误信息</p><h3><span id="抽象类和接口有什么不同">抽象类和接口有什么不同</span></h3><ul><li>抽象类是用来继承而接口是用来实现的。</li><li>接口中的所有方法都必须是抽象方法，而抽象类中即可以包含抽象方法也可以包含非抽象的方法。</li><li>接口中声明的成员变量都是final的，而抽象类则没有限制。</li><li>接口中的方法默认是public的，而抽象类方法的访问权限可以任意指定。</li><li>类可以实现多个接口，但是只能继承一个抽象类。</li><li>抽象类可以在不实现接口方法的情况下实现接口。</li></ul><h3><span id="mysql间歇锁的实现原理">mysql间歇锁的实现原理</span></h3><p>间歇锁是innodb在可重复读提交下为了解决幻读问题而引入的锁机制，它是一种行锁。间隙锁会锁定一个范围但是不包含记录本身。<br>间隙锁会根据检索添加向左寻找最靠近检索条件的记录值A，作为左区间，向右寻找最靠近检索添加的记录值B作为右区间，即锁定的间隙为[A，记录），（记录，B]。<br><a href="https://www.jianshu.com/p/32904ee07e56" target="_blank" rel="noopener">https://www.jianshu.com/p/32904ee07e56</a></p><h3><span id="future的底层实现异步原理">future的底层实现异步原理</span></h3><p>Future表示异步的计算结果，它提供了检查计算结果是否完成的方法以及等待计算的完成，并获取计算的结果。计算完成后可以通过get方法获取，如果有必要可以阻塞该方法知道计算完成。</p><h3><span id="多线程讲一下futuretask">多线程讲一下，FutureTask</span></h3><p>Future表示一个任务的生命周期，是一个可取消的异步运算。FutureTask提供了Future的最基础的实现。它的内部有一个<code>Callable</code>任务，一个执行任务的线程，一个保存等待线程的栈，和一个用于保存结果或异常的<code>Object</code>对象.当调用get方法获取结果的时，如果任务未完成就假如等待栈中，知道计算完毕后唤醒。</p><h3><span id="乐观锁和悲观锁">乐观锁和悲观锁</span></h3><p>悲观锁采用“先取锁再访问”的保守策略，使用悲观锁会增加数据库的开销，还带来了死锁的分享。而乐观锁不会刻意去依赖锁，而是利用数据本身来保证数据恶的正确性。乐观锁的一种常见实现就是通过给数据加上版本号，类似CAS的思想。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;所有面试题都是从网上收集的，知识面比较广，可能有重复的题目。所有的答案都是我自己查阅资料加上自己的理解所写的，难免有不详之处，希望大家不吝赐教！&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&quot;volatile的底层如何实现，怎么就能保住可见性了？&quot;&gt;&lt;a href=&quot;#volatile的底层如何实现，怎么就能保住可见性了？&quot; class=&quot;headerlink&quot; title=&quot;volatile的底层如何实现，怎么就能保住可见性了？&quot;&gt;&lt;/a&gt;volatile的底层如何实现，怎么就能保住可见性了？&lt;/h3&gt;&lt;p&gt;&lt;code&gt;volatile&lt;/code&gt;关键字修饰的变量可以确保内存可见性，禁止指令重排序。&lt;br&gt;&lt;code&gt;volatile&lt;/code&gt;修饰的变量不允许线程内存cache缓存和重排序，线程读取数据的时候直接读取内存，同时&lt;code&gt;volatile&lt;/code&gt;不会对变量加锁，因此性能会比&lt;code&gt;synchronized&lt;/code&gt;好。&lt;br&gt;还有一种说法是：读取一个&lt;code&gt;volatile&lt;/code&gt;关键字会使相应的处理器执行刷新处理器缓存的动作，写一个&lt;code&gt;volatile&lt;/code&gt;关键字会使得相应的处理器执行冲刷处理器缓存的动作。&lt;/p&gt;
&lt;p&gt;拓展：&lt;br&gt;假如我们有一个使用&lt;code&gt;volatile&lt;/code&gt;的变量&lt;code&gt;instance&lt;/code&gt;.有如下代码：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;instance = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Singleton();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;它的汇编代码如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;0x01a3de1d: movb $0x0,0x1104800(%esi);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;0x01a3de24: lock  addl $0x0,(%esp); //使用volatile修饰的变量会多这行&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;lock&lt;/code&gt;前缀的指令会引发两件事情：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将当前处理器缓存含的数据写回到系统内存&lt;/li&gt;
&lt;li&gt;这个写回内存的操作回引起在其它CPU里缓存了该内存地址的数据无效&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Linux常用命令</title>
    <link href="http://yoursite.com/2020/02/12/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2020/02/12/Linux常用命令/</id>
    <published>2020-02-12T09:45:00.000Z</published>
    <updated>2020-02-12T09:46:03.030Z</updated>
    
    <content type="html"><![CDATA[<h3><span id="查找文件">查找文件</span></h3><p><code>find / -name filename.txt</code><br>查找/目录下名字为filename.txt的文件。</p><p><code>find / -iname filename.txt</code><br>忽略大小写。（忽略大小写都是在添加i）</p><p><code>find /usr/ -path &quot;*local*&quot;</code><br>匹配路径</p><p><a href="https://man.linuxde.net/find" target="_blank" rel="noopener">find</a></p><h3><span id="终止线程">终止线程</span></h3><p><code>kill -9 19979</code><br>强制终止线程号为19979的线程</p><p><a href="https://man.linuxde.net/kill" target="_blank" rel="noopener">kill</a></p><h3><span id="查看一个程序是否运行">查看一个程序是否运行</span></h3><p><code>ps -ef|grep tomcat</code><br>查看所有与tomcat相关的进程<br><a href="https://man.linuxde.net/ps" target="_blank" rel="noopener">ps</a><br><a href="https://man.linuxde.net/grep" target="_blank" rel="noopener">grep</a></p><h3><span id="查看所有的文件包含隐藏文件">查看所有的文件包含隐藏文件</span></h3><p><code>ls -a</code></p><h3><span id="创建和删除目录">创建和删除目录</span></h3><p><code>mkdir newfolder</code><br><code>rmdir deleteEmptyFilder</code></p><h3><span id="压缩和解压文件">压缩和解压文件</span></h3><p>压缩：<br><code>tar -czf test.tar.gz /test</code><br>解压:<br><code>tar -xvzf test.tar.gz</code></p><h3><span id="修改文件的权限">修改文件的权限</span></h3><p><code>chmod u+x,g+w,o-x filename.txt</code><br>r读取属性，w写入属性，x执行属性，u文件所有者，g与文件同组的用户，o其它用户。</p><h3><span id="删除文件包括其子文件">删除文件包括其子文件</span></h3><p><code>rm -rf deleteFile</code></p><h3><span id="移动文件">移动文件</span></h3><p><code>mv /temp/movefile /targetFolder</code></p><h3><span id="复制文件到指定的目录">复制文件到指定的目录</span></h3><p><code>cp -r sourceFolder targetFolder</code></p><h3><span id="查看文件尾10行">查看文件尾10行</span></h3><p><code>tail -n 10 file.txt</code></p><h3><span id="查看日志文件">查看日志文件</span></h3><p><code>tail -f logfile.log</code><br>该命令工会自动显示新增的内容。</p><h3><span id="查看线程个数">查看线程个数</span></h3><p><code>ps -Lf 端口号 |wc -l</code></p><p><a href="https://man.linuxde.net/ps" target="_blank" rel="noopener">ps</a></p><h3><span id="查看内存cpu占用命令">查看内存，CPU占用命令</span></h3><p><code>top</code> 查看CPU占用情况<br><code>free -m</code>查看内存占用情况<br><code>vmstat 3(间隔时间) 100（监控次数）</code>查看CPU和内存的占用</p><h3><span id="查看端口占用情况">查看端口占用情况</span></h3><p><code>netstat -anp |grep 3306</code> 查看特定端口3306的进程<br><code>lsof -i:3306</code> 查看某个端口是否被占用</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3&gt;&lt;span id=&quot;查找文件&quot;&gt;查找文件&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;code&gt;find / -name filename.txt&lt;/code&gt;&lt;br&gt;查找/目录下名字为filename.txt的文件。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;find / -iname filena
      
    
    </summary>
    
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC源码分析之一个请求的处理</title>
    <link href="http://yoursite.com/2020/02/06/SpringMVC%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E4%B8%80%E4%B8%AA%E8%AF%B7%E6%B1%82%E7%9A%84%E5%A4%84%E7%90%86/"/>
    <id>http://yoursite.com/2020/02/06/SpringMVC源码分析之一个请求的处理/</id>
    <published>2020-02-06T07:08:00.000Z</published>
    <updated>2020-02-26T02:58:20.406Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="概述">概述</span></h2><p>SpringMVC是一种web层的mvc框架，用于替代Servlet，主要用于处理和相应请求，获取表单参数，表单校验。使用SpringMVC可以简化编程。</p><h2><span id="springmvc底层的执行流程">SpringMVC底层的执行流程</span></h2><p>首先通过一张流传广泛的图，来了解一下大致的流程。<br><img src="https://s2.ax1x.com/2020/02/05/1rJAu4.png" alt="1rJAu4.png"><br><a id="more"></a></p><p>从这张图可以看出，整个请求的入口是<code>DispatcherServlet</code>类。之所以请求的入口会是这个类是因为我们在配置springmvc的时候在<code>web.xml</code>中，将所有的请求都交由<code>DispatcherServlet</code>处理了。<br>请求到达<code>DispatcherServlet</code>类首先由<code>void doService(HttpServletRequest request, HttpServletResponse response)</code>处理的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doService</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//省略了打印日志的代码</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//attributesSnapshot一个用于保存请求快照的map</span></span><br><span class="line">Map&lt;String, Object&gt; attributesSnapshot = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (WebUtils.isIncludeRequest(request)) &#123;</span><br><span class="line"><span class="comment">//如果包含请求，就将request中的所有的属性存放到map中</span></span><br><span class="line">attributesSnapshot = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">Enumeration&lt;?&gt; attrNames = request.getAttributeNames();</span><br><span class="line"><span class="keyword">while</span> (attrNames.hasMoreElements()) &#123;</span><br><span class="line">String attrName = (String) attrNames.nextElement();</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.cleanupAfterInclude || attrName.startsWith(<span class="string">"org.springframework.web.servlet"</span>)) &#123;</span><br><span class="line">attributesSnapshot.put(attrName, request.getAttribute(attrName));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将一些对象设置到request中</span></span><br><span class="line">request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, getWebApplicationContext());</span><br><span class="line">request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, <span class="keyword">this</span>.localeResolver);</span><br><span class="line">request.setAttribute(THEME_RESOLVER_ATTRIBUTE, <span class="keyword">this</span>.themeResolver);</span><br><span class="line">request.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*FlashMap中保存的是上次转发请求中的属性*/</span></span><br><span class="line">FlashMap inputFlashMap = <span class="keyword">this</span>.flashMapManager.retrieveAndUpdate(request, response);</span><br><span class="line"><span class="comment">/*首先判断FlashMap中是否有数据，如果有数据就先设置到inputFlashMap中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span> (inputFlashMap != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">/*如果inputFlashMap不为空，一般代表上一次请求（一般是重定向）</span></span><br><span class="line"><span class="comment">中设置了参数，那么就吧这些参数存放到当前请求的FlashMap中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap));</span><br><span class="line">&#125;</span><br><span class="line">request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, <span class="keyword">new</span> FlashMap());</span><br><span class="line">request.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, <span class="keyword">this</span>.flashMapManager);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//调用doDispatch</span></span><br><span class="line">doDispatch(request, response);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123;</span><br><span class="line"><span class="comment">// Restore the original attribute snapshot, in case of an include.</span></span><br><span class="line"><span class="keyword">if</span> (attributesSnapshot != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//恢复请求参数的快照</span></span><br><span class="line">restoreAttributesAfterInclude(request, attributesSnapshot);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过对<code>doService</code>方法源码的分析，我们可以知道整个方法所做了三件事情：</p><ol><li>快照请求中的属性到<code>attributesSnapshot</code></li><li>将一些组件设置到request中，方便之后使用</li><li>处理FlashMap</li><li>调用<code>doDispatch(request, response)</code> </li><li><code>doDispatch(request, response)</code> 调用完成后利用<code>attributesSnapshot</code>对request中的属性进行还原</li></ol><p><code>doService</code>还没有真正的进行请求的处理，它所做的事情只是一些准备工作。</p><p>下面我们看<code>doDispatch(request, response)</code>到底做了什么事情：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">HttpServletRequest processedRequest = request;</span><br><span class="line">HandlerExecutionChain mappedHandler = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">boolean</span> multipartRequestParsed = <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取异步请求处理器管理器</span></span><br><span class="line">WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">ModelAndView mv = <span class="keyword">null</span>;</span><br><span class="line">Exception dispatchException = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//判断是否是Multipart请求</span></span><br><span class="line">processedRequest = checkMultipart(request);</span><br><span class="line"><span class="comment">//判断是否有多部分请求</span></span><br><span class="line">multipartRequestParsed = (processedRequest != request);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 确定当前请求的处理程序</span></span><br><span class="line">mappedHandler = getHandler(processedRequest);</span><br><span class="line"><span class="keyword">if</span> (mappedHandler == <span class="keyword">null</span> || mappedHandler.getHandler() == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//如果没找到当前请求的处理程序</span></span><br><span class="line">noHandlerFound(processedRequest, response);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据Handler找到对应的HandleAdapter</span></span><br><span class="line">HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Process last-modified header, if supported by the handler.</span></span><br><span class="line"><span class="comment">//获取请求的类型</span></span><br><span class="line">String method = request.getMethod();</span><br><span class="line"><span class="keyword">boolean</span> isGet = <span class="string">"GET"</span>.equals(method);</span><br><span class="line"><span class="keyword">if</span> (isGet || <span class="string">"HEAD"</span>.equals(method)) &#123;</span><br><span class="line"><span class="keyword">long</span> lastModified = ha.getLastModified(request, mappedHandler.getHandler());</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Last-Modified value for ["</span> + getRequestUri(request) + <span class="string">"] is: "</span> + lastModified);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">new</span> ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用HandlerAdapter处理请求，返回ModleAndView对象</span></span><br><span class="line">mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//设置默认视图名字</span></span><br><span class="line">applyDefaultViewName(request, mv);</span><br><span class="line"><span class="comment">//应用拦截器的后置处理方法</span></span><br><span class="line">mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">dispatchException = ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果处理</span></span><br><span class="line">processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line"><span class="comment">//触发完成后的回调</span></span><br><span class="line">triggerAfterCompletion(processedRequest, response, mappedHandler, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Error err) &#123;</span><br><span class="line"><span class="comment">//触发出现错误的回调</span></span><br><span class="line">triggerAfterCompletionWithError(processedRequest, response, mappedHandler, err);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line"><span class="comment">// Instead of postHandle and afterCompletion</span></span><br><span class="line"><span class="keyword">if</span> (mappedHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Clean up any resources used by a multipart request.</span></span><br><span class="line"><span class="keyword">if</span> (multipartRequestParsed) &#123;</span><br><span class="line">cleanupMultipart(processedRequest);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>doDispatch</code>的执行步骤大致可以分为三个部分：</p><ol><li>根据request找到对应的Handler</li><li>根据找到的Handler找到对应的HandlerAdapter</li><li>用HandlerAdapter调用Handler处理请求</li><li>调用processDispatcheResult方法处理Handler处理之后的结果</li></ol><p>这4个步骤内部又完成了许多非常复杂的操作。下面我们就依次解析。</p><p><strong>1. <code>doDispatch</code>是如何通过request找到对应的Handler的？</strong><br>寻找对应的Handler实际上是由<code>mappedHandler = getHandler(processedRequest);</code>完成的。</p><p>它的具体实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> HandlerExecutionChain <span class="title">getHandler</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (HandlerMapping hm : <span class="keyword">this</span>.handlerMappings) &#123;</span><br><span class="line">HandlerExecutionChain handler = hm.getHandler(request);</span><br><span class="line"><span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> handler;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>去掉了打印日志的代码后，逻辑显得非常的简单。遍历<code>handlerMappings</code>，尝试从每一个<code>HandlerMapping</code>获取handler，一旦拿到就直接返回。<br>这里又有一个疑问：<code>handlerMappings</code>到底是什么？<br>它的声明如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** List of HandlerMappings used by this servlet */</span></span><br><span class="line"><span class="keyword">private</span> List&lt;HandlerMapping&gt; handlerMappings;</span><br></pre></td></tr></table></figure></p><p>而<code>HandlerMapping</code>其实比较复杂。它的整个架构设计图如下：<br><img src="https://s2.ax1x.com/2020/02/05/1rOyIU.png" alt="1rOyIU.png"><br>它的顶层接口<code>HandlerMapping</code>如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HandlerMapping</span> </span>&#123;</span><br><span class="line">String PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE = HandlerMapping.class.getName() + <span class="string">".pathWithinHandlerMapping"</span>;</span><br><span class="line"></span><br><span class="line">String BEST_MATCHING_PATTERN_ATTRIBUTE = HandlerMapping.class.getName() + <span class="string">".bestMatchingPattern"</span>;</span><br><span class="line"></span><br><span class="line">String INTROSPECT_TYPE_LEVEL_MAPPING = HandlerMapping.class.getName() + <span class="string">".introspectTypeLevelMapping"</span>;</span><br><span class="line"></span><br><span class="line">String URI_TEMPLATE_VARIABLES_ATTRIBUTE = HandlerMapping.class.getName() + <span class="string">".uriTemplateVariables"</span>;</span><br><span class="line"></span><br><span class="line">String MATRIX_VARIABLES_ATTRIBUTE = HandlerMapping.class.getName() + <span class="string">".matrixVariables"</span>;</span><br><span class="line"></span><br><span class="line">String PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE = HandlerMapping.class.getName() + <span class="string">".producibleMediaTypes"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">HandlerExecutionChain <span class="title">getHandler</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>简单的讲就是<code>HandlerMapping</code>中的<code>getHandler</code>方法会返回一个<code>HandlerExecutionChain</code>对象，该对象封装了一个Handler处理对象和一些interctptors（拦截器）。<br>下面是一个<code>HandlerExecutionChain</code>对象的属性：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Object handler;</span><br><span class="line"><span class="keyword">private</span> HandlerInterceptor[] interceptors;</span><br><span class="line"><span class="keyword">private</span> List&lt;HandlerInterceptor&gt; interceptorList;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> interceptorIndex = -<span class="number">1</span>;</span><br></pre></td></tr></table></figure></p><p><strong>2. <code>doDispatch</code>是如何通过Handler找到HandlerAdapter的，以及什么是HandlerAdapter？</strong></p><p>实现用<code>Handler</code>获取<code>HandlerAdapter</code>的代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</span><br></pre></td></tr></table></figure></p><p>它的具体实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> HandlerAdapter <span class="title">getHandlerAdapter</span><span class="params">(Object handler)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (HandlerAdapter ha : <span class="keyword">this</span>.handlerAdapters) &#123;</span><br><span class="line"><span class="keyword">if</span> (ha.supports(handler)) &#123;</span><br><span class="line"><span class="keyword">return</span> ha;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ServletException(<span class="string">"No adapter for handler ["</span> + handler +</span><br><span class="line"><span class="string">"]: The DispatcherServlet configuration needs to include a HandlerAdapter that supports this handler"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>去掉打印日志的方法后，我们可以发现，这个方法和根据request获取Handler的方法非常的一致。因此我们将重点放在：什么是<code>HandlerAdapter</code>上。<br><code>HandlerAdapter</code>接口声明如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HandlerAdapter</span> </span>&#123;</span><br><span class="line"><span class="comment">//查看当前的HandlerAdapter是否支持该handler解析</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Object handler)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用Handler处理请求</span></span><br><span class="line"><span class="function">ModelAndView <span class="title">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">getLastModified</span><span class="params">(HttpServletRequest request, Object handler)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>之所以需要HandlerAdapter，是因为Handler的格式是不固定的，所以处理请求的时候需要HandlerAdapter做适配。</p><p>拿到<code>HandlerAdapter</code>，就可做处理请求了。<br><code>mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</code><br>处理请求后就拿到了一个<code>ModelAndView</code>对象。</p><p>具体的代码实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最终拿到了我们的Controller类</span></span><br><span class="line">Class&lt;?&gt; clazz = ClassUtils.getUserClass(handler);</span><br><span class="line"><span class="comment">//判断是否使用了@SessionAttributes</span></span><br><span class="line">Boolean annotatedWithSessionAttributes = <span class="keyword">this</span>.sessionAnnotatedClassesCache.get(clazz);</span><br><span class="line"><span class="keyword">if</span> (annotatedWithSessionAttributes == <span class="keyword">null</span>) &#123;</span><br><span class="line">annotatedWithSessionAttributes = (AnnotationUtils.findAnnotation(clazz, SessionAttributes.class) != <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">this</span>.sessionAnnotatedClassesCache.put(clazz, annotatedWithSessionAttributes);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (annotatedWithSessionAttributes) &#123;</span><br><span class="line"><span class="comment">// Always prevent caching in case of session attribute management.</span></span><br><span class="line">checkAndPrepare(request, response, <span class="keyword">this</span>.cacheSecondsForSessionAttributeHandlers, <span class="keyword">true</span>);</span><br><span class="line"><span class="comment">// Prepare cached set of session attributes names.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 禁用缓存</span></span><br><span class="line">checkAndPrepare(request, response, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Execute invokeHandlerMethod in synchronized block if required.</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.synchronizeOnSession) &#123;</span><br><span class="line">HttpSession session = request.getSession(<span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">if</span> (session != <span class="keyword">null</span>) &#123;</span><br><span class="line">Object mutex = WebUtils.getSessionMutex(session);</span><br><span class="line"><span class="keyword">synchronized</span> (mutex) &#123;</span><br><span class="line"><span class="keyword">return</span> invokeHandlerMethod(request, response, handler);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> invokeHandlerMethod(request, response, handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最终又来到了<code>invokehandlerMethod</code>方法了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ModelAndView <span class="title">invokeHandlerMethod</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">ServletHandlerMethodResolver methodResolver = getMethodResolver(handler);</span><br><span class="line"><span class="comment">//获取处理请求的方法</span></span><br><span class="line">Method handlerMethod = methodResolver.resolveHandlerMethod(request);</span><br><span class="line"><span class="comment">//创建各种组件</span></span><br><span class="line">ServletHandlerMethodInvoker methodInvoker = <span class="keyword">new</span> ServletHandlerMethodInvoker(methodResolver);</span><br><span class="line">ServletWebRequest webRequest = <span class="keyword">new</span> ServletWebRequest(request, response);</span><br><span class="line">ExtendedModelMap implicitModel = <span class="keyword">new</span> BindingAwareModelMap();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用方法拿到结果</span></span><br><span class="line">Object result = methodInvoker.invokeHandlerMethod(handlerMethod, handler, webRequest, implicitModel);</span><br><span class="line"><span class="comment">//获取ModelAndView</span></span><br><span class="line">ModelAndView mav =</span><br><span class="line">methodInvoker.getModelAndView(handlerMethod, handler.getClass(), result, implicitModel, webRequest);</span><br><span class="line"><span class="comment">//更新view中的属性</span></span><br><span class="line">methodInvoker.updateModelAttributes(handler, (mav != <span class="keyword">null</span> ? mav.getModel() : <span class="keyword">null</span>), implicitModel, webRequest);</span><br><span class="line"><span class="keyword">return</span> mav;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后调用<code>mappedHandler.applyPostHandle(processedRequest, response, mv);</code>进行后处理。后处理的过程就是调用所有的后置拦截器进行处理。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;SpringMVC是一种web层的mvc框架，用于替代Servlet，主要用于处理和相应请求，获取表单参数，表单校验。使用SpringMVC可以简化编程。&lt;/p&gt;
&lt;h2 id=&quot;SpringMVC底层的执行流程&quot;&gt;&lt;a href=&quot;#SpringMVC底层的执行流程&quot; class=&quot;headerlink&quot; title=&quot;SpringMVC底层的执行流程&quot;&gt;&lt;/a&gt;SpringMVC底层的执行流程&lt;/h2&gt;&lt;p&gt;首先通过一张流传广泛的图，来了解一下大致的流程。&lt;br&gt;&lt;img src=&quot;https://s2.ax1x.com/2020/02/05/1rJAu4.png&quot; alt=&quot;1rJAu4.png&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="源码" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="SpringMVC" scheme="http://yoursite.com/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC源码分析一</title>
    <link href="http://yoursite.com/2020/02/05/SpringMVC%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%80/"/>
    <id>http://yoursite.com/2020/02/05/SpringMVC源码分析一/</id>
    <published>2020-02-05T02:01:00.000Z</published>
    <updated>2020-02-26T02:58:22.497Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="什么是servlet">什么是Servlet？</span></h2><p>Servlet实际是Server+Applet的缩写，表示一个服务器应用。Servlet是JavaEE规范的一部分。</p><p>在Servlet3.1中，它的结构图如下：<br><img src="https://s2.ax1x.com/2020/01/31/18mZLV.png" alt="18mZLV.png"></p><a id="more"></a><p>Servlet接口定义如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Servlet</span></span>&#123;</span><br><span class="line">    <span class="comment">/*这个方法在容器启动的时候被容器调用，</span></span><br><span class="line"><span class="comment">    但是当load-on-startup设置为负数或者不设置的时候，</span></span><br><span class="line"><span class="comment">    是在Servlet第一次被用到的时候调用*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> nServletException</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*用于获取ServletConfig*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletConfig <span class="title">getServletConfig</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/*用于处理具体的请求*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req,ServletResponse res)</span> <span class="keyword">throws</span> ServletException,IOException</span>;</span><br><span class="line">    <span class="comment">/*获取Servlet的相关信息，如作者等，默认实现返回空串*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getServletInfo</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*在Servlet销毁的时候（关闭服务器）调用，用于释放资源，只会调用一次*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在<code>init(ServletConfig config)</code>调用的时候，需要一个<code>ServletConfig</code>对象，这个对象中存放了初始化Servlet的信息，其中一部分就来自于我们的配置文件中的<code>&lt;init-param&gt;</code><br>标签下的内容。<br><img src="https://s2.ax1x.com/2020/02/01/18gtns.png" alt="18gtns.png"></p><p>ServletConfig接口的定义如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ServletConfig</span></span>&#123;</span><br><span class="line">    <span class="comment">/*返回的就是我们配置的servlet-name*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getServletName</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/*这个地方返回的ServletContext代表的就是我们这个应用本身*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletContext <span class="title">getServletContext</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*用于获取init-param配置的参数*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getInitParameter</span><span class="params">(String name)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Enumeration&lt;String&gt; <span class="title">getInitParameterNames</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2><span id="tomcat的顶层结构">Tomcat的顶层结构</span></h2><p>Tomcat最顶层的是Server，代表整个服务器，Server中至少包含一个Service，用于提供具体的服务。一个Service主要包含两个部分，分别是Connector和Container。  Connector用于处理连接相关的事情，并提供Socket与request、response的转化，Container用于封装和管理Servlet，以及剧吐处理request请求。一个Service中可以有多个connectors，但是只有一个Container。<br><img src="https://s2.ax1x.com/2020/02/01/18hYTA.png" alt="18hYTA.png"></p><p>Tomcat中的server由org.apache.catalina.startup.Catalina来管理，它是整个Tomcat的管理类，它里面包含了load，start，stop方法，分别用来管理整个服务器的生命周期。load方法会根据conf/server.xml创建Server并调用Server的init方法进行初始化，start方法用于启动服务器，stop方法用于停止服务器。<br>在启动的时候会逐层调用这些方法。<br>Tomcat虽然由Catalina管理，但是Tomcat的main却在org.qpache.catalina.startup.Bootstrap中，Bootstrap的作用类似一个CatalinaAdaptor，具体的处理过程还是使用Catalina来进行的，这样将启动类和管理类分开，可以更加方便地拓展启动方式。</p><h3><span id="bootstrap的启动过程">Bootstrap的启动过程</span></h3><p>启动tomcat首先就是调用Bootstrap的main方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (daemonLock) &#123;</span><br><span class="line">            <span class="keyword">if</span> (daemon == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="comment">//初始化一个启动器</span></span><br><span class="line">                Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//创建了catalina实例，并且赋值给了catalinaDaemon变量</span></span><br><span class="line">                    bootstrap.init();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    handleThrowable(t);</span><br><span class="line">                    t.printStackTrace();</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                daemon = bootstrap;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// When running as a service the call to stop will be on a new</span></span><br><span class="line">                <span class="comment">// thread so make sure the correct class loader is used to</span></span><br><span class="line">                <span class="comment">// prevent a range of class not found exceptions.</span></span><br><span class="line">                Thread.currentThread().setContextClassLoader(daemon.catalinaLoader);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理main方法传入的命令</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String command = <span class="string">"start"</span>;</span><br><span class="line">            <span class="keyword">if</span> (args.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                command = args[args.length - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (command.equals(<span class="string">"startd"</span>)) &#123;</span><br><span class="line">                args[args.length - <span class="number">1</span>] = <span class="string">"start"</span>;</span><br><span class="line">               </span><br><span class="line">                daemon.load(args);</span><br><span class="line">                daemon.start();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (command.equals(<span class="string">"stopd"</span>)) &#123;</span><br><span class="line">                args[args.length - <span class="number">1</span>] = <span class="string">"stop"</span>;</span><br><span class="line">                daemon.stop();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (command.equals(<span class="string">"start"</span>)) &#123;</span><br><span class="line">             <span class="comment">//处理启动命令</span></span><br><span class="line">            <span class="comment">//这里的三个方法都调用了Catalina的相关方法</span></span><br><span class="line">                daemon.setAwait(<span class="keyword">true</span>);</span><br><span class="line">                daemon.load(args);</span><br><span class="line">                daemon.start();</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == daemon.getServer()) &#123;</span><br><span class="line">                    System.exit(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (command.equals(<span class="string">"stop"</span>)) &#123;</span><br><span class="line">                daemon.stopServer(args);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (command.equals(<span class="string">"configtest"</span>)) &#123;</span><br><span class="line">                daemon.load(args);</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == daemon.getServer()) &#123;</span><br><span class="line">                    System.exit(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                System.exit(<span class="number">0</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                log.warn(<span class="string">"Bootstrap: command \""</span> + command + <span class="string">"\" does not exist."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="comment">// Unwrap the Exception for clearer error reporting</span></span><br><span class="line">            <span class="keyword">if</span> (t <span class="keyword">instanceof</span> InvocationTargetException &amp;&amp;</span><br><span class="line">                    t.getCause() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                t = t.getCause();</span><br><span class="line">            &#125;</span><br><span class="line">            handleThrowable(t);</span><br><span class="line">            t.printStackTrace();</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h3><span id="catalina的启动过程">Catalina的启动过程</span></h3><p>通过对Bootstrap启动类的分析，我们可以知道，启动Catalina主要是通过以下三个方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置Server启动完成后是否立即进入等待状态的标志</span></span><br><span class="line">daemon.setAwait(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">//加载配置文件，创建并初始化Server</span></span><br><span class="line">daemon.load(args);</span><br><span class="line"><span class="comment">//启动服务器</span></span><br><span class="line">daemon.start();</span><br></pre></td></tr></table></figure></p><p>在Bootstrap中这三个方法的实现其实都是利用反射调用了Catalina中的相应的方法，我们直接查看Catalina中的实现。<br>下面我们依次看这三个方法的具体实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAwait</span><span class="params">(<span class="keyword">boolean</span> b)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//这个方法仅仅是设置了一个标志位，表示启动后是否立即进入等待状态</span></span><br><span class="line">    await = b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">load</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (loaded) &#123;</span><br><span class="line">    <span class="comment">//如果已经load过了，就返回</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置标志位，表示已经加载过了</span></span><br><span class="line">    loaded = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//用于记录启动耗时</span></span><br><span class="line">    <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//下面的代码都是用来创建Server的</span></span><br><span class="line">    initDirs();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Before digester - it may be needed</span></span><br><span class="line">    initNaming();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用Digester解析conf/server.xml文件创建了Server对象，</span></span><br><span class="line">    <span class="comment">//并赋值给了Server属性</span></span><br><span class="line">    <span class="comment">// Set configuration source</span></span><br><span class="line">    ConfigFileLoader.setSource(<span class="keyword">new</span> CatalinaBaseConfigurationSource(Bootstrap.getCatalinaBaseFile(), getConfigFile()));</span><br><span class="line">    File file = configFile();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create and execute our Digester</span></span><br><span class="line">    Digester digester = createStartDigester();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> (ConfigurationSource.Resource resource = ConfigFileLoader.getSource().getServerXml()) &#123;</span><br><span class="line">        InputStream inputStream = resource.getInputStream();</span><br><span class="line">        InputSource inputSource = <span class="keyword">new</span> InputSource(resource.getURI().toURL().toString());</span><br><span class="line">        inputSource.setByteStream(inputStream);</span><br><span class="line">        digester.push(<span class="keyword">this</span>);</span><br><span class="line">        digester.parse(inputSource);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.warn(sm.getString(<span class="string">"catalina.configFail"</span>, file.getAbsolutePath()), e);</span><br><span class="line">        <span class="keyword">if</span> (file.exists() &amp;&amp; !file.canRead()) &#123;</span><br><span class="line">            log.warn(sm.getString(<span class="string">"catalina.incorrectPermissions"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getServer().setCatalina(<span class="keyword">this</span>);</span><br><span class="line">    getServer().setCatalinaHome(Bootstrap.getCatalinaHomeFile());</span><br><span class="line">    getServer().setCatalinaBase(Bootstrap.getCatalinaBaseFile());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Stream redirection</span></span><br><span class="line">    initStreams();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start the new server</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        getServer().init();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (LifecycleException e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Boolean.getBoolean(<span class="string">"org.apache.catalina.startup.EXIT_ON_INIT_FAILURE"</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> java.lang.Error(e);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.error(sm.getString(<span class="string">"catalina.initError"</span>), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> t2 = System.nanoTime();</span><br><span class="line">    <span class="keyword">if</span>(log.isInfoEnabled()) &#123;</span><br><span class="line">        log.info(sm.getString(<span class="string">"catalina.init"</span>, Long.valueOf((t2 - t1) / <span class="number">1000000</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (getServer() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        load();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (getServer() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        log.fatal(sm.getString(<span class="string">"catalina.noServer"</span>));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start the new server</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//调用Server的start方法，启动服务器</span></span><br><span class="line">        getServer().start();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (LifecycleException e) &#123;</span><br><span class="line">        log.fatal(sm.getString(<span class="string">"catalina.serverStartFail"</span>), e);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            getServer().destroy();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (LifecycleException e1) &#123;</span><br><span class="line">            log.debug(<span class="string">"destroy() failed for failed Server "</span>, e1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> t2 = System.nanoTime();</span><br><span class="line">    <span class="keyword">if</span>(log.isInfoEnabled()) &#123;</span><br><span class="line">        log.info(sm.getString(<span class="string">"catalina.startup"</span>, Long.valueOf((t2 - t1) / <span class="number">1000000</span>)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册关闭钩爪代码</span></span><br><span class="line">    <span class="keyword">if</span> (useShutdownHook) &#123;</span><br><span class="line">        <span class="keyword">if</span> (shutdownHook == <span class="keyword">null</span>) &#123;</span><br><span class="line">            shutdownHook = <span class="keyword">new</span> CatalinaShutdownHook();</span><br><span class="line">        &#125;</span><br><span class="line">        Runtime.getRuntime().addShutdownHook(shutdownHook);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If JULI is being used, disable JULI's shutdown hook since</span></span><br><span class="line">        <span class="comment">// shutdown hooks run in parallel and log messages may be lost</span></span><br><span class="line">        <span class="comment">// if JULI's hook completes before the CatalinaShutdownHook()</span></span><br><span class="line">        LogManager logManager = LogManager.getLogManager();</span><br><span class="line">        <span class="keyword">if</span> (logManager <span class="keyword">instanceof</span> ClassLoaderLogManager) &#123;</span><br><span class="line">            ((ClassLoaderLogManager) logManager).setUseShutdownHook(</span><br><span class="line">                    <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//更加await的值确定是否进入等待状态</span></span><br><span class="line">    <span class="keyword">if</span> (await) &#123;</span><br><span class="line">        await();</span><br><span class="line">        stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个Server的启动过程如下，首先设置启动后是否进入等待的标志位，然后调用load方法来加载配置文件，创建Server对象，最后调用server对象的start方法来启动服务器，最后再注册服务器关闭的钩爪函数，根据之前设置的标志位决定是否进入等待状态。</p><h3><span id="server的启动过程">Server的启动过程</span></h3><p>Server接口中提供了<code>addServer(Server service)</code>，<code>removeService(Service service)</code>来添加和删除Service。Server的init方法和start方法，分配循环调用了每个Service的init方法和start方法以此来启动所有的Service。</p><p>Server的默认实现是<code>org/apache/catalina/core/StandardServer.java</code><br><code>class StandardServer extends LifecycleMBeanBase implements Server</code></p><p>Server继承了<code>LifecycleBeanBase</code>，init和start方法就是在<code>LifecycleBeanBase</code>的父类<code>LifecycleBase</code>中定义的。<br>StandardServer中的<code>initInternal</code>和<code>startInternal</code>方法就是Tomcate生命周期的管理方式。<br>这两个方法的内部主要就是向下面一样，依次调用所有的Service的相应的方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (servicesLock) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; services.length; i++) &#123;</span><br><span class="line">                services[i].start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p><h3><span id="service的启动过程">Service的启动过程</span></h3><p>Service的默认实现是<code>org.apache.catalina.core.StandardService</code>,<br><code>class StandardService extends LifecycleMBeanBase implements Service</code><br>它同样也是继承自<code>LifecycleMBeanBase</code>类的，所以init和start方法最终就会调用<code>initInternal</code>和<code>startInternal</code>方法。<br>这两个方法的具体实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">startInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(log.isInfoEnabled())</span><br><span class="line">            log.info(sm.getString(<span class="string">"standardService.start.name"</span>, <span class="keyword">this</span>.name));</span><br><span class="line">        setState(LifecycleState.STARTING);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Start our defined Container first</span></span><br><span class="line">        <span class="keyword">if</span> (engine != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (engine) &#123;</span><br><span class="line">            <span class="comment">//调用engine的start方法</span></span><br><span class="line">                engine.start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (executors) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Executor executor: executors) &#123;</span><br><span class="line">                executor.start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mapperListener.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Start our defined Connectors second</span></span><br><span class="line">        <span class="keyword">synchronized</span> (connectorsLock) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Connector connector: connectors) &#123;</span><br><span class="line">                <span class="comment">// If it has already failed, don't try and start it</span></span><br><span class="line">                <span class="keyword">if</span> (connector.getState() != LifecycleState.FAILED) &#123;</span><br><span class="line">                    connector.start();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>以<code>startInternal</code>为例，<code>startInternal</code>和<code>initInternal</code>方法内部主要是调用container,executors,mapperListener,connectors的init和start方法。其中executors的作用主要是管理线程池。</p><p>整个Tomcat服务器的启动流程图如下：<br><img src="https://s2.ax1x.com/2020/02/01/1Gha80.png" alt="1Gha80.png"></p><h2><span id="tomcat的生命周期管理">Tomcat的生命周期管理</span></h2><p>Tomcat的生命周期管理是由<code>org.apache.catalina.lifecycle</code>接口来定义的。<br>该接口主要完成3件事情：</p><ol><li>定义了13个string类型的常量，用于LifecycleEvent事件的type属性，作用是区分组件发出的LifecycleEvent事件的状态。</li><li>定义了3个管理监听器的方法，addLifecycleListener,findLifecycleListeners和removeLifecycleListener.</li><li>定义了4个生命周期方法,init,start,stop,destory</li><li>定义了获取当前状态的两个方法getState和getStateName</li></ol><p>LifecycleBase是LifecycleBase接口的默认实现。而监听器的管理是由<code>LifecycleSupport</code>类来完成的。</p><p>以<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (LifecycleState.STARTING_PREP.equals(state) || LifecycleState.STARTING.equals(state) ||</span><br><span class="line">            LifecycleState.STARTED.equals(state)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">            Exception e = <span class="keyword">new</span> LifecycleException();</span><br><span class="line">            log.debug(sm.getString(<span class="string">"lifecycleBase.alreadyStarted"</span>, toString()), e);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (log.isInfoEnabled()) &#123;</span><br><span class="line">            log.info(sm.getString(<span class="string">"lifecycleBase.alreadyStarted"</span>, toString()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调整状态</span></span><br><span class="line">    <span class="keyword">if</span> (state.equals(LifecycleState.NEW)) &#123;</span><br><span class="line">        init();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state.equals(LifecycleState.FAILED)) &#123;</span><br><span class="line">        stop();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!state.equals(LifecycleState.INITIALIZED) &amp;&amp;</span><br><span class="line">            !state.equals(LifecycleState.STOPPED)) &#123;</span><br><span class="line">        invalidTransition(Lifecycle.BEFORE_START_EVENT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    </span><br><span class="line">        setStateInternal(LifecycleState.STARTING_PREP, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//调用相应的模板方法</span></span><br><span class="line">        startInternal();</span><br><span class="line">        <span class="keyword">if</span> (state.equals(LifecycleState.FAILED)) &#123;</span><br><span class="line">            <span class="comment">// This is a 'controlled' failure. The component put itself into the</span></span><br><span class="line">            <span class="comment">// FAILED state so call stop() to complete the clean-up.</span></span><br><span class="line">            stop();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!state.equals(LifecycleState.STARTING)) &#123;</span><br><span class="line">            <span class="comment">// Shouldn't be necessary but acts as a check that sub-classes are</span></span><br><span class="line">            <span class="comment">// doing what they are supposed to.</span></span><br><span class="line">            invalidTransition(Lifecycle.AFTER_START_EVENT);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            setStateInternal(LifecycleState.STARTED, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="comment">// This is an 'uncontrolled' failure so put the component into the</span></span><br><span class="line">        <span class="comment">// FAILED state and throw an exception.</span></span><br><span class="line">        handleSubClassException(t, <span class="string">"lifecycleBase.startFail"</span>, toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个方法的实现时，首先会判断当前状态和要处理的方法是否匹配，如果不匹配会执行相应的方法使其匹配，然后再调用相应的模板方法并设置状态。</p><h2><span id="container分析">Container分析</span></h2><p>Container时tomcat容器的接口。Container一共有4个子接口Engine、Host、Context、Wrapper和一个默认实现类ContainerBase.每个子接口都是一个容器。</p><p><img src="https://s2.ax1x.com/2020/02/01/1GXJVx.png" alt="1GXJVx.png"></p><p>Container的子容器Engine，Host，Context，Wrapper是逐层包含的关系。<br><img src="https://s2.ax1x.com/2020/02/01/1GXwxH.png" alt="1GXwxH.png"></p><ul><li>Engine：引擎，用于管理多个站点，一个Service最多只能有一个Engine。</li><li>Host：代表一个站点，也称为虚拟主机，通过配置host就可以添加站点。</li><li>Context：代表一个应用程序，对应着平时开发的一个程序，或WEB-INF下的一个web.xml文件</li><li>Wrapper：每个Wrapper封装着一个Servlet。</li></ul><h2><span id="connector分析">Connector分析</span></h2><p>Connector用于接收请求并将请求封装成Request和Response来具体处理，最底层是使用Socket来进行连接的，Request和Response是按照HTTP协议来封装的，所以Connecter同时实现了TCP/IP协议和HTTP协议，Request和Response封装完之后交给Container进行处理。Container就是Servlet的容器，Container处理完之后返回给Connector，最后Connector使用Socker将结果返回给客户端，这样整个请求就处理完成了。<br><img src="https://s2.ax1x.com/2020/02/02/1YM9Zn.png" alt="1YM9Zn.png"></p><p>Connector具体是使用ProtocolHandler来处理请求的，不同的ProtocolHandler代表不同的连接类型。ProtocolHandler里面有3个组件：Endpoint，Processor和Adapter。Endpoint用于处理底层的Socket网络连接，Processor用于将Endpoint接收到的Socket封装成为Request，Adapter负责将请求适配到Servlet容器进行具体的处理。</p><h2><span id="springmvc的启动过程">SpringMVC的启动过程</span></h2><h3><span id="springmvc的结构">SpringMVC的结构</span></h3><p><img src="https://s2.ax1x.com/2020/02/03/1NTGcj.png" alt="1NTGcj.png"></p><p>spring部分的EnvironmentAware和ApplicationContextAware接口，都是继承自Aware接口的，在spring中XXXAware接口表示对XXX可感知的，继承相应的接口然后实现setXXX方法，就可以拿到相应的对象。比如继承EnvironmentAware接口并实现setEnvironment就可以拿到spring中的Environment对象了，spring会自动注入。</p><p>而EnvironmentCapable接口就是告诉spring自己可以提供Environment，实现它其中唯一的一个方法<code>Environment getEnvironment()</code></p><p>而我们分析SpringMVC的启动过程主要就是分析HttpServletBean，FrameworkServlet，DispatcherServlet三个类。</p><h3><span id="httpservletbean">HttpServletBean</span></h3><p>通过之前的分析我们知道Servlet的创建首先会调用无参的init方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Initializing servlet '"</span> + getServletName() + <span class="string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set bean properties from init parameters.</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//将Servlet中配置的信息封装到pvs变量中</span></span><br><span class="line">PropertyValues pvs = <span class="keyword">new</span> ServletConfigPropertyValues(getServletConfig(), <span class="keyword">this</span>.requiredProperties);</span><br><span class="line">BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(<span class="keyword">this</span>);</span><br><span class="line">ResourceLoader resourceLoader = <span class="keyword">new</span> ServletContextResourceLoader(getServletContext());</span><br><span class="line">bw.registerCustomEditor(Resource.class, <span class="keyword">new</span> ResourceEditor(resourceLoader, getEnvironment()));</span><br><span class="line"><span class="comment">//模板方法，可以在子类调用，做一些初始化的工作。</span></span><br><span class="line">initBeanWrapper(bw);</span><br><span class="line"><span class="comment">//将配置的初始化值设置到DispatchcherServlet中</span></span><br><span class="line">bw.setPropertyValues(pvs, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">logger.error(<span class="string">"Failed to set bean properties on servlet '"</span> + getServletName() + <span class="string">"'"</span>, ex);</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Let subclasses do whatever initialization they like.</span></span><br><span class="line"><span class="comment">//模板方法，子类初始化的入口方法</span></span><br><span class="line">initServletBean();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Servlet '"</span> + getServletName() + <span class="string">"' configured successfully"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在HttpServletBean的init方法中，首先将Serlvet中配置的参数（封装到了pvs中）使用BeanWrapper（Spring提供的用来操作javaBean属性的工具，使用它可以直接修改一个对象的属性）设置到DispatcherServle的相关属性，然后调用模板方法initServletBean，子类就通过这个方法初始化。</p><h3><span id="frameworkserlvet">FrameworkSerlvet</span></h3><p>从HttpServletBean的init流程，我们可以知道FrameworkServlet的初始化入口方法应该是<code>initServletBean</code>.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">initServletBean</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">getServletContext().log(<span class="string">"Initializing Spring FrameworkServlet '"</span> + getServletName() + <span class="string">"'"</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.logger.isInfoEnabled()) &#123;</span><br><span class="line"><span class="keyword">this</span>.logger.info(<span class="string">"FrameworkServlet '"</span> + getServletName() + <span class="string">"': initialization started"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//初始化WebApplicationContext</span></span><br><span class="line"><span class="keyword">this</span>.webApplicationContext = initWebApplicationContext();</span><br><span class="line"><span class="comment">//调用模板方法，初始化FrameworkServlet</span></span><br><span class="line">initFrameworkServlet();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ServletException ex) &#123;</span><br><span class="line"><span class="keyword">this</span>.logger.error(<span class="string">"Context initialization failed"</span>, ex);</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (RuntimeException ex) &#123;</span><br><span class="line"><span class="keyword">this</span>.logger.error(<span class="string">"Context initialization failed"</span>, ex);</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.logger.isInfoEnabled()) &#123;</span><br><span class="line"><span class="keyword">long</span> elapsedTime = System.currentTimeMillis() - startTime;</span><br><span class="line"><span class="keyword">this</span>.logger.info(<span class="string">"FrameworkServlet '"</span> + getServletName() + <span class="string">"': initialization completed in "</span> +</span><br><span class="line">elapsedTime + <span class="string">" ms"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>用于初始化WebApplicationContext的<code>initWebApplicationContext();</code>方法的实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> WebApplicationContext <span class="title">initWebApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取rootContext</span></span><br><span class="line">WebApplicationContext rootContext =</span><br><span class="line">WebApplicationContextUtils.getWebApplicationContext(getServletContext());</span><br><span class="line">WebApplicationContext wac = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果已经通过构造方法设置了webApplicationContext</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.webApplicationContext != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// A context instance was injected at construction time -&gt; use it</span></span><br><span class="line">wac = <span class="keyword">this</span>.webApplicationContext;</span><br><span class="line"><span class="keyword">if</span> (wac <span class="keyword">instanceof</span> ConfigurableWebApplicationContext) &#123;</span><br><span class="line">ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) wac;</span><br><span class="line"><span class="keyword">if</span> (!cwac.isActive()) &#123;</span><br><span class="line"><span class="comment">// The context has not yet been refreshed -&gt; provide services such as</span></span><br><span class="line"><span class="comment">// setting the parent context, setting the application context id, etc</span></span><br><span class="line"><span class="keyword">if</span> (cwac.getParent() == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// The context instance was injected without an explicit parent -&gt; set</span></span><br><span class="line"><span class="comment">// the root application context (if any; may be null) as the parent</span></span><br><span class="line">cwac.setParent(rootContext);</span><br><span class="line">&#125;</span><br><span class="line">configureAndRefreshWebApplicationContext(cwac);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (wac == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// No context instance was injected at construction time -&gt; see if one</span></span><br><span class="line"><span class="comment">// has been registered in the servlet context. If one exists, it is assumed</span></span><br><span class="line"><span class="comment">// that the parent context (if any) has already been set and that the</span></span><br><span class="line"><span class="comment">// user has performed any initialization such as setting the context id</span></span><br><span class="line"><span class="comment">//当webApplicationContext已经存在ServletContext中时，</span></span><br><span class="line"><span class="comment">//通过配置在Servlet中的contextAttribute参数获取</span></span><br><span class="line">wac = findWebApplicationContext();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (wac == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// No context instance is defined for this servlet -&gt; create a local one</span></span><br><span class="line"><span class="comment">//如果webApplicationContext还没看有创建，则创建一个</span></span><br><span class="line">wac = createWebApplicationContext(rootContext);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.refreshEventReceived) &#123;</span><br><span class="line"><span class="comment">// Either the context is not a ConfigurableApplicationContext with refresh</span></span><br><span class="line"><span class="comment">// support or the context injected at construction time had already been</span></span><br><span class="line"><span class="comment">// refreshed -&gt; trigger initial onRefresh manually here.</span></span><br><span class="line"><span class="comment">//当contextRefreshedEvent事件没有触发时调用此模板方法</span></span><br><span class="line">onRefresh(wac);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.publishContext) &#123;</span><br><span class="line"><span class="comment">// Publish the context as a servlet context attribute.</span></span><br><span class="line"><span class="comment">//将ApplicatinoContext保存到ServletContext中</span></span><br><span class="line">String attrName = getServletContextAttributeName();</span><br><span class="line">getServletContext().setAttribute(attrName, wac);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line"><span class="keyword">this</span>.logger.debug(<span class="string">"Published WebApplicationContext of servlet '"</span> + getServletName() +</span><br><span class="line"><span class="string">"' as ServletContext attribute with name ["</span> + attrName + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> wac;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>initWebApplicationContext()</code>方法做了三件事情：</p><ol><li>获取spring的根容器rootContext</li><li>设置webApplicationContext并根据情况调用onRefresh方法</li><li>将webApplicationContext设置到ServletContext中</li></ol><h3><span id="dispatcherservlet">DispatcherServlet</span></h3><p>onRefresh方法时DispatcherServlet的入口方法。OnRefresh中简单的调用了initStrategies，在initStrategies中调用了9个初始化方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRefresh</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line">initStrategies(context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initStrategies</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line">initMultipartResolver(context);</span><br><span class="line">initLocaleResolver(context);</span><br><span class="line">initThemeResolver(context);</span><br><span class="line">initHandlerMappings(context);</span><br><span class="line">initHandlerAdapters(context);</span><br><span class="line">initHandlerExceptionResolvers(context);</span><br><span class="line">initRequestToViewNameTranslator(context);</span><br><span class="line">initViewResolvers(context);</span><br><span class="line">initFlashMapManager(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是Servlet？&quot;&gt;&lt;a href=&quot;#什么是Servlet？&quot; class=&quot;headerlink&quot; title=&quot;什么是Servlet？&quot;&gt;&lt;/a&gt;什么是Servlet？&lt;/h2&gt;&lt;p&gt;Servlet实际是Server+Applet的缩写，表示一个服务器应用。Servlet是JavaEE规范的一部分。&lt;/p&gt;
&lt;p&gt;在Servlet3.1中，它的结构图如下：&lt;br&gt;&lt;img src=&quot;https://s2.ax1x.com/2020/01/31/18mZLV.png&quot; alt=&quot;18mZLV.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="源码" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="SpringMVC" scheme="http://yoursite.com/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>对秒杀系统的一些思考</title>
    <link href="http://yoursite.com/2020/01/28/%E5%AF%B9%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/"/>
    <id>http://yoursite.com/2020/01/28/对秒杀系统的一些思考/</id>
    <published>2020-01-28T08:43:56.000Z</published>
    <updated>2020-01-28T13:51:03.504Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="秒杀系统的特点">秒杀系统的特点</span></h2><ul><li>高性能：秒杀涉及到大量的并发读和并发写，因此支持高并发访问这点非常的关键。</li><li>一致性：秒杀是有限数量的商品在同一时刻被很多倍的请求同时来减库存，在大并发更新的过程中都要保证数据的准确性。</li><li>高可用：秒杀时会在瞬间涌入大量的流量，为了避免系统宕机，保证高可用，需要做好流量限制。</li></ul><a id="more"></a><h2><span id="秒杀系统的优化思路">秒杀系统的优化思路</span></h2><h3><span id="后端优化">后端优化</span></h3><ol><li>限流：秒杀系统往往是多于商品数量数倍的请求来抢购，我们可以屏蔽掉无用的流量，允许少部分流量走后端。</li><li>削峰：秒杀请求在时间上高度集中于某一个时间点，随时的流量很容易压垮系统，因此需要对流量进行削峰处理，缓冲瞬时流量，尽量让服务器平缓的处理这些请求。</li><li>异步：将同步请求转化为异步请求，来提高并发量。</li><li>利用缓存：创建订单时，每次都需要先查询判断库存，只有少部分成功的请求才会创建订单，因此可以将商品信息放在缓存中，减少数据库查询。</li><li>负载均衡：利用Nginx进行负载均衡，减轻单个服务器的压力。</li></ol><h3><span id="前端优化">前端优化</span></h3><ol><li>限流：前端答题或验证码来分散用户的请求。</li><li>禁止重复提交：限定每个用户发起一次秒杀之后，需要等待才可以发起另一次请求，从而减少重复的用户请求。</li><li>本地标记：当用户成功秒杀到商品后，禁止用户再次提交请求。</li><li>动静分离：将前端静态数据直接缓存到离用户最近的地方，比如用户浏览器、CDN或者服务器的缓存中。</li></ol><h3><span id="防作弊优化">防作弊优化</span></h3><ol><li>隐藏秒杀接口：为了避免在秒杀开始之前被用户发现刷接口，因此需要用户在没到秒杀开始不能获取秒杀接口，只有秒杀开始了，才返回秒杀地址url和验证MD5，用户拿到这两个数据才可以进行秒杀。</li><li>对僵尸账号限制：对于一些僵尸账号，可以检测账号的活跃度或者等级信息来进行限制。当然也可以通过用户画像限制僵尸号。</li></ol><h2><span id="如何做好限流">如何做好限流</span></h2><p>在应对秒杀，大促销等高性能压力的场景时，为了保证系统的平稳运行，必须针对超过预期的流浪，通过预先设定的限流规则选择性的对某些请求进行限流“熔断”。</p><p>下面就介绍一下，我了解到的一些限流算法。</p><h3><span id="计数器算法">计数器算法</span></h3><p>通过一个计数器counter来统计一段时间内请求的数量，并且在指定的时间之后重置计数器。该算法实现简单，但是会出现<strong>临界问题</strong>。<br>比如，我们的限流规则是每秒不超过100次请求。假如，第一个1s的时间窗口内，请求集中到最后的10ms内，在第二个1s的时间窗口内，100次请求都集中在最开始的10ms内，那们实际上在短短的20ms内就集中的200次请求，那么很能就会压垮系统。</p><p>计数器限流算法的Redis Lua实现：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">-- 资源的唯一标识位</span></span><br><span class="line"><span class="keyword">local</span> key=KEYS[<span class="number">1</span>]</span><br><span class="line"><span class="comment">-- 限流大小</span></span><br><span class="line"><span class="keyword">local</span> limit=<span class="built_in">tonumber</span>(ARGV[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 获取当前的流量</span></span><br><span class="line"><span class="keyword">local</span> currentLimit=<span class="built_in">tonumber</span>(redis.call(<span class="string">'get'</span>,key) <span class="keyword">or</span> <span class="string">"0"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> currentLimit+<span class="number">1</span>&gt;limit <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 已经达到限流大小，返回0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="comment">-- 没有达到阈值value+1</span></span><br><span class="line">    redis.call(<span class="string">'INCRBY'</span>,key,<span class="number">1</span>)</span><br><span class="line">    <span class="comment">-- 设置过期时间</span></span><br><span class="line">    redis.call(<span class="string">'EXPIRE'</span>,key,<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> currentLimit+<span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><h3><span id="滑动窗口算法">滑动窗口算法</span></h3><p>滑动窗口算法是计数器算法的一种改进，将原来的一个时间窗口划分为多个时间窗口，并且不断向右滑动该窗口。流量经过滑动时间窗口整形之后，可以保证任意时间窗口内，都不会超过最大允许的限流值，从而流量曲线回更加平滑，可以部分解决上面提到的临界突发流量问题。<br>但是基于时间窗口的限流算法，只能在选定的时间粒度上限流，对选定时间粒度内的更加细粒度的访问频率不做限制。</p><h3><span id="令牌桶法">令牌桶法</span></h3><p>令牌桶法的工作流程如下；</p><ol><li>如果在t秒内限制请求的数量为n，那么每过t/n秒向桶内添加一个token。</li><li>如果令牌桶内的token的数量超过限制b，那么多于的token会被抛弃。</li><li>每次请求进入之时，需要先尝试从令牌桶中拿token，只有拿到了token才会处理接口请求，否则进行限流处理。</li></ol><p>基于Redis Lua的令牌桶限流算法实现：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 令牌的唯一标识</span></span><br><span class="line"><span class="keyword">local</span> bucketKey = KEYS[<span class="number">1</span>]</span><br><span class="line"><span class="comment">-- 上次请求的时间</span></span><br><span class="line"><span class="keyword">local</span> last_mill_request_key = KEYS[<span class="number">2</span>]</span><br><span class="line"><span class="comment">-- 令牌桶的容量</span></span><br><span class="line"><span class="keyword">local</span> limit = <span class="built_in">tonumber</span>(ARGV[<span class="number">1</span>])</span><br><span class="line"><span class="comment">-- 请求令牌的数量</span></span><br><span class="line"><span class="keyword">local</span> permits = <span class="built_in">tonumber</span>(ARGV[<span class="number">2</span>])</span><br><span class="line"><span class="comment">-- 令牌流入的速率</span></span><br><span class="line"><span class="keyword">local</span> rate = <span class="built_in">tonumber</span>(ARGV[<span class="number">3</span>])</span><br><span class="line"><span class="comment">-- 当前时间</span></span><br><span class="line"><span class="keyword">local</span> curr_mill_time = <span class="built_in">tonumber</span>(ARGV[<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 添加令牌</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 获取当前令牌的数量</span></span><br><span class="line"><span class="keyword">local</span> current_limit = <span class="built_in">tonumber</span>(redis.call(<span class="string">'get'</span>, bucketKey) <span class="keyword">or</span> <span class="string">"0"</span>)</span><br><span class="line"><span class="comment">-- 获取上次请求的时间</span></span><br><span class="line"><span class="keyword">local</span> last_mill_request_time = <span class="built_in">tonumber</span>(redis.call(<span class="string">'get'</span>, last_mill_request_key) <span class="keyword">or</span> <span class="string">"0"</span>)</span><br><span class="line"><span class="comment">-- 计算向桶里添加令牌的数量</span></span><br><span class="line"><span class="keyword">if</span> last_mill_request_time == <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line"><span class="comment">-- 如果是第一次请求，那么令牌桶初始化</span></span><br><span class="line"><span class="comment">-- 更新上次请求时间</span></span><br><span class="line">redis.call(<span class="string">"HSET"</span>, last_mill_request_key, curr_mill_time)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="comment">-- 计算应该添加的令牌的数量</span></span><br><span class="line"><span class="keyword">local</span> add_token_num = <span class="built_in">math</span>.<span class="built_in">floor</span>((curr_mill_time - last_mill_request_time) * rate)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 更新令牌的数量</span></span><br><span class="line"><span class="keyword">if</span> current_limit + add_token_num &gt; limit <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 如果当前的令牌数量已经超过了容量，多余的则抛弃</span></span><br><span class="line">    current_limit = limit</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">current_limit = current_limit + add_token_num</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">    <span class="comment">-- 更新令牌的数量</span></span><br><span class="line">redis.<span class="built_in">pcall</span>(<span class="string">"HSET"</span>,bucketKey, current_limit)</span><br><span class="line"><span class="comment">-- 设置过期时间</span></span><br><span class="line">redis.call(<span class="string">"EXPIRE"</span>, bucketKey, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 限流判断</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> current_limit - permits &lt; <span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 达到限流大小（令牌不够）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="comment">-- 没有达到限流大小</span></span><br><span class="line">current_limit = current_limit - permits</span><br><span class="line"><span class="comment">-- 更新令牌的数量</span></span><br><span class="line">redis.<span class="built_in">pcall</span>(<span class="string">"HSET"</span>, bucketKey, current_limit)</span><br><span class="line">    <span class="comment">-- 设置过期时间</span></span><br><span class="line">    redis.call(<span class="string">"EXPIRE"</span>, bucketKey, <span class="number">2</span>)</span><br><span class="line"><span class="comment">-- 更新上次请求的时间</span></span><br><span class="line">redis.call(<span class="string">"HSET"</span>, last_mill_request_key, curr_mill_time)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><h3><span id="漏桶法">漏桶法</span></h3><p>相比于令牌桶算法，漏桶法对于去令牌的频率也有限制，要按照t/n的固定速率来取令牌。</p><h3><span id="限流规则的合理性">限流规则的合理性</span></h3><p>限流规则包含三个部分：时间粒度，接口粒度，最大限流值。时间粒度的选择尤其重要。比如我们可以选择1秒钟不超过1000次，也可以选择10毫秒不超过10次。虽然看起来一致，但是实际的效果却大不系统。比如1秒钟不超过1000次，但是很可能1000次请求就集中在几毫秒内。但如果选择10毫秒不超过10次，会导致误杀许多不应该限流的请求。因此时间粒度的选择要根据实际情况，灵活调整。</p><h2><span id="如何利用好缓存">如何利用好缓存</span></h2><h3><span id="缓存可以解决哪些问题">缓存可以解决哪些问题</span></h3><ul><li><p>提升性能<br>在绝大多数的应用中，查询数据库都是非常耗时的。而很多时候其实都是读多写少的，这个时候正确的使用缓存可以极大的提升系统的性能。</p></li><li><p>缓解数据库压力<br>当用户请求增多的时候增多时，数据库的压力将大大增加，通过缓存能够大大降低数据库的压力。</p></li></ul><p>因此我们可以看出，缓存使用于那些读多写少的情况。还使用于一些对性能要求高的场景，比如秒杀。</p><h2><span id="缓存的三种模式">缓存的三种模式</span></h2><h3><span id="cache-aside-更新模式">Cache Aside 更新模式</span></h3><p>这种工作模式是比较常见的工作模式了。<br>其具体的流程是：</p><ul><li>失效：应用程序先从cache中取数据，如果没有拿到，则从数据库中取数据，成功后放到缓存中。</li><li>命中：应用程序从cache中取数据，取到后返回。</li><li>更新：先把数据存到数据库中，成功后再让缓存失效。</li></ul><p><img src="https://s2.ax1x.com/2020/01/28/1MZjMD.png" alt="1MZjMD.png"></p><h4><span id="注意点">注意点</span></h4><ol><li><strong>先更新数据库，再更新缓存可能会出现并发写操作导致脏数据</strong>。这种方法其实是实际应用中推荐的，但是理论上仍然存在问题。假如，有两个线程再同时并发的进行更新，先更新数据库的反而后更新缓存，那么就可能导致缓存中的数据是脏数据。</li><li><strong>先更新缓存，再更新数据库，这个逻辑是错误的，因为并发的读和写可能导致脏数据</strong>，假如，有两个线程同时并发的进行更新，一个线程删除了缓存，此时第二个线程来读取缓存，没有命中，然后从数据库中取出老数据，并更新回缓存。这个时候第一个线程也把数据库更新了。这个时候缓存中数据就是过期的就数据了。</li></ol><h3><span id="readwrite-through更新模式">Read/Write Through更新模式</span></h3><p>在Read/Write Through更新模式中，应用程序只需要维护缓存，数据库的维护由缓存来代理。</p><p><img src="https://s2.ax1x.com/2020/01/28/1Mmtc8.png" alt="1Mmtc8.png"><br>这种模式相较于 Cache Aside模式，缓存的维护工作不再由调用方负责了，而是由缓存服务自己来加载。</p><h3><span id="write-behind-caching-更新模式">Write Behind Caching 更新模式</span></h3><p>Write Behind Caching更新模式就是在更新数据时，只更新缓存，不更新数据库，缓存会异步的批量的更新数据库。这样的好处在于可以合并多次更新，是直接的内存操作。但是问题在于，数据不再是强一致的，而且可能丢失。</p><p><img src="https://s2.ax1x.com/2020/01/28/1MmLuD.png" alt="1MmLuD.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;秒杀系统的特点&quot;&gt;&lt;a href=&quot;#秒杀系统的特点&quot; class=&quot;headerlink&quot; title=&quot;秒杀系统的特点&quot;&gt;&lt;/a&gt;秒杀系统的特点&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;高性能：秒杀涉及到大量的并发读和并发写，因此支持高并发访问这点非常的关键。&lt;/li&gt;
&lt;li&gt;一致性：秒杀是有限数量的商品在同一时刻被很多倍的请求同时来减库存，在大并发更新的过程中都要保证数据的准确性。&lt;/li&gt;
&lt;li&gt;高可用：秒杀时会在瞬间涌入大量的流量，为了避免系统宕机，保证高可用，需要做好流量限制。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="项目" scheme="http://yoursite.com/tags/%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>JVM之G1和CMS收集器</title>
    <link href="http://yoursite.com/2020/01/27/JVM%E4%B9%8BG1%E5%92%8CCMS%E6%94%B6%E9%9B%86%E5%99%A8/"/>
    <id>http://yoursite.com/2020/01/27/JVM之G1和CMS收集器/</id>
    <published>2020-01-27T08:43:56.000Z</published>
    <updated>2020-01-27T08:43:55.500Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="cms垃圾回收器">CMS垃圾回收器</span></h1><h2><span id="什么是cms垃圾回收器cms回收器的特点">什么是CMS垃圾回收器，CMS回收器的特点</span></h2><p>CMS即Concurrent Mark Sweep，是一款并发的、使用标记-清除算法的针对老年代的垃圾回收器。如果老年代使用CMS垃圾回收器，需要添加虚拟机参数<code>-XX:+UseConcMarkSweepGC</code><br>CMS垃圾回收器GC过程暂停短，适合对时延要求较高的服务，用户线程不允许长时间的停顿的场景。但是容易造成严重的内存碎片化，且对CPU资源非常的敏感，无法处理浮动垃圾，可能出现<code>Concurrent Mode Failure</code>失败而导致Full GC产生。</p><a id="more"></a><h2><span id="cms垃圾回收器的工作流程与原理">CMS垃圾回收器的工作流程与原理</span></h2><p>CMS垃圾回收器的工作需要经历初始标记、并发标记、重新标记、并发清除四个步骤。</p><ol><li>初始标记<br>初始标记的对象为：</li></ol><ul><li>标记老年代中所有GC Roots引用的对象</li><li>老年代中被年轻代中存活的对象引用的对象。</li></ul><p><img src="https://s2.ax1x.com/2020/01/27/1nrd4P.png" alt="1nrd4P.png"><br>由于需要对所有的对象进行标记，为了避免在标记过程中对象状态发生改变，所以需要Stop the world即停止所有用户线程，但是整个标记的过程耗时较短。</p><ol start="2"><li><p>并发标记<br>从初始标记阶段找到GC Roots开始进行Tracing，找到所有的存活对象。<br><img src="https://s2.ax1x.com/2020/01/27/1nsnKg.png" alt="1nsnKg.png"><br>并发标记阶段会与用户线程同时进行，因此会有一些对象的引用状态发生改变。</p></li><li><p>重新标记<br>标记在并发标记阶段引用发生变化的对象，如果发现对象的引用发生变化，则JVM会标记堆的这个区域为Dirty Card。<br><img src="https://s2.ax1x.com/2020/01/27/1nsyRK.png" alt="1nsyRK.png"><br>那些能够从Dirty Card达到的对象也被标记为存活，当标记完成后，这个Dirty Card区域就会消失。<br><img src="https://s2.ax1x.com/2020/01/27/1nsgMD.png" alt="1nsgMD.png"><br>该阶段是一个并发阶段，能够与用户线程同时运行，不会中断它们。</p></li><li><p>并发清除<br>清除那些未被标记的对象回收内存空间。<br><img src="https://s2.ax1x.com/2020/01/27/1nsTRf.png" alt="1nsTRf.png"></p></li></ol><h1><span id="g1垃圾回收器">G1垃圾回收器</span></h1><h2><span id="什么是g1回收器g1回收器的特点">什么是G1回收器，G1回收器的特点</span></h2><p>G1回收器(Garbage First).可以通过<code>-XX+UseG1GC</code>.G1垃圾回收器以关注延迟为目标、服务器短应用的垃圾收集器。G1的设置原则是“首先收集尽可能多的垃圾”，因此G1并不会等内存耗尽或者快耗尽的时候开始垃圾收集，而是在内部采用了启发式算法，在老年代中找出具有高回收收益的分区进行收集。同时G1可以根据用户设置的暂停时间目标自动跳转年轻代和总堆大小，暂停目标越短年轻代空间越小、总空间就越大。</p><h2><span id="g1的内存模型">G1的内存模型</span></h2><p>G1采用自动分区(Region)的思路，将内存划分为一个个相等大小的内存分区，回收时则以分区为单位进行回收，存活的对象复制到另一个空闲分区中。由于都是以相等大小获得分区为单位进行操作，因此G1天然就是一种压缩方案。这些reding最后又被分别标记为Eden，Survivor和old，这里只是逻辑分区不是物理表示<br>。在这之外还有Humongous Regin，巨型对象分区，巨型对象会独占一个或多个连续分区，确定巨型对象分区空间需要扫描整个堆，因此应用程序应该避免生成巨型对象。</p><h2><span id="g1工作的流程">G1工作的流程</span></h2><ol><li><p>RSet的维护<br>RSet即已ji’yi。在串行和并行收集器中，GC通过整个堆扫描，来去顶对象是否处于可达路径中。然而G1为了避免整堆扫描时的Stop the world，它在每个分区记录了一个已记忆集合，内部类似一个方向指针，记录引用分区对象的卡片索引。当要回收该分区时，通过扫描分区的RSet，来确定引用本分区内的对象是否存活，进而确定本分区的对象存活情况。</p></li><li><p>初始标记<br>初始标记负责标记所有能直接可达的根对象(虚拟机栈对象，全局对象，本地方法栈对象)。在初始标记过程之中需要暂停用户线程(Stop the world).G1一般利用年轻代STW时间段完成初始标记。初始标记时并发执行的，直到所有的分区处理完。</p></li><li>并发标记<br>并发标记和应用线程并发执行，每个线程每次只扫描一个分区，从而标记出存活对象图。</li><li>最终标记<br>最终标记是最后一个标记阶段。在该阶段中，G1需要一个暂停的时间，区处理剩下的SATB日志缓冲区和所有更新，找出所有未被访问的存活对象，同时完成存活数据统计。这个阶段也是并行执行的。</li><li>筛选回收<br>该阶段主要进行Rset梳理，启发式算法会根据活跃度和RSet尺寸对分区定义不同等级，同时RSet数理也有助于发现无用的引用。参数-XX:+PrintAdaptiveSizePolicy可以开启打印启发式算法决策细节；整理堆分区，识别所有空闲分区，即发现无存活对象的分区。该分区可在清理阶段直接回收为混合收集周期识别回收收益高(基于释放空间和暂停目标)的老年代分区集合；无需等待下次收集周期。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;CMS垃圾回收器&quot;&gt;&lt;a href=&quot;#CMS垃圾回收器&quot; class=&quot;headerlink&quot; title=&quot;CMS垃圾回收器&quot;&gt;&lt;/a&gt;CMS垃圾回收器&lt;/h1&gt;&lt;h2 id=&quot;什么是CMS垃圾回收器，CMS回收器的特点&quot;&gt;&lt;a href=&quot;#什么是CMS垃圾回收器，CMS回收器的特点&quot; class=&quot;headerlink&quot; title=&quot;什么是CMS垃圾回收器，CMS回收器的特点&quot;&gt;&lt;/a&gt;什么是CMS垃圾回收器，CMS回收器的特点&lt;/h2&gt;&lt;p&gt;CMS即Concurrent Mark Sweep，是一款并发的、使用标记-清除算法的针对老年代的垃圾回收器。如果老年代使用CMS垃圾回收器，需要添加虚拟机参数&lt;code&gt;-XX:+UseConcMarkSweepGC&lt;/code&gt;&lt;br&gt;CMS垃圾回收器GC过程暂停短，适合对时延要求较高的服务，用户线程不允许长时间的停顿的场景。但是容易造成严重的内存碎片化，且对CPU资源非常的敏感，无法处理浮动垃圾，可能出现&lt;code&gt;Concurrent Mode Failure&lt;/code&gt;失败而导致Full GC产生。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM之垃圾回收</title>
    <link href="http://yoursite.com/2020/01/26/JVM%E4%B9%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    <id>http://yoursite.com/2020/01/26/JVM之垃圾回收/</id>
    <published>2020-01-26T13:47:56.000Z</published>
    <updated>2020-01-26T13:51:22.009Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="需要回收的区域">需要回收的区域</span></h2><p>JVM的运行时内存可以分为5个区域：程序计数器，虚拟机栈，本地方法栈，方法区，堆区。其中程序计数器，虚拟机栈，本地方法栈都是与线程同生共死的，因此不要进行垃圾回收。垃圾回收主要关注的堆区和方法区。</p><a id="more"></a><h2><span id="如何判断一个对象是否还存活">如何判断一个对象是否还存活</span></h2><h3><span id="引用计数算法">引用计数算法</span></h3><p>引用计数是垃圾回收器中的早期策略。这种方法，堆中的每个实例都有一个引用计数。当一个对象被创建的时候，就会为给该实例分配一个计数器，这个计数器的初始值为1.当任何其它变量被赋值为这个对象的引用的时候，计数器加1，但当一个对象实例的某个引用超过了生命周期或者被设置为一个新值的时候，对象实例的引用计数器减1.当计数器的值为0的时候，就可以认为其所对应的对象已经“死亡”了。垃圾回收器就可以对其进行回收了。</p><h4><span id="优缺点">优缺点</span></h4><p>优点：引用计数器可以很快的执行，交织再程序运行中。<br>缺点：无法检测出循环引用，循环引用计数器永不为0。</p><h3><span id="可达性分析">可达性分析</span></h3><p>可达性分析算法是从离散数学图论中引入的，程序把所有的引用关系看作一个图，从一个GC ROOT开始，寻找对应的引用节点，找到这个节点以后，继续寻找这个节点的引用节点，当所有的引用节点寻找完毕之后，剩余的节点则被认为是没有被引用到的节点，即“死亡”的对象。</p><p>那么可以被作为GC Roots的对象包括那些呢？</p><ul><li>虚拟机栈中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中引用的对象</li></ul><p>这个算法的思路就是沿着一系列的GC roots作为起点向下搜索，当一个对象不可达，那么就判定为可回收的。</p><p>当然被可达性分析判定为可回收，需要经历两次标记的过程。如果对象在可达性分析后发现不可达，那它会被第一标记并进行一次筛选，筛选的条件就是此对象是否有需要执行的<code>finalize()</code>方法，如果有，那么会调用一次（最多一次）<code>finalize()</code>方法，可以通过<code>finalize()</code>方法来拯救一次被回收的对象。</p><p>两次标记分别是：</p><ol><li>通过GC Roots对象是否可达，如果对象不可达. </li><li>待回收的对象是否需要执行<code>finalize()</code>方法。在<code>finalize()</code>方法中没有于引用链建立关联关系的，将被进行第二次标记。</li></ol><p>只有两次标记都成功的对象，才会被真正的回收。</p><h2><span id="java中的引用">Java中的引用</span></h2><p>在Java引用中，将引用分为强引用、软引用、弱引用、虚引用4种。这四种引用的强度依次减弱。</p><ul><li>强引用：强引用是程序代码种普遍存在的，类似于<code>Object obj=new Object()</code>。只要强引用还存在，垃圾回收器就永远不会回收掉被引用的对象。</li><li>软引用：用来描述一些有用但并非必须的对象。对于软引用关联的对象，在系统将要发生内存溢出异常之前，将会把这些对象列入回收范围之中进行第二次回收。如果这次回收之后还没有足够的内存，才会抛出内存溢出。</li><li>弱引用：也是描述非必须对象的，但是它的强度比软引用要弱，被弱引用关联的对象只能生存到下一次垃圾回收器发生之前。当垃圾回收器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。</li><li>虚引用:虚引用是最弱的一种引用，一个对象是否存在虚引用，完全不会影响其生存时间，也无法通过虚引用来获取一个对象实例。它的作用是能在这个对象被回收器回收时收到一个系统通知。</li></ul><p><strong>无论是引用计数器算法还是可达性分析算法，都是针对于强引用的</strong></p><p>什么是引用？<br>如果reference类型的数据中存储的是数值代表的是另一块内存的起始地址，那么称这块内存代表着一个引用。</p><h2><span id="方法区的垃圾回收">方法区的垃圾回收</span></h2><p>方法区回收的内容主要有两类：一类是废弃的常量，另一类是无用的类。对于废弃的常量可以通过可达性分析来判断是否可以回收。<br>但是无用的类需要同时满足以下几个条件：</p><ul><li>该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例</li><li>加载该类的ClassLoader(类加载器)已经被回收</li><li>该类对应的java.lang.Class对象无法在任何地方被引用，无法在任何地方通过反射来访问该类的方法。</li></ul><h2><span id="堆中的垃圾回收">堆中的垃圾回收</span></h2><p>Java堆中存放着几乎所有的对象实例，也是垃圾回收器工作的主要目标。</p><h3><span id="常用的垃圾回收算法">常用的垃圾回收算法、</span></h3><h4><span id="引用计数器法">引用计数器法</span></h4><p>这个算法在之前已经介绍过来。这种算法实现简单，效率高可以于程序交织运行，但是不能解决循环依赖的问题。因此主流的JVM并没有采用引用计数器法来管理内存。</p><h4><span id="标记-清除算法mark-sweep">标记-清除算法(Mark-Sweep)</span></h4><p>标记清除算法分为两个阶段：分别为标记阶段和清除阶段。<br>标记阶段：<br>采用可达性分析算法来判断对象的存活情况，并对需要清除的对象进行标记。<br>清除阶段：<br>清除阶段扫描整个堆内存，清除掉被标记的对象。</p><p>该算法实现简单，在存活对象较多的情况下效率非常的高，但是因为其直接回收对象不会对内存进行整理，因此会造成内存的碎片。</p><h4><span id="复制算法">复制算法</span></h4><p>复制算法将整个堆内存划分为大小相等的两个部分，每次只使用其中一块。当一块内存用完了，就将还存活的对象赋值到另一块内存中，然后再把已经使用的一半内存之情清理掉。这样就解决了标记-清除算法的产生碎片的问题。</p><p>这种算法实现简单，运行高效且很好的解决了内存碎片的问题。但是降低了内存的利用率，因为同一时间只能有效利用一半的内存。</p><h4><span id="标记-整理mark-compact算法">标记-整理(Mark-compact)算法</span></h4><p>该算法首先会对需要回收的算法进行一次标记，然后将存活的对象移向一段（整理），移动过后，清理掉边界以外的内存。（<strong>先标记再移动最后清除</strong>）</p><p>标记整理算法也解决了标记清除算法的内存碎片问题，但是因为存在对象移动的开销，因此效率较低。</p><h4><span id="分代收集算法generational-collection">分代收集算法（Generational Collection）</span></h4><p>分代收集算法是目前大部分JVM采用的垃圾收集器算法。它的核心思想是根据对象存活的生命周期将内存划分为若干个不同的区域。一般划分为老年代（Tenured Generation）和新生代(Young Generation)，在堆区之外还有一个永久代(Permanet Generation)。</p><p>老年代的特点是每次垃圾回收只有少量的对象需要回收，而新生代的特点是每次垃圾回收时都有大量的对象需要被回收。然后根据不同代的特点来采用合适的收集算法。</p><p>对于新生代，目前主流的是采用<strong>复制算法</strong>，因为新生代中每次都会回收绝大多数的对象，因此需要复制的对象较少。但是不是按照1：1的比例还划分新生代空间的。一般来说将新生代划分为一块较大的Eden空间和两块较大的Survivor空间(8:1:1),每次使用Eden和其中一块Survivor，当进行回收时，将Eden和Survivor中还存活的对象复制到另一个Survivor空间中，然后清理掉Eden和刚才使用过的Survivor空间。</p><p>所有新生成的对象首先存放在年轻代中。年轻代的目标就是尽可能块的收集掉那些生命周期短的对象。回收时，首先将eden区中存活的对象复制到一个survivor0区中，然后清空eden区，当survivor0区满了之后，就会将survivor0区和eden区中存活的对象复制到survivor1区，然后清空eden和这个survivor0区，然后将survivior0区和survivor1区交换。当survivor1区不足以存放eden和survivior0中存活的对象时，就会将存活对象存放到老年代。若是老年代也满了就会触发一次Full GC（Major GC），也就是新生代，老年代都进行回收。新生代中发生的GC也叫做Minor GC，Minor GC发生的频率比较高。</p><p>对于老年代，因为每次需要回收的内存的数量较少，因此一般采用标记整理算法。</p><h2><span id="常见的垃圾回收器">常见的垃圾回收器</span></h2><h3><span id="serial收集器">Serial收集器</span></h3><p>新生代单线程收集器，标记和清理都是单线程，优点是简单高效。采用的是复制算法。是client级别默认的GC方式，可以通过<code>-XX:+UseSerialGC</code>来强制指定。</p><h3><span id="serial-old">Serial Old</span></h3><p>老年代单线程收集器，是Serial收集器的老年代版本。采用的是标记-整理算法。</p><h3><span id="parnew收集器">parNew收集器</span></h3><p>新生代收集器，可以认为是Serial收集器的多线程版本，在多核CPU环境下有着比Serial更好的表现。</p><h3><span id="parallel-scavenge收集器">Parallel Scavenge收集器</span></h3><p>并行收集器，追求高吞吐量，高效利用CPU。采用的是停止-复制算法。适合后台引用等对交互响应要求不高的场景。是Service级别默认采用的GC方式，可用<code>-XX:+UseParallelGC</code>来强制指定，用<code>-XX:ParallelGCThread=4</code>来指定线程数。</p><h3><span id="parallel-old收集器">Parallel Old收集器</span></h3><p>Parallel Scavenge收集器的老年代版本，并行收集器，吞吐量优先。</p><h3><span id="cmsconcurrnet-mark-sweep收集器">CMS（concurrnet mark sweep）收集器</span></h3><p>高并发，低停顿，追求最短GC回收停顿时间，CPU占用比较高，停顿时间短，多和CPU追求高响应时间的选择。采用的是标记-清理算法。</p><h2><span id="gc是生命时候触发的">GC是生命时候触发的</span></h2><p>由于对对象进行了分代处理，因此垃圾回收的区域，时间也不一样。GC有两种类型： Scavenge GC 和 Full GC。</p><h3><span id="scavenge-gc">Scavenge GC</span></h3><p>一般情况下，当新对象生成，并在eden申请空间失败是，就会触发Scavenge GC，对Eden区域进行GC，清除非存活对象，并且把尚且存活的对象移动到Survivor区。然后整理Survivor的两个区。这种GC仅仅是在年轻代的Eden区进行，不会影响到老年代。因为Eden区空间不大，且大部分对象都是从Eden区开始的，因此Eden区的GC非常的频繁。</p><h3><span id="full-gc">Full GC</span></h3><p>对整个堆进行整理。因为Full GC需要对整个堆进行整理。因此比Scavenge GC要慢，因此应该要尽可能减少Full GC的次数。导致Full GC的原因有以下几种：</p><ul><li>老年代写满</li><li>持久代写满</li><li>system.gc()被显式调用</li><li>上一次GC之后堆区各域的分配策略动态变化。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;需要回收的区域&quot;&gt;&lt;a href=&quot;#需要回收的区域&quot; class=&quot;headerlink&quot; title=&quot;需要回收的区域&quot;&gt;&lt;/a&gt;需要回收的区域&lt;/h2&gt;&lt;p&gt;JVM的运行时内存可以分为5个区域：程序计数器，虚拟机栈，本地方法栈，方法区，堆区。其中程序计数器，虚拟机栈，本地方法栈都是与线程同生共死的，因此不要进行垃圾回收。垃圾回收主要关注的堆区和方法区。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM之概述</title>
    <link href="http://yoursite.com/2020/01/25/JVM%E4%B9%8B%E6%A6%82%E8%BF%B0/"/>
    <id>http://yoursite.com/2020/01/25/JVM之概述/</id>
    <published>2020-01-25T08:54:56.000Z</published>
    <updated>2020-01-25T08:49:58.937Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="什么是java虚拟机">什么是java虚拟机？</span></h2><p>虚拟机是一种抽象化的计算机，通过在实际上的计算机上仿真模拟各种计算机功能来实现的。Java虚拟机有自己完善的硬件架构，如处理器、堆栈、寄存器等，还具有相应的指令体系。<strong>JVM屏蔽了与具体操作系统平台相关的信息</strong>，使得Java程序只需要生成在java虚拟机上运行的目标代码，就可以在多种平台上不加修改地运行。做到了一次编译到处运行。<br>在JVM启动之后，它实际上就是一个操作系统中的进程。</p><h2><span id="jvm的体系结构">JVM的体系结构</span></h2><p><img src="https://s2.ax1x.com/2020/01/17/1SuGSU.png" alt="1SuGSU.png"><br><a id="more"></a></p><h3><span id="类装载器">类装载器</span></h3><h4><span id="什么是类加载机制">什么是类加载机制？</span></h4><p>JVM把描述类信息的class文件加载到内存，并对数据进行校验，转换解析和初始化，最终形成可以被虚拟机直接使用的java类型的过程就是JVM的类加载机制。</p><h4><span id="类加载机制的意义是什么">类加载机制的意义是什么？</span></h4><p>在java语言里，类型的加载、连接和初始化都是在运行时通过类加载机制完成的，这种机制虽然会增加性能的开销，但是也成就了java的灵活性。<br>例子：</p><ol><li>用户可以编写一个面向接口的应用程序，可以等到运行时再指定实际的实现类。</li><li>用户可以实现自己的类加载器，让一个本地运行的程序可以通过网络等方式从其它地方加载二进制流作为程序代码的一部分。</li></ol><h4><span id="一个类的生命周期">一个类的生命周期</span></h4><p>一个类从被加载到JVM到卸载出内存需要经历如下过程。</p><ul><li>加载（Loading）<br>通过一个类的全限定名，来获取此类的二进制流。将这个字节流所代表的静态存储结构转化为方法区的运行时数据区。在内存中生成一个代表这个类的java.lang.class对象，作为方法区这个类的各种数据的访问入口。</li><li>验证 (Verification)<br>验证主要确保Class文件二进制流中所包含的信息是否符合虚拟机的要求，是否会危害虚拟机的运行。验证主要包括，文件格式校验，元数据验证，字节码验证等工作。</li><li>准备 (Preparation)<br>准备阶段是正式为类变量（static修饰的变量）分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区进行分配。这里所说的初始值通常来值数据的零值。<br><code>public static int value=123;</code>这还代码在准备阶段后，<code>value</code>的值为0，而不是123.</li><li>解析 (Resolution)<br>解析过程是将虚拟机常量池中的符号引用替换为直接引用的过程。</li></ul><ul><li>符号引用：符号引用以一组符号来描述所引用的符号。</li><li>直接引用：是可以直接指向目标的指针，相对偏移量或者是一个间接定位到目标的句柄。</li></ul><ul><li>初始化 (Initialization)</li><li>使用 (Using)</li><li>卸载 (Unloading)<br>其中验证，准备和解析可以统称为连接（Linking）。</li></ul><p>需要立即对类进行初始化的5种情况：</p><ul><li>遇到new，getstatic,putstatic或invokestatic这四条指令的时候，如果类没有进行初始化，则需要进行初始化。简单来讲就是我们在java代码中，使用new关键字实例化对象的时候，读取或设置一个类的静态字段的时候（被final修饰，已经在编译期把结果放入常量池的静态字段除外），已经调用一个类的静态方法的时候。</li><li>使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有初始化，那么需要先触发其初始化。</li><li>如果初始化一个类的时候，发现它的父类还没有进行过初始化的时候，则需要触发器父类进行初始化。</li><li>当虚拟机启动时，用户需要指定一个执行的主类，虚拟机会先初始化这个主类。</li><li>当使用JDK1.7的动态语言支持时，如果java.lang.invoke.MethodHeanle实例最后的结果为REF_getStatic，REF_putStaic,REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。</li></ul><p>以上五种情况为对类的主动引用。还存在对类的被动引用：</p><ul><li>通过子类去引用父类的静态字段，不会导致子类初始化<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderStudy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//通过子类去引用父类的静态字段</span></span><br><span class="line">        System.out.println(SubClass.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"superClass init"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> val=<span class="number">123</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"subclass init"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">superClass init</span><br><span class="line">123</span><br></pre></td></tr></table></figure></p><ul><li>通过数组定义来引用类，不会触发此类的初始化<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderStudy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//通过数组引用的类不会对类进行初始化。</span></span><br><span class="line">       SuperClass[] arr=<span class="keyword">new</span> SuperClass[<span class="number">10</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"superClass init"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> val=<span class="number">123</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"subclass init"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>没有任何的输出，说明没有对SuperClass类进行初始化。</p><ul><li>常量在编译时会存入调用类的常量池中，因此不会触发定义常量的类的初始化。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderStudy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//通过数组引用的类不会对类进行初始化。</span></span><br><span class="line">        System.out.println(SuperClass.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"superClass init"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> val=<span class="number">123</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"subclass init"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有任何的输出。<br>可见并没有初始化该常量的定义类。</p><h4><span id="类加载器">类加载器</span></h4><p>类加载器的工作就是：“通过一个类的全限定名来获取此类的二进制字节流”<br><strong>比较两个类是否相等，只有在这两个类是由同一个类加载器加载的前提下从才有意义</strong></p><p>一共有四种类加载器：</p><ul><li>启动类加载器（Bootstrap ClassLoader），这个类加载器是使用C++编写的，这个类主要负责将存放在&lt;JAVA_HOME&gt;/lib目录中，或者-Xbootclasspath参数所指定的路径中的。并且是由虚拟机识别的类库加载到虚拟机内存中。</li><li>拓展类加载器（Extension ClassLoader）：这个类加载器负责加载&lt;JAVA_HOME&gt;/lib/ext目录中的，或者被jave.ext.dirs系统变量所指定的路径中的所有类库。开发者可以直接使用类加载器。</li><li>应用类加载器（application Classloader），这个类加载器负责加载用户路径（ClassPath）上所指定的类库。</li><li>自定义类加载器，我们可以继承<code>ClassLoader</code>实现自己的类加载器。</li></ul><h4><span id="双亲委派机制">双亲委派机制</span></h4><p>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此。因此只有当父加载器反馈无法完成这个加载请求时，子加载器才会尝试自己去加载。</p><p>双亲委派机制使得类随着它的加载器具备了一种带有优先级的层次关系。实现了沙箱安全。</p><h3><span id="执行引擎">执行引擎</span></h3><h4><span id="什么是jvm执行引擎">什么是JVM执行引擎</span></h4><p>java编写的代码（.java文件）Java编译器(java compiler)编译为Java字节码(.class)文件。类加载器负责转载编译后的字节码，并加载到运行时数据区中，然后执行引擎执行这些字节码。<br>执行引擎按照字节码指令来执行相应的任务。因为字节码计算机是无法直接运行的，所以需要将其转化为能够被计算机执行的及其语言。这个过程JVM执行引擎有两种方案。一种是解释执行：即一条条读取，解释并执行字节码指令。这种方案加载快，但执行较慢。另一种是即时编译(Just-In-Time):在合适的时候，即时编译器会将整段的字节码编译为本地代码（编译后的本地代码缓存在cache中），然后自己执行本地代码。编译后的代码，比解释执行更加的快。但编译的过程比较耗时。</p><p>因此内置了JIT编译器的JVM都会检查方法的执行频率，如果一个方法的执行频率超过一个特定的值的话，那么这个方法就会被编译成本地代码。</p><p>JVM规范并没有定义执行引擎到底要如何区执行。因此JVM的提供者通过使用不同的技术以及不同的类型的JIT编译器来提高执行引擎的效率，</p><p>大部分的JIT编译器会将字节码转化为一个中间层表达式，然后进行优化，最后再把这种表示转化为本地代码。</p><p>Oracle Hotspot VM使用了一种叫做热点编译器的JIT编译器。它会通过分析代码的调用频数，寻找代码热点，然后会把热点代码编译为本地代码。如果代码不再是热点了，那么就会将本地代码从cache中移除，继续使用解释执行的方案。</p><h3><span id="运行时数据区">运行时数据区</span></h3><p>JVM在执行java程序的时候会它管理的内存分为若干个不同的数据区域，这些区域有着不同的用途。<br>运行时数据区可以分为方法区，堆区，虚拟机栈，本地方法栈，程序计数器。</p><h4><span id="程序计数器">程序计数器</span></h4><p>程序计数器是一块较小的内存空间，可以看作当前线程所执行的字节码的行号指示器。通过修改程序计数器的值，可以实现跳转执行等功能。它是线程私有的。<br>如果线程正在执行一个java方法，这个计数器记录的就是正在执行的虚拟机字节码指令的地址。如果正在执行的是native方法，那么这个计数器则为null。</p><p>此块区域是唯一一个在JVM规范中没有规定的任何OutOfMemoryError情况的区域。</p><h4><span id="java虚拟机栈">Java虚拟机栈</span></h4><p>线程私有的，生命周期和线程相同，虚拟机栈描述的是<strong>Java方法</strong>执行的内存模型。我们知道函数的调用是通过栈来完成的，每个方法在执行的时候都会开辟一个栈帧，方法中的局部变量其实就是存放在栈帧中。<br>在JVM规范中，对此区域规定了两种异常情况：如果线程请求的栈深度超过了虚拟机允许的最大深度，那么就会抛出StackOverflowError异常；如果允许虚拟机栈可以动态拓展时，无法申请到足够的内存，就会抛出OutOfMemoryError异常。</p><h4><span id="本地方法栈">本地方法栈</span></h4><p>本地方法栈所发挥的作用其实和虚拟机栈的作用是非常相似的。只不过本地方法栈描述的是<strong>native方法</strong>执行的内存模型。在虚拟即规范中没有对本地方法栈中方法使用的语言与数据结构做出强制规定，因此具体的虚拟机可以自由的实现本地方法栈。本地方法栈也会抛出StatkcOverflowError和OutOfMemoryError异常。它同样也是线程私有的。</p><h4><span id="方法区">方法区</span></h4><p>方法区是线程共享的，它主要存储已被JVM加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。<br>运行时常量池也是方法区的一部分，它主要存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。</p><h4><span id="堆">堆</span></h4><p>堆是线程共享的。它是JVM中最大的一块内存区域，在虚拟机启动的时候就已经创建了。这块区域的目的就是存放对象实例和数组，几乎所有的对象实例都在这里分配。堆区是垃圾收集管理最主要的区域。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是java虚拟机？&quot;&gt;&lt;a href=&quot;#什么是java虚拟机？&quot; class=&quot;headerlink&quot; title=&quot;什么是java虚拟机？&quot;&gt;&lt;/a&gt;什么是java虚拟机？&lt;/h2&gt;&lt;p&gt;虚拟机是一种抽象化的计算机，通过在实际上的计算机上仿真模拟各种计算机功能来实现的。Java虚拟机有自己完善的硬件架构，如处理器、堆栈、寄存器等，还具有相应的指令体系。&lt;strong&gt;JVM屏蔽了与具体操作系统平台相关的信息&lt;/strong&gt;，使得Java程序只需要生成在java虚拟机上运行的目标代码，就可以在多种平台上不加修改地运行。做到了一次编译到处运行。&lt;br&gt;在JVM启动之后，它实际上就是一个操作系统中的进程。&lt;/p&gt;
&lt;h2 id=&quot;JVM的体系结构&quot;&gt;&lt;a href=&quot;#JVM的体系结构&quot; class=&quot;headerlink&quot; title=&quot;JVM的体系结构&quot;&gt;&lt;/a&gt;JVM的体系结构&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2020/01/17/1SuGSU.png&quot; alt=&quot;1SuGSU.png&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>mybatis源码分析之缓存机制</title>
    <link href="http://yoursite.com/2020/01/23/mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2020/01/23/mybatis源码分析之缓存机制/</id>
    <published>2020-01-23T08:11:56.000Z</published>
    <updated>2020-02-28T02:30:42.278Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="概述">概述</span></h2><p>mybatis提供了缓存机制减轻数据库压力，提高数据库性能。mybatis的缓存分为两级：一级缓存、二级缓存。<br>一级缓存是<code>SqlSession</code>级别的缓存，缓存的数据只在<code>SqlSession</code>内有效。<br>二级缓存是<code>mapper</code>级别的缓存，同一个<code>namespace</code>共用一个缓存，所以对<code>SqlSession</code>是共享的。<br><a id="more"></a><br><img src="https://s2.ax1x.com/2020/01/23/1VSh0s.png" alt="1VSh0s.png"></p><h2><span id="一级缓存">一级缓存</span></h2><p>一级缓存默认是开启状态的。<br><img src="https://s2.ax1x.com/2020/01/23/1VSrkt.png" alt="1VSrkt.png"></p><h3><span id="一级缓存的生命周期">一级缓存的生命周期</span></h3><ul><li>mybatis在开启一个数据库会话的时，会创建一个新的<code>SqlSession</code>对象，<code>SqlSession</code>对象中会持有一个<code>Executor</code>对象，<code>Executor</code>对象中持有一个新的<code>PerpetualCache</code>对象；当会话结束时<code>SqlSession</code>对象及其内部的<code>Executor</code>对象还有<code>perpetualChache</code>对象也会被释放掉。</li><li>在<code>SqlSession</code>调用了<code>close()</code>方法，会释放掉一级缓存<code>PerpetualCache</code>对象，一级缓存将不可使用。</li><li>如果<code>SqlSession</code>调用了<code>clearCache()</code>，会清空<code>PerpetualCache</code>对象中的数据（缓存数据），但是一级缓存仍然是可用的，只是之前的数据被清空了。</li><li><code>SqlSession</code>中执行了任何一个update操作，都会清空<code>perpetualCache</code>对象的数据，但是该对象可以继续使用。</li></ul><h3><span id="如何判断两次查询时完全相同的">如何判断两次查询时完全相同的？</span></h3><p>mybaits认为，对于两次查询，如果以下条件都完全一样，那么就任务它们时完全相同的两次查询。</p><ul><li>传入的statementId</li><li>查询时要求的结果集的结果的范围</li><li>查询传递给JDBC的sql语句字符串</li><li>传递给java.sql.Statement要设置的参数值。<h2><span id="二级缓存">二级缓存</span></h2>mybatis的二级缓存是application级别的缓存，它可以提高数据库查询的效率，以提高应用的性能。<br>二级缓存默认是不开启的。如果需要开启二级缓存，需要进行配置，并且要求返回的pojo必须是可序列化的。<br>如果开启了二级缓存：</li><li>映射语句文件中的所有select语句将会被缓存</li><li>映射语句文件中的所有insert，update和delete语句会刷新缓存。</li><li>缓存会使用默认的LRU算法来回收。</li><li>根据时间表，缓存不会以任何时间顺序来刷新。</li><li>缓存会存储列表集合或对象的1024个引用。</li><li>缓存会被视为可读可写的缓存，意味着对象检索式不共享的，而且可以安全的被调用者修改，不干扰其它调用者或线程所做的潜在修改。</li></ul><h3><span id="如何开启二级缓存">如何开启二级缓存</span></h3><ol><li>首先查询返回的pojo类必须要实现<code>Serializable</code>即可，表示式可序列化的。</li><li>在对应的mapper文件中开启缓存。<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span> <span class="attr">eviction</span>=<span class="string">"LRU"</span> <span class="attr">readOnly</span>=<span class="string">"true"</span> <span class="attr">flushInterval</span>=<span class="string">"6000"</span> <span class="attr">size</span>=<span class="string">"1024"</span>/&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p><code>cache</code>标签有几个属性需要注意：</p><ul><li>eviction:设置缓存的清除策略，默认值为LRU<ul><li><code>LRU</code>:最近最少使用：移除最长时间不被使用的对象。</li><li><code>FIFO</code>：先进先出：按对象进入缓存的顺序来移除 它们</li><li><code>SOFT</code>:软引用：基于垃圾回收器状态和软引用规则移除对象。</li><li><code>WEAK</code>:弱引用：更积极的基于浪迹回收器状态和如弱引用规则移除对象。</li></ul></li><li>flushInterval：刷新间隔，默认清空下为不设置，自会在特定语句时刷新缓存</li><li>size：引用数目，默认是1024</li><li>readOnly：只读属性，设置为只读的比可写的性能更高，避免了对缓存对象的拷贝。</li></ul><ol start="3"><li>在全局配置文件中开启二级缓存<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"cacheEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;mybatis提供了缓存机制减轻数据库压力，提高数据库性能。mybatis的缓存分为两级：一级缓存、二级缓存。&lt;br&gt;一级缓存是&lt;code&gt;SqlSession&lt;/code&gt;级别的缓存，缓存的数据只在&lt;code&gt;SqlSession&lt;/code&gt;内有效。&lt;br&gt;二级缓存是&lt;code&gt;mapper&lt;/code&gt;级别的缓存，同一个&lt;code&gt;namespace&lt;/code&gt;共用一个缓存，所以对&lt;code&gt;SqlSession&lt;/code&gt;是共享的。&lt;br&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="mybatis" scheme="http://yoursite.com/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>mybatis源码分析之插件机制</title>
    <link href="http://yoursite.com/2020/01/22/mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E6%8F%92%E4%BB%B6%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2020/01/22/mybatis源码分析之插件机制/</id>
    <published>2020-01-22T13:24:56.000Z</published>
    <updated>2020-02-28T02:30:43.215Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="概述">概述</span></h2><p>mybatis插件又被称为拦截器，mybaits采用责任链模式，通过动态代理组织多个插件，通过这些插件可以改变mybatis的默认行为。mybatis允许在映射语句执行的某一点进行拦截调用。默认情况下，mybatis使用允许使用插件来拦截方法的调用包括：</p><a id="more"></a><ul><li>Executor是mybatis的执行器，它负责调用statementHandler操作数据库，并把结果集通过ResultSetHandler进行自动映射，另外，它还处理了二级缓存的操作。</li><li>StatementHandler是mybatis直接和数据库执行sql脚本的对象，另外它也实现了mybatis的一级缓存。</li><li>ParameterHandler是mybatis实现sql入参设置的对象。</li><li>ResultSetHandler是mybatis把ResultSet结果集映射成POJO的接口对象。</li></ul><h2><span id="拦截器的原理是什么">拦截器的原理是什么</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Executor <span class="title">newExecutor</span><span class="params">(Transaction transaction, ExecutorType executorType)</span> </span>&#123;</span><br><span class="line">   executorType = executorType == <span class="keyword">null</span> ? defaultExecutorType : executorType;</span><br><span class="line">   executorType = executorType == <span class="keyword">null</span> ? ExecutorType.SIMPLE : executorType;</span><br><span class="line">   Executor executor;</span><br><span class="line">   <span class="keyword">if</span> (ExecutorType.BATCH == executorType) &#123;</span><br><span class="line">     executor = <span class="keyword">new</span> BatchExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ExecutorType.REUSE == executorType) &#123;</span><br><span class="line">     executor = <span class="keyword">new</span> ReuseExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     executor = <span class="keyword">new</span> SimpleExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (cacheEnabled) &#123;</span><br><span class="line">     executor = <span class="keyword">new</span> CachingExecutor(executor);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   executor = (Executor) interceptorChain.pluginAll(executor);</span><br><span class="line">   <span class="keyword">return</span> executor;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> ParameterHandler <span class="title">newParameterHandler</span><span class="params">(MappedStatement mappedStatement, Object parameterObject, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">   ParameterHandler parameterHandler = mappedStatement.getLang().createParameterHandler(mappedStatement, parameterObject, boundSql);</span><br><span class="line">   <span class="comment">//增强</span></span><br><span class="line">   parameterHandler = (ParameterHandler) interceptorChain.pluginAll(parameterHandler);</span><br><span class="line">   <span class="keyword">return</span> parameterHandler;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> StatementHandler <span class="title">newStatementHandler</span><span class="params">(Executor executor, MappedStatement mappedStatement, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">   StatementHandler statementHandler = <span class="keyword">new</span> RoutingStatementHandler(executor, mappedStatement, parameterObject, rowBounds, resultHandler, boundSql);</span><br><span class="line">   <span class="comment">//增强</span></span><br><span class="line">   statementHandler = (StatementHandler) interceptorChain.pluginAll(statementHandler);</span><br><span class="line">   <span class="keyword">return</span> statementHandler;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> ResultSetHandler <span class="title">newResultSetHandler</span><span class="params">(Executor executor, MappedStatement mappedStatement, RowBounds rowBounds, ParameterHandler parameterHandler,</span></span></span><br><span class="line"><span class="function"><span class="params">     ResultHandler resultHandler, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">   ResultSetHandler resultSetHandler = <span class="keyword">new</span> DefaultResultSetHandler(executor, mappedStatement, parameterHandler, resultHandler, boundSql, rowBounds);</span><br><span class="line">   <span class="comment">//增强</span></span><br><span class="line">   resultSetHandler = (ResultSetHandler) interceptorChain.pluginAll(resultSetHandler);</span><br><span class="line">   <span class="keyword">return</span> resultSetHandler;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>通过这几段代码我们不难看出，四大接口皆通过调用<code>interceptorChain</code>的<code>pluginAll</code>方法来对对象进行进一步的处理。</p><p>我们查看<code>interceptorChain</code>类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterceptorChain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一个拦截器集合</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">pluginAll</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Interceptor interceptor : interceptors) &#123;</span><br><span class="line">    <span class="comment">//调用所有的插件对target进行进一步的处理</span></span><br><span class="line">      target = interceptor.plugin(target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptor</span><span class="params">(Interceptor interceptor)</span> </span>&#123;</span><br><span class="line">    interceptors.add(interceptor);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;Interceptor&gt; <span class="title">getInterceptors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Collections.unmodifiableList(interceptors);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么对对象进行进一步加工的拦截器的结构又是怎样的呢。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进行拦截是要执行的方法</span></span><br><span class="line">  <span class="function">Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line">    <span class="comment">//用于封装目标对象，可以返回代理对象或者对象本身</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Object <span class="title">plugin</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Plugin.wrap(target, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="comment">//用于获取自定义相关属性</span></span><br><span class="line">  <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// NOP</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2><span id="如何开发一个插件">如何开发一个插件</span></h2><p>一个官方推荐的插件开发方式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Intercepts</span>(&#123;<span class="meta">@Signature</span>(type = Executor.class, method = <span class="string">"query"</span>,</span><br><span class="line">        args = &#123;MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class&#125;)&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Object target = invocation.getTarget(); <span class="comment">//被代理对象</span></span><br><span class="line">        Method method = invocation.getMethod(); <span class="comment">//代理方法</span></span><br><span class="line">        Object[] args = invocation.getArgs(); <span class="comment">//方法参数</span></span><br><span class="line">        <span class="comment">// do something ...... 方法拦截前执行代码块</span></span><br><span class="line">        Object result = invocation.proceed();</span><br><span class="line">        <span class="comment">// do something .......方法拦截后执行代码块</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">plugin</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Plugin.wrap(target, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3><span id="编写一个简单的拦截器">编写一个简单的拦截器</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Intercepts</span>(&#123;<span class="meta">@Signature</span>(type = Executor.class,method = <span class="string">"update"</span>,args = &#123;MappedStatement.class, Object.class&#125;)&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPlugin</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"拦截到了"</span>);</span><br><span class="line">    <span class="keyword">return</span> invocation.proceed();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">plugin</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Plugin.wrap(target,<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时我们在全局配置文件中对我们编写的拦截器进行注册。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugins&gt;</span><br><span class="line">  &lt;plugin interceptor=<span class="string">"example.MyPlugin"</span>/&gt;</span><br><span class="line">&lt;/plugins&gt;</span><br></pre></td></tr></table></figure></p><p>这段代码就会拦截<code>Executor</code>的<code>int update(MappedStatement ms, Object parameter)</code>方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;mybatis插件又被称为拦截器，mybaits采用责任链模式，通过动态代理组织多个插件，通过这些插件可以改变mybatis的默认行为。mybatis允许在映射语句执行的某一点进行拦截调用。默认情况下，mybatis使用允许使用插件来拦截方法的调用包括：&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="mybatis" scheme="http://yoursite.com/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>FutureTask源码分析</title>
    <link href="http://yoursite.com/2020/01/21/FutureTask%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2020/01/21/FutureTask源码分析/</id>
    <published>2020-01-21T08:30:56.000Z</published>
    <updated>2020-01-22T13:25:49.158Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="概述">概述</span></h2><p>Future表示一个任务的生命周期，是一个可取消的异步运算，可以把它看作是一个异步操作的结果的占位符，它将在未来的某个时刻完成，并提供对结果的访问。<br>FutureTask为Future提供了基础实现，如获取任务执行结果何取消任务等。如果尚未完成，获取任务执行结果的线程会被阻塞，一旦执行结束，任务就不能被重启或取消。FutureTask常用来封装Clallable和Runnable，也可以作为一个任务提交到线程池中执行。</p><a id="more"></a><p>FutureTask内部维护了一个由<code>volatule</code>修饰的int型变量-state，待变当前任务的运行状态，state有7种状态。</p><ul><li>NEW:新建</li><li>COMPLETING:完成</li><li>NORMAL:正常运行</li><li>EXCEPTIONAL：异常退出</li><li>CANCELLED：任务取消</li><li>INTERRUPTING：线程中断中。</li><li>INTERRUPTED:线程已中断</li></ul><p><img src="https://s2.ax1x.com/2020/01/20/1iXcB8.png" alt="1iXcB8.png"></p><h2><span id="源码分析">源码分析</span></h2><h3><span id="继承体系">继承体系</span></h3><p><img src="https://s2.ax1x.com/2020/01/20/1iXgHS.png" alt="1iXgHS.png"></p><h3><span id="核心属性">核心属性</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 内部持有的callable任务，运行完毕后置为空*/</span></span><br><span class="line"><span class="keyword">private</span> Callable&lt;V&gt; callable;</span><br><span class="line"><span class="comment">/** 从get()中返回的结果或抛出的异常 */</span></span><br><span class="line"><span class="keyword">private</span> Object outcome; <span class="comment">// non-volatile, protected by state reads/writes</span></span><br><span class="line"><span class="comment">/** 运行callable的线程*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Thread runner;</span><br><span class="line"><span class="comment">/** 使用treiber栈保存等待的线程*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> WaitNode waiters;</span><br></pre></td></tr></table></figure><h3><span id="重要方法分析">重要方法分析</span></h3><h4><span id="fun方法">fun方法</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//新建任务，CAS替换runner（运行Callable的线程）为当前线程</span></span><br><span class="line">       <span class="keyword">if</span> (state != NEW ||</span><br><span class="line">           !UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, runnerOffset,</span><br><span class="line">                                        <span class="keyword">null</span>, Thread.currentThread()))</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           Callable&lt;V&gt; c = callable;</span><br><span class="line">           <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; state == NEW) &#123;</span><br><span class="line">               V result;</span><br><span class="line">               <span class="keyword">boolean</span> ran;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">//调用Callable的call方法，并记录结果</span></span><br><span class="line">                   result = c.call();</span><br><span class="line">                   ran = <span class="keyword">true</span>;</span><br><span class="line">               &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                   result = <span class="keyword">null</span>;</span><br><span class="line">                   ran = <span class="keyword">false</span>;</span><br><span class="line">                   setException(ex);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (ran)<span class="comment">//设置执行结果</span></span><br><span class="line">                   set(result);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="comment">// runner must be non-null until state is settled to</span></span><br><span class="line">           <span class="comment">// prevent concurrent calls to run()</span></span><br><span class="line">           runner = <span class="keyword">null</span>;</span><br><span class="line">           <span class="comment">// state must be re-read after nulling runner to prevent</span></span><br><span class="line">           <span class="comment">// leaked interrupts</span></span><br><span class="line">           <span class="keyword">int</span> s = state;</span><br><span class="line">           <span class="keyword">if</span> (s &gt;= INTERRUPTING)</span><br><span class="line">               handlePossibleCancellationInterrupt(s);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>运行任务，如果任务状态为NEW状态，则利用CAS修改为当前线程，执行完毕后调用<code>set</code>方法设置执行的结果。</p><h4><span id="set方法">set方法</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(V v)</span> </span>&#123;</span><br><span class="line"><span class="comment">//设置为完成态</span></span><br><span class="line">    <span class="keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, NEW, COMPLETING)) &#123;</span><br><span class="line">        <span class="comment">//设置结果</span></span><br><span class="line">        outcome = v;</span><br><span class="line">        <span class="comment">//设置为最终状态</span></span><br><span class="line">        UNSAFE.putOrderedInt(<span class="keyword">this</span>, stateOffset, NORMAL); <span class="comment">// final state</span></span><br><span class="line">        finishCompletion();<span class="comment">//执行结束，唤醒等待结果的线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>set方法主要是修改状态为完成态，获得结果，设置为结束状态。然后调用<code>finishCompletion</code>方法唤醒等待结果的线程。</p><h4><span id="finishcompletion">finishCompletion</span></h4><p>该方法的主要作用就是唤醒所有等待结果的线程来取结果了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finishCompletion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// assert state &gt; COMPLETING;</span></span><br><span class="line">       <span class="keyword">for</span> (WaitNode q; (q = waiters) != <span class="keyword">null</span>;) &#123;</span><br><span class="line">       <span class="comment">//移除等待的线程</span></span><br><span class="line">           <span class="keyword">if</span> (UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, waitersOffset, q, <span class="keyword">null</span>)) &#123;              </span><br><span class="line">               <span class="keyword">for</span> (;;) &#123;<span class="comment">//自旋遍历等待队列</span></span><br><span class="line">                   Thread t = q.thread;</span><br><span class="line">                   <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                       q.thread = <span class="keyword">null</span>;</span><br><span class="line">                       <span class="comment">//唤醒park阻塞的线程</span></span><br><span class="line">                       LockSupport.unpark(t);</span><br><span class="line">                   &#125;</span><br><span class="line">                   WaitNode next = q.next;</span><br><span class="line">                   <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   q.next = <span class="keyword">null</span>; <span class="comment">// unlink to help gc</span></span><br><span class="line">                   q = next;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   <span class="comment">//调用任务完成的回调函数，可拓展</span></span><br><span class="line">       done();</span><br><span class="line">       <span class="comment">//任务执行完毕后将callable设置为null</span></span><br><span class="line">       callable = <span class="keyword">null</span>;        <span class="comment">// to reduce footprint</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><h4><span id="get方法">get方法</span></h4><p>get方法是去获取结果，如果运行还没有结果，那么就会阻塞。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = state;</span><br><span class="line">    <span class="keyword">if</span> (s &lt;= COMPLETING)</span><br><span class="line">    <span class="comment">//任务还未完成，到阻塞队列中去等待</span></span><br><span class="line">        s = awaitDone(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">    <span class="keyword">return</span> report(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个地方调用<code>awaitDone</code>方法</p><h4><span id="report方法"><code>report</code>方法</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">report</span><span class="params">(<span class="keyword">int</span> s)</span> <span class="keyword">throws</span> ExecutionException </span>&#123;</span><br><span class="line">       Object x = outcome;</span><br><span class="line">       <span class="keyword">if</span> (s == NORMAL)</span><br><span class="line">       <span class="comment">//如果是正常结束的，就返回结果</span></span><br><span class="line">           <span class="keyword">return</span> (V)x;</span><br><span class="line">       <span class="keyword">if</span> (s &gt;= CANCELLED)</span><br><span class="line">       <span class="comment">//如果是被取消的，那返回异常</span></span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> CancellationException();</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> ExecutionException((Throwable)x);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4><span id="awaitdone方法">awaitDone方法</span></h4><p><code>awaitDone</code>方法用于等待任务完成，或者因为任务中断或超时而终止。返回任务的完成状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">awaitDone</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//获取任务返回的结果的最后期限</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> deadline = timed ? System.nanoTime() + nanos : <span class="number">0L</span>;</span><br><span class="line">        WaitNode q = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> queued = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            <span class="comment">//如果线程中断，移除等待</span></span><br><span class="line">                removeWaiter(q);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> s = state;</span><br><span class="line">            <span class="keyword">if</span> (s &gt; COMPLETING) &#123;<span class="comment">//如果任务已经完成</span></span><br><span class="line">                <span class="keyword">if</span> (q != <span class="keyword">null</span>)</span><br><span class="line">                <span class="comment">//置空等待节点线程</span></span><br><span class="line">                    q.thread = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">return</span> s;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s == COMPLETING) <span class="comment">// cannot time out yet</span></span><br><span class="line">                Thread.yield();<span class="comment">//线程让出CPU时间</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (q == <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">//将q设置为等待节点</span></span><br><span class="line">                q = <span class="keyword">new</span> WaitNode();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!queued)</span><br><span class="line">            <span class="comment">//cas修改awit</span></span><br><span class="line">                queued = UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, waitersOffset,</span><br><span class="line">                                                     q.next = waiters, q);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (timed) &#123;</span><br><span class="line">                nanos = deadline - System.nanoTime();</span><br><span class="line">                <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                <span class="comment">//如果已经超时，则移除等待节点</span></span><br><span class="line">                    removeWaiter(q);</span><br><span class="line">                    <span class="keyword">return</span> state;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//阻塞当前线程</span></span><br><span class="line">                LockSupport.parkNanos(<span class="keyword">this</span>, nanos);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;Future表示一个任务的生命周期，是一个可取消的异步运算，可以把它看作是一个异步操作的结果的占位符，它将在未来的某个时刻完成，并提供对结果的访问。&lt;br&gt;FutureTask为Future提供了基础实现，如获取任务执行结果何取消任务等。如果尚未完成，获取任务执行结果的线程会被阻塞，一旦执行结束，任务就不能被重启或取消。FutureTask常用来封装Clallable和Runnable，也可以作为一个任务提交到线程池中执行。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="源码" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
</feed>
