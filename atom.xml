<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>个人博客</title>
  
  <subtitle>博观而约取 厚积而薄发</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-12-04T15:46:45.657Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>爱写代码的小书童</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>变强日记5</title>
    <link href="http://yoursite.com/2019/12/04/%E5%8F%98%E5%BC%BA%E6%97%A5%E8%AE%B05/"/>
    <id>http://yoursite.com/2019/12/04/变强日记5/</id>
    <published>2019-12-04T09:22:56.000Z</published>
    <updated>2019-12-04T15:46:45.657Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="主要内容">主要内容</span></h2><ol><li>Java接口和抽象类的区别是什么？ </li><li>快速幂算法</li></ol><a id="more"></a><h2><span id="java接口和抽象类的区别是什么">Java接口和抽象类的区别是什么？</span></h2><h3><span id="什么是接口">什么是接口？</span></h3><p>接口是方法的集合。接口不是类。接口不能用于实例化对象，接口也没有构造方法，接口中的所有方法必须是抽象方法，<strong>接口不能包含成员变量，除了static和final修饰的变量</strong>。</p><h3><span id="什么是抽象类">什么是抽象类？</span></h3><p>如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。<strong>*抽象类除了没法直接被实例化之外，与普通的类没有什么区别</strong>，它依然有<strong>构造器</strong>，成员变量，成员方法。抽象类因为不能被直接实例化，因此抽象类是用来继承的。</p><h3><span id="它们的区别">它们的区别</span></h3><ol><li>接口中的所有方法都必须是抽象方法，当时抽象类可以同时包含抽象和非抽象的方法。</li><li>类可以实现多个接口，但是只能继承一个抽象类。</li><li>接口中声明的成员变量默认都是final的，而抽象类没有这个限制。</li><li>接口中的方法默认是public的，而抽象类中的方法可以任意指定。</li><li>抽象类可以在不实现接口方法的情况下实现接口。</li></ol><h2><span id="快速幂算法">快速幂算法</span></h2><p>题目描述：<br>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。<br>保证base和exponent不同时为0</p><p>代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">double</span> result=<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">boolean</span> flag=<span class="keyword">true</span>;</span><br><span class="line">       <span class="keyword">if</span>(exponent&lt;<span class="number">0</span>)&#123;</span><br><span class="line">           flag=<span class="keyword">false</span>;</span><br><span class="line">           exponent*=-<span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">while</span> (exponent&gt;<span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">if</span>(exponent%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">               exponent=exponent/<span class="number">2</span>; <span class="comment">//指数缩小为原来的一半</span></span><br><span class="line">               base*=base; <span class="comment">//底数扩大为原来的平方</span></span><br><span class="line">           &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">//指数为奇数的情况</span></span><br><span class="line">               exponent--;<span class="comment">//将指数化为(偶数+1)的形式</span></span><br><span class="line">               result=result*base;<span class="comment">//计算分离上面出来的那个一次方</span></span><br><span class="line">               exponent/=<span class="number">2</span>;</span><br><span class="line">               base*=base;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">return</span> flag?result:<span class="number">1</span>/result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>分析：<br>在进行幂运算的时候，最简单的方式就是利用循环。想要实现“快速”就得从减少循环的次数入手。首先看一组举例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//计算2的8次方，需要循环8次，而其等价写法</span><br><span class="line">//4的4次方只需要4次循环，这就是减少循环次数优化</span><br><span class="line">//幂计算的基本思路。我们通过变化，不断减小幂，增加第</span><br><span class="line">//从而使得循环次数不断减少</span><br><span class="line">2^8=(2^2)^(4)</span><br><span class="line"></span><br><span class="line">//当不是所有的幂都能被2整除的，这个时候我们需要一点小小的变换技巧</span><br><span class="line">2^7=(2^2)^(3)*2</span><br></pre></td></tr></table></figure></p><p>这些变换的技巧基本属于初中数学的范畴，我们只需要注意幂为偶数，和奇数的两种情况即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;主要内容&quot;&gt;&lt;a href=&quot;#主要内容&quot; class=&quot;headerlink&quot; title=&quot;主要内容&quot;&gt;&lt;/a&gt;主要内容&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;Java接口和抽象类的区别是什么？ &lt;/li&gt;
&lt;li&gt;快速幂算法&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
    
      <category term="变强日记" scheme="http://yoursite.com/tags/%E5%8F%98%E5%BC%BA%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Spring Bean的加载流程</title>
    <link href="http://yoursite.com/2019/11/30/Spring%20Bean%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/11/30/Spring Bean的加载流程/</id>
    <published>2019-11-30T09:22:56.000Z</published>
    <updated>2019-11-30T09:26:36.787Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="bean加载的总体流程">Bean加载的总体流程</span></h2><p>以这行代码为起点，探究这背后到底经历了什么？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyTestBean bean=(MyTestBean)bf.getBean(<span class="string">"MyTestBean"</span>)；</span><br></pre></td></tr></table></figure></p><ol><li>调用<code>getBean(&quot;MyTestBean&quot;)</code>背后实际是调用了<code>doGetBean(name,null,null,false)</code><br><code>doGetBean</code>方法。这个方法干的事情有些多，但总结起来就这们几步：</li></ol><ul><li>通过传入的的name参数，提取beanName属性.这个地方有可能会有疑问，传入的name不就是bean的Name吗。其实不然，因为spring还允许有别名。</li><li>尝试使用直接从缓存获取，或者sinletionFactories中的ObjectFactory中获取，具体的也就是在<code>Object sharedInstance = getSingleton(beanName);</code>代码中。这里的缓存其实就是指<code>DefaultSingletonBeanRegistry</code>类中的<code>singletonObjects:Map</code>。这个缓存就是一个<code>ConcurrentHashMap</code>其中键为BeanName，值就是对应的Bean。<a id="more"></a>具体的代码实现如下:<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*这个方法中蕴含了解决循环依赖的原理</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, <span class="keyword">boolean</span> allowEarlyReference)</span> </span>&#123;</span><br><span class="line"><span class="comment">//尝试从缓存中拿该bean</span></span><br><span class="line">Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line"><span class="comment">//如果缓存中没有该bean，且该bean正在创建中</span></span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line"><span class="comment">/**尝试从提前暴露缓存中拿到该bean</span></span><br><span class="line"><span class="comment"> *这个earlySingletonObjects也是一个map</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果从提前暴露缓存中拿也没拿到，且是允许提前引用的</span></span><br><span class="line"><span class="comment"> * 就尝试从singletonFactories中获取</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ObjectFactory&lt;?&gt; singletonFactory = <span class="keyword">this</span>.singletonFactories.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果获取到了该bean的单例工厂，就从单例工厂中来获取</span></span><br><span class="line"><span class="comment"> * 该bean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">singletonObject = singletonFactory.getObject();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将获取到的对象加入，提前暴露缓存，这个时候，其实还不能算作bean</span></span><br><span class="line"><span class="comment"> * 因为该对象还没有走完bean的生命周期</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line"><span class="comment">//从单例工厂缓存中移除该bean的单例工厂</span></span><br><span class="line"><span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> singletonObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>回到刚才的<code>doGetBean</code>方法，通过<code>getSingleton</code>方法的一番努力，如果拿到了bean，现在我们可以返回实例了。<br>这一步是由<code>bean = getObjectForBeanInstance(sharedInstance, name, beanName, null)</code>来实现<br>但值得注意的是，<strong>有些存在beanFactory的时候，spring并不是返回的实例本身，而是返回指定方法返回的实例</strong>。这个地方有点绕，其实很好理解，因为spring创建bean本身就有两种创建方法（大分类），一种是利用构造器，一种是利用工厂方法（又可分为静态工厂和实例工厂）。如果是利用工厂方法，我们当然不能直接返回工厂对象咯，而是应该返回该工厂对象中getObejct()方法返回的对象。</p><ul><li>如果没有拿到bean，那<code>doGetBean</code>还要经过一番努力。如果已经加载的类中不包括beanName（已经加载的类存在beanDefinitionMap中，值得注意的BeanDefintion对应Bean的关系，就像Class对应Object的关系一样）。那么就尝试从<code>parentBeanFactory</code>中获取BeanFactory，如果每找到就递归到BeanFactory中去找。</li><li><p>如果不仅仅做类型检测而是需要创建bean，就将该beanName记录为正在创建的状态。这个一步由这段代码实现:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">         <span class="keyword">if</span> (!typeCheckOnly) &#123;</span><br><span class="line">markBeanAsCreated(beanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>进行属性的准备，如果是子bean的话，需要合并父类的相关属性，这个也很好理解，如果一个类有继承的父类的时候，它本身包含的属性是不完整的，它还有一部分属性在它的父类中体现。这一步主要由这段代码实现:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">checkMergedBeanDefinition(mbd, beanName, args);</span><br></pre></td></tr></table></figure></li><li><p>如果存在依赖，这需要递归实例化依赖的bean。这里涉及一个不太常见的用法<code>depend-on</code>。这一步主要由这段代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">String[] dependsOn = mbd.getDependsOn();</span><br><span class="line"><span class="keyword">if</span> (dependsOn != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (String dep : dependsOn) &#123;</span><br><span class="line"><span class="keyword">if</span> (isDependent(beanName, dep)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">"Circular depends-on relationship between '"</span> + beanName + <span class="string">"' and '"</span> + dep + <span class="string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line">registerDependentBean(dep, beanName);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">getBean(dep);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">"'"</span> + beanName + <span class="string">"' depends on missing bean '"</span> + dep + <span class="string">"'"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建了bean之后，就可以实例化mbd本身了。这个时候，又分为了两种情况，一种是单例的创建，一种是原型的创建。</p></li><li>类型的转换</li></ul><h2><span id="创建bean">创建Bean</span></h2><p>createBean函数负责创建bean。这个函数在<code>doGetBean</code>方法中调用过。现在进入这个方法内部，查看其具体实现。<br>首先这个方法的声明是这样的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)</span></span></span><br></pre></td></tr></table></figure></p><p>它主要干了这些事情：</p><ol><li>调用<code>Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);</code>,根据设置的class属性和className来解析Class。这个方法的内部没有什么特别的。并且利用该方法得到的resolvedClass来初始化<code>mbdToUse:RootBeanDefinition</code></li><li>验证准备覆盖的方法<code>mbdToUse.prepareMethodOverrides();</code>.说人话，就是对override属性进行标记及验证。</li><li>通过调用<code>Object bean = resolveBeforeInstantiation(beanName, mbdToUse);</code>给bean后置处理器一个通过代理类替换目标类的机会。这个地方需要注意。</li><li>调用<code>Object beanInstance = doCreateBean(beanName, mbdToUse, args);</code>来进行Bean的创建</li></ol><h2><span id="循环依赖">循环依赖</span></h2><p>什么是循环依赖？<br>循环依赖就是循环引用。就是两个或多个bean相互之间持有对方。比如beanA中引用了beanB，而beanB中引用了beanA。那么这两个bean之间就形成了循环依赖。<strong>值得注意的是循环依赖不等于循环调用。</strong>循环调用是方法调用之间成环。循环调用是无解的。</p><p>spring是如何解决循环依赖的？<br>要回答回答这个问题，首先要清楚，spring中bean有哪几种循环依赖，哪些循环依赖是可以解决的。</p><h3><span id="循环依赖的分类">循环依赖的分类</span></h3><ol><li>构造器循环依赖<br>这种依赖的成因是因为构造器注入形成的循环依赖。这种依赖是无解的。因此，我们不太建议使用构造器注入。至于为什么无法解决构造器循环依赖，原因其实非常的简单。举例：假如beanA在调用构造器的时候，发现需要beanB作为参数，然后去调用beanB的构造器，发现又需要beanA作为参数，这种情况根本没得搞，死循环了。</li><li>setter循环依赖<br>表示通过setter注入方式构成的循环依赖。setter循环依赖在单例作用域下是可以解决的。spring通过提前暴露完成实例化的bean来解决setter循环依赖。举个栗子：beanA实例化后，进行属性赋值的时候，发现它需要通过setter注入beanB,然后他就去实例化beanB，beanB实例化之后，在beanB属性赋值的时候，发现需要注入beanA，这个时候因为beanA已经提前暴露了（它现在还没完整的创建），beanB发现了beanA，然后直接把beanA注入即可，这个时候beanB的属性赋值阶段，已经完成了，这个时候我们再看beanA，这个时候直接把beanB注入beanA即可了，这样循环依赖就解决了。</li></ol><p><strong>在解决循环依赖的过程中，很关键的两点是：哪些bean正在创建需要透明；bean实例化之后，就可暴露出来，供其它bean注入。</strong></p><ol start="3"><li>prototype范围的依赖处理<br>prototype范围的循环依赖也是无解的，因为spring不会缓存prototype范围的对象，因此无法实现提前暴露。</li></ol><h2><span id="常规的bean的创建">常规的bean的创建</span></h2><h3><span id="总体的流程">总体的流程</span></h3><p>所谓的常规的，就是指在<code>createBean</code>中调用了<code>Object bean = resolveBeforeInstantiation(beanName, mbdToUse);</code>后，并没有创建代理，就调用<code>doCreateBean</code>。该方法进行的就是常规的bean的创建。</p><p>这个类主要做了这些事情：</p><ol><li><p>如果是单例则首先清除缓存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">instanceWrapper = <span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>根据bean所指定的策略创建实例,将beanDefinition转换为BeanWrapper，这个方法的内部实现其实比较复杂。如果存在工厂方法，就使用工厂方法进行初始化；如果有多个构造器，则根据参数匹配构造器来初始化；如果没有工厂方法，也不存在带参数的构造器，则使用默认构造方法进行实例化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br></pre></td></tr></table></figure></li><li><p>判断是否需要提前曝光，根据这些条件来进行判断：单例&amp;允许循环依赖&amp;当前bean正在创建过程中。当需要提前曝光时，在bean创建完成之前将创建实例的ObjectFactory加入工厂</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">isSingletonCurrentlyInCreation(beanName));</span><br><span class="line"><span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Eagerly caching bean '"</span> + beanName +</span><br><span class="line"><span class="string">"' to allow for resolving potential circular references"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为避免后期循环依赖，可以在bean初始化完成之前将创建实例的ObjectFactory加入工厂</span></span><br><span class="line"><span class="comment"> *getEarlyBeanReference需要注意，AOP就是在这将advice织入bean的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>属性填充，也就是在这个地方，就可能出现循环依赖，如果存在依赖其它bean的属性，则会递归初始化bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">populateBean(beanName, mbd, instanceWrapper);</span><br></pre></td></tr></table></figure></li><li><p>调用初始化方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br></pre></td></tr></table></figure></li><li><p>检测依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">removeSingletonIfCreatedForTypeCheckOnly(dependentBean)<span class="keyword">for</span> (String dependentBean : dependentBeans) &#123;</span><br><span class="line"><span class="keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">actualDependentBeans.add(dependentBean);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><code>removeSingletonIfCreatedForTypeCheckOnly(dependentBean)</code>方法所做的事情就是去一个<code>alreadyCreated:Map</code>中看，该bean所依赖的bean，是否已经被创建了，如果被创建了，就将该bean从三级缓存和<code>registeredSingletons:map</code>中删除，并返回true。如果所依赖的bean已经被创建，就将该bean加入<code>actualDependentBeans:Set</code>.完成对所有的依赖的bean的检测之后，如果<code>actualDependentBeans:Set</code>不为空，就抛出循环依赖异常（这个地方值得注意的是，如果一个bean创建成功了，那么它所依赖的bean也一定是创建了的，如果它所依赖的bean没有被创建，这就说明存在循环依赖）</p><ol start="7"><li><p>根据scopse注册bean<br>所谓的注册就是将bean加入一个<code>disposableBeans:map</code>中去。便于在销毁时使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br></pre></td></tr></table></figure></li><li><p>完成创建并返回</p></li></ol><h3><span id="完成bean实例化的createbeaninstance方法">完成bean实例化的createBeanInstance方法</span></h3><p><code>instanceWrapper = createBeanInstance(beanName, mbd, args);</code>这个方法主要完成了bean的实例化。这也是bean生命周期的第一步。<br>这个方法主要做以下几件事情：</p><ol><li>拿到beanName对应的class<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName);</span><br></pre></td></tr></table></figure></li></ol><p>像class这些信息在spring初始化的使用就已经拿到了。这个敌法只是取出来就可以了。</p><ol start="2"><li>如果有相应的工厂方法，就使用工厂方法创建bean<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mbd.getFactoryMethodName() != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> instantiateUsingFactoryMethod(beanName, mbd, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>spring创建bean无非就是两种方案，一个是利用工厂方法，一个是利用构造器。如果没有对应的工厂方法，那就只好使用构造器来实例化。</p><ol start="3"><li>没有对应的工厂方法，就使用构造器来实例化。先锁定构造方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;</span><br><span class="line"><span class="keyword">if</span> (mbd.resolvedConstructorOrFactoryMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">resolved = <span class="keyword">true</span>;</span><br><span class="line">autowireNecessary = mbd.constructorArgumentsResolved;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>因为一个类可能有多个构造方法，所以这个地方需要根据参数来确定调用哪个构造函数或工厂方法。因为这个操作是比较费时的所以spring采用了缓存的机制。</p><ol start="4"><li><p>经过解析，调用相应的构造方法进行初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果已经解析过勒，则使用解析好的构造函数方法，而无需再次锁定</span></span><br><span class="line"><span class="keyword">if</span> (resolved) &#123;</span><br><span class="line"><span class="keyword">if</span> (autowireNecessary) &#123;</span><br><span class="line"><span class="comment">//构造函数自动注入</span></span><br><span class="line"><span class="keyword">return</span> autowireConstructor(beanName, mbd, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//使用默认构造函数注入</span></span><br><span class="line"><span class="keyword">return</span> instantiateBean(beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果需要根据参数来解析构造函数，就执行以下几步</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Candidate constructors for autowiring?</span></span><br><span class="line">Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);</span><br><span class="line"><span class="keyword">if</span> (ctors != <span class="keyword">null</span> || mbd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR ||</span><br><span class="line">mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) &#123;</span><br><span class="line"><span class="keyword">return</span> autowireConstructor(beanName, mbd, ctors, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>带参数的实例化，其实非常的复杂，因为它充满了不确定性。</p><h2><span id="容器功能的拓展">容器功能的拓展</span></h2><p>ApplicationContext对BeanFactory进行了拓展。ApplicationContext包含了BeanFactory的所有功能。<br>从这行代码，为起点来看它背后的东西：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext bf=<span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"beanFactory.xml"</span>);</span><br></pre></td></tr></table></figure></p><ol><li>首先它调用了一个有参构造器<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(String configLocation)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="keyword">this</span>(<span class="keyword">new</span> String[] &#123;configLocation&#125;, <span class="keyword">true</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>它又调用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">String[] configLocations, <span class="keyword">boolean</span> refresh, @Nullable ApplicationContext parent)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">super</span>(parent);</span><br><span class="line"><span class="comment">//将配置文件以路径数组的方式传入</span></span><br><span class="line">setConfigLocations(configLocations);</span><br><span class="line"><span class="keyword">if</span> (refresh) &#123;</span><br><span class="line">refresh();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="2"><li>设置了配置文件的路径，之后就可以进行配置文件的解析和各种功能的实现了。这些东西都是在<code>refresh</code>方法中实现了。<br>完整的代码如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line"><span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line"><span class="comment">//准备刷新的上下文环境</span></span><br><span class="line">prepareRefresh();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line"><span class="comment">//初始化BeanFactory并进行xml文件的读取</span></span><br><span class="line">ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line"><span class="comment">//对beanFactory进行功能上的填充</span></span><br><span class="line">prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line"><span class="comment">//子类覆盖方法做额外的处理</span></span><br><span class="line">postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line"><span class="comment">//调用各种beanFactory处理器</span></span><br><span class="line">invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line"><span class="comment">//注册拦截bean创建的bean处理器</span></span><br><span class="line">registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize message source for this context.</span></span><br><span class="line"><span class="comment">//为上下文初始化message源，即不同的语言的消息体，国际化处理</span></span><br><span class="line">initMessageSource();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line"><span class="comment">//初始化应用消息广播器</span></span><br><span class="line">initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line"><span class="comment">//留给子类来初始化其它的bean</span></span><br><span class="line">onRefresh();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check for listener beans and register them.</span></span><br><span class="line"><span class="comment">//在所有的bean中查找listener bean，并注册到消息广播器中</span></span><br><span class="line">registerListeners();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line"><span class="comment">//初始化剩下的非懒加载的单实例</span></span><br><span class="line">finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line"><span class="comment">//完成刷新过程</span></span><br><span class="line">finishRefresh();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">logger.warn(<span class="string">"Exception encountered during context initialization - "</span> +</span><br><span class="line"><span class="string">"cancelling refresh attempt: "</span> + ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">destroyBeans();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reset 'active' flag.</span></span><br><span class="line">cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Propagate exception to caller.</span></span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">// Reset common introspection caches in Spring's core, since we</span></span><br><span class="line"><span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">resetCommonCaches();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>它主要做了这些事情：</p><ul><li>初始化前的准备工作。例如对系统属性或者环境变量进行准备和验证</li><li><p>初始化beanFactory并进行xml文件的读取。因为ApplicationContext包含了BeanFactory所提供的一切特征，在这一步就是利用BeanFactroy中的xml文件读取的相关功能。也就是从这一步开始ApplicationContext已经包含了一个BeanFactory了。这段代码可以佐证：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title">obtainFreshBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">refreshBeanFactory();</span><br><span class="line"><span class="comment">//这一步就创建了一个BeanFactory</span></span><br><span class="line">ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Bean factory for "</span> + getDisplayName() + <span class="string">": "</span> + beanFactory);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> beanFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对BeanFactory进行各种功能填充，常见的<code>@Autowired</code>就是在这一步增加支持的。</p></li><li>子类覆盖方法做额外的处理。通过这个拓展点，可以方便程序员来拓展spring的功能</li><li>调用各种beanFactoty处理器</li><li>注册拦截bean创建的bean处理器，这一步并没有调用，真正调用的是在getBean的时候</li><li>为上下文初始化message源，对不同语言的消息题进行国际化处理。</li><li>初始化应用消息广播器。</li><li>留给子类来初始化其它的bean</li><li>在所有的注册的bean中查找 listener bean，注册到消息广播器中。</li><li>初始化涉嫌的单实例</li><li>完成刷新过程</li></ul><h3><span id="重要步骤细节分析">重要步骤细节分析</span></h3><p><strong>1. 环境准备</strong><br>环境准备调用的是<code>protected void prepareRefresh()</code>方法，该方法的内部实现，有行关键的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//留给子类覆盖的，这个方法内部是空的</span></span><br><span class="line">initPropertySources();</span><br><span class="line"><span class="comment">//验证所需的属性文件是否都已经放入环境中了</span></span><br><span class="line">getEnvironment().validateRequiredProperties();</span><br></pre></td></tr></table></figure></p><p>其实这两行代码基本没做什么实际的事情，包括第二行代码，因为实际上因为没有什么需要验证的属性，所以第二行代码也没有做什么实际的事情。这两行的代码的意义在于，提供了拓展点。通过重写<code>initPropertySources()</code>来实现个性化的属性处理，之后再利用<code>validateRequiredProperties</code>对属性进行验证。</p><p><strong>2. 加载BeanFactory</strong></p><p>获取<code>BeanFactory</code>,这个工作由这行代码实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br></pre></td></tr></table></figure></p><p>也正是从这个地方开始，ApplicationContext有了BeanFactory的全部功能。<br><code>obtainFreshBeanFactory()</code>方法中调用了<code>refreshBeanFactory()</code>方法，由这个方法来完成了BeanFactory的初始化工作。<br>这个方法完成的首要工作就是创建<code>beanFactory：DefaultListableBeanFactory</code>,这个对象非常的重要，它整个IOC容器的关键。之后是指定序列化ID，定制BeanFactory，加载BeanDefinition，最后使用全局变量记录BeanFactory实例。</p><p><strong>3. 加载beanDefinition</strong><br>加载beanDefeinition的第一步就是初始化用于读取配置文件的<code>beanDefinitionReader:XmlBeanDefinitionReader</code>.创建成功之后，对<code>beanDefinitionReader</code>做环境变量的设置之后，就可以使用<code>loadBeanDefinitions(beanDefinitionReader)</code>读取并解析spring配置文件，来加载BeanDefinitinon。</p><p><strong>4. 功能拓展</strong><br>spring在<code>prepareBeanFactory(ConfigurableListableBeanFactory beanFactory)</code>,方法中完成了ApplicationContext的功能的拓展。<br>主要是添加了以下几个方面的拓展：</p><ol><li>增加对spEL语言的支持</li><li>证件对属性编辑器的支持</li><li>增加对一些内置类的信息注入。</li><li>设置了依赖功能可能忽略的接口</li><li>注册了一些固定依赖的属性</li><li>增加了AspectJ的支持</li><li>将相关环境变量及属性注册以单例模式注册</li></ol><p><strong>5. BeanFactory的后处理</strong><br>BeanFactory作为spring中容器功能的基础，用于存放所有已经加载的bean，为了保证程序的高可拓展性，Spring针对BeanFactory做了大量的拓展。PostProcessor等都是在这个地方实现的。<br>后处理主要做了这些事情：</p><ol><li>激活BeanFactoryPostProcessor<br><code>invokeBeanFactoryPostProcessors(beanFactory);</code>调用了所有的后置处理器，其中首先调用所有的硬编码配置的后置处理器，其后调用了配置注册的后置处理器。在执行的时候，它会按照配置中order属性来按一定的顺序来执行那些后置处理器。spring通过三个list来记录这些后置处理器。它们分别是：</li><li><code>registryPostProcessors</code>记录通过硬编码方式注册的<code>BeanDefinitionRegistryPostProcessor</code>类型的处理器</li><li><code>regularPostProcessors</code>记录通过硬编码方式注册的<code>BeanFactoryPostProcessor</code>类型的处理器</li><li><code>registryPostProcessorBeans</code>记录通过配置方式注册的<code>BeanDefinitonRegistryPostProcessor</code>类型的处理器。</li></ol><p><strong>6. 注册BeanPostProcessor</strong><br>实现了对BeanFactoryPostProcessor的调用之后，就要进行BeanPostProcessor的注册了。spring中许多的功能都是通过后处理器的方式来拓展的。BeanPostProcessor的处理与BeanFactoryPostProcessor的处理几位相似。在注册之前需要根据 <code>PriorityOrdered</code>进行排序，根据<code>Ordered</code>进行排序或者无序。</p><p><strong>7. 初始化消息资源</strong><br>初始化消息资源是为了进行国际化处理。在确定特定类型的本地化信息的时候，，需要两个条件，一个是“语言条件”，另一个是“国家/地区的类型”。spring定义了国际化信息的<code>MessageSource</code>接口。</p><p><strong>8. 初始化ApplicationEventMulticaster</strong><br>首先来展示一下Spring事件监听器的简单用法：<br>1.定义监听事件<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> classs TestEvent extends ApplicationEvent&#123;</span><br><span class="line">    <span class="keyword">public</span> String msg;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestEvent</span><span class="params">(Object source)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(source);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestEvent</span><span class="params">(Object source,String msg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(source);</span><br><span class="line">        <span class="keyword">this</span>.msg=msg;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="2"><li><p>定义监听器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationEvent event)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(event <span class="keyword">instanceof</span> TestEvent)&#123;</span><br><span class="line">            TestEvent testEvent=(TestEvent)event;</span><br><span class="line">            testEvent.print();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写配置文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"testListener"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.test.event.TestListener"</span>/&gt;</span><br></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ApplicationContext context=<span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"classpath:applicationContext.xml"</span>);</span><br><span class="line">        TestEvent event=<span class="keyword">new</span> TestEvent(<span class="string">"hello"</span>,<span class="string">"msg"</span>);</span><br><span class="line">        context.publishEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>控制台输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msg</span><br></pre></td></tr></table></figure></p><p>具体的操作由<code>initApplicationEventMulticaster();</code>来实现，它无非就处理了两种情况一种是：如果用户自定义了事件广播器，那么使用用户自定义的事件广播器。第二种情况：如果用户没有自定义事件广播器，那么使用默认的ApllicationEventMulticaster。<br><strong>这个地方运用了设计模式的观察者模式</strong>.<br>当spring事件产生的时候会默认使用<code>SimpleApplicationEventMulticaster</code>的<code>multicastEvent</code>来广播事件，Spring会遍历所有的监听器，并使用监听器的<code>onApplicationEvent</code>方法来进行监听器的处理。因此其实每个监听器都可以收到事件，是否进行处理则由监听器来决定。</p><p><strong>9. 注册监听器</strong><br>注册监听器由<code>registerListeners();</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerListeners</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//硬编码方式注册的监听器处理</span></span><br><span class="line"><span class="keyword">for</span> (ApplicationListener&lt;?&gt; listener : getApplicationListeners()) &#123;</span><br><span class="line">getApplicationEventMulticaster().addApplicationListener(listener);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 配置文件注册的监听器处理</span></span><br><span class="line">String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">for</span> (String listenerBeanName : listenerBeanNames) &#123;</span><br><span class="line">getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Publish early application events now that we finally have a multicaster...</span></span><br><span class="line">Set&lt;ApplicationEvent&gt; earlyEventsToProcess = <span class="keyword">this</span>.earlyApplicationEvents;</span><br><span class="line"><span class="keyword">this</span>.earlyApplicationEvents = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (earlyEventsToProcess != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (ApplicationEvent earlyEvent : earlyEventsToProcess) &#123;</span><br><span class="line">getApplicationEventMulticaster().multicastEvent(earlyEvent);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>10. 初始化非延时加载的单例</strong><br>其中包括<code>ConversionService</code>的配置,配置冻结以及非延迟加载的bean的初始化工作。所谓的冻结配置就是注册的bean的定义将不被修改或进行任何进一步的处理。ApplicationContext实现的默认行为就是在启动时将所有单例bean提前进行实例化。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Bean加载的总体流程&quot;&gt;&lt;a href=&quot;#Bean加载的总体流程&quot; class=&quot;headerlink&quot; title=&quot;Bean加载的总体流程&quot;&gt;&lt;/a&gt;Bean加载的总体流程&lt;/h2&gt;&lt;p&gt;以这行代码为起点，探究这背后到底经历了什么？&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;MyTestBean bean=(MyTestBean)bf.getBean(&lt;span class=&quot;string&quot;&gt;&quot;MyTestBean&quot;&lt;/span&gt;)；&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;调用&lt;code&gt;getBean(&amp;quot;MyTestBean&amp;quot;)&lt;/code&gt;背后实际是调用了&lt;code&gt;doGetBean(name,null,null,false)&lt;/code&gt;&lt;br&gt;&lt;code&gt;doGetBean&lt;/code&gt;方法。这个方法干的事情有些多，但总结起来就这们几步：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;通过传入的的name参数，提取beanName属性.这个地方有可能会有疑问，传入的name不就是bean的Name吗。其实不然，因为spring还允许有别名。&lt;/li&gt;
&lt;li&gt;尝试使用直接从缓存获取，或者sinletionFactories中的ObjectFactory中获取，具体的也就是在&lt;code&gt;Object sharedInstance = getSingleton(beanName);&lt;/code&gt;代码中。这里的缓存其实就是指&lt;code&gt;DefaultSingletonBeanRegistry&lt;/code&gt;类中的&lt;code&gt;singletonObjects:Map&lt;/code&gt;。这个缓存就是一个&lt;code&gt;ConcurrentHashMap&lt;/code&gt;其中键为BeanName，值就是对应的Bean。
    
    </summary>
    
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>变强日记4</title>
    <link href="http://yoursite.com/2019/11/16/%E5%8F%98%E5%BC%BA%E6%97%A5%E8%AE%B04/"/>
    <id>http://yoursite.com/2019/11/16/变强日记4/</id>
    <published>2019-11-16T09:23:56.000Z</published>
    <updated>2019-11-16T09:24:23.276Z</updated>
    
    <content type="html"><![CDATA[<p>最近被spring的源码搞自闭了，有好几天没写这个分类的文章了。</p><h2><span id="主要内容">主要内容</span></h2><ol><li>Hashmap的一些知识点</li><li>Java实现二叉搜索树<a id="more"></a><h2><span id="hashmap的一些知识点">Hashmap的一些知识点</span></h2>JDK8以后采用了数组+链表+红黑树的方式来实现hashmap；使用链表存储的优势是可以降低内存的使用率，而红黑树的优点是查询效率更高。<h3><span id="hashmap的扩容">Hashmap的扩容</span></h3><strong>扩容的过程？</strong><br>hashmap的扩容一般是发生在插入元素的时候，当数组的使用率超过负载因子的时候（默认值是0.75），便会进行扩容。扩容为原来的两倍。<br><strong>为什么总是2倍扩容，为什么初始容量是2的n次幂？</strong><br>因为插入元素时，需要利用key的hashcode来找到对应的桶位，java并没有采用取模的方式来确定桶位，而是<strong>采用length-1进行与运算来确定桶位</strong>。如果length是2的倍数，那么length-1的二进制就是全为1的，这样在与key的hashcode进行与运算，hashcode的每一位都能够起到作用。（如果length-1的二进制某一位为0，那么key的hashcode对应的位，无论是1还是0，结果都一样，都是0，显然，这一位在确定桶位的时候，就没有了意义）<h3><span id="为什么要使用红黑树而是不avl树">为什么要使用红黑树，而是不AVL树？</span></h3>AVL树和红黑树都是常见的平衡二叉树。AVL更加严格平衡，因此能够有更好的查询效率。对于插入密集型任务红黑树更加适合。<h3><span id="并发环境下使用hashmap会导致什么问题">并发环境下使用HashMap会导致什么问题</span></h3>因为hashmap不是线程安全的，不适用于多线程环境。</li><li>可能导致get无限循环<br>在对现场rehash的过程中可能会形成循环链表，导致查找元素的时候一直无法遍历完整个链表，从而出现死循环。最终导致CPU使用率100%。 其原因在于并发下Rehash可能导致循环链表的实现。</li><li>可能导致put丢失<br>在put的时候，如果两个产生hash碰撞，导致两个线程得到同样的index去存储，导致覆盖丢失的情况。</li></ol><h2><span id="java实现二叉查找树">java实现二叉查找树</span></h2><p>二叉树的中的关键字总是以满足二叉搜索树的性质的方式来存储的：<br>设x是二叉搜索树的一个节点。如果y是x左子树的一个节点 ，那么y.key&lt;=x.key。如果y是x的右子树中的一个节点，那么y.key&gt;=x.key.</p><p>二叉查找树的插入，查找，更新比较简单。而删除操作比较复杂，尤其是待删除的节点既有左子树又有右子树的情况，非常的复杂。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二叉查找树</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;value&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BSTree</span> &lt;<span class="title">key</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">key</span>&gt;,<span class="title">value</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该二叉查找树的根</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 节点内部类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> key k;</span><br><span class="line">        <span class="keyword">private</span> value v;</span><br><span class="line">        <span class="keyword">private</span> Node left;</span><br><span class="line">        <span class="keyword">private</span> Node right;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(key k,value val)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.k=k;</span><br><span class="line">            <span class="keyword">this</span>.v=val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 二叉查找树的插入</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(key k,value v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//如果当前树是空树，就进行插入</span></span><br><span class="line">            root=<span class="keyword">new</span> Node(k,v);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node cur=root;</span><br><span class="line">        Node parent=<span class="keyword">new</span> Node();</span><br><span class="line">        <span class="keyword">boolean</span> isLeftTree=<span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            parent=cur;</span><br><span class="line">            <span class="keyword">if</span>(cur.k.compareTo(k)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                cur=cur.right;</span><br><span class="line">                isLeftTree=<span class="keyword">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                cur=cur.left;</span><br><span class="line">                isLeftTree=<span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//新节点</span></span><br><span class="line">        Node newNode =<span class="keyword">new</span> Node(k,v);</span><br><span class="line">        <span class="keyword">if</span>(isLeftTree)&#123;</span><br><span class="line">            parent.left=newNode;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            parent.right=newNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">delete</span><span class="params">(key k)</span></span>&#123;</span><br><span class="line">        Node cur=root;</span><br><span class="line">        Node parent=root;</span><br><span class="line">        <span class="keyword">boolean</span> isLeftTree=<span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//首先查找待删除的节点的位置</span></span><br><span class="line">        <span class="keyword">while</span> (cur.k!=k)&#123;</span><br><span class="line">            parent=cur;</span><br><span class="line">            <span class="keyword">if</span>(k.compareTo(cur.k)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                cur=cur.left;</span><br><span class="line">                isLeftTree=<span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                cur=cur.right;</span><br><span class="line">                isLeftTree=<span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cur==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//待删除节点是叶子节点的情况</span></span><br><span class="line">        <span class="keyword">if</span>(cur.left==<span class="keyword">null</span>&amp;&amp;cur.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur==root)&#123;</span><br><span class="line">                root=<span class="keyword">null</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>  <span class="keyword">if</span>(isLeftTree)&#123;</span><br><span class="line">                parent.left=<span class="keyword">null</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                parent.right=<span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cur.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//当前节点只有左孩子</span></span><br><span class="line">            <span class="keyword">if</span>(cur==root)&#123;</span><br><span class="line">                root=cur.left;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(isLeftTree)&#123;</span><br><span class="line">                parent.left=cur.left;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                parent.right=cur.left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cur.left==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//当前节点只有右孩子</span></span><br><span class="line">            <span class="keyword">if</span>(cur==root)&#123;</span><br><span class="line">                root=cur.right;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(isLeftTree)&#123;</span><br><span class="line">                parent.left=cur.right;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                parent.right=cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//待删除的节点有既有左孩子，又有右孩子的情况</span></span><br><span class="line">            Node successor=getSuccessor(cur);</span><br><span class="line">            <span class="keyword">if</span>(cur==root)&#123;</span><br><span class="line">                root=successor;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(isLeftTree)&#123;</span><br><span class="line">                parent.left=successor;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                parent.right=successor;</span><br><span class="line">            &#125;</span><br><span class="line">            successor.left=cur.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对以待删除的节点为根的树进行旋转</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> delNode</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">getSuccessor</span><span class="params">(Node delNode)</span></span>&#123;</span><br><span class="line">        Node successorParent=delNode;</span><br><span class="line">        Node successor=delNode;</span><br><span class="line">        Node cur=delNode.right;</span><br><span class="line">        <span class="keyword">while</span> (cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            successorParent=successor;</span><br><span class="line">            successor=cur;</span><br><span class="line">            cur=cur.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(successor!=delNode.right)&#123;</span><br><span class="line">            successorParent.left=successor.right;</span><br><span class="line">            successor.right=delNode.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> successor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查找</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> value <span class="title">get</span><span class="params">(key k)</span></span>&#123;</span><br><span class="line">        Node cur=root;</span><br><span class="line">        <span class="keyword">while</span> (cur.k!=k)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.k.compareTo(k)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                cur=cur.right;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                cur=cur.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cur==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur.v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 改</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> newVal</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">update</span><span class="params">(key k,value newVal)</span></span>&#123;</span><br><span class="line">        Node cur=root;</span><br><span class="line">        <span class="keyword">while</span> (cur.k!=k)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.k.compareTo(k)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                cur=cur.right;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                cur=cur.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cur==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.v=newVal;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近被spring的源码搞自闭了，有好几天没写这个分类的文章了。&lt;/p&gt;
&lt;h2 id=&quot;主要内容&quot;&gt;&lt;a href=&quot;#主要内容&quot; class=&quot;headerlink&quot; title=&quot;主要内容&quot;&gt;&lt;/a&gt;主要内容&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;Hashmap的一些知识点&lt;/li&gt;
&lt;li&gt;Java实现二叉搜索树
    
    </summary>
    
    
    
      <category term="变强日记" scheme="http://yoursite.com/tags/%E5%8F%98%E5%BC%BA%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>变强日记3</title>
    <link href="http://yoursite.com/2019/11/07/%E5%8F%98%E5%BC%BA%E6%97%A5%E8%AE%B03/"/>
    <id>http://yoursite.com/2019/11/07/变强日记3/</id>
    <published>2019-11-07T12:55:56.000Z</published>
    <updated>2019-11-11T14:13:17.459Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="主要内容">主要内容</span></h2><ol><li>java中的==、equals()和hashCode()</li><li>算法题leetcode[15]:3Sum</li></ol><h2><span id="java中的-equals和hashcode">java中的==、equals()和hashCode()</span></h2><h3><span id="运算符">“==”运算符</span></h3><p>首先来看最基础的<code>==</code>符号，它比较的是变量（栈）内存中存放的对象（堆）的内存地址，用来判断两个对象的地址是否相同，即是否指向同一个对象。<br><strong>简单来说==比较的是，是否指向同一个对象（堆）</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       String str1=<span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">       String str2=<span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line"></span><br><span class="line">       String str3=<span class="string">"efg"</span>;</span><br><span class="line">       String str4=<span class="string">"efg"</span>;</span><br><span class="line">       System.out.println(str1==str2);</span><br><span class="line">       System.out.println(str3==str4);</span><br><span class="line">       <span class="comment">//输出：</span></span><br><span class="line">       <span class="comment">//false</span></span><br><span class="line">       <span class="comment">//true</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>现象解释：<code>str1==str2</code>输出false，是因为str1和str2虽然存储的字符串相同，但是它们各自new了自己单独的对象，而==比较的是指向的对象是否相同，所以输出false。<br>而<code>str3==str4</code>是因为<strong>java中变量池</strong>的存在，定义str3和str4的时候，java回到变量池中寻找是否存在已经定义过的，如果有已经定义了的，那么直接将引用指向它就可以了，不必再重新新建对象了。因为str3和str4指向同一个对象，所以<code>str3==str4</code>为true。</p><h3><span id="equals">equals()</span></h3><p>首先看一段代码我们写了一个Myobj，并new了两个对象，分别使用==和equals()来进行比较<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Myobj obj1=<span class="keyword">new</span> Myobj(<span class="string">"aaa"</span>);</span><br><span class="line">        Myobj obj2=<span class="keyword">new</span> Myobj(<span class="string">"aaa"</span>);</span><br><span class="line">        System.out.println(obj1==obj2);</span><br><span class="line">        System.out.println(obj1.equals(obj2));</span><br><span class="line">        <span class="comment">//输出</span></span><br><span class="line">        <span class="comment">//false</span></span><br><span class="line">        <span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Myobj</span></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Myobj</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>现象解释：</strong><br><code>obj1==obj2</code>输出false，很好理解，因为==比较的是指向的对象是否是同一个，因为obj1和obj2指向了它们各自new的对象，所以为false。<br><code>obj1.equals(obj2)</code>输出false，是因为我们在<code>Myobj</code>没有重写<code>equals()</code>方法,使用的是<code>Object</code>中的<code>equals()</code>方法.<br><code>Object</code>类中的<code>equals()</code>方法的实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看到了<code>Object</code>类中的<code>equals()</code>方法的实现，对<code>obj1.equals(obj2)</code>输出false也很好理解了，因为它本质上和<code>obj1==obj2</code>是一样的。<br><strong>重写equals()方法：</strong><br>如果我们认为name相同的MyObject对象就是equals的的话，我们就需要重写equals()方法了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Myobj obj1=<span class="keyword">new</span> Myobj(<span class="string">"aaa"</span>);</span><br><span class="line">        Myobj obj2=<span class="keyword">new</span> Myobj(<span class="string">"aaa"</span>);</span><br><span class="line">        System.out.println(obj1==obj2);</span><br><span class="line">        System.out.println(obj1.equals(obj2));</span><br><span class="line">        <span class="comment">//输出；</span></span><br><span class="line">        <span class="comment">//false</span></span><br><span class="line">        <span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Myobj</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Myobj</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Myobj obj)</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>.name.equals(obj.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3><span id="hashcode">hashCode()</span></h3><ol><li>hashCode()方法的作用是什么<br>HashCode()方法主要是在哈希表中起作用，如HashSet、HashMap等。单我们向哈希表中添加对象的时候，首先会调用hashCode()方法计算Object的哈希码，根据哈希码的值，确定该对象在哈希表中的位置，如果该位置已经有对象了，那么就调用equals()比较这些对象与Object是否相等，如果相等，则不需要保存object对象，如果不相等，则把对象加入链表中。<br>这也就解释了<strong>equals()相等，则hashCode()必须相等</strong>，如果两个对象equals相等，那么它们在哈希表中应该只出现一次，如果hashCode不相等，那么它们会被散列到哈希表中的不同位置，就不止出现一次了。</li></ol><p><strong>重写hashCode()</strong><br>几个原则：</p><ol><li>equals相等，则hashCode必须相等（重点）</li><li>hashCode不能太简单，否则哈希冲突会很多</li><li>hashCode不能太复杂，否则计算耗时，影响性能</li></ol><p><code>Object</code>类中的hashCode方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p><p>重写hashcode<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Myobj obj1=<span class="keyword">new</span> Myobj(<span class="string">"aaa"</span>,<span class="number">1</span>);</span><br><span class="line">        Myobj obj2=<span class="keyword">new</span> Myobj(<span class="string">"aaa"</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(obj1.equals(obj2));</span><br><span class="line">        System.out.println(obj1.hashCode()==obj2.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Myobj</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Myobj</span><span class="params">(String name,<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">        <span class="keyword">this</span>.id=id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Myobj obj)</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>.name.equals(obj.name)&amp;&amp;<span class="keyword">this</span>.id==obj.id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hash=<span class="number">17</span>;</span><br><span class="line">        <span class="comment">//选取了equals方法中的两个用于比较的域name和id</span></span><br><span class="line">        hash=hash*<span class="number">31</span>+name.hashCode();</span><br><span class="line">        hash=hash*<span class="number">31</span>+id;</span><br><span class="line">        <span class="keyword">return</span> hash;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>《Effective Java》中提出的一种重写hashCode的方法：</p><ol><li>初始化一个整形变量，并赋予一个非零的常数</li><li>选取equals方法中用于比较的所有域，然后针对每个域的属性进行计算（确保原则一）</li><li>将每个域的散列码合并到对象的哈希码中</li></ol><h2><span id="算法题leetcode153sum">算法题leetcode[15]:3Sum</span></h2><p><strong>题目：</strong><br>Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.</p><p>Note:<br>The solution set must not contain duplicate triplets.</p><p>Example:<br>Given array nums = [-1, 0, 1, 2, -1, -4],<br>A solution set is:<br>[<br>  [-1, 0, 1],<br>  [-1, -1, 2]<br>]</p><p><strong>分析：</strong><br>首先对数据进行排序，然后固定也给位置，从两边进行夹逼。</p><p><strong>解法：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result=<span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="comment">//用于存储结果</span></span><br><span class="line">       </span><br><span class="line">        <span class="keyword">if</span>(nums==<span class="keyword">null</span>||nums.length&lt;<span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 首先进行排序</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="comment">//首先国定一个位置，再去寻找另外两个数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length-<span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;nums[i]==nums[i-<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            find(nums,i+<span class="number">1</span>,nums.length-<span class="number">1</span>,nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> begin,<span class="keyword">int</span> end,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l=begin;</span><br><span class="line">        <span class="keyword">int</span> r=end;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">            <span class="keyword">if</span>((nums[l]+nums[r]+target)==<span class="number">0</span>)&#123;</span><br><span class="line">                List&lt;Integer&gt; list=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">                list.add(target);</span><br><span class="line">                list.add(nums[l]);</span><br><span class="line">                list.add(nums[r]);</span><br><span class="line">                result.add(list); <span class="comment">//加入结果集</span></span><br><span class="line">                <span class="keyword">while</span>(l&lt;r&amp;&amp;nums[l]==nums[l+<span class="number">1</span>])&#123;</span><br><span class="line">                    l++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span>(l&lt;r&amp;&amp;nums[r]==nums[r-<span class="number">1</span>])&#123;</span><br><span class="line">                    r--;</span><br><span class="line">                &#125;</span><br><span class="line">                l++;</span><br><span class="line">                r--;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>((nums[l]+nums[r]+target)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;&lt;span id=&quot;主要内容&quot;&gt;主要内容&lt;/span&gt;&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;java中的==、equals()和hashCode()&lt;/li&gt;
&lt;li&gt;算法题leetcode[15]:3Sum&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;&lt;span id=&quot;java中的-equa
      
    
    </summary>
    
    
    
      <category term="变强日记" scheme="http://yoursite.com/tags/%E5%8F%98%E5%BC%BA%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>变强日记2</title>
    <link href="http://yoursite.com/2019/11/06/%E5%8F%98%E5%BC%BA%E6%97%A5%E8%AE%B02/"/>
    <id>http://yoursite.com/2019/11/06/变强日记2/</id>
    <published>2019-11-06T13:36:56.000Z</published>
    <updated>2019-11-06T12:36:38.480Z</updated>
    
    <content type="html"><![CDATA[<p>不得不说，周末要去考软考了，有点小慌张。天气冷了，早上起床好难受啊！！<br><img src="https://s2.ax1x.com/2019/11/06/MiJpGD.png" alt="MiJpGD.png"></p><h2><span id="主要内容">主要内容</span></h2><ol><li>单例模式的实现方式</li><li>滑动窗口算法解leetcode[3]Longest Substring Without Repeating Characters</li></ol><a id="more"></a><h2><span id="单例模式的实现方式">单例模式的实现方式</span></h2><p>我能想到的单例模式的实现方式一共有5中：</p><ol><li>懒汉式</li><li>饿汉式</li><li>双重锁判断机制实现单例</li><li>静态内部类实现</li><li>枚举类实现</li></ol><h3><span id="懒汉式单例模式">懒汉式单例模式</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 类初始化时，不初始化这个对象（延时加载）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造器私有化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法同步，效率低</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">            instance=<span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：</p><ol><li>可以实现延时加载</li><li>线程安全<br>缺点：</li><li>效率不高</li></ol><h3><span id="饿汉式单例模式">饿汉式单例模式</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 类初始化时，就初始化这个对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance=<span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造器私有化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：</p><ol><li>线程安全</li><li>调用效率搞<br>缺点：</li><li>不能实现延时加载</li></ol><h3><span id="双重锁判断机制实现单例">双重锁判断机制实现单例</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 类初始化时，不初始化这个对象，延迟加载</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造器私有化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 双重锁机制，调用效率有所提高</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance=<span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：</p><ol><li>延迟加载</li><li>调用效率较高<br>缺点：</li><li>因为JVM底层的原因，偶尔会出问题</li></ol><h3><span id="静态内部类实现单例模式">静态内部类实现单例模式</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态内部类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonClassInstance</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE=<span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造器私有化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonClassInstance.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：</p><ol><li>线程安全</li><li>调用效率高</li><li>可以实现延迟加载</li></ol><h3><span id="使用枚举类实现单例模式">使用枚举类实现单例模式</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//枚举元素本身就是单例</span></span><br><span class="line">   INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 可以添加自己需要的操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span>&#123;</span><br><span class="line">       </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：</p><ol><li>线程安全 </li><li>调用效率高</li><li>能够天然的放置反射和反序列化调用</li></ol><p>缺点：</p><ol><li>不能实现延迟加载</li></ol><h2><span id="滑动窗口算法解leetcode3longest-substring-without-repeating-characters">滑动窗口算法解leetcode[3]Longest Substring Without Repeating Characters</span></h2><p><strong>题目描述</strong><br>Given a string, find the length of the longest substring without repeating characters.</p><p>Example 1:<br>Input: “abcabcbb”<br>Output: 3<br>Explanation: The answer is “abc”, with the length of 3. </p><p>Example 2:<br>Input: “bbbbb”<br>Output: 1<br>Explanation: The answer is “b”, with the length of 1.</p><p>Example 3:<br>Input: “pwwkew”<br>Output: 3<br>Explanation: The answer is “wke”, with the length of 3.<br>             Note that the answer must be a substring, “pwke” is a subsequence and not a substring.</p><p><strong>解题思路</strong><br>使用两个指针l，r来标识区间[l,r]为滑动窗口。<br>并且使用一个数组来记录窗口内字符出现的次数，整个数组充当了map的角色<br>最初窗口大小是0的，右指针向右扩展，直到右边的字符已经在窗口中出现了，这个时候我们让左指针向右拓展（窗口在缩小）直到窗口内没有重复的字符串。</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] chars=s.toCharArray();</span><br><span class="line">        <span class="comment">//用来记录窗口内部，字符的出现的次数，充当map的角色</span></span><br><span class="line">        <span class="keyword">int</span>[] freq=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>; <span class="comment">//窗口左侧下标</span></span><br><span class="line">        <span class="keyword">int</span> r=-<span class="number">1</span>; <span class="comment">//窗口右侧下标</span></span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;chars.length)&#123;</span><br><span class="line">            <span class="comment">//窗口右侧的元素，纳入窗口，窗口中的元素不会出现重复</span></span><br><span class="line">            <span class="comment">//窗口就向右侧扩张</span></span><br><span class="line">            <span class="keyword">if</span>((r&lt;s.length()-<span class="number">1</span>)&amp;&amp;freq[chars[r+<span class="number">1</span>]]==<span class="number">0</span>)&#123;</span><br><span class="line">                ++r;</span><br><span class="line">                freq[chars[r]]++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//窗口右侧的元素，在窗口中已经出现了，则从左侧收缩窗口</span></span><br><span class="line">                freq[chars[l]]--;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            res=Math.max(res,r-l+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不得不说，周末要去考软考了，有点小慌张。天气冷了，早上起床好难受啊！！&lt;br&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/11/06/MiJpGD.png&quot; alt=&quot;MiJpGD.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;主要内容&quot;&gt;&lt;a href=&quot;#主要内容&quot; class=&quot;headerlink&quot; title=&quot;主要内容&quot;&gt;&lt;/a&gt;主要内容&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;单例模式的实现方式&lt;/li&gt;
&lt;li&gt;滑动窗口算法解leetcode[3]Longest Substring Without Repeating Characters&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
    
      <category term="变强日记" scheme="http://yoursite.com/tags/%E5%8F%98%E5%BC%BA%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>变强日记1</title>
    <link href="http://yoursite.com/2019/11/05/%E5%8F%98%E5%BC%BA%E6%97%A5%E8%AE%B01/"/>
    <id>http://yoursite.com/2019/11/05/变强日记1/</id>
    <published>2019-11-05T13:32:56.000Z</published>
    <updated>2019-11-05T13:32:53.512Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="主要内容">主要内容</span></h2><ol><li>java中的等待通知机制</li><li>动态规划解leetcode10:Regular Expression Matching</li></ol><a id="more"></a><h2><span id="java中的等待通知机制">java中的等待通知机制</span></h2><h3><span id="什么是等待通知机制">什么是等待通知机制</span></h3><p>一个线程因为执行目标动作锁需要的保护条件未满足而被暂停的过程就被成为等待。<br>一个线程更新了系统的状态，使得其它线程所需要的保护条件成立，唤醒那些被暂停的线程的过程被称为通知。</p><h3><span id="waitnotfy方案">wait/notfy方案</span></h3><p>java中提供了<code>Object.wait()/Object.wait(long timeoout)</code>,<code>Object.notify()/Object.notifyAll()</code>可以用来实现等待和通知<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(someObject)&#123;</span><br><span class="line">    <span class="keyword">while</span>(保护条件不成立)&#123;</span><br><span class="line">        someObject.wait();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//执行目标动作</span></span><br><span class="line">    doAction();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(someObject)&#123;</span><br><span class="line">    <span class="comment">//更新保护条件涉及的共享变量</span></span><br><span class="line">    updateSharedState();</span><br><span class="line">    <span class="comment">//通知等待的线程</span></span><br><span class="line">    someObject.notify();</span><br><span class="line">&#125;</span><br><span class="line">```、</span><br><span class="line">该方案存在的问题：</span><br><span class="line"><span class="number">1</span>. 过早唤醒</span><br><span class="line">因为同一个对象上可以有多个wait的线程。假设一组等待/通知线程同步在对象someObject上，初始状态下均不成立，当线程N1更新了共享变量state1使得N1执行notifyAll方法唤醒所有线程，当其它线程的保护条件可能并不成立，这使得线程唤醒后还得睡眠。</span><br><span class="line"><span class="number">2</span>. 信号丢失</span><br><span class="line">如果等待线程在wait之前没有判断保护条件是否成立，那么有这样一种情况，就是通知线程在等待线程进入等待之前就更新了保护条件，使得保护条件成立，等待线程在睡眠后就再也不会收到唤醒通知了。</span><br><span class="line">比如下面这个例子：</span><br></pre></td></tr></table></figure><p>T1:<br>synchronized(sharedMonitor){<br>    updateSomeCondition();//更新保护条件<br>    sharedMonitor.notify();</p><p>}<br>T2:<br>while(someCondition){<br>//Point1:<br>    synchronized(sharedMonitor){<br>      sharedMonitor.wait();<br>   }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">假如T2先执行，当它判断保护条件someCondition成立后，进入Point1时（注意synchronized代码块的位置），线程调度器可能切换到了T1，T1发出唤醒信号。然后线程调度器重新回到point1执行，T2线程进入等待。T2也就错过了唤醒信号，再也不会被唤醒了。所以一定要注意`synchronized`关键字的位置。</span><br><span class="line">3. 欺骗性唤醒。等待线程也可能存在没有其它任何线程执行notify和notifyAll线程的情况下被唤醒。</span><br><span class="line">4. 上下文切换问题。wait/notify的时候可能导致较多的上下文切换</span><br><span class="line"></span><br><span class="line">### 条件变量方案</span><br><span class="line">一种比wait/notfy方案更好的实现方案是使用jdk1.5之后引入的条件变量java.util.concurent.locks.Condition接口。</span><br><span class="line"></span><br><span class="line">`Lock.newCondition()`的返回值就是一个Condition实例。因此调用任何一个显示锁的实例的newCondition方法都可以创建一个相应的Condition接口。Condition.await()/signal()也要求其执行线程持有创建该Condition实例的**显示锁**。每个Condition实例内部都维护乐一个用于存储等待线程的队列。</span><br><span class="line"></span><br><span class="line">假设cond1和cond2是两个不同的Condition实例，一个线程执行Cond1.await()会导致其被暂停，并被存入cond1的等待队列。cond1.signal会使cond1的等待队列中的任意线程被唤醒。调用cond1.signalAll()会使cond1的等待队列中的所有线程被唤醒。而cond2等待队列中的任何一个等待线程都不会受此影响。这样就避免了过早唤醒的问题。</span><br><span class="line">```java</span><br><span class="line">public class Test &#123;</span><br><span class="line">    //显示锁</span><br><span class="line">    private final Lock lock=new ReentrantLock(); </span><br><span class="line">    //条件变量</span><br><span class="line">    private final Condition condition=lock.newCondition();</span><br><span class="line">    </span><br><span class="line">    public void methodA() throws InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            while (保存条件不成立)&#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            //执行目标动作</span><br><span class="line">            doAction();</span><br><span class="line">            </span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void methodB()&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            //更新保护条件</span><br><span class="line">            updateState();</span><br><span class="line">            //唤醒该条件变量上的等待线程</span><br><span class="line">            condition.signal();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该方案很好的解决了过早唤醒问题。并且<code>boolean awaitUntil(Date deadline)</code>可以根据返回值区分是等待超时唤醒的还是被其它线程唤醒的。</p><h3><span id="countdownlatch方案">CountDownLatch方案</span></h3><p>CountDownLatch叫做倒计时协调器。<br>ConutDownLatch内部维护了一个用于表示<strong>未完成的先决操作数量的计数器</strong>。每调用一次countDown（）相应实例的计数器值会减少1（先决条件完成了一个），await()方法相当于一个受保护的方法，其保护条件为计数器的值为0(先决条件全部完成)。<br>因此，当<strong>计数器的值不为0</strong>的时候，CountDownLatch.await()的执行线程会被<strong>暂停</strong>。这些线程就被称为CountDownLatch上的等待线程。CountDownlatch.countDown()相对于一个<strong>通知方法</strong>，它会在<strong>计数器达到0的时候唤醒</strong>相应实例上的等待线程。<br>因为CountDownLatch内部封装了对“全部先决条件的等待与通知的逻辑”，所以客户端代码在调用await,countDown方法都<strong>无需加锁</strong>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用实例，演示了如何用CountDownLatch实现10个线程同时启动</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CountDownLatchTest countDownLatchTest=<span class="keyword">new</span> CountDownLatchTest();</span><br><span class="line">        countDownLatchTest.runThread();</span><br><span class="line">    &#125;</span><br><span class="line">    CountDownLatch countDownLatch=<span class="keyword">new</span> CountDownLatch(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个线程</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Thread <span class="title">createThread</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        Thread thread=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    countDownLatch.await();</span><br><span class="line">                    System.out.println(<span class="string">"thread"</span>+Thread.currentThread().getName()+<span class="string">"准备完毕"</span>+System.currentTimeMillis());</span><br><span class="line">                &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.setName(<span class="string">"thread-"</span>+i);</span><br><span class="line">        <span class="keyword">return</span>  thread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runThread</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ExecutorService executorService= Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                executorService.submit(createThread(i));</span><br><span class="line">                <span class="comment">//待等待的线程数减去一</span></span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>CountDownLatch是无法重用的。</strong></p><h3><span id="cyclicbarrier方案">CyclicBarrier方案</span></h3><p>jdk1.5之后引入了<code>java.util.concurrent.CyclicBarrier</code>类，该类也可以实现等待通知。<br>CyclicBarrier方案让多个线程相互等待，直到达到一个屏障点，并且CyclicBarrier是可重用的。<br>比如让10个线程相互等待，以实现10个线程同时开始执行：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CyclicBarrierTest cyclicBarrierTest=<span class="keyword">new</span> CyclicBarrierTest();</span><br><span class="line">        cyclicBarrierTest.runThread();</span><br><span class="line">    &#125;</span><br><span class="line">    CyclicBarrier cyclicBarrier=<span class="keyword">new</span> CyclicBarrier(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个线程</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Thread <span class="title">createThread</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        Thread thread=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">/*除了最后一个线程，其余的线程都会在此等待，</span></span><br><span class="line"><span class="comment">                直到最后一个线程执行到此，唤醒之前所有等待的线程*/</span></span><br><span class="line">                    cyclicBarrier.await(); </span><br><span class="line">                    System.out.println(<span class="string">"thread"</span>+Thread.currentThread().getName()+<span class="string">"准备完毕"</span>+System.currentTimeMillis());</span><br><span class="line">                &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">catch</span> (BrokenBarrierException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.setName(<span class="string">"thread-"</span>+i);</span><br><span class="line">        <span class="keyword">return</span>  thread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runThread</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ExecutorService executorService= Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                executorService.submit(createThread(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2><span id="动态规划解leetcode10regular-expression-matching">动态规划解leetcode10:Regular Expression Matching</span></h2><p><strong>题目：</strong><br>Given an input string (s) and a pattern (p), implement regular expression matching with support for ‘.’ and ‘<em>‘.<br>‘.’ Matches any single character.<br>‘</em>‘ Matches zero or more of the preceding element.<br>The matching should cover the entire input string (not partial).</p><p>Note:<br>s could be empty and contains only lowercase letters a-z.<br>p could be empty and contains only lowercase letters a-z, and characters like . or *.<br>Example 1:</p><p>Input:<br>s = “aa”<br>p = “a”<br>Output: false<br>Explanation: “a” does not match the entire string “aa”.</p><p><strong>思路：</strong><br>使用一个二维数组来表示匹配结果b[i+1][j+1]表示s[0..i]匹配p[0..j]<br>两个边界条件：</p><ol><li>b[0][0],及两个空串进行匹配，为true</li><li>对于空串的匹配b[i+1][0]的数值必须为False</li></ol><p><strong>解法：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lenA=s.length();</span><br><span class="line">        <span class="keyword">int</span> lenP=p.length();</span><br><span class="line">        <span class="keyword">char</span>[] charsS=s.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] charsP=p.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span>[][] b=<span class="keyword">new</span> <span class="keyword">boolean</span>[lenA+<span class="number">1</span>][lenP+<span class="number">1</span>];</span><br><span class="line">        b[<span class="number">0</span>][<span class="number">0</span>]=<span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lenA;i++)&#123;</span><br><span class="line">            b[i+<span class="number">1</span>][<span class="number">0</span>]=<span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;lenP;j++)&#123;</span><br><span class="line">            b[<span class="number">0</span>][j+<span class="number">1</span>]=j&gt;<span class="number">0</span>&amp;&amp;charsP[j]==<span class="string">'*'</span>&amp;&amp;b[<span class="number">0</span>][j-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lenA;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;lenP;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(charsP[j]!=<span class="string">'*'</span>)&#123;</span><br><span class="line">                    b[i+<span class="number">1</span>][j+<span class="number">1</span>]=b[i][j]&amp;&amp;(<span class="string">'.'</span>==charsP[j]||charsS[i]==charsP[j]);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    b[i+<span class="number">1</span>][j+<span class="number">1</span>]=b[i + <span class="number">1</span>][j - <span class="number">1</span>] &amp;&amp; j &gt; <span class="number">0</span> || b[i + <span class="number">1</span>][j] ||</span><br><span class="line">                    b[i][j + <span class="number">1</span>] &amp;&amp; j &gt; <span class="number">0</span> &amp;&amp; (<span class="string">'.'</span> == charsP[j - <span class="number">1</span>] || charsS[i] == charsP[j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b[lenA][lenP];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;主要内容&quot;&gt;&lt;a href=&quot;#主要内容&quot; class=&quot;headerlink&quot; title=&quot;主要内容&quot;&gt;&lt;/a&gt;主要内容&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;java中的等待通知机制&lt;/li&gt;
&lt;li&gt;动态规划解leetcode10:Regular Expression Matching&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
    
      <category term="变强日记" scheme="http://yoursite.com/tags/%E5%8F%98%E5%BC%BA%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>变强日记0</title>
    <link href="http://yoursite.com/2019/11/04/%E5%8F%98%E5%BC%BA%E6%97%A5%E8%AE%B00/"/>
    <id>http://yoursite.com/2019/11/04/变强日记0/</id>
    <published>2019-11-04T12:55:56.000Z</published>
    <updated>2019-11-04T12:55:56.318Z</updated>
    
    <content type="html"><![CDATA[<p>这是变强日记的第一篇内容。必须得开个好头啊。之所以开这个分类，是因为感觉自己的博客都是些读书笔记，大多都是知识点的摘抄，缺乏总结，也没有把知识点串起来。每天分析一个面试题问题，一个算法题，也算是对自己成长的记录吧。也希望自己能像这个分类的名字一样“变强”。</p><h2><span id="主要内容">主要内容</span></h2><ol><li>Redis为什么这么快</li><li>动态规划求字符串的最长回文子串</li></ol><a id="more"></a><h2><span id="redis为什么这么快">Redis为什么这么快</span></h2><p>看牛客网上的分享，许多老哥都遇到过这个问题。想要回答好这个问题，需要系统的了解Redis的原理才行，刚好前段时间拜读了《Redis设计与实现》，虽然看完了书，但是想要系统的回答还是挺难的。</p><p>Redis之所以快，主要有以下几个方面的原因：</p><ol><li>完全基于内存</li><li>简洁高效的数据结构设计</li><li>采用单线程，避免了不必要的上下文切换和竞争条件</li><li>使用了多路复用IO，非阻塞IO。</li><li>Redis自己构建了VM机制来提高效率</li></ol><h3><span id="基于内存">基于内存</span></h3><p>这一点很好理解，Redis处理的许多请求都是直接内存操作的，内存的读写速率显然是要比磁盘高很多倍的，</p><h3><span id="简洁高效的数据结构设计">简洁高效的数据结构设计</span></h3><p>Redis在底层实现上使用了许多设计精妙的数据结构，来提高效率。<br>比如Redis的字符串类型的底层实现使用的SDS，它可以常数复杂度获取字符串长度，空间预分配、惰性空间释放来提高效率。又比如使用跳跃表来实现快速访问节点和进行范围操作。<br>而且每个Redis中每个数据库对象（RedisDB）中都维护了一个字典（dict）来保存数据库中的所有键值对。类似于HashMap，其查找和操作的时间复杂度都为O(1)<br><img src="https://s2.ax1x.com/2019/11/04/KxTlpd.png" alt="KxTlpd.png"></p><h3><span id="采用单线程">采用单线程</span></h3><p>Redis为什么使用单线程，官方的解释是Redis的性能瓶颈不在CPU，最有可能的性能瓶颈在于机器的内存和网络带宽。而且单线程也符合Redis简洁的设计风格。<br><em>强调单线程是指在处理网络请求的时候只有一个线程，在其它时候也是不只一个线程的</em><br>详细原因：</p><ol><li>不需要要各种锁的性能消耗<br>Redis中有一些复杂的数据结构如list，hash等结构复制的数据结构，当需对这些复制的数据结构进行细粒度的操作的时候，如果不是单线程的话，就需要加很多的锁，导致同步的开销大大增加，但是使用单线程就不会存在这个我呢提。</li><li>降低了CPU的消耗<br>多线程会到来上下文切换和竞争条件带来的开销，使用单线程就不会出现这样的问题。</li><li>可以使用单线程多进程的集群方案<br>当CPU的性能成为瓶颈的时候，可以使用单线程多进程的集群方案来解决这个问题。</li><li>代码简洁<br>使用单线程，代码将会变得简洁清晰，处理逻辑也更简单。</li></ol><h3><span id="io多路复用技术">IO多路复用技术</span></h3><p>Redis是单线程的，为了避免等待输入和输出带来的阻塞，redis使用了IO多路复用技术来解决这个问题。<br>Redis服务采用Reactor方式来实现文件事件处理器，每个网络连接都对应一个文件描述符。文件事件处理器使用IO多路复用模块同时监听多个套接字，每次套接字变为可应答，可写或者可读时，相应的文件事件就会产生。<br><img src="https://s2.ax1x.com/2019/11/04/KxODc4.png" alt="KxODc4.png"><br>当有多个文件事件并发出现的使用，IO多路复用程序会将所有产生事件的套接字放到一个队列里面。<br><img src="https://s2.ax1x.com/2019/11/04/KxO7DA.png" alt="KxO7DA.png"></p><p>IO多路复用技术，中“多路”是指多个网络连接，“复用”是指复用一个线程。<br>复用技术可以让单个线程处理多个连接请求，提高了吞吐率。</p><h3><span id="vm机制">VM机制</span></h3><p>VM机制主要是为了避免内存不足而造成的访问速度下降的问题。Redis并没有使用操作系统实现的SWAP，而是自己实现的。<br>当数据多到内存放不下了，那就不可避免地会把冷数据放到磁盘中去，把热数据继续留到内存中。Redis通过自己实现地VM来提高了这一过程地效率。</p><p>Redis的作者对为什么不使用操作系统的VM而是使用自己实现的VM做出了以下的解释：</p><ol><li>OS是基于page（4k）的，而Redis对象大多都小于4k，因此OS提供的page方案对于Redis来说粒度太大了。如果使用OS的VM，那么一个页面上可能有多个Redis对象，另外比如list这种数据结构可能在多个页面上，这就导致哪怕只有很少的键被经常访问，当许多的页面都会被OS认为是活跃的，这样只有内存真正耗尽的时候OS才会交换页面。</li><li>相比于OS的交换方式，redis可以对交换到磁盘的对象进行压缩。</li><li>OS交换的时候是会阻塞线程的，而redis可以让工作线程来完成交换，主线程继续处理请求。</li></ol><h2><span id="动态规划求字符串的最长回文子串">动态规划求字符串的最长回文子串</span></h2><p><strong>思路：</strong><br>若长度为L的字符串是回文，那么去掉首尾也是回文字符串。及全局最优解包含局部最优解。<br><strong>最小子问题：</strong></p><ol><li>每个单独的字符组成的字符串是回文的</li><li>两个相邻的相同的字符串是回文。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] chars=s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> len=s.length();</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[][] dp=<span class="keyword">new</span> <span class="keyword">int</span>[len][len];</span><br><span class="line">        <span class="keyword">int</span> maxLen=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> resIndex=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化矩阵，键最小子问题1的情况都设置为true</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            dp[i][i]=<span class="number">1</span>; <span class="comment">//子问题一</span></span><br><span class="line">            <span class="keyword">if</span>((i&lt;len-<span class="number">1</span>)&amp;&amp;chars[i]==chars[i+<span class="number">1</span>])&#123;</span><br><span class="line">                dp[i][i+<span class="number">1</span>]=<span class="number">1</span>; <span class="comment">//子问题2</span></span><br><span class="line">                resIndex=i;</span><br><span class="line">                maxLen=<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">       </span><br><span class="line">        <span class="comment">//从长度为3开始逐渐增长来检查回文字符串</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> L=<span class="number">3</span>;L&lt;=len;L++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=len-L;i++)&#123;</span><br><span class="line">                <span class="comment">//如果字符串是回文的，那么首尾加上相同的字符也是回文的</span></span><br><span class="line">                <span class="keyword">if</span>(dp[i+<span class="number">1</span>][i+L-<span class="number">2</span>]==<span class="number">1</span>&amp;&amp;chars[i]==chars[i+L-<span class="number">1</span>])&#123;</span><br><span class="line">                    dp[i][i+L-<span class="number">1</span>]=<span class="number">1</span>;  <span class="comment">//首尾加上相同的字符也是回文的</span></span><br><span class="line">                    maxLen=L;</span><br><span class="line">                    resIndex=i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(chars,resIndex,maxLen);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是变强日记的第一篇内容。必须得开个好头啊。之所以开这个分类，是因为感觉自己的博客都是些读书笔记，大多都是知识点的摘抄，缺乏总结，也没有把知识点串起来。每天分析一个面试题问题，一个算法题，也算是对自己成长的记录吧。也希望自己能像这个分类的名字一样“变强”。&lt;/p&gt;
&lt;h2 id=&quot;主要内容&quot;&gt;&lt;a href=&quot;#主要内容&quot; class=&quot;headerlink&quot; title=&quot;主要内容&quot;&gt;&lt;/a&gt;主要内容&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;Redis为什么这么快&lt;/li&gt;
&lt;li&gt;动态规划求字符串的最长回文子串&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
    
      <category term="变强日记" scheme="http://yoursite.com/tags/%E5%8F%98%E5%BC%BA%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Redis设计与实现读书笔记二</title>
    <link href="http://yoursite.com/2019/10/31/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%BA%8C/"/>
    <id>http://yoursite.com/2019/10/31/Redis设计与实现读书笔记二/</id>
    <published>2019-10-31T12:54:56.000Z</published>
    <updated>2019-10-31T12:55:18.714Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="redis服务器">redis服务器</span></h2><p>redis服务器负责与多个客户端建立网络连接，处理客户端发送的命令请求，在数据库中保存客户端执行命令所产生的数据，并通过资源管理器来维持服务器自身的运转。</p><h3><span id="命令请求的过程">命令请求的过程</span></h3><p>加入我们使用了这样一天个命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET KEY VALUE</span><br><span class="line">OK</span><br></pre></td></tr></table></figure></p><p>整个执行的流程</p><ol><li>客户端会将命令转换为协议格式，然后通过连接到服务器的套接字按协议格式的命令请求发送给服务器。</li><li>当客户端与服务器之间连接的套接字变得可读时，服务器调用命令求情处理器。</li><li>读取套接字中协议格式的命令，将它保存到客户端状态的输入缓冲区里。</li><li>对输入缓冲区中的数据进行分析，将请求参数存入argv中，参数个数保存在argc中。</li><li>根据请求参数（查找命令表），调用相应的命令执行器，执行指定的命令（在正式执行之前还会检测出参数个数是否正确，客户端是否通过身份认证，如果服务器打开了maxmenory功能，那么在执行命令之前，先检查服务器的内存占用情况，并在需要时进行内存回收，之后再进行执行，并且服务器没被阻塞）。</li><li>再实现函数调用之后，还会执行一系列的后续工作，比如检查是否需要记录到慢查询日志，更新命令的redisCommand结构的milliseconds属性，并将器calls属性加一，如果开启了AOF持久化功能，那么将刚才的命令写入到AOF缓冲区中，如果有其它服务器正在复制这个服务器，那么服务器会见刚刚执行的命令传播到所有从服务器。<a id="more"></a></li><li>见结果回复保存到客户端的输出缓冲区里面，并为客户端套接字关联命令回复处理器，当客户端变为可写状态时，服务器就会执行命令回复处理器，并将保存在客户端输出缓冲区中的信息。</li><li>回复处理器情况输出缓冲区，为下一次命令请求做准备。</li><li>客户端接收到协议格式的命令返回后，会将这些命令转换为人类可读的格式，并打印给用户。</li></ol><h4><span id="servercron函数">serverCron函数</span></h4><p>serverCron函数默认100毫秒执行一次，这个函数负责管理服务器的资源，并保持服务器自身的良好运转。</p><ol><li><p>更新服务器时间缓存<br>Redis中许多服务都依赖于服务器时间，为了避免获取系统时间的大量开销，服务器状态（redisServer）中有unixtime属性和mstime属性被用作当前时间缓存。<br>serverCorn函数每100毫秒执行一次，获取系统时间更新这两个属性，所以这两个属性记录的时间<strong>精度不是很高</strong>。<br>对于需要高精度的时间的时候，Redis还是会执行系统调用来获取最准确的系统时间。</p></li><li><p>更新对象的LRU时钟<br>服务器状态中的lruclock属性保存了服务器的LRU时钟，也是服务器时间缓存的一种。<br>每个Redis对象中都有一个lru属性，该属性保持了对象最后一次被直接命中访问的时间。</p></li></ol><p>当服务器需要计算一个数据库键的空转时间的时候，就会使用服务器的lruclock属性的记录减去对象的lru属性的记录，得出对象的空转时间。<br>serverCorn函数默认会以每10秒一次的频率更新lruclock属性，因为这个时钟不是实时的。所以根据这个属性计算出来的Lru时间实际是一个模糊的估算值。</p><ol start="3"><li><p>更新服务器每秒执行命令次数<br>serverCron函数中的trackOperationsPerSecond函数会以每100毫秒一次的频率执行，通过抽样计算的方式，估算服务器在最近一秒钟处理的命令请求数量。trackOperationsPerSecond函数会根据ops_sec_last_sample_time记录的上次抽样时间和服务器的当前时间，以及ops_sec_last_sample_ops记录的上一次抽样的已执行命令数量和服务器当前的已执行命令数量，计算出两次trackOperationsPerSecond掉用直接，服务器平均每毫秒处理了多少个命令请求，然后将这个值乘以1000，就得到了服务器在一秒钟内能处理多少个命令请求的估计值。</p></li><li><p>更新服务器内存分治记录<br>服务器状态中stat_peak_memory属性记录了服务器的内存峰值大小。</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span>&#123;</span></span><br><span class="line">    <span class="comment">//..</span></span><br><span class="line">    <span class="comment">//已使用内存峰值</span></span><br><span class="line">    <span class="keyword">size_t</span> stat_peak_memory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次serverCron执行的时候，都会查看服务器的已使用内存，并与stat_peak_menory进行比较。如果当前的值更大，就更新stat_peak_menory</p><ol start="5"><li>处理SIGTERM信号<br>在启动服务器的时候，Redis会为每个服务器进程关联SIGTERM信号关联处理器sigtermHandler函数，这个信号处理器负责在服务器接到SIGTERM信号时，打开服务器状态的shutdown_asap标识。每次ServerCorn函数运行时，程序都会对服务器状态的shutdown_asap属性进行检查，并根据属性的值决定是否关闭服务器。</li></ol><ol start="6"><li><p>管理客户端资源<br>serverCron函数每次执行都会调用clientCron函数检查客户端与服务器的连接是否超时（如果超时则断开），输入缓冲区是否（超过了一定的长度，如果超过了就释放原来的缓冲区，分配一个新的缓冲区）</p></li><li><p>管理数据库资源<br>serverCron函数每次执行都会调用databasesCron函数，这个函数对对服务器中的一部分数据库进行检查，删除其中的过期键，如果有需要时，对字典进行收缩。</p></li><li><p>执行被延迟的BGREWRITEAOF<br>在服务器执行BGSAVE命令期间，如果客户端向服务器发来的BGREWRITEAOF会被延迟，服务器状态中的aof_rewrite_scheduled标识记录了服务器是否延迟了BGREWRITEAOF命令。</p></li><li><p>检查持久化操作的运行状态。<br>服务器状态中使用rdb_child_pid属性和aof_child_pid属性记录执行BGSAVE命令和BGREWRITEAOF命令的子进程ID，这两个属性也可以用于检测BGSAVE命令或者BGREWRITEAOF命令是否正在执行。</p></li><li><p>将AOF缓冲区内的内容写入AOF文件<br>如果服务器开启了AOF持久化，并且AOF缓冲区内有待写入的数据，那么serverCron函数会调用相应的程序，将AOF缓冲区中的内容写入AOF文件中。</p></li><li><p>关闭异步客户端<br>关闭那些输出缓冲区大小超出限制的客户端。</p></li><li>增加cronloops计数器的值。<br>服务器状态中cronloops属性记录了serverCron函数执行的次数。</li></ol><h3><span id="服务器的初始化">服务器的初始化</span></h3><p>初始化服务器的第一步就是创建一个redisServer类型的示例变量，server作为服务器的状态，并为结构中的每个属性设置默认值。<br><strong>初始化server变量</strong>的工作由redis.c/initsServerConfig函数完成，它除妖进行以下的工作：</p><ol><li>设置服务器的运行ID</li><li>设置服务器的默认运行频率</li><li>设置服务器的默认配置文件路径</li><li>设置服务器的运行架构</li><li>设置服务器的运行架构</li><li>设置服务器的默认端口号</li><li>设置服务器的默认RDB持久化条件和AOF持久化条件</li><li>初始化服务器的LRU时钟</li><li>创建命令表 </li></ol><p>在启动服务器时，用户可以用户给定配置参数或指定配置文件来修改服务器的默认配置。如果用户为这些属性设置了新的值，那么服务器就使用用户设定的这些值，否则使用默认值。</p><p><strong>初始化服务器数据结构</strong>：<br>initServerConfig函数初始化了server状态，服务器还需要创建其它数据结构（initServer负责）：</p><ol><li>server.clinets链表，器包含了所有与服务器向连的客户端的状态结构。构成链表的节点redisClients代表了一个redis客户端。</li><li>server.db数组，该数组包含了所有的数据库。</li><li>用于保存频道订阅信息的server.pubsub_channels字典，以及用于保存模式订阅信息的server.pubsub_patterns链表。</li><li>用于执行Lua脚本的Lua环境server.lua属性</li><li>用于保存慢查询日志的server.slowlog属性</li></ol><p>除了初始化数据结构，initServer还进行了一些非常<strong>重要的设置操作</strong>，包括：</p><ol><li>为服务器设置进程信号量</li><li>创建共享对象（比如共享的字符串对象）</li><li>打开服务器的监听端口</li><li>为serverCron函数创建时间事件</li><li>入股AOF持久化以及打开，那么打开现有的AOF文件，如果没有现有的文件则创建。</li><li>初始化服务器后台的IO模块。</li></ol><p><strong>还原数据库状态</strong>：<br>在完成对服务器状态server的初始化之后，服务器需要在入RDB文件或者AOF文件。并根据文件内容还原数据库状态。<br>如果启用了AOF持久化功能，则使用AOF还原数据库，如果没有启用则使用RDB文件还原数据库。<br>完成数据库状态还原后，在日志中打印还原数据库的耗时。</p><p><strong>执行事件循环</strong>：<br>在完成数据库状态的还原后，开始进入事件循环。</p><h2><span id="多机数据库的实现">多机数据库的实现</span></h2><h3><span id="复制">复制</span></h3><p>Redis中可以通过执行SLAVEOF命令设置服务器去复制另一个服务器。比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">复制127.0.0.1 6379主机，成为从服务器</span><br><span class="line">SLAVEOF 127.0.0.1 6379</span><br></pre></td></tr></table></figure></p><p>我们在主服务器上添加的键值对，在从服务器和主服务器上都能查询到。</p><h4><span id="复制功能的实现">复制功能的实现</span></h4><p><strong>旧版</strong><br>Redis的复制，分为同步和命令传播两个操作。<br>同步是让从服务器的状态更新至主服务器的状态。<br>命令传播，是当主服务器的数据库状态被更改后，让从服务器和主服务器保持一致的方式。</p><p><strong>同步</strong><br>从服务器与主服务器同步需要从服务器向主服务器发送SYNC命令，具体步骤如下：</p><ol><li>从服务器向主服务器发送SYNC命令</li><li>主服务器收到命令后，执行BGSAVE命令，后台生成RDB文件。同时使用缓冲区记录从现在开始执行的写命令</li><li>主服务器BGSAVE执行完毕后，主服务器件RDB文件发送给从服务器。从服务器载入RDB文件，与将服务器状态更新至与RDB文件中的状态一致。</li><li>主服务器将缓冲区的命令发送给RDB文件，从服务器执行这些命令，保持与主服务器状态一致。<br><img src="https://s2.ax1x.com/2019/10/28/K6mrQS.png" alt="K6mrQS.png"></li></ol><p><strong>命令传播</strong>：<br>当主服务器因为执行命令导致主服务器与从服务器的状态不一致后，主服务器会向从服务器发送命令，使主服务器和从服务器的状态保持一致。</p><p><strong>旧版复制功能的缺陷</strong><br>旧版复制功能的最大的缺陷就是断线复制，需要重新执行一次同步操作（从发送SYNC开始）。而SYNC命令使意向非常消耗资源的操作。</p><p><strong>新版</strong><br>从Redis2.8开始，使用PSYNC命令来执行复制时的同步操作。<br>PSYNC具有完整重同步和部分重同步两种模式：<br>和旧版的同步操作的区别住哟啊在于部分重同步。步骤：</p><ol><li>断线重连后，从服务器向主服务器发送PSYNC命令。</li><li>主服务器收到PSYNC命令后，向从服务器返回+CONTINUE回复，表示执行部分重同步</li><li>从服务器接收到+CONTINUE命令之后，准备执行部分从同步。</li><li>主需要器向从服务器发送断线期间收到的写命令</li><li>从服务器接收这些写命令并执行，完成同步。</li></ol><p><img src="https://s2.ax1x.com/2019/10/28/K6KJLF.png" alt="K6KJLF.png"></p><p>部分重同步的<strong>实现原理</strong>：<br>主要由三个部分组成：</p><ol><li>主服务器的复制偏移量和从服务器的复制偏移量</li><li>从服务器的复制积压缓冲区</li><li>服务器的运行ID</li></ol><p><strong>复制偏移量</strong><br>主服务器和从服务器都分别维护了两个复制偏移量。<br>主服务器的复制偏移量记录了发送了的字节数量。<br>从服务器的复制偏移量记录了接收了的字节数量。</p><p>通过对主从服务器的复制偏移量可以很容易的知道主从服务器是否处于一致状态。</p><p><strong>复制积压缓冲区</strong><br>复制积压缓冲区是由主服务器维护的一个固定长度先进先出队列，默认大小为1MB。当主服务器在进行命令传播的时候，不仅会把写命令发送给所有的从服务器，还会将写命令入队到复制积压缓冲区。<br><img src="https://s2.ax1x.com/2019/10/28/K6lXYd.png" alt="K6lXYd.png"><br>当主服务器收到从服务器的复制偏移量之后，主服务器会根据偏移量之后的数据是否在复制积压缓冲区内来决定以何种同步方式进行同步。如果采用部分重同步的方式，主服务器就把复制积压缓冲区内的偏移量之后的命令发送给从服务器。</p><p><strong>服务器ID</strong><br>部分重同步还需要服务器ID，无论是主服务器还是从服务器都需要有自己的服务器ID。运行ID在服务器启动的时候随机生成。当从服务器对主服务器进行初次复制时，主服务器会把自己的ID传送给从服务器，而从服务器会将这个ID保存起来。<br>从服务器通过保存的主服务器ID，可以判断断线前连接的服务器是否是断线前连接的主服务器。</p><p><strong>PSYNC的执行流程</strong><br><img src="https://s2.ax1x.com/2019/10/28/K6wEQg.png" alt="K6wEQg.png"></p><p>心跳检测：在命令传播阶段，还会从服务器还会以每秒一次的频率，向主服务器发送<br><code>ACK &lt;replication_offset&gt;</code>。它有三个作用，一是检测主从服务器的网络连接状态，二是辅助实现min-salaves选项，三是检测命令丢失。</p><h2><span id="sentinel哨兵">Sentinel（哨兵）</span></h2><p>Sentinel（哨兵）是Redis的高可用解决方案。由一个或多个哨兵实例组成的哨兵系统可以监视任意多个主服务器，以及这些主服务器的从犯服务器。当被监视的主服务器进入下线状态时，自动将下线主服务器属下的从服务器升级为新的主服务器。然后由新的主服务器代替已下线的主服务器继续处理请求命令。</p><p>哨兵监视系统的工作例子：</p><ol><li>下图时哨兵系统的例子<br><img src="https://s2.ax1x.com/2019/10/28/KcjhYd.png" alt="KcjhYd.png"></li><li>主服务器下线，从服务器终止复制<br><img src="https://s2.ax1x.com/2019/10/28/Kcxivt.png" alt="Kcxivt.png"></li><li>若下线的主服务器没有在规定的时间内上线，哨兵系统会让其从服务器升级为主服务器，并对新的主服务器的所有从服务器发送复制指令<br><img src="https://s2.ax1x.com/2019/10/28/KcvIN4.png" alt="KcvIN4.png"></li><li>如果向下的主服务器从新上线，那么会被哨兵降级为从服务器。<br><img src="https://s2.ax1x.com/2019/10/28/KcxaG9.png" alt="KcxaG9.png"></li></ol><h3><span id="启动并初始化sentinel">启动并初始化Sentinel</span></h3><p>启动一个Sentinel可以使用的命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-sentinel /path/to/your/sentinel.conf //方案一</span><br><span class="line">redis-server /path/to/your/sentinel.conf --sentinel //方案二</span><br></pre></td></tr></table></figure></p><ol><li>初始化服务器<br>因为Sentinel的本质时一个特殊的redis服务器，所以它会和普通的redis服务器一样被初始化，但是Sentinel不会通过在入RDB或AOF来还原数库状态，因为它不需要承担数据库的角色。</li><li>将普通的redis服务器使用的代码替换为Sentinel专用代码<br>Sentinel虽然是一种特殊的Redis服务器，当终究不是Redis服务器，所以代码实现也是不一样的，它会把普通的Redis服务代码替换为Sentinel专用代码，因此如端口号命令表等东西也是不同的。</li><li><p>初始化Sentinel状态<br>在启用了Sentinel专用代码之后，服务器会出初始化一个sentinelState结构，它保存了服务器中所有和Sentinel功能相关的状态。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sentinelState</span>&#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> current_epoch; <span class="comment">//当前纪元</span></span><br><span class="line">    dict *masters;<span class="comment">//指向保存了所有被监视的主服务器信息的字典</span></span><br><span class="line">    <span class="keyword">int</span> tilt;<span class="comment">//是否进入tilt模式</span></span><br><span class="line">    <span class="keyword">int</span> running_scripts;<span class="comment">//目前正在执行的脚本数量</span></span><br><span class="line">    <span class="keyword">mstime_t</span> tilt_start_time;<span class="comment">//进入tilt模式的时间</span></span><br><span class="line">    <span class="keyword">mstime_t</span> previous_time;<span class="comment">//最后一次执行时间处理器的时间</span></span><br><span class="line">    <span class="built_in">list</span> *script_queue; <span class="comment">//一个FIFO队列，包含了所有要执行的用户脚本</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>根据给定的配置文件，初始化Sentinel的监视主服务器列表（masters属性）<br>masters属性是一个指向字典的指针，字典的键是主服务器的名称，值为保存主服务器信息的sentinelRedisInstance结构</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">sentinelRedisInstance</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> flags; <span class="comment">//标识值，记录了实例的类型，以及实例的当前状态</span></span><br><span class="line">    <span class="keyword">char</span> *name; <span class="comment">//实例名称</span></span><br><span class="line">    <span class="keyword">char</span> *runid;<span class="comment">//实例的运行ID</span></span><br><span class="line">    <span class="keyword">uint64_t</span> config_epoch;<span class="comment">//配置纪元</span></span><br><span class="line">    sentinelAddr *addr；<span class="comment">//实例的地址</span></span><br><span class="line">    <span class="keyword">mstime_t</span> down_after_period;<span class="comment">//实例多少毫米之后才会被判断为主观下线</span></span><br><span class="line">    <span class="keyword">int</span> quorum;<span class="comment">//判断这个实例为客观下线所需的支持投票数量</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> parallel_syncs;<span class="comment">//在执行故障转移操作时，可以同时对新的主服务器进行同步的从服务器数量</span></span><br><span class="line">    <span class="keyword">mstime_t</span> failover_timeoout;<span class="comment">//刷新故障转移状态的最大时限</span></span><br><span class="line">&#125;sentinelRedisInstance;</span><br></pre></td></tr></table></figure></li></ol><p>masters字典的初始化需要根据被载入的Sentinel配置文件进行的。</p><ol start="5"><li>创建连向主服务器的网络连接<br>最后一步是创建连向主服务器的网络连接，Sentinel将成为主服务器的客户端，它可以从主服务器发送命令，并从命令回复中获取相关信息。<br>一般是有两个连接，一个是命令连接，一个是订阅连接。</li></ol><h3><span id="sentinel的工作流程">Sentinel的工作流程</span></h3><p><strong>1. 获取主服务器信息</strong></p><p>Sentinel默认每十秒向连接的主服务发送INFO命令，并根据INFO命令的回复来获取主服务器的当前信息。<br>INFO命令的回复信息中主要包含了两个方面的信息：</p><ol><li>主服务器本身的信息，如服务器运行Id，服务器角色等信息。</li><li>另以方面是主服务器属性的从服务器信息。这使得Sentinel无需配置从服务器的地址就可以自动发现从服务器。</li></ol><p><strong>2. 获取从服务器信息</strong><br>Sentinel发现主服务器有了新的从服务器后，Sentinel会为新的从服务器创建新颖的实例结构，还会创建连接到从服务器的命令连接和订阅连接。</p><p><strong>3. 向主服务器和从服务器发送信息</strong><br>在默认情况下，Sentinel会一每两秒一次的频率，通过命令连接线被监视的主服务器和从服务器发送命令。<br><img src="https://s2.ax1x.com/2019/10/28/KgnVl6.png" alt="KgnVl6.png"></p><p><strong>4. 接收来自主服务器和从服务器的频道信息</strong><br>当Sentinel与一个主服务器或者从服务器建立起订阅连接之后，Sentinel就会通过订阅连接，向服务器发送以下命令。<code>SUBSCRIBE _sentinel_:hello</code><br>Sentinel对<em>sentinel</em>:hello频道的订阅会一直持续到Sentinel与服务器连接断开为止。</p><p><strong>5. 更新sentinels字典</strong><br>Sentinel为主服务器创建的实例机构中的sentinels字典保存了除Sentinel本身之外，所有同样监视这个主服务器的其它Sentinel的资料。当一个Sentinel接收到其它Sentinel发来的信息是，目标Sentinel会从信息中分析并提取除以下两个方面参数：</p><ol><li>与Sentinel有关的参数：源Sentinel信息。</li><li>与主服务器有关的参数：源Sentinel正在监视的主服务器的信息。</li></ol><p><strong> 6. 创建连向其它Sentinel的命令连接</strong><br>当Sentinel通过频道信息发现一个新的Sentinel时，它不仅会从新Sentinel在sentinels字典中创建相应的实例结构，还会创建一个新Sentinel的命令连接。</p><p><strong>7. 检测主观下线状态</strong><br>默认情况下，Sentinel每秒都会想其它创建了连接的实例发送PING命令，并通过实例返回PING命令回复来判断实例是否在线。如果一个实例在down-after-minlliseconds毫秒内，连续向Sentinel返回回复无效。就会判定为主观下线，在结构的flags属性中打开SRI_S_DOWN标识。（多个Sentinel时，它们的主观下线时长可能不同）</p><p><img src="https://s2.ax1x.com/2019/10/28/Kg1XE8.png" alt="Kg1XE8.png"></p><p><strong>8. 检查客观下线状态</strong><br>当一个Sentinel将一个主观服务器判断为主观下线之后，会向同一个监视这个主服务器的其它Sentinel进行询问，看它们是否也认为主服务器已经进入了下线状态。当认为主服务器下线的Sentinel的数量超过Sentinel配置中设置的quorum参数的值。那么该Sentinel就会认为主服务器进入客观下线状态。</p><p><strong>9. 选举领头Sentinel</strong><br>当一个主服务器被判定为客观下线后，所有监视这个主服务器的Sentinel会进行协商，选出一个领头的Sentinel，并由领头的Sentinel进行故障转移操作。<br>选取规则如下：</p><ol><li>所有在线的Sentinel都由被选为领头Sentinel的资格。</li><li>每次进行领头Sentinel进行选举，无论选举是否成功，所有Sentinel的配置纪元的值都会自增一。</li><li>在一个配置纪元里，每个Sentinel都有一次将某个Sentinel设置为局部领头的机会。</li><li>每个发现主服务器下线的Sentinel都会要求其它的Sentinel把自己设置为局部领头。</li><li>一个源Sentinel向另一个目标Sentinel发送SENTINEL is-master-down-by-addr命令，并且表示源Sentnel要求目标Sentinel将前者设置为后者的局部领头Sentinel。</li><li>Sentinel设置局部领头Sentinel的规则是先到先得的。</li><li>目标Sentinel在接收到SENTINEL is-master-down-by-addr后会向源Sentinel发送一条信息，其中leader_runid和leader_epoch参数分别记录了目标Sentinel的局部领头和Sentinel的运行id。</li><li>如果收到命令的回复总，leader_epoch和自己的一致，且leader_runid和自己的运行id一致，那么表示自己被设置为了局部领头。</li><li>如果某个Sentinel被半数以上的Sentinel设置为了局部领头Sentinel，那么其会成为领头Sentinel。</li><li>如果在一段时间内没有一个Sentinel被选举为领头，那么一段时间后会进行重新选举。</li></ol><p><strong>10. 故障转移</strong><br>当选出领头Sentinel后，领头的Sentinel会进行故障转移：</p><ol><li>在已下线的主服务器的从服务器中选择一个作为新的主服务器。</li><li>让一下线的主服务器属下的从服务器改为复制新的主服务器</li><li>将已下线的主服务器设置为新的主服务器的从服务器。</li></ol><h2><span id="集群">集群</span></h2><p>Redis集群式Redis提供的分布式数据库法案，集群通过分片来进行数据共享，并提供复制和故障转移功能。</p><h3><span id="节点">节点</span></h3><p>一个Redis集群通常是由多个节点组成的，在刚开始的时候，每个节点都是相互独立的，他么都处于一个只包含自己的集群当中。<br>连接各个集群可以使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CLUSTER MEET &lt;ip&gt; &lt;post&gt;</span><br></pre></td></tr></table></figure></p><p>向一个节点发送CLUSTER MEET命令，可以让该节点与指定的节点握手，握手成功后，就会把这个节点添加到自己所在的集群中。<br>一个节点在启动的时候会根据cluster-enabled配置选项是否为yes来决定是否开启服务器的集群模式。</p><p><img src="https://s2.ax1x.com/2019/10/29/KWUyad.png" alt="KWUyad.png"></p><p><strong>节点的数据结构：</strong><br>clusterNode结构保存了一个节点的当前状态，比如节点的创建时间、节点的名字、节点的当前配置纪元、节点的IP地址和端口号等信息。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">mstime_t</span> ctime; <span class="comment">//创建节点的时间</span></span><br><span class="line">    <span class="keyword">char</span> name[REDIS_CLUSTER_NAMELEN]；<span class="comment">//节点的名称</span></span><br><span class="line">    <span class="keyword">int</span> flags;<span class="comment">//节点标识</span></span><br><span class="line">    <span class="keyword">uint64_t</span> configEpoch;<span class="comment">//节点的当前配置纪元</span></span><br><span class="line">    <span class="keyword">char</span> ip[REDIS_IP_STR_LEN];<span class="comment">//节点的IP地址</span></span><br><span class="line">    <span class="keyword">int</span> port;<span class="comment">//节点的端口号</span></span><br><span class="line">    clusterLine *link;<span class="comment">//保存连接节点所需要的相关信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>link指向了一个clusterLink结构。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clusterLink</span>&#123;</span></span><br><span class="line">    <span class="keyword">mstime_t</span> ctime; <span class="comment">//连接创建的时间</span></span><br><span class="line">    <span class="keyword">int</span> fd; <span class="comment">//TCP套接字连接描述符</span></span><br><span class="line">    sds sndbuf; <span class="comment">//输出缓冲区</span></span><br><span class="line">    sds rcvbuf;<span class="comment">//输入缓冲区</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span> *<span class="title">node</span>;</span><span class="comment">//与这个节点相关联的节点</span></span><br><span class="line">    </span><br><span class="line">&#125;clusterLink;</span><br></pre></td></tr></table></figure></p><p>每个节点都保存了一个clusterState结构，这个结构记录了在当前节点的视角下，集群目前所处的状态。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span>&#123;</span></span><br><span class="line">    clusterNode *myself; <span class="comment">//指向当前节点的指针</span></span><br><span class="line">    <span class="keyword">uint64_t</span> currentEpoch;<span class="comment">//集群的当前配置纪元</span></span><br><span class="line">    <span class="keyword">int</span> state;<span class="comment">//集群当前的状态</span></span><br><span class="line">    <span class="keyword">int</span> size;<span class="comment">//集群中至少处理着一个槽的节点的数量</span></span><br><span class="line">    dict *nodes;<span class="comment">//集群节点的名单</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="https://s2.ax1x.com/2019/10/29/KWx6JS.png" alt="KWx6JS.png"></p><h3><span id="槽指派">槽指派</span></h3><p>Redis集群中通过分片的方式来保存数据库中的键值对。整数数据库被划分为16384个槽，数据库中的每个键都属于一个槽，一个节点可以处理一个或多个槽，当所有的槽都被处理时，集群处于上线状态。</p><p>槽指派<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CLUSTER ADDSLOTS &lt;slot&gt; [slot ...]</span><br></pre></td></tr></table></figure></p><p>clusterNode结构中的slots属性和numsslsot属性记录节点复制处理哪些槽<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> slots[<span class="number">16384</span>/<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">int</span> numslots;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>一个节点除了会见自己负责处理的槽记录在clusterNode结构和solt属性和numslots属性中之外，还会将自己的slots数组通过消息发送给集群中的其它节点。<br>clusterState结构中，记录了集群中所有槽的指派信息：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clusterState</span>&#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    clusterNode *slote[<span class="number">16384</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="https://s2.ax1x.com/2019/10/29/KfFmuD.png" alt="KfFmuD.png"></p><p><strong>在集群中执行命令</strong><br>当客户端向集群发送命令时，接收命令的节点会计算出数据库键属于那个槽，并检查这个槽是否指派给了自己。</p><ol><li>如果这个槽刚好是自己，那么就执行命令</li><li>如果这个槽不是属于自己，那么就会向客户端返回一个MOVED错误，指引客户端转向正确的节点</li></ol><p><img src="https://s2.ax1x.com/2019/10/29/KfE9Hg.png" alt="KfE9Hg.png"></p><p><strong>重新分片</strong><br>Redis集群的重新分片操作可以将任意数量已经指派给某个节点的槽改为指派给另一个节点。并且相关槽所属的键值对也会从源节点被移动到目标节点。<br>重新分片操作可以在向进行，在重新分片的过程中，集群不需要下线，并且源节点和目标节点都可以继续处理命令请求。</p><h2><span id="事务">事务</span></h2><p>Redis通过MULTI、EXEC、WATCH等命令来实现事务的功能。<br>Redis的事务首先以MULTI命令开始，接着放入事务当中，最后由EXEC命令将在这个事务提交给服务器执行。</p><h3><span id="事务的实现">事务的实现</span></h3><p>一个事务会经历以下三个阶段：</p><ol><li>事务开始</li><li>事务入队</li><li>事务执行</li></ol><p><img src="https://s2.ax1x.com/2019/10/29/KfJIJ0.png" alt="KfJIJ0.png"></p><p><strong>事务入队</strong><br>每个redis客户端都有自己的事务状态，这个事务站台保存在客户端状态的mstate属性里面：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> stcuct redisCline&#123;</span><br><span class="line">    <span class="comment">//..</span></span><br><span class="line">    multiState mstate;<span class="comment">//事务状态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>每个事务状态包含了一个事务队列：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">multiState</span>&#123;</span></span><br><span class="line">    multiCmd *commands;<span class="comment">//事务队列FIFO顺序</span></span><br><span class="line">    <span class="keyword">int</span> count;<span class="comment">//已入对命令计数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>事务队列是一个multiCmd类型的数组：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">multiCmd</span>&#123;</span></span><br><span class="line">    robj **argv;<span class="comment">//参数</span></span><br><span class="line">    <span class="keyword">int</span> argc;<span class="comment">//参数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> *<span class="title">cmd</span>;</span><span class="comment">//命令指针</span></span><br><span class="line">&#125;multiCmd;</span><br></pre></td></tr></table></figure></p><p><img src="https://s2.ax1x.com/2019/10/29/KfNcQK.png" alt="KfNcQK.png"></p><p><strong>执行事务</strong><br>当一个处于事务状态的客户端向服务器发送<code>EXEC</code>命令时，这个EXEC命令会立即执行。服务器会遍历这个客户端的事务队列，执行队列中保存的所有的命令，最后将执行命令所得到的结果全部返回给客户端。</p><h3><span id="watch命令的实现">WATCH命令的实现</span></h3><p>WATCH命令是一个乐观锁。它可以在事务提交前监视任意数量的键，并在事务提交时检查监视的键是否过期了，如果过期了，服务器会拒绝执行事务，并向客户端返回代表事务执行失败的空回复。<br>每个reids数据库中都保存着一个watched_keys字典。这个字典的键是某个被WATCH命令监视的数据库键，而字典的值则是一个链表。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span>&#123;</span></span><br><span class="line">    <span class="comment">//。。</span></span><br><span class="line">    dict *watched_keys;</span><br><span class="line">&#125;redisDb;</span><br></pre></td></tr></table></figure></p><p>通过watched_keys字典，服务器可以清楚的知道，哪些数据库键正在被监视，以及哪些客户端正在监视这些数据库键。<br><img src="https://s2.ax1x.com/2019/10/31/KIPiIH.png" alt="KIPiIH.png"><br>如果被监视的键被修改，那么监视该键的所有客户端的REDIS_DIRY_CAS标识将被打开。当服务器接收到一个客户端发来的EXEC命令时，服务器会根据客户端是否打开了REDSI_EIDY_CAS标识是否打开了。<br><img src="https://s2.ax1x.com/2019/10/31/KoEk6A.png" alt="KoEk6A.png"></p><p>Redis的事务和传统的关系型数据库的事务的不同之处在于<strong>Redis不支持事务的回滚机制</strong>，即使事务中的某个命令出错了，整个事务也会继续执行下去。在事务命令的入队期间，如果有错误的命令，那么Redis会拒绝执行这个事务。如果事务在执行的过程中出错了，那么数据库不会进行任何的修改，因此对事务的一致性产生任何使用。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;redis服务器&quot;&gt;&lt;a href=&quot;#redis服务器&quot; class=&quot;headerlink&quot; title=&quot;redis服务器&quot;&gt;&lt;/a&gt;redis服务器&lt;/h2&gt;&lt;p&gt;redis服务器负责与多个客户端建立网络连接，处理客户端发送的命令请求，在数据库中保存客户端执行命令所产生的数据，并通过资源管理器来维持服务器自身的运转。&lt;/p&gt;
&lt;h3 id=&quot;命令请求的过程&quot;&gt;&lt;a href=&quot;#命令请求的过程&quot; class=&quot;headerlink&quot; title=&quot;命令请求的过程&quot;&gt;&lt;/a&gt;命令请求的过程&lt;/h3&gt;&lt;p&gt;加入我们使用了这样一天个命令&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;redis&amp;gt; SET KEY VALUE&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;OK&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;整个执行的流程&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;客户端会将命令转换为协议格式，然后通过连接到服务器的套接字按协议格式的命令请求发送给服务器。&lt;/li&gt;
&lt;li&gt;当客户端与服务器之间连接的套接字变得可读时，服务器调用命令求情处理器。&lt;/li&gt;
&lt;li&gt;读取套接字中协议格式的命令，将它保存到客户端状态的输入缓冲区里。&lt;/li&gt;
&lt;li&gt;对输入缓冲区中的数据进行分析，将请求参数存入argv中，参数个数保存在argc中。&lt;/li&gt;
&lt;li&gt;根据请求参数（查找命令表），调用相应的命令执行器，执行指定的命令（在正式执行之前还会检测出参数个数是否正确，客户端是否通过身份认证，如果服务器打开了maxmenory功能，那么在执行命令之前，先检查服务器的内存占用情况，并在需要时进行内存回收，之后再进行执行，并且服务器没被阻塞）。&lt;/li&gt;
&lt;li&gt;再实现函数调用之后，还会执行一系列的后续工作，比如检查是否需要记录到慢查询日志，更新命令的redisCommand结构的milliseconds属性，并将器calls属性加一，如果开启了AOF持久化功能，那么将刚才的命令写入到AOF缓冲区中，如果有其它服务器正在复制这个服务器，那么服务器会见刚刚执行的命令传播到所有从服务器。
    
    </summary>
    
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis设计与实现读书笔记一</title>
    <link href="http://yoursite.com/2019/10/27/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%80/"/>
    <id>http://yoursite.com/2019/10/27/Redis设计与实现读书笔记一/</id>
    <published>2019-10-27T09:39:56.000Z</published>
    <updated>2019-11-05T02:37:55.334Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="简单动态字符串">简单动态字符串</span></h2><p>Redis没有直接使用C语言中的以空字符结尾的字符串。而是自己构建了中名为简单动态字符串（SDS）的抽象类型。<br>Redis中直接使用C字符串的地方仅仅是那些不需要对字符串进行修改的地方，作为字面量使用。<br>Redis底层使用了大量的SDS。<br>比如<code>set msg &quot;hello world&quot;</code>，这个命令会建立一个键值对，Redis会位msg创建一个SDS，位’hello world’创建一个键值对。</p><h3><span id="sds的定义">SDS的定义</span></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> len; <span class="comment">//记录buf中已经使用的字节数，等于SDS所保存的字符串的长度</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">free</span>; <span class="comment">//记录buf中空闲的字节的数量</span></span><br><span class="line">    <span class="keyword">char</span> buf[]; <span class="comment">//字节数组，用于保存字符串</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>SDS也遵循了C语言字符串以空字符结尾的惯例</strong><br><img src="https://s2.ax1x.com/2019/10/21/K1syu9.png" alt="K1syu9.png"></p><h3><span id="sds与c字符串的区别">SDS与C字符串的区别</span></h3><p>SDS的优势：</p><ol><li>常数复杂度，获取字符串的长度。</li><li>可以杜绝缓冲区溢出<br>C语言因为本身不记录自身长度，很容易就可能照成缓冲区溢出。比如<code>char *strcat(char *dest,const char *src)</code>，如果没有对dest分配足够的空间，那么很容易就会出现缓冲区溢出。而SDS的api需要对SDS进行修改的时候会首先检查空间是否足够，完全杜绝了溢出的可能。</li><li>减少修改支付串时带来的内存重分配次数<br>C字符串的长度和其所使用的空间总是存在len+1的关系，所以在对C字符串进行长度修改的时候，都需要重新分配空间。而SDS的空间分配策略（<strong>空间预分配，惰性空间释放</strong>）使得不需要每次都需要进行内存的重新分配。</li><li>二进制安全<br>因为C字符串使用空字符作为字符串的结束符，也就是说，C语言字符串是不能包含空字符的，这种限制也使得C字符串只能保存以某种编码的文本。SDS api都是二进制安全的，所有的SDS api都会以处理二进制的方式来处理SDS存放在buf中的数据，程序不会对数据做任何限制。</li><li>兼容部分的C函数<br>SDS依然遵循C语言字符串的一空字符结尾的规定，所以SDS也可以重用string.h库中定义的函数<br><img src="https://s2.ax1x.com/2019/10/23/KtM0ij.png" alt="KtM0ij.png"></li></ol><h2><span id="链表">链表</span></h2><p>链表提供了高效的节点重排能力，以及顺序性的节点访问方式，并且根据通过增删节点来灵活地调整链表地长度。</p><p>在Redis中许多地方都使用到了链表，比如列表键的底层实现。当一个列表键包含了数量比较多的元素，又或者列表中包含的元素都是比较长的字符串时，Redis就会用链表作为列表键底层实现。</p><h3><span id="链表的定义">链表的定义</span></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listnode</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">void</span> *value; <span class="comment">//节点的值</span></span><br><span class="line">&#125;listNode;</span><br></pre></td></tr></table></figure><p>使用多个listNode来组成链表，使用adlist.h/list来持有链表<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span>&#123;</span></span><br><span class="line">    listNode *head;</span><br><span class="line">    listNode *tail;</span><br><span class="line">    <span class="comment">//链表所包含的节点数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line">    <span class="comment">//节点值复制函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="comment">//节点值释放函数</span></span><br><span class="line">    <span class="keyword">void</span> (*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="comment">//节点值对比函数</span></span><br><span class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">void</span> *ptr,<span class="keyword">void</span> *key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Redis实现的链表有以下几个特点：</p><ol><li>双向</li><li>无环</li><li>带表头指针和表尾指针</li><li>带链表长度计数器</li><li>多态</li></ol><h2><span id="字典">字典</span></h2><p>字典是一种用于保存键值对的抽象数据结构。<br>字典中的每个键都是独一无二的，程序可以在字典中根据键查找与之关联的值。</p><p>当我们在数据库中执行：<br><code>SET msg &quot;hello world&quot;</code>，Redis就会创建一个键为“msg”值为“hello world”的键值对。这个键值对就保存在代表数据库字典里面。<br>除了用于保存数据库之外，字典还是哈希键的底层实现之一。</p><h3><span id="定义与实现">定义与实现</span></h3><p>Redis的字典使用的哈希表由dict.h/dictht结构定义<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hash表定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span>&#123;</span></span><br><span class="line">    <span class="comment">//hash表数组</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line">    <span class="comment">//哈希表大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size;</span><br><span class="line">    <span class="comment">//哈希表大小掩码，用于计算索引值</span></span><br><span class="line">    <span class="comment">//总是等于size-1</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;</span><br><span class="line">    <span class="comment">//该哈希表已有节点的数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;</span><br><span class="line">&#125;dictht;</span><br><span class="line"></span><br><span class="line"><span class="comment">//哈希表节点定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span>&#123;</span></span><br><span class="line">    <span class="comment">//键</span></span><br><span class="line">    <span class="keyword">void</span> *key;</span><br><span class="line">    <span class="comment">//值</span></span><br><span class="line">    <span class="keyword">union</span>&#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="number">8</span>val;</span><br><span class="line">        uint64_tu64;</span><br><span class="line">        int64_ts64;</span><br><span class="line">    &#125;v;</span><br><span class="line">    <span class="comment">//指向下一个哈希表节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;dictEntry;</span><br></pre></td></tr></table></figure></p><p><img src="https://s2.ax1x.com/2019/10/23/KtYEDI.png" alt="KtYEDI.png"></p><p>Redis中字典的定义<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span>&#123;</span></span><br><span class="line">    dictType *type;</span><br><span class="line">    <span class="comment">//私有数据</span></span><br><span class="line">    <span class="keyword">void</span> *privdata;</span><br><span class="line">    <span class="comment">//哈希表</span></span><br><span class="line">    dicht ht[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">//rehash索引，当rehash不在进行时，值为-1</span></span><br><span class="line">    <span class="keyword">int</span> trehashidx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中type属性时一个指向dictType结构的指针，每个dictType结构保存着操作用于操作特定类型的键值对的函数。<br>privadata属性则保存着需要传递给那些类型特定函数的可选参数<br>ht属性包含两个项的数组，数组中的每个项都是一个dictht哈希表，平时只使用ht[0]，ht[1]在rehash时使用。</p><p><img src="https://s2.ax1x.com/2019/10/23/KtUNIP.png" alt="KtUNIP.png"></p><p><strong>解决键冲突：</strong><br>Redis的哈希表采用链地址法来解决键冲突，每个节点都有一个next指针，被分配到同一个索引的节点通过单向链表连接起来，以此来解决键冲突问题。</p><p><strong>rehash</strong><br>为了让哈希表的负载因子维持在一个合理的范围，当哈希表中保存的简直对数量太多或太少的时候，程序需要对hash表的大小进行相应的拓展或收索。<br>Redis的哈希表执行rehash的步骤：</p><ol><li>为ht[1]分配空间</li><li>将ht[0]中的键值对重新计算hash值和索引值，然后键hash值放置在ht[1]哈希表的指定位置上。</li><li>释放ht[0]，将ht[1]设置为ht[0],并在ht[1]创建一个空白的哈希表。</li></ol><p><strong>哈希表的拓展和收索</strong><br>当以下的条件任意一个被满足的时候，程序会自动开始对hash表执行拓展命令</p><ol><li>服务器没有在执行BGSAVE或REWRITEAOF命令，且负载因子大于等于1</li><li>服务器正在执行BGSAVE或REWRITEAOF命令，且负载因子大于等于5</li></ol><p>负载因子的计算公式：<code>load_factor=ht[0].used/ht[0].size</code><br>当哈希表的负载因子小于0.1,程序会自动开始对哈桑表进行收索操作</p><p><strong>渐进式rehash</strong><br>rehash动作并不是一次性的，集中式地完成地，而是分多次、渐进式地完成地。因为如果一次性rehash太多地键值对，那么庞大地计算量可能会导致服务器在一段实践内停止服务。<br>渐进式hash，是通过hash表中地rehashidx属性记录rehash进度的。</p><p>在渐进式hash的过程中对hash表进行操作的话，查找首先会在ht[0]中查找，如果没有找到再去ht[1]中查找。新添加的键值对都会被保存在ht[1]中。</p><h2><span id="跳跃表">跳跃表</span></h2><p>跳跃表是一种有序的数据结构，它通过在每个节点中维护多个指向其它节点的指针，从而达到快速访问节点的目的。<br>Redis使用跳跃表来作为<strong>有序集合</strong>的底层实现之一。<br><img src="https://s2.ax1x.com/2019/10/23/KtDKPI.png" alt="KtDKPI.png"></p><p><img src="https://s2.ax1x.com/2019/10/23/KtDKPI.png" alt="KtDKPI.png"></p><h3><span id="跳跃表的定义与实现">跳跃表的定义与实现</span></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//跳跃表节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span>&#123;</span></span><br><span class="line">    <span class="comment">//层</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span>&#123;</span></span><br><span class="line">        <span class="comment">//前进指针</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line">        <span class="comment">//跨度</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> span;</span><br><span class="line">    &#125;level[];</span><br><span class="line">    <span class="comment">//后退指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line">    <span class="comment">//分值</span></span><br><span class="line">    <span class="keyword">double</span> score;</span><br><span class="line">    <span class="comment">//成员对象</span></span><br><span class="line">    robj *obj;</span><br><span class="line">&#125;zskiplistNode;</span><br></pre></td></tr></table></figure><p>跳跃表节点的level节点数组可以包含多个元素，每个元素都包含了一个指向其它节点的指针。程序可以通过这些层来加快访问其它节点的速度。<br>每个层都有指向表尾方向的前进指针，用于从表头项表尾方向访问节点。<br><strong>跨度</strong>，层的跨度用于记录两个节点之间的距离。两个节点之间的跨度越大，它们相距的就越远。指向NULL的所有前进指针的跨度都为0，因为它们没有连向任何的节点。跨度实际上是用来计算排位的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">skiplistNode</span> *<span class="title">header</span>,*<span class="title">tail</span>;</span></span><br><span class="line">    <span class="comment">//表中节点的数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> length;</span><br><span class="line">    <span class="comment">//表中层数最大的节点的层数</span></span><br><span class="line">    <span class="keyword">int</span> level;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="整数集合">整数集合</span></h2><p>整数集合是集合键的底层实现之一，当一个集合只包含整数值元素，并且这个集合元素的数量不够多时，Redis就会使用整数集合作为集合键的底层实现。</p><h3><span id="整数集合的设计与实现">整数集合的设计与实现</span></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span>&#123;</span></span><br><span class="line">    <span class="comment">//编码方式</span></span><br><span class="line">    <span class="keyword">uint32_t</span> encoding;</span><br><span class="line">    <span class="comment">//集合包含的元素数量</span></span><br><span class="line">    <span class="keyword">uint_32_t</span> length;</span><br><span class="line">    <span class="comment">//保存元素的数组</span></span><br><span class="line">    <span class="keyword">int8_t</span> contents[];</span><br><span class="line">&#125;intset;</span><br></pre></td></tr></table></figure><p><img src="https://s2.ax1x.com/2019/10/24/KNceWd.png" alt="KNceWd.png"></p><p><strong>升级：</strong><br>当我们要将一个新元素添加到整数集合里面，并且新元素的类型比整数集合现有所有元素的类型还要长的时候，整数集合需要先进行升级。<br>升级主要分为三个步骤：</p><ol><li>根据新元素的类型，拓展整个整数集合底层数组的空间大小，并未新元素分配空间。</li><li>将底层数组现有的所有元素都转化为与新元素相同的类型，并将转化后的类型放到正确的位置（保持有序）。</li><li>将新元素添加到底层数组里面。</li></ol><p><strong>整数集合是不支持降级的</strong></p><p><strong>升级的好处：</strong></p><ol><li>提升灵活性<br>C语言是静态类型语言，我们通常不会把两种不同类型的值放在同一个数据结构里面。</li><li>节约内存<br>整数集合在确保可能存放多种不同类型的值的同时，确保升级操作只在有需要的时候进行。</li></ol><h2><span id="压缩列表">压缩列表</span></h2><p>压缩列表是列表键和哈希键的底层实现之一。当一个列表键字包含少量的列表项，并且每个列表项要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做列表键的底层实现。</p><h3><span id="压缩列表的定义与实现">压缩列表的定义与实现</span></h3><p>压缩列表是Redis为了解决内存而开发的。是由一系列特殊编码的连续内存块组成的顺序型数据结构。</p><p><strong>previous_entry_length</strong><br>以字节为单位，记录了压缩列表中前一个节点的长度。previous_entry_length属性长度可以是1字节或5字节。<br><strong>encoding</strong><br>记录了节点content属性所保存数据的类型以及长度。<br><strong>content</strong><br>节点的content属性负责保存节点的值，节点值可以是一个字节数组或者整数，值得类型和长度由节点encoding属性决定。</p><h2><span id="对象">对象</span></h2><p>Redis并没有直接使用之前提到的简单数据结构来实现键值对数据库，而是基于这些数据结构创建了一个对象系统，这个系统包含了字符串对象，列表对象，哈希对象，集合对象和有序集合对象五种类型的对象。</p><h3><span id="对象类型和编码">对象类型和编码</span></h3><p>Redis使用对象类表示数据库中的键和值，每当我们在Redis的数据库中新创建一个键值对时，我们至少会创建两个对象，一个是键对象，一个是值对象。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//redis的每一个对象都是由一个redisObject结构表示的</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span>&#123;</span></span><br><span class="line">    <span class="comment">//类型</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line">    <span class="comment">//编码</span></span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line">    <span class="comment">//指向底层实现数据结构的指针</span></span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ptr指向对象的底层实现数据结构，这些数据结构由对象的encoding属性决定。encoding属性记录了对象所使用的编码，也就是说对象使用了什么数据结构作为对象的底层实现。<br><img src="https://s2.ax1x.com/2019/10/24/KaiGnJ.png" alt="KaiGnJ.png"></p><p>每种类型的对象都至少使用了两种不同类型的编码。<br><img src="https://s2.ax1x.com/2019/10/24/KaiUtx.png" alt="KaiUtx.png"><br>通过encoding属性来设定对象所使用的编码，而不是为特定类型的对象关联一种固定的编码，极大的提高了redis的灵活性和效率。因为Redis可以根据不同的使用场景来为对象设定不同的编码，从而优化了对象在某一场景下的效率。</p><h2><span id="字符串对象">字符串对象</span></h2><p>字符串对象的编码可以是int,row,embstr.<br>如果一个字符串对象保存的是整数值，并且这个整数值可以用long类型表示，那么字符串对象会值保存在字符串对象数据结构中ptr属性里，并将编码类型设置为int。</p><p>如果字符串对象保存的是一个字符串值，并且这个字符串的长度大于32字节，那么这个对象将使用SDS来保存这个字符串值，并将对象编码设置为row。</p><p>如果字符串对象保存的是一个字符串值，且这个字符串值的长度小于等于32字节是，那么字符串对象间使用embstr编码的方式来保存这个字符串值。embstr编码也会使用SDS，只不过它通过一次内存分配获取一片连续的空间，就实现了redisObject 和sdshdr结构内存的分配。而row编码，需要两次.一次用来分配redisObject一次用来分配sdshar。而且因为Redis中没有embstr编码的修改程序，也就说其实embstr编码是只读的，写操作会重新分配。<br>通过embstr编码创建的内存块的结构：<br><img src="https://s2.ax1x.com/2019/10/24/KaAY7j.png" alt="KaAY7j.png"></p><p><strong>值得注意的是，可以用long double表示的浮点数，在redis中也是作为字符串值来存放的</strong></p><h2><span id="列表对象">列表对象</span></h2><p>列表对象的编码可以是ziplist或linkedlist。<br>ziplist编码的列表使用压缩列表来作为底层实现，每个压缩列表节点保存一个列表节点。<br>另一个方面，linkedlist编码的列表对象使用双端链表作为底层实现。每个双端链表都保存了一个字符串对象，而每个字符串对象都保存了一个列表元素。双端列表结构中可以嵌套多个字符串对象。<br><strong>编码转换</strong><br>当列表对象同时满足以下两个条件时，列表对象可以使用ziplist。</p><ol><li>列表保存的字符串元素都是小于列表</li><li>列表对象保存的元素数量时小于512个的。</li></ol><h2><span id="哈希对象">哈希对象</span></h2><p>哈希对象的编码可以是ziplist或者hashtable。<br>ziolist编码的哈希对象实现，是将键和值同时一次推入压缩列表表尾。<br>hashtable编码的哈希表实现使用字典作为底层实现，哈希对象的每个键值对都使用一个字典键值对来保存。<strong>字典的键和值都是字符串对象</strong>。</p><p><strong>编码转换：</strong><br>当哈希对象可以<strong>同时满足</strong>以下两个条件时，哈希对象使用siplist编码：</p><ol><li>哈希对象所保存的键和值的字符串长度都是小于64字节的。</li><li>哈希对象所保存的键值对数量是小于512个的。</li></ol><h2><span id="集合对象">集合对象</span></h2><p>集合对象的编码可以是intset或者hashtable。<br>intset编码的集合使用整数集合作为底层实现，集合对象包含的而所有元素都保存在整数集合中。</p><p>hashtable编码的集合对象使用字典作为底层实现，字典的每个值都是一个字符串对象，每个字符串对象包含了一个集合元素，而字典的值都被全部设置为null。</p><p><strong>编码的转换：</strong><br>当集合的对象满足以下两个条件时，可以使用intset编码。</p><ol><li>集合对象保存的所有元素都是整数值</li><li>集合对象保存的元素数量不超过512个</li></ol><h2><span id="有序集合对象">有序集合对象</span></h2><p>有序集合对象的编码可以是ziplist或者skiplist。<br>ziplist使用压缩列表来作为底层实现，集合中的每个元素使用两个挨在一起的列表节点来博爱从，第一个节点保存成员，第二个节点保存分数。压缩列表按分值从小到大进行排序。</p><p>skiplist编码的有序集合对象使用zset结构作为底层实现，一个zset结构结构同时包含了一个字典和一个跳跃表。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zset</span>&#123;</span></span><br><span class="line">    zskiplist *zsl;</span><br><span class="line">    dict *dict;</span><br><span class="line"></span><br><span class="line">&#125;zset;</span><br></pre></td></tr></table></figure></p><p>zset中的zsl跳跃表按分值的大小保存了从小到大所有集合元素，每个跳跃表界定啊都保存了一个集合元素。跳跃表节点的object属性保存了元素的成员，而跳跃表界定啊的score属性保存了元素的分值。<strong>通过跳跃表可以非常方便的实现有序集合的范围性操作</strong>。<br>而zset中的dist属性保存了有序集合中成员到分数的映射，<strong>可以以常数复杂度查找给定成员的分数。</strong></p><p><strong>编码的转换</strong><br>当有序集合对象可以同时满足以下两个条件时，对象使用ziplist编码：</p><ol><li>有序集合保存的元素数量小于128个</li><li>有序集合中所有元素的成员都小于64字节。</li></ol><h2><span id="内存回收">内存回收</span></h2><p>Redis实现了自己的引用计数计数，通过这一机制，程序可以通过跟踪对象的引用计数信息，在适当的时候释放对象并进行内存回收。每个对象的引用计数信息，由redisObject结构的refcount属性记录。</p><p>引用计数信息的变化：</p><ol><li>当创建一个对象时，引用计数的值会被初始化为1</li><li>当一个对象被一个新的程序使用时，它的引用计数值会被增一</li><li>当对象不再被一个程序使用时，它的引用计数值会被减一。</li><li>当对象的引用计数值为0时，对象所占用的内存会被释放。</li></ol><p><img src="https://s2.ax1x.com/2019/10/25/KabneS.png" alt="KabneS.png"></p><h2><span id="对象共享">对象共享</span></h2><p>对象的引用计数还可以实现对象共享。<br><img src="https://s2.ax1x.com/2019/10/25/KabRTe.png" alt="KabRTe.png"></p><p><strong>redis不会共享包含字符串的对象</strong></p><h2><span id="对象的空转时长">对象的空转时长</span></h2><p>redisObject结构中还包含了一个lru属性，该属性记录了对象最后一次被命令程序访问的时间。<br>如果服务器打开了maxmemory选项，并且服务器用于回收内存的算法为volatile-lru或者allkeys-lru，那么当服务器占用的内存数超过maxmemory选项设置的上限值时，空转时长较高的那部分会被优先释放。</p><h2><span id="服务器中的数据库">服务器中的数据库</span></h2><p>Redis服务器的所有状态都保存在redis.h/redisServer结构的db数组中，db数组的每个项都是一个redis.h/redisDb结构，每个redisDb结构代表一个数据库。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span>&#123;</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="comment">//一个数组，保存服务器中的所有数据库</span></span><br><span class="line">redisDb *db;</span><br><span class="line"><span class="comment">//服务器的数据库数量</span></span><br><span class="line"><span class="keyword">int</span> dbnum;</span><br><span class="line"><span class="comment">//..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在初始化服务器时，程序会根据服务器状态的dbnum属性来决定应该创建多少个数据库。dbnum的值有服务器配置的database选项决定，默认情况下，该选项的值为16.</p><h3><span id="切换数据库">切换数据库</span></h3><p>每个redis客户端都有自己的目标数据库，默认情况下redis客户端的默认数据库为0号数据库，用户可以通过select命令来切换数据库。客户端状态的redisclinet结构的db属性记录了客户端当前的目标数据库，这个属性是一个指向redisdb结构的指针。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisClient</span>&#123;</span></span><br><span class="line">    <span class="comment">//记录客户端当前正在使用的数据库</span></span><br><span class="line">    redisDb *db;</span><br><span class="line">&#125;redisClient;</span><br></pre></td></tr></table></figure></p><p>通过修改db指针的值，让它指向服务器中不同的数据库。</p><p><img src="https://s2.ax1x.com/2019/10/25/KajvQA.png" alt="KajvQA.png"></p><h3><span id="数据库键空间">数据库键空间</span></h3><p>服务器中每个数据库都由一个redisDb结构表示，其中redisDb结构的dict字典保存了数据库中所有键值对，我们将这个字典称为键空间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span>&#123;</span></span><br><span class="line">    <span class="comment">//。。。</span></span><br><span class="line">    <span class="comment">//数据库键空间</span></span><br><span class="line">    dict  *dict;</span><br><span class="line">&#125;redisDb;</span><br></pre></td></tr></table></figure><p>键空间的键也就是数据库的键，每个键都是一个字符串对象。<br>键空间的值也就是数据库的值，每个值可以是字符串对象、列表对象、哈希表对象、集合对象和有序集合对象中的任意一种Redis对象。<br><img src="https://s2.ax1x.com/2019/10/25/KwEA2t.png" alt="KwEA2t.png"></p><p><strong>添加键、删除键，更新键</strong><br>添加键和删除键其实就是操作键空间中的键值对对象。</p><p><strong>对键取值</strong><br>对键取值就是在在键空间中去除键所对应的值对象。</p><p><strong>读写键空间时的维护操作</strong><br>当使用Redis命令对数据库进行读写时，数据库不仅会对键空间执行制定的读写操作，还会执行一些额外的维护操作：</p><ol><li>在读取一个键之后，服务器会根据键是否存在来更新服务器的键空间命中和键不命中次数</li><li>在读取一个键之后，服务器会更新键的LRU（最后一次使用时间），这个值可以计算键的闲置时间。</li><li>如果服务器在读取一个键时，发现这个键已经过期了，那么它会首先删除这个键。</li><li>如果客户端使用WATCH监视一个键时，如果被监视的对象被修改的话，这个键会被标记为脏。</li><li>服务器每修改一个键之后，都会对脏键计数器的值增一，这个值会触发服务器的持久化以及复制操作。</li><li>如果服务器开启了数据库通知，那么对键修改之后，服务器将按配置发送相应的数据库通知。</li></ol><p><strong>设置键的生存时间或过期时间：</strong><br>通过EXPLRE命令或PEXPIRE命令，客户端可以以秒或毫秒为单位为数据库中的某个键设置生存时间（Time to live，TTL）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EXPLRE &lt;key&gt; &lt;ttl&gt; //将键的生存时间设置为ttl秒</span><br><span class="line">PEXPIRE &lt;key&gt; &lt;ttl&gt; //将键的生存时间设置为ttl毫秒</span><br><span class="line">EXPIREAT &lt;key&gt; &lt;timestamp&gt; //将key的过期时间设置为timestamp所指定的秒数时间戳</span><br><span class="line"></span><br><span class="line">PEXPIREAT &lt;key&gt; &lt;timestamp&gt; //将键的过期时间设置为timestamp所指定的毫秒数时间戳</span><br></pre></td></tr></table></figure></p><p>无论在客户端中使用的是哪一种命令，最终的执行效果都和PEXPIREAT命令一样<br><img src="https://s2.ax1x.com/2019/10/25/KwBO78.png" alt="KwBO78.png"></p><p><strong>保存过期时间</strong><br>redisDb结构中的expires字典保存了数据库中所有键的过期时间，我们称之为过期字典。<br>过期字典的键是一个指向键空间中某个对象的指针，而过期字典的值是一个long类型的整数。<br><img src="https://s2.ax1x.com/2019/10/25/KwrfRH.png" alt="KwrfRH.png"></p><p><strong>过期键删除策略</strong></p><ol><li>定时删除，在设置键的过期时间的同时，创建一个定时器，让定时器在键的过期时间来临时，立即执行对键的删除操作。<br>它能及时地删除过期地键，但是对CPU时间是最不友好地。</li><li>惰性删除，放任键的过期时间，只是从键空间取键时，检查是否过期，如果发现过期就进行删除。<br>对CPU是最友好的，但是对内存时不友好的。过期键可能长时间的占用内存。</li><li>定期删除：每隔一段时间，程序就会对数据库进行一次检查，删除里面的过期键。<br>定时删除是对前两种方案的一种折中。</li></ol><h3><span id="过期键对aofrdb和复制功能的影响">过期键对AOF，RDB和复制功能的影响</span></h3><p><strong>RDB</strong><br>在生存RDB文件的时候，程序会对数据库中的键进行检查，已过期的键不会被保存到新创建的RDB文件中。</p><p>当载入RDB文件的时候，如果服务器以主服务器运行，那么程序会对文件中的键进行检查，未过期的键会被载入数据库中。<br>如果服务器以从服务器模式运行，那么载入RDB文件时，文件中保存的所有键，无论过期与否都会被载入。<br><strong>AOF</strong><br>如果数据库中的某个键已经过期了，但是它还没有被惰性删除或定期删除，那么AOF将不会受任何的影响。当过期的键被惰性删除或定期删除之后，程序会线AOF文件中追加一条DEL命令，来显示的指明该键已被删除。<br>当在进行AOF重写的时候，程序会对键进行检查，已过期的键不会被保存到重写后的AOF文件中。</p><p><strong>复制</strong><br>当服务器运行在复制模式下时，从服务器的过期键删除动作由主服务器控制。</p><ol><li>当主服务器在删除一个过期键之后，会显示地向所有从服务器发送一个DEL命令，告知从服务器删除这个过期键。</li><li>从服务器在处理读命令时，即使发现了键过期了，也会当作没过期来进行处理。</li><li>从服务器只在收到主服务器发来地DEL命令之后，才会删除过期键。</li></ol><h2><span id="rdb持久化">RDB持久化</span></h2><p>RDB持久化既可以手动执行，也可以根据服务器配置选项定期执行，该功能可以将某个时间点上的数据库状态（指服务器中的非空数据库以及它们的状态）保存到已RDB文件中。RDB持久化生成的是一个经过压缩的二进制文件，通过该文件可以还原生成RDB文件时的数据库状态。</p><p>服务器在启动时候会主动取检测RDB文件，然后自动载入，但是如果服务器开启了AOF持久化功能，那么<strong>优先使用AOF文件</strong>来还原数据库状态。只有在AOF持久化关闭的时候才会使用AOF来进行数据库的还原。</p><p>值得注意的时候BGREWRITEAOF和BGSAVE同一时间只能有一个在执行，有些是出于避免竞争条件的考虑，有些是出于性能的考虑。</p><p>Redis服务启动的时候，用户可以通过配置文件或者传入启动参数的形式设置save选项。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span>&#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//记录保存条件的数组</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">saveparam</span> *<span class="title">saveparams</span>;</span></span><br><span class="line">    <span class="comment">//修改计数器，据上一次save或bgsave后的修改次数</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> dirty;</span><br><span class="line">    <span class="comment">//上一次执行保存的时间</span></span><br><span class="line">    <span class="keyword">time_t</span> lastsave;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">saveparam</span>&#123;</span></span><br><span class="line">    <span class="comment">//秒数</span></span><br><span class="line">    <span class="keyword">time_t</span> seconds;</span><br><span class="line">    <span class="comment">//修改数</span></span><br><span class="line">    <span class="keyword">int</span> changes;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3><span id="rdb文件结构">RDB文件结构</span></h3><p>RDB文件所保存的是二进制数据。<br><img src="https://s2.ax1x.com/2019/10/26/KDmsRe.png" alt="KDmsRe.png"><br>开头的REDIS部分长度为5个字节，用来检测文件是否是RDS文件。<br>db_version：长度为4字节，记录了文件的版本号。<br>databases:包含着零个或任意多个数据库，以及各个数据库中的键值对数据。<br>EOF：长度为1字节，标识RDB文件的正式结束。</p><p>每个非空数据库又包含3个部分：<br><img src="https://s2.ax1x.com/2019/10/26/KDuZBn.png" alt="KDuZBn.png"><br>其中SELECTDB的值为一字节，当程序读到这个值的时候，它就知道接下来是数据库号码了。<br>每个key_value_pairs也是由三部分组成的。<br><img src="https://s2.ax1x.com/2019/10/26/KDu03D.png" alt="KDu03D.png"></p><h2><span id="aof持久化">AOF持久化</span></h2><p>AOF持久化是通过保存服务器所执行的写命令来记录数据库状态的。<br><img src="https://s2.ax1x.com/2019/10/26/KDQ3jg.png" alt="KDQ3jg.png"><br>被写入AOF文件的所有命令都是以Redis的命令请求协议格式保存的，Redis请求协议是纯文本的。<br>在服务器启动的时候，可以通过载入和执行AOF文件中保存的命令来还原服务器关闭之前的数据库状态。</p><h3><span id="aof持久化的实现">AOF持久化的实现</span></h3><p>AOF持久化功能的实现可以分为命令追加，文件写入，文件同步。<br>当服务器在执行完写命令后，会以协议格式见被执行的命令写入到aof_buf中<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span>&#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//AOF缓冲区</span></span><br><span class="line">    sds aof_buf;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过配置服务器：appendfsync：</p><ol><li>always：将aof_buf缓冲区中的所有内容<strong>写入并同步</strong>到AOF文件</li><li>everysec:将aof_buf缓冲区中的内容<strong>写入</strong>到文件，如果上次写入<strong>超过一秒种</strong>，就再次对AOF进行<strong>同步</strong>。这个同步是由一个线程专门负责。</li><li>no：aof_buf缓冲区中的内容写入文件，并从不主动同步，由操作系统决定。</li></ol><p><em>这个地方的写入是指，调用系统的write写入到缓冲区，同步是将缓冲区写入到磁盘</em></p><p><strong>现代OS中调用write函数首先是写入到缓冲区中，等待一定的时机，才由缓冲区写入磁盘，只有当写入磁盘了才算真正的持久化了</strong></p><h3><span id="aof重写">AOF重写</span></h3><p>随着服务器的运行，AOF文件中的内容也会越来越多。这个时候，就需要使用Redis的AOF重写功能。它会创建一个新的AOF文件来代替原来的AOF文件，且新的AOF文件中不包含冗余的命令。<strong>AOF重写是不会依赖于旧的AOF文件的</strong>，而是通过服务器的当前状态来实现的。因此新的AOF文件只包含还原当前状态的必须命令。<br>Redis使用子进程对AOF进行重写，在这期间执行的命令可能改变数据库的状态，所以Redis引入了一个AOF重写缓冲区。</p><p>在子进程执行AOF重写期间，服务器进程需要执行以下三个工作：</p><ol><li>执行客户端发来的命令</li><li>将执行后的写命令追加到AOF缓冲区</li><li>将执行后的写命令追加到AOF重写缓冲区。</li></ol><p><strong>从创建子进程起，服务器执行的所有写命令都会被记录到AOF重写缓冲区里面</strong><br><img src="https://s2.ax1x.com/2019/10/26/KDNbVO.png" alt="KDNbVO.png"></p><h2><span id="事件">事件</span></h2><p>Redis服务器是一个事件驱动程序，服务器需要处理两类事件：</p><ol><li>文件事件，文件事件就是服务器套接字操作的抽象，服务器与客户端的通信会产生相应的文件事件，而服务器则通过监听并处理这些事件来完成一系列的通信操作。</li><li>时间事件，时间事件就是对定时操作的抽象。</li></ol><h3><span id="文件事件">文件事件</span></h3><p>Redis基于Reactor模式开发了自己的网络事件处理器，这个处理器被称为文件事件处理器。文件事件是对套接字操作的抽象，每次套接字变为可应答，可写或者可读时，相应的文件事件就会产生。<br>文件事件处理器使用IO多路服务程序来同时监听多个套接字。<br><img src="https://s2.ax1x.com/2019/10/26/KDDX01.png" alt="KDDX01.png"><br>尽管多个文件事件可能会并发的出现，当IO多路复用程序总是会将所有产生的事件的套接字放到一个队列里面，然后通过这个<strong>队列</strong>，以有序的、同步的、每次执行一个套接字的方式向文件事件分派起传送套接字。</p><p><img src="https://s2.ax1x.com/2019/10/26/KDrthT.png" alt="KDrthT.png"><br>Redis的IO多路复用程序有多个IO多路复用库实现可选。<br><img src="https://s2.ax1x.com/2019/10/26/KDr6N6.png" alt="KDr6N6.png"></p><p>IO多路复用程序允许服务器同时监听套接字的AE_READABLE事件和AE_WRITABLE事件，如果一个套接字同时产生了这两种事件，那么事件分派器会优先处理AE_READABLE事件。</p><h3><span id="时间事件">时间事件</span></h3><p>Redis时间时间又可以细分为定时事件和周期性事件。<br>一个时间时间通过上个属性来描述：</p><ol><li>id，服务器会为每个时间时间创建一个全局唯一ID，ID从小到大递增。</li><li>when：毫秒精度的unix时间戳。</li><li>timeproc：时间处理函数，一个函数。</li></ol><p>一个时间事件是定时事件还是走起周期性事件是由timeproc的返回值决定的，如果返回的是AE_NOMORE, 那么这个事件是定时事件，事件到达一次后，就会被删除，如果返回的不是AE_NNOMORE那么就是一个周期性事件，每次事件到达后都会更新when。</p><p>Redis将所有的事件事件都放置在一个无序链表（指不是按when排序的）中，每当时间事件执行器运行的时候，它就遍历整个链表，查找所以已达到（<code>when&gt;=当前时间</code>）的时间事件，并调用相应的事件处理器。<br><img src="https://s2.ax1x.com/2019/10/27/KsDxhV.md.png" alt="KsDxhV.md.png"></p><p>事件处理角度下的服务器运行流程：<br><img src="https://s2.ax1x.com/2019/10/27/Kss6Zd.png" alt="Kss6Zd.png"></p><h2><span id="redis客户端">Redis客户端</span></h2><p>Redis通过使用由IO多路复用技术实现的文件事件处理器，Redis服务器使用单线程单进程的方式来处理命令请求，并与多个客户端进行网络通信。</p><p>服务器为每个客户端都建立了一个redisClinet结构，整个结构保存了客户端当前的状态信息，以及执行相应的功能许哟啊用到的数据结构。<br><img src="https://s2.ax1x.com/2019/10/27/KsgR0g.md.png" alt="KsgR0g.md.png">]<br>在redisServer中保存了一个指向由客户端状态结构组成的链表的指针。</p><h3><span id="客户端的属性">客户端的属性</span></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisClient</span>&#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">int</span> fd; <span class="comment">//套接字描述符</span></span><br><span class="line">    robj *name; <span class="comment">//客户端名字</span></span><br><span class="line">    <span class="keyword">int</span> flags;<span class="comment">//客户端标准属性</span></span><br><span class="line">    sds querybuf;<span class="comment">//输入缓冲区</span></span><br><span class="line">    robj **argv; <span class="comment">//命令参数</span></span><br><span class="line">    <span class="keyword">int</span> argc;<span class="comment">//命令参数数量</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">redisCommmand</span> *<span class="title">cmd</span>;</span><span class="comment">//命令的实现函数</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*输出缓冲区*/</span></span><br><span class="line">    <span class="keyword">char</span> buf[REDIS_REPLY_CHUNK_BYTE]; <span class="comment">//固定大小输出缓冲区</span></span><br><span class="line">    <span class="keyword">int</span> bufpos; <span class="comment">//固定大小输出缓冲区的实际使用长度</span></span><br><span class="line">    <span class="built_in">list</span> *reply; <span class="comment">//可变大小输出缓冲区</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> authenticated; <span class="comment">//身份认证属性，1为通过认证，0为未通过认证</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">time_t</span> ctime; <span class="comment">//创建客户端的时间</span></span><br><span class="line">    <span class="keyword">time_t</span> lastinteraction; <span class="comment">//最后一次与服务器互动的时间</span></span><br><span class="line">    <span class="keyword">tine_t</span> obuf_soft_limit_reached_time; <span class="comment">//输出缓冲区第一次到达软性限制时间</span></span><br><span class="line">&#125;redisClient;</span><br></pre></td></tr></table></figure><p><strong>套接字描述符fd</strong></p><p>根据客户端类型的不同，fd属性的值可以是-1或者大于-1的整数。</p><ol><li>伪客户端：fd的值为-1.命令的来于AOF文件或者Lua脚本，而不是网络，这种客户端不需要设置套接字连接。</li><li>普通客户端：fd的值大于-1的整数，使用套接字来与服务器进行通讯。</li></ol><p><strong>客户端名字</strong><br>默认情况下，客户端是没有名字的，也就是所name是指向null的。如果设置了名字，男儿name就指向保存了名字的对象。</p><p><strong>客户端标志属性</strong><br>客户端标志属性flags记录了客户端的角色，以及客户端目前所处的状态。flags属性的值可以是单个标志也可以是多个标志的二进制或。如：<br><code>flags=&lt;flag&gt;</code><br><code>flags=&lt;falg1&gt;|&lt;flag2&gt;|&lt;flag3&gt;</code></p><p>常见的表示角色的客户端：</p><ol><li>REDIS_MASTER表示客户端代表的是一个主服务器。</li><li>REDIS_SLAVE表示客户端代表的是一个从服务器。</li><li>REDIS_LUA_CLIENT表示客户端专门用于处理Lua脚本中包含Redis命令的伪客户端。</li><li>REDIS_MONITOR表示客户端正在执行MONITOR命令。</li><li>REDIS_UNIX-SOCKE表示服务器使用UNIX套接字来连接客户端。</li></ol><p><strong>输入缓冲区querybuf</strong><br>客户端状态的输入缓冲区用于保存客户端发送的命令请求。输入缓冲区的大小会根据输入内容动态地缩小或者扩大，但他地最大大小不能超过1GB，否则服务器将会关闭这个客户端。</p><p><strong>命令与命令参数</strong><br>服务器将客户端发送来的命令保存在客户端状态的querybuf属性中，之后就会对命令的内容进行分析，并将得出的命令参数以及命令参数的个数，<br>argv属性是一个数组，数组中的每个元素都是一个字符串对象，其中argv[0]是要执行的命令，其后的argc-1项都是传给该命令的参数。<br><img src="https://s2.ax1x.com/2019/10/27/Ks5g8H.png" alt="Ks5g8H.png"><br>在该图中的例子中，argc==3，因为set本身也是一个参数</p><p><strong>命令实现函数</strong><br>cmd，当服务器完成协议内容的解析得到argv和argc后，服务器就会根据argv[0]知道对应的实现函数。寻找对应的命令实现函数需要借助一个字典。这个字典的键位sds结构，保存命令的名称，字典的值是一个rediscommand结构，该结构保存了实现函数、命令的标记，命令应该给定的参数个数、命令总执行次数和总消耗时长等统计信息。<br><img src="https://s2.ax1x.com/2019/10/27/Ks7Ess.png" alt="Ks7Ess.png"></p><p><strong>输出缓冲区</strong><br>执行命令所得到命令回复会被保存在客户端状态的输出缓冲区里面，每个客户端都有两个输出缓冲区可用。<br>固定大小的已被用于保存那些比较短的回复；可变大小缓冲区主要保存那些长度比较大的回复。<br><img src="https://s2.ax1x.com/2019/10/27/KsHe6H.png" alt="KsHe6H.png"></p><p><img src="https://s2.ax1x.com/2019/10/27/KsHM7t.png" alt="KsHM7t.png"></p><p><strong>身份认证</strong><br>客户端状态的authenticated属性记录了客户端是否通过了身份验证。0为未通过认证，1为通过了认证。当authenticated属性的值为0时，除了执行auth命令，其余所有命令都会被拒绝。<br><strong>authenticated仅在服务器启用了身份认证功能之后，才能生效</strong></p><p><strong>时间</strong><br>ctime属性记录了客户端创建的时间，<br>lastinteraction属性记录了客户端与服务器最后一次进行互动的时间。该属性可以用来计算客户端的空转时间。<br>obuf_soft_limit_reached_time属性记录了输出缓冲区第一次到达软性限制的时间。</p><h3><span id="客户端的创建与关闭">客户端的创建与关闭</span></h3><h4><span id="创建普通客户端">创建普通客户端</span></h4><p>如果客户端是通过网络与服务器进行连接的普通客户端，那么在客户端使用connect函数连接服务器的时候，服务器就创建了连接事件处理器，为客户端创建相应的客户端状态，并将这个客户端状态添加到服务器状态结构clinets链表尾。</p><h4><span id="关闭普通客户端">关闭普通客户端</span></h4><p>照成普通客户端关闭的原因：</p><ol><li>客户端进程被杀死，或网络连接关闭。</li><li>客户端向服务端发送了不符合协议格式的请求。</li><li>客户端称为了CLIENT KILL命令的目标</li><li>服务器端配置了timeout选项，当客户端的空转时间超过限制，就会被服务器端关闭。</li><li>客户端发送的请求超过了输入缓冲区的限制（1GB）</li><li>要发送给客户端的命令回复的大小超过了输入缓冲区的限制大小。</li></ol><p>为了避免客户端的回复过大，服务器会检查输出缓冲区的大小，服务器有两种模式来限制客户端的输出缓冲区的大小：</p><ol><li>硬性限制，输出缓冲区的大小达到限制的大小，服务器立刻关闭客户端。</li><li>软性限制，如果输出缓冲区的大小达到限制的大小后，记录达到软性限制的起始时间，如果缓冲区大小一直超出软性限制（超过设定的时长），那么服务器将关闭客户端。</li></ol><h3><span id="lua伪客户端">Lua伪客户端。</span></h3><p>服务器在创建的时候就会创建一个用于执行Lua脚本中的redis命令的客户端，并将这个伪客户端关联在服务器状态结构的lua_client属性中。<br>直到服务器关闭才会关闭Lua伪客户端。</p><h3><span id="aof文件的伪客户端">AOF文件的伪客户端</span></h3><p>当服务器载入AOF文件时，会创建AOF文件的伪客户端，当载入完成，就会关闭这个伪客户端。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简单动态字符串&quot;&gt;&lt;a href=&quot;#简单动态字符串&quot; class=&quot;headerlink&quot; title=&quot;简单动态字符串&quot;&gt;&lt;/a&gt;简单动态字符串&lt;/h2&gt;&lt;p&gt;Redis没有直接使用C语言中的以空字符结尾的字符串。而是自己构建了中名为简单动态字符串（SDS）的抽象类型。&lt;br&gt;Redis中直接使用C字符串的地方仅仅是那些不需要对字符串进行修改的地方，作为字面量使用。&lt;br&gt;Redis底层使用了大量的SDS。&lt;br&gt;比如&lt;code&gt;set msg &amp;quot;hello world&amp;quot;&lt;/code&gt;，这个命令会建立一个键值对，Redis会位msg创建一个SDS，位’hello world’创建一个键值对。&lt;/p&gt;
&lt;h3 id=&quot;SDS的定义&quot;&gt;&lt;a href=&quot;#SDS的定义&quot; class=&quot;headerlink&quot; title=&quot;SDS的定义&quot;&gt;&lt;/a&gt;SDS的定义&lt;/h3&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;sdshdr&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; len; &lt;span class=&quot;comment&quot;&gt;//记录buf中已经使用的字节数，等于SDS所保存的字符串的长度&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;free&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;//记录buf中空闲的字节的数量&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; buf[]; &lt;span class=&quot;comment&quot;&gt;//字节数组，用于保存字符串&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis实战学习笔记二</title>
    <link href="http://yoursite.com/2019/10/23/Redis%E5%AE%9E%E6%88%98%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/"/>
    <id>http://yoursite.com/2019/10/23/Redis实战学习笔记二/</id>
    <published>2019-10-23T08:39:56.000Z</published>
    <updated>2019-10-27T09:49:13.954Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="使用redis构建支持程序">使用Redis构建支持程序</span></h2><h3><span id="案例一-使用redis实现日志的记录">案例一： 使用Redis实现日志的记录</span></h3><p><strong>需求：</strong> 在构建应用程序和服务的过程中，对正在运行的系统的相关信息进行挖掘变得越来越重要。这都依赖于日志。</p><p><strong>分析：</strong> 许多日志的记录的方式都是将日志记录到文件中去，然后随着时间的流逝新建日志文件（因为日志文件大大小不可能无限的增长），因为每个服务都有相应的日志记录，并且每种服务的日志轮换机制也是不同的，这就会缺少了一种将这些日志聚合的方案。<br>还有一种日志记录方式是利用syslog服务来进行日志的记录。syslog服务接收各个服务的日志信息，并路由到不同的磁盘上，它还负责日志的轮换和删除工作。它要比直接写文件方便的多。</p><p>我们也可以利用Redis来实现日志的记录。</p><p><strong>实现方式：</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">SEVERITY=&#123;   <span class="comment"># 设置一个字典，将日志的安全级别映射为字符串</span></span><br><span class="line">    loggin.DEBUG:<span class="string">'debug'</span>,</span><br><span class="line">    loggin.INFO：<span class="string">'info'</span>,</span><br><span class="line">    loggin.WARNING:<span class="string">'warning'</span>,</span><br><span class="line">    loggin.ERROR:<span class="string">'error'</span>,</span><br><span class="line">    loggin.CRITICAL:<span class="string">'critical'</span></span><br><span class="line">&#125;</span><br><span class="line">SERVERITY.update((name,name) <span class="keyword">for</span> name <span class="keyword">in</span> SERVERITY.values())</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log_recent</span><span class="params">(conn,name,message,severity=loggin.INFO,pipe=None)</span>:</span></span><br><span class="line">    <span class="comment"># 将日志的安全级别映射为简单的字符串</span></span><br><span class="line">    severity=str(SEVERITY.get(severity,severity)).lower() </span><br><span class="line">    <span class="comment"># 创建负责存储消息的键</span></span><br><span class="line">    destination=<span class="string">'recent:%s:%s'</span>%(name,severity)</span><br><span class="line">    <span class="comment"># 在消息中添加当前时间</span></span><br><span class="line">    message=time.asctime()+<span class="string">' '</span>+message</span><br><span class="line">    <span class="comment"># 使用流水线通信方式</span></span><br><span class="line">    pipe=pipe <span class="keyword">or</span> conn.pipeline()</span><br><span class="line">    pipe=lpush(destination,message)</span><br><span class="line">    <span class="comment"># 对日志列表进行修剪，只保留100条消息</span></span><br><span class="line">    pipe.ltrim(destination,<span class="number">0</span>,<span class="number">99</span>)</span><br><span class="line">    <span class="comment"># 执行两个命令</span></span><br><span class="line">    pipe.execute()</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>我们还可以统计每种消息出现的频率，并根据消息频率来进行消息的排序，从而找出最重要的信息。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log_common</span><span class="params">(conn,name,message,severity=logging.INFO,timeout=<span class="number">5</span>)</span>:</span></span><br><span class="line">    severity=ser(SEVERITY.get(severity,severity)).lower()</span><br><span class="line">    destination=<span class="string">'common:%s:%s'</span>%(name,severity)</span><br><span class="line">    start_key=destination+<span class="string">':start'</span></span><br><span class="line">    pipe=conn.pipeline()</span><br><span class="line">    end = time.time()+timeout</span><br><span class="line">    <span class="keyword">while</span> time.time() &lt;end</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            pipe.watch(start_key)</span><br><span class="line">            now=datetime.utcnow().timetuple()</span><br><span class="line">            hour_start=datetime(*now[:<span class="number">4</span>]).isoformat()</span><br><span class="line">            existing=pipe.get(start_key)</span><br><span class="line">            pipe.multi() <span class="comment"># 创建一个事务</span></span><br><span class="line">            <span class="keyword">if</span> existing <span class="keyword">and</span> existing &lt; hour_start:</span><br><span class="line">                pipe.rename(destination,destination+<span class="string">':last'</span>)</span><br><span class="line">                pipe.rename(start_key,destination+<span class="string">':pstart'</span>)</span><br><span class="line">                pipe.set(start_key,hour_start)</span><br><span class="line">                <span class="comment"># 对日志出现的次数的计算器自增</span></span><br><span class="line">            pipe.zincrby(destination,message) </span><br><span class="line">            log_recent(pipe,name,message,severity,pipe)</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        <span class="keyword">except</span> redis.exceptions.WatchError:</span><br><span class="line">            <span class="comment"># 如果因为其它客户端正在执行归档而出现监视错误，就重试</span></span><br><span class="line">            <span class="keyword">continue</span></span><br></pre></td></tr></table></figure></p><h3><span id="案例二计数器和统计数据">案例二：计数器和统计数据</span></h3><p><strong>需求：</strong>为了收集指标数据并进行监视和分析，我们构建一个能够持续创建并维护计数器的工具，这个工具创建的每个计数器都有自己的名字。这些技术器以指定的精度存储指定的数据样本。<br><strong>分析：</strong> 为了记录点击量，我们使用了一个hash，它的名字为count:5:hit表示记录每5秒为一个时间断内的点击量，其中键为时间段，值为点击量。<br><img src="https://i.bmp.ovh/imgs/2019/10/35ccded437ce3269.png" alt></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">PRECISION=[<span class="number">1</span>,<span class="number">5</span>,<span class="number">60</span>,<span class="number">300</span>,<span class="number">3600</span>,<span class="number">16000</span>,<span class="number">86400</span>] <span class="comment"># 计数器精度</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">更新计数器</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">def update_counter();</span><br><span class="line">    now=now <span class="keyword">or</span> time.time()</span><br><span class="line">    <span class="comment"># 创建一个事务型流水线</span></span><br><span class="line">    pipe=conn.pipeline()</span><br><span class="line">    <span class="keyword">for</span> prec <span class="keyword">in</span> PRECISION</span><br><span class="line">        <span class="comment"># 获取当前时间片开始的时间 </span></span><br><span class="line">        pnow =int(npw/prec)*prec</span><br><span class="line">        hash=<span class="string">'%s:%s'</span>%(prec,name)</span><br><span class="line">        pipe.zadd(<span class="string">'known:'</span>,hash,<span class="number">0</span>)</span><br><span class="line">        pipe.hincrby(<span class="string">'count:'</span>+hash,pnow,count)</span><br><span class="line">    pipe.execute()</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">获得指定计数器中的内容</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_counter</span><span class="params">(conn,name,precision)</span>:</span></span><br><span class="line">    <span class="comment"># 获得取得存储计数器的键的名字 </span></span><br><span class="line">    hash=<span class="string">'%s:%s'</span>%(precision,name)</span><br><span class="line">    data=conn.hgetall(<span class="string">'count:'</span>+hash)</span><br><span class="line">    to_return=[]</span><br><span class="line">    <span class="keyword">for</span> key,value <span class="keyword">in</span> data.iteritems():</span><br><span class="line">        to_return.append(int(key),int(value)))</span><br><span class="line">    to_return.sort() <span class="comment"># 排序，对旧的样本排在前面</span></span><br><span class="line">    <span class="keyword">return</span> to_return</span><br><span class="line">    </span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">清理旧的计数器</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clean_counters</span><span class="params">()</span>:</span></span><br><span class="line">    pipe=conn.pipeline(<span class="literal">True</span>)</span><br><span class="line">    passes=<span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> QUIT:</span><br><span class="line">        start=time.time()</span><br><span class="line">        index=<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> index&lt;conn.zcard(<span class="string">'konw:'</span>):</span><br><span class="line">            hash=conn.zrange(<span class="string">'know:'</span>,index,index)</span><br><span class="line">            index+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> hash:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            hash=hash[<span class="number">0</span>]</span><br><span class="line">            prec=int(hash.partition(<span class="string">':'</span>)[<span class="number">0</span>]) <span class="comment">#获取计数器的精度</span></span><br><span class="line">            bprec=int(prec//<span class="number">60</span>) <span class="keyword">or</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> passes % bprec:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            hkey=<span class="string">'count:'</span>+hash</span><br><span class="line">            cotoff=time.time() -SAMPLE_COUNT*prec</span><br><span class="line">            samples=map(int.conn.hkeys(hkey))</span><br><span class="line">            samples.sort()</span><br><span class="line">            remove=bisect.bisect_right(samples,cutoff)</span><br><span class="line">            <span class="keyword">if</span> remove:</span><br><span class="line">                conn.hdel(hkey,*samples[:remove])</span><br><span class="line">                <span class="keyword">if</span> remove ==len(samples):</span><br><span class="line">                    <span class="keyword">try</span>:</span><br><span class="line">                        pipe.watch(hkey):</span><br><span class="line">                            pipe.multi()</span><br><span class="line">                            pipe.zrem(<span class="string">'know:'</span>,hash)</span><br><span class="line">                            pipe.execute()</span><br><span class="line">                            index=<span class="number">-1</span></span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            pipe.unwatch()</span><br><span class="line">                    <span class="keyword">except</span> redis.exceptions.WatchError:</span><br><span class="line">                        <span class="keyword">pass</span></span><br><span class="line">                passes+=<span class="number">1</span></span><br><span class="line">                duration=min(int(time.time()-start)+<span class="number">1</span>,<span class="number">60</span>)</span><br><span class="line">                time.sleep(max(<span class="number">60</span>-duration,<span class="number">1</span>))</span><br></pre></td></tr></table></figure><h2><span id="使用redis构建应用程序组件">使用Redis构建应用程序组件</span></h2><h3><span id="案例一自动补全最近联系人">案例一：自动补全最近联系人</span></h3><p>在web领域里，自动补全是一种能够让用户不进行搜索的情况下，就能快速找到所需东西的计数。自动补全一般会根据用户已输入的字母来查找所有已经输入字母为开头的单词。<br><strong>需求：</strong>实现一个用于记录最近练习人的自动补全程序。<br><strong>分析：</strong>构建最近练习人自动补全列表通常需要对Redis执行三个步骤：</p><ol><li>如果指定的联系人已经存在于最近联系人列表里面，那么从列表里面移除它。</li><li>将指定的联系人添加到最近联系人列表的最前面</li><li>将添加操作完成后，如果最近联系人列表包含的联系人数量超过了100个，那么对列表进行修剪，只保留位于列表前面的100个联系人。</li></ol><p><strong>实现方案：</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_update_contact</span><span class="params">(conn,user,contact)</span>:</span></span><br><span class="line">    ac_list=<span class="string">'recent:'</span>+user</span><br><span class="line">    pipeline=conn.pipeline(<span class="literal">True</span>)</span><br><span class="line">    pipeline=lrem(ac_list,contact) <span class="comment"># 如果该联系人存在，则移除它</span></span><br><span class="line">    pipeline.lpush(ac_list,contact) <span class="comment"># 将联系人推入列表最前端</span></span><br><span class="line">    pipeline.ltrim(ac_list,<span class="number">0</span>,<span class="number">99</span>) <span class="comment"># 只保留前面的100个联系人</span></span><br><span class="line">    pipeline.execute()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fetch_autocomplete_list</span><span class="params">(conn,user,prefix)</span>:</span></span><br><span class="line">    candidates=conn.lrange(<span class="string">'recent:'</span>+user,<span class="number">0</span>,<span class="number">-1</span>) <span class="comment"># 自动获取补全列表</span></span><br><span class="line">    matches=[]</span><br><span class="line">    <span class="keyword">for</span> candidate <span class="keyword">in</span> candidates:</span><br><span class="line">        <span class="keyword">if</span> candidate.lower().startswith(prefix):</span><br><span class="line">            matches.append(candidate)</span><br><span class="line">        <span class="keyword">return</span> matches <span class="number">3</span> 返回所有匹配到的联系人</span><br></pre></td></tr></table></figure></p><h3><span id="案例二分布式锁">案例二：分布式锁</span></h3><p>分布式锁会执行“先获取锁，然后执行操作，最后释放锁”动作。但是这种锁石油不同的机器上的不同的Redis客户端进行获取和释放的，</p><p><strong>需求：</strong>为了对Redis存储的数据进行排它性访问，客户端需要访问一个锁，这个锁必须定义在一个可以让所有客户端都看得到的范围之内，而这个范围就是Redis本身，因此我们需要将锁构建在Redis里面。</p><p><strong>简单的锁：</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">获取锁</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">acquire_lock</span><span class="params">(conn,lockname,acquire_timeout=<span class="number">10</span>)</span>:</span></span><br><span class="line">    identifier=srt(uuid.uuid4()) <span class="comment">#128位随机标识符</span></span><br><span class="line">    end=time.time()+acquire_timeout</span><br><span class="line">    <span class="keyword">while</span> time.time() &lt;end:</span><br><span class="line">        <span class="keyword">if</span> conn.setnx(<span class="string">'lock:'</span>+lockname,identifier): <span class="comment"># 尝试获得锁</span></span><br><span class="line">            <span class="keyword">return</span> identifier</span><br><span class="line">        time.sleep(<span class="number">.001</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure></p><p>它使用了SETNX命令，尝试在代表锁的键不存在的情况下，为键设置一个值，以此来获取锁。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">release_lock</span><span class="params">(conn,lockname,identifier)</span>:</span></span><br><span class="line">    pipe=conn.pipeline(<span class="literal">True</span>)</span><br><span class="line">    lockname=<span class="string">'lock:'</span>+lockname</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            pipe.watch(lockname)</span><br><span class="line">            <span class="comment"># 检查进程是否仍然持有锁</span></span><br><span class="line">            <span class="keyword">if</span> pipe.get(lockname) == identifier:</span><br><span class="line">                pipe.multi()</span><br><span class="line">                pipe.delete(lockname)</span><br><span class="line">                pipe.execute()</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            pipe.unwatch()</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># 有其它客户端修改了锁，重试</span></span><br><span class="line">        <span class="keyword">except</span> redis.exceptions.WatchError: </span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span> <span class="comment"># 进程已经失去了锁</span></span><br></pre></td></tr></table></figure><p>目前这种锁的实现方式，当锁的持有者崩溃后锁不会被自动释放，这回导致锁一直处于被获取的状态。</p><p><strong>带有超时限制的锁</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">acquire_lock</span><span class="params">(conn,lockname,acquire_timeout=<span class="number">10</span>,lock_timeout=<span class="number">10</span>)</span>:</span></span><br><span class="line">    identifier=srt(uuid.uuid4()) <span class="comment">#128位随机标识符</span></span><br><span class="line">    <span class="comment"># 确保传给EXPIRE的都是整数</span></span><br><span class="line">    lock_timeout=int(math.ceil(lock_timeout))</span><br><span class="line">    end=time.time()+acquire_timeout</span><br><span class="line">    <span class="keyword">while</span> time.time() &lt;end:</span><br><span class="line">        <span class="keyword">if</span> conn.setnx(<span class="string">'lock:'</span>+lockname,identifier): <span class="comment"># 尝试获得锁</span></span><br><span class="line">            conn.expire(lockname.lock_timeout)</span><br><span class="line">            <span class="keyword">return</span> identifier</span><br><span class="line">        elseif:</span><br><span class="line">            <span class="comment"># 检查过期时间，并在有需要的时候进行更新</span></span><br><span class="line">            conn.expire(lockname,lock_timeout)</span><br><span class="line">        time.sleep(<span class="number">.001</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure></p><h3><span id="案例三计数信号量">案例三：计数信号量</span></h3><p>计数信号量也是一种锁，它可以限制一项资源同时被多个进程访问，通常用于限定能够同时使用的资源数量。</p><p><strong>构建简单的计数信号量：</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">acquire_semaphore</span><span class="params">(conn,semname,limit,timeout=<span class="number">10</span>)</span>:</span></span><br><span class="line">    identifier=str(uuid.uuid4()) <span class="comment"># 128位随机标识符</span></span><br><span class="line">    now =time.time()</span><br><span class="line">    pipeline=conn.pipeline(<span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># 清理过期的信号量持有者</span></span><br><span class="line">    pipeline=zremrangebyscore(semname,<span class="string">'-inf'</span>,now-timeout)</span><br><span class="line">    pipeline=zadd(semname,identifier,now)</span><br><span class="line">    pipeline.zrank(semname,identifier)</span><br><span class="line">    <span class="keyword">if</span> pipeline.execute()[<span class="number">-1</span>]&lt;limit:</span><br><span class="line">        <span class="keyword">return</span> identifier</span><br><span class="line">    <span class="comment"># 获取信号量失败，删除之前添加的标识符</span></span><br><span class="line">    conn.zrem(semname,identifier) </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">release_semphore</span><span class="params">(conn,semname,identifier)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> conn.zrem(semname,identifier)</span><br></pre></td></tr></table></figure></p><p>这种信号量的实现存在一些问题，它假设假设每个进程访问到系统的时间都是相同的，而这一假设在多主机环境下可能并不成立。<br>每当锁或信号量因为系统时钟的细微不同而导致锁的获取结果出现剧烈变化时，这个锁或者信号量就是不公平的。不公平的锁或信号量可能会导致客户端永远无法获取到它原本应该得到的锁或信号量。</p><p><strong>公平信号量：</strong><br>为了尽可能地减少系统时间不一致带来的问题，我们需要给信号量实现添加一个计数器以及一个有序集合。其中，计数器通过持续地执行自增操作，创建一种类似于计时器的机制，确保最先对计数器执行自增操作的客户段能够获得信号量。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">acquire_fair_semaphore</span><span class="params">(conn, semname, limit, timeout=<span class="number">10</span>)</span>:</span></span><br><span class="line">    identifier = str(uuid.uuid4())                             </span><br><span class="line">    czset = semname + <span class="string">':owner'</span></span><br><span class="line">    ctr = semname + <span class="string">':counter'</span></span><br><span class="line">    now = time.time()</span><br><span class="line">    pipeline = conn.pipeline(<span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># 删除超时信号量</span></span><br><span class="line">    pipeline.zremrangebyscore(semname, <span class="string">'-inf'</span>, now - timeout)  </span><br><span class="line">    pipeline.zinterstore(czset, &#123;czset: <span class="number">1</span>, semname: <span class="number">0</span>&#125;) </span><br><span class="line">    <span class="comment"># 对计数器实现自增</span></span><br><span class="line">    pipeline.incr(ctr)                                         </span><br><span class="line">    counter = pipeline.execute()[<span class="number">-1</span>]   </span><br><span class="line">    <span class="comment"># 尝试获取信号量</span></span><br><span class="line">    pipeline.zadd(semname, &#123;identifier: now&#125;)                  </span><br><span class="line">    pipeline.zadd(czset, &#123;identifier: counter&#125;)                </span><br><span class="line">    pipeline.zrank(czset, identifier)                          </span><br><span class="line">    <span class="keyword">if</span> pipeline.execute()[<span class="number">-1</span>] &lt; limit:                         </span><br><span class="line">        <span class="keyword">return</span> identifier                                      </span><br><span class="line">    pipeline.zrem(semname, identifier)                         </span><br><span class="line">    pipeline.zrem(czset, identifier)                           </span><br><span class="line">    pipeline.execute()</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">释放公平锁</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">release_fair_semaphore</span><span class="params">(conn, semname, identifier)</span>:</span></span><br><span class="line">    pipeline = conn.pipeline(<span class="literal">True</span>)</span><br><span class="line">    pipeline.zrem(semname, identifier)</span><br><span class="line">    pipeline.zrem(semname + <span class="string">':owner'</span>, identifier)</span><br><span class="line">    <span class="keyword">return</span> pipeline.execute()[<span class="number">0</span>]</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">刷新信号量</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">refresh_fair_semaphore</span><span class="params">(conn,semname,identifier)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> conn.zadd(semname,identifier,time.time()):</span><br><span class="line">        release_fair_semaphore(conn,semname,identifier)</span><br><span class="line">        <span class="keyword">return</span> Flase</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">acquire_semaphore_with_lock():</span><br><span class="line">    identifier=acquire_lock(conn,semname,acquire_timeout=<span class="number">.01</span>)</span><br><span class="line">    <span class="keyword">if</span> identifier:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> acquire_fair_semaphore(conn,semname,limit,timeout)</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            release_lock(conn,semname,identifier)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;使用Redis构建支持程序&quot;&gt;&lt;a href=&quot;#使用Redis构建支持程序&quot; class=&quot;headerlink&quot; title=&quot;使用Redis构建支持程序&quot;&gt;&lt;/a&gt;使用Redis构建支持程序&lt;/h2&gt;&lt;h3 id=&quot;案例一：-使用Redis实现日志的记录&quot;&gt;&lt;a href=&quot;#案例一：-使用Redis实现日志的记录&quot; class=&quot;headerlink&quot; title=&quot;案例一： 使用Redis实现日志的记录&quot;&gt;&lt;/a&gt;案例一： 使用Redis实现日志的记录&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;需求：&lt;/strong&gt; 在构建应用程序和服务的过程中，对正在运行的系统的相关信息进行挖掘变得越来越重要。这都依赖于日志。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分析：&lt;/strong&gt; 许多日志的记录的方式都是将日志记录到文件中去，然后随着时间的流逝新建日志文件（因为日志文件大大小不可能无限的增长），因为每个服务都有相应的日志记录，并且每种服务的日志轮换机制也是不同的，这就会缺少了一种将这些日志聚合的方案。&lt;br&gt;还有一种日志记录方式是利用syslog服务来进行日志的记录。syslog服务接收各个服务的日志信息，并路由到不同的磁盘上，它还负责日志的轮换和删除工作。它要比直接写文件方便的多。&lt;/p&gt;
&lt;p&gt;我们也可以利用Redis来实现日志的记录。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实现方式：&lt;/strong&gt;&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;SEVERITY=&amp;#123;   &lt;span class=&quot;comment&quot;&gt;# 设置一个字典，将日志的安全级别映射为字符串&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    loggin.DEBUG:&lt;span class=&quot;string&quot;&gt;&#39;debug&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    loggin.INFO：&lt;span class=&quot;string&quot;&gt;&#39;info&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    loggin.WARNING:&lt;span class=&quot;string&quot;&gt;&#39;warning&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    loggin.ERROR:&lt;span class=&quot;string&quot;&gt;&#39;error&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    loggin.CRITICAL:&lt;span class=&quot;string&quot;&gt;&#39;critical&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SERVERITY.update((name,name) &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; name &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; SERVERITY.values())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;log_recent&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(conn,name,message,severity=loggin.INFO,pipe=None)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;# 将日志的安全级别映射为简单的字符串&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    severity=str(SEVERITY.get(severity,severity)).lower() &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;# 创建负责存储消息的键&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    destination=&lt;span class=&quot;string&quot;&gt;&#39;recent:%s:%s&#39;&lt;/span&gt;%(name,severity)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;# 在消息中添加当前时间&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    message=time.asctime()+&lt;span class=&quot;string&quot;&gt;&#39; &#39;&lt;/span&gt;+message&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;# 使用流水线通信方式&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    pipe=pipe &lt;span class=&quot;keyword&quot;&gt;or&lt;/span&gt; conn.pipeline()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    pipe=lpush(destination,message)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;# 对日志列表进行修剪，只保留100条消息&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    pipe.ltrim(destination,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;99&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;# 执行两个命令&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    pipe.execute()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis实战学习笔记一</title>
    <link href="http://yoursite.com/2019/10/21/Redis%E5%AE%9E%E6%88%98%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/"/>
    <id>http://yoursite.com/2019/10/21/Redis实战学习笔记一/</id>
    <published>2019-10-21T08:39:56.000Z</published>
    <updated>2019-10-21T08:39:25.865Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="初识redis">初识Redis</span></h2><p>Redis是一个远程内存数据库。它是一个速度非常快的非关系型内存数据库。它可以存储键到五种类型的映射。并且可以将存储到内存中的数据持久化到磁盘。并且可以使用复制特性来提高读性能，使用客户端分片来提高写性能/</p><h3><span id="redis的独到之处">Redis的独到之处</span></h3><p>Redis不同于我们常用的MySQL数据库的一个特性是它是非关系型数据库。简单的讲就是不会使用表。</p><p>它和memcached的一大不同之处在于它支持多种不同的数据类型，而memcached只支持字符串键。</p><p>Redis还有一个独特之处在于它是内存数据库。因为内存是易失性存储，所以不得不考虑持久化的问题。Redis的持久化提供了两种方案，一种是时间点转储，第二种方案就是将所有<strong>修改了数据库</strong>的命令写入一个只追加的文件中，根据用户的设置可以选择从不同步、每秒同步一次或者没写入一个命令就同步一次。</p><a id="more"></a><p><img src="https://s2.ax1x.com/2019/10/14/KpabTA.png" alt="KpabTA.png"></p><h3><span id="redis的用法">Redis的用法</span></h3><p>Redis的数据结构<br><img src="https://s2.ax1x.com/2019/10/17/KkbVAK.png" alt="KkbVAK.png"></p><ol><li><p>string<br><img src="https://s2.ax1x.com/2019/10/17/Kkb4D1.png" alt="Kkb4D1.png"></p></li><li><p>list<br>一个列表可以有序的存储多个字符串。<br><a href="https://imgchr.com/i/KkXbdI" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/10/17/KkXbdI.png" alt="KkXbdI.png"></a></p></li><li>集合 set<br>集合通过散列表来确保自己存储的每个字符串都是各不相同的。Redis的集合使用无序方式存储元素。<br><img src="https://s2.ax1x.com/2019/10/17/KkvjKg.png" alt="KkvjKg.png"></li><li>hash<br>Redis的散列可以存储多个键值对之间的映射。和字符串一样散列存储的既可以是字符串又可以是数字值，并且用户同样可以对散列存储的数字执行自增或自减操作。<br><img src="https://s2.ax1x.com/2019/10/17/Kkx1xO.png" alt="Kkx1xO.png"></li><li>Redis有序结合 zset<br>有序集合的键被称为成员，每个成员都是不同的。有序集合的值被称为分值。<br><img src="https://s2.ax1x.com/2019/10/17/KkxrQS.png" alt="KkxrQS.png"></li></ol><h2><span id="使用redis构建web应用">使用Redis构建web应用</span></h2><h3><span id="登录和cookie缓存">登录和cookie缓存</span></h3><p>在我们登录互联网服务的时候，这些服务都会使用cookie来记录我们的身份，cookie由少量数据组成，网站会要求我们在之后的每次请求中携带cookie数据。对于用来登录的cookie，有两种常用的方法可以将登录信息存储在cookie中，一种是签名（signed）cookie，另一种是（token）cookie。</p><p>我们可以使用Redis来重新实现登录cookie功能。我们使用一个散列表来存储登录cookie令牌与已登录用户之间的映射。要检查一个用户是否已经登录，需要根据给定的令牌来查找与之对应的用户，并在用户已经登陆的情况下，返回该用户的ID。</p><h4><span id="实战">实战：</span></h4><p><strong>案例一：</strong><br><strong>需求</strong>：<br>现在有一个大型的网上商城，每天用户会有大概一亿次点击，并从网站上购买10万多件商品。我们要管理用户的登录会话，并记录用户最近访问的商品。<br><strong>解决方案：</strong><br>首先使用一个hash来存储用户的cookie和已登录用户之间的映射，实现那对登录会话的管理。至于记录用户最近浏览的商品，我们可以先计算一下负载，平均每秒需要写入1200次，高峰时期需要写入6000次，如果使用关系型数据库来记录是非常的困难的，因为一台关系型数据库每秒大概能处理200-2000个插入请求。所以我们可以考虑使用吞吐率极大的Redis来存储这些浏览记录。</p><p>用到了哪些数据结构：</p><ol><li>一个名为<code>login：</code>的哈希表，其中键为用户的令牌，值为用户信息</li><li>一个名为<code>recent:</code>的有序集合，其中成员为用户的token，分数为用户最后一次登录的时间戳</li><li>一组名为<code>viewed:</code>+token的有序集合，其中成员为该用户浏览过的商品信息，分数为时间戳<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用于检查登录cookie的方法，尝试获取比并返回令牌对应的用户</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_token</span><span class="params">(conn,token)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> conn.hget(<span class="string">'login:'</span>,token) <span class="comment"># 尝试获取比并返回令牌对应的用户</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用于记录用户的浏览记录，维持登录用户与令牌的关系</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_token</span><span class="params">(conn,token,user,item=None)</span>:</span></span><br><span class="line">    timestamp=time.time() <span class="comment"># 获取当前的时间戳</span></span><br><span class="line">    conn.hset(<span class="string">'login:'</span>,token,user) <span class="comment"># 维持令牌与已登录用户之间的映射（哈希）</span></span><br><span class="line">    conn.zadd(<span class="string">'recent:'</span>,token,timestamp) <span class="comment"># 记录令牌最后一次出现的时间 （有序集合）</span></span><br><span class="line">    <span class="keyword">if</span> item:</span><br><span class="line">        conn.zadd(<span class="string">'viewed:'</span>+token,item,timestamp) <span class="comment"># 记录用户浏览过的商品</span></span><br><span class="line">        conn.zremrangebyrank(<span class="string">'viewed:'</span>+token,<span class="number">0</span>,<span class="number">-26</span>) <span class="comment"># 移除旧的记录，只保留26各记录</span></span><br></pre></td></tr></table></figure></li></ol><p>因为存储的会话数据会随着时间的推移而不断地增多，所以我需要定时地清理一些会话数据。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">QUIT = <span class="literal">False</span></span><br><span class="line">LIMIT = <span class="number">10000000</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clean_session</span><span class="params">(conn)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> QUIT:</span><br><span class="line">        size=conn.zcard(<span class="string">'recent:'</span>)</span><br><span class="line">        <span class="keyword">if</span> size &lt;= LIMIT: <span class="comment"># 在令牌数量未达到限制之前一直休眠</span></span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        end_index=min(size-LIMIT,<span class="number">100</span>)</span><br><span class="line">        tokens=conn.zrange(<span class="string">'recent:,0,end_index-1) # 获取需要移除地令牌的ID</span></span><br><span class="line"><span class="string">        session_key=[]</span></span><br><span class="line"><span class="string">        for token in tokens:</span></span><br><span class="line"><span class="string">            session_keys.append('</span>view:<span class="string">'+token) # 构建待删除的列表</span></span><br><span class="line"><span class="string">        conn.delete(*session_keys)</span></span><br><span class="line"><span class="string">        conn.hdel('</span>login:<span class="string">',*tokens) # 移除那些最旧的令牌</span></span><br><span class="line"><span class="string">        conn.zrem('</span>recent:<span class="string">',*tokens)</span></span><br></pre></td></tr></table></figure></p><p>其实<code>clean_session</code>这个行数存在竞争条件的，如果正在清理用户信息的同时，用户登录了，那么这个用户就得重新登录了，因为它刚刚记录的登录信息会被清除掉。</p><hr><p><strong>案例2</strong><br><strong>需求</strong><br>使用Redis实现购物车<br><strong>解决方案</strong><br>每个用户的购物车都是一个散列，这个散列存储了商品ID与商品订购数量之间的映射。我们还需要对商品的数量变动进行维护。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_to_cart</span><span class="params">(conn,session,item,count)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> count &lt;= <span class="number">0</span>:</span><br><span class="line">        conn.hrem(<span class="string">'cart:'</span>+session,item) <span class="comment"># 如果数量商品小于0了就移除</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        conn.hset(<span class="string">'cart:+session,item,count) # 将指定的商品添加到购物车中</span></span><br></pre></td></tr></table></figure></p><p>我们需要改造之前的会话清理函数，在清理用户会话的时候，将其购物车也一并清理。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clean_session</span><span class="params">(conn)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> QUIT:</span><br><span class="line">        size=conn.zcard(<span class="string">'recent:'</span>)</span><br><span class="line">        <span class="keyword">if</span> size &lt;= LIMIT: <span class="comment"># 在令牌数量未达到限制之前一直休眠</span></span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        end_index=min(size-LIMIT,<span class="number">100</span>)</span><br><span class="line">        sessions=conn.zrange(<span class="string">'recent:,0,end_index-1) # 获取需要移除地令牌的ID</span></span><br><span class="line"><span class="string">        session_key=[]</span></span><br><span class="line"><span class="string">        for session in sessions:</span></span><br><span class="line"><span class="string">            session_keys.append('</span>view:<span class="string">'+session) # 构建待删除的列表</span></span><br><span class="line"><span class="string">            seesion_keys.append('</span>cart:<span class="string">'+session)</span></span><br><span class="line"><span class="string">        conn.delete(*session_keys)</span></span><br><span class="line"><span class="string">        conn.hdel('</span>login:<span class="string">',*sessions) # 移除那些最旧的令牌</span></span><br><span class="line"><span class="string">        conn.zrem('</span>recent:<span class="string">',*sessions)</span></span><br></pre></td></tr></table></figure></p><h3><span id="网页缓存">网页缓存</span></h3><p>在动态生成网页的时候，通常会使用模板语言来简化网页的生成，其实网页不必每次都重新生成，因为变化的网页只是极少数。我们可以将这些不变的网页缓存起来，下次需要使用的时候直接使用即可。</p><p><strong>案例一</strong><br><strong>需求：</strong><br>将可悲缓存的网页缓存起来，避免没有必要的重复动态生成。从而减少载入不常改变的页面所需的时间。<br><strong>解决方案</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cache_request</span><span class="params">(conn.request,callback)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> can_cache(conn,request):</span><br><span class="line">        <span class="keyword">return</span> callback(request) <span class="comment"># 对于不能缓存的请求，直接调用回调函数</span></span><br><span class="line">    page_key=<span class="string">'cache:'</span>+hash_request(request)</span><br><span class="line">    content=conn.get(page_key) <span class="comment"># 尝试查找被缓存的页面</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> content:</span><br><span class="line">        content=callback(request) <span class="comment"># 没有被缓存就生成页面</span></span><br><span class="line">        conn.setex(page_key,content,<span class="number">300</span>) <span class="comment"># 缓存生成的页面</span></span><br><span class="line">    <span class="keyword">return</span> content <span class="comment"># 返回页面</span></span><br></pre></td></tr></table></figure></p><h3><span id="缓存行数据">缓存行数据</span></h3><p>一些页面也被我们缓存起来了，比如商品界面每次需要从数据库中载入一两行数据。程序可以通过缓存页面载入时所需的数据库行来减少载入页面所需的时间。</p><p><strong>案例一</strong><br><strong>需求</strong><br>假设一个商城为了清空库存和吸引消费者决定开始新一轮的促销活动，每天都会提供一些特价商品，所以商品的数量都是有限的，售完即止。<br><strong>解决方案</strong><br>在这种情况下，我们是不能对整个页面进行缓存的，否则用户可能看到错误的剩余数量。但是如果，每次载入数据都从数据库中取得话，又会给数据库带来巨大得压力。<br>我们可以使用一个守护进程函数，将指定得数据行缓存到Redis里面，并不定期得对这些缓存进行更新。缓存得数据以JSON格式进行编码。</p><p>使用的数据结构；</p><ol><li>一个名为schedule的有序集合，其中成员为数据行的行ID，分值为缓存该数据行的时间戳。</li><li>一个名为delay的有序集合，其中成员为数据行的行ID，分值为所缓存的数据行，需要多久更新一次。</li><li>一组名为<code>inv:</code>+row_id的集合，其中存储的是以JSON格式保存的行数据</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">schedule_row_cache</span><span class="params">(conn,row_id,delay)</span>:</span></span><br><span class="line">    conn.zadd(<span class="string">'delay:'</span>,row_id,delay)</span><br><span class="line">    conn.zadd(<span class="string">'schedule:'</span>,row_id,time.time())</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cache_rows</span><span class="params">(conn)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> QUIT:</span><br><span class="line">        next =conn.zrange(<span class="string">'schedule:'</span>,<span class="number">0</span>,<span class="number">0</span>,withscores=Ture)</span><br><span class="line">        now=time.time()</span><br><span class="line">        <span class="keyword">if</span>  <span class="keyword">not</span> next <span class="keyword">or</span> next[<span class="number">0</span>][<span class="number">1</span>] &gt;now</span><br><span class="line">            time.sleep(<span class="number">0.05</span>)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        row_id =next[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">            delay=conn.zscore(<span class="string">'delay:'</span>,row_id)</span><br><span class="line">            <span class="keyword">if</span> delay&lt;=<span class="number">0</span> <span class="comment"># 如果延迟时间为小于等于0则不必再缓存了</span></span><br><span class="line">                conn.zrem(<span class="string">'delay:'</span>,row_id)</span><br><span class="line">                conn.zrem(<span class="string">'schedule'</span>,row_id)</span><br><span class="line">                conn.delete(<span class="string">'inv:'</span>+row_id)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            row =Inventory.get(row_id) <span class="comment"># 读取数据行</span></span><br><span class="line">            conn.zadd(<span class="string">'schedule:'</span>,row_id,now+delay)</span><br><span class="line">            conn.set(<span class="string">'inv:'</span>+row_id,json.dumps(row.to_dict())) <span class="comment">#缓存行数据</span></span><br></pre></td></tr></table></figure><h3><span id="网页分析">网页分析</span></h3><p>我们是不可能将所有的页面都缓存起来的，所以我们需要挑选用户经常访问的页面。为此，我们可以修改之前记录用户浏览记录的函数，来统计最经常被浏览的一批商品，然后我们再缓存它。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用于记录用户的浏览记录，维持登录用户与令牌的关系</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_token</span><span class="params">(conn,token,user,item=None)</span>:</span></span><br><span class="line">    timestamp=time.time() <span class="comment"># 获取当前的时间戳</span></span><br><span class="line">    conn.hset(<span class="string">'login:'</span>,token,user) <span class="comment"># 维持令牌与已登录用户之间的映射（哈希）</span></span><br><span class="line">    conn.zadd(<span class="string">'recent:'</span>,token,timestamp) <span class="comment"># 记录令牌最后一次出现的时间 （有序集合）</span></span><br><span class="line">    <span class="keyword">if</span> item:</span><br><span class="line">        conn.zadd(<span class="string">'viewed:'</span>+token,item,timestamp) <span class="comment"># 记录用户浏览过的商品</span></span><br><span class="line">        conn.zremrangebyrank(<span class="string">'viewed:'</span>+token,<span class="number">0</span>,<span class="number">-26</span>) <span class="comment"># 移除旧的记录，只保留26各记录</span></span><br><span class="line">        conn.zincrby(<span class="string">'viewed:'</span>,item,<span class="number">-1</span>) <span class="comment"># 新添加的代码</span></span><br></pre></td></tr></table></figure></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定期维护浏览次数排行榜</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rescake_viewed</span><span class="params">(conn)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> QUIT:</span><br><span class="line">        conn.zremrangebyrank(<span class="string">'viewed:'</span>,<span class="number">0</span>,<span class="number">-20001</span>) <span class="comment"># 删除排名在20000名之后的商品</span></span><br><span class="line">        conn.zinterstore(<span class="string">'viewd:'</span>,&#123;<span class="string">'viewed:'</span>:<span class="number">.5</span>&#125;) <span class="comment"># 将浏览次数降低为原来的一半</span></span><br><span class="line">        time.sleep(<span class="number">300</span>) <span class="comment"># 5分钟之后再次执行这个操作</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">can_cache</span><span class="params">()</span>:</span></span><br><span class="line">    item_id=extract_item_id(request)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> item_id <span class="keyword">or</span> is_dynamic(request):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    rank=conn.zrank(<span class="string">'viewed:'</span>,item_id)</span><br><span class="line">    <span class="keyword">return</span> rank <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> rank &lt;<span class="number">10000</span> <span class="comment"># 只有排名在10000名之前的才能被缓存</span></span><br></pre></td></tr></table></figure><h2><span id="redis核心概念">Redis核心概念</span></h2><h3><span id="redis命令">Redis命令</span></h3><h4><span id="字符串">字符串</span></h4><p>Redis的字符串就是一个由字节组成的序列，它可以存储一下3中类型的值：</p><ol><li>字符串</li><li>整数</li><li>浮点数<br>Redis可以对存储的整数或浮点数进行自增或自减操作。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">incr key-name //将键存储的值加一</span><br><span class="line">decr key-name //将键存储的值减一</span><br><span class="line">incrby key-name amount //将键存储的值加上整数amount</span><br><span class="line">decrby key-name amount //将键存储的值减去整数amount</span><br><span class="line">incrbyfloat key-name amount //键键存储的值加上浮点数</span><br></pre></td></tr></table></figure><p><strong>如果对一个不存在的键或者空串进行自增，自减操作的话，会按这个键值为0进行处理；如果进行操作的键的值不能被解释为整数或者浮点数的时候会报错</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">append key-name value //将值追加到给定键key-name当前存储的值的末尾</span><br><span class="line">getrange key-name start end //获取一个由偏移量start至end范围内所有字符组成的子串</span><br><span class="line">setrange key-name offset value //键从start偏移量开始的子串设置为给定值</span><br><span class="line">getbit key-name offset //将字节串看作是二进制位串，并返回位串中便宜量位offset的二进制位的值</span><br><span class="line">setbit setbit key-name offset value //将字符串看作是二进制位串，并将位串中偏移量位offset的二进制位的值设置位value</span><br><span class="line">bitcount key-name [start end] // 统计二进制位串中值位1的二进制位的数量</span><br><span class="line">bittop operation dest-key key-name [key-name ...] //对一个或多个二进制位串执行包括并，或、异或、非在内的任意一种按位运算操作，并将计算的得出的结果保存到dest-key键里面。</span><br></pre></td></tr></table></figure></p><h4><span id="列表">列表</span></h4><p>Redis的列表允许用户从序列的两端推入或弹出元素，获取列表元素，以及执行各种常见额列表操作。<br><a href="https://imgchr.com/i/Knf2wt" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/10/19/Knf2wt.png" alt="Knf2wt.png"></a></p><p>阻塞执行的命令：<br><img src="https://s2.ax1x.com/2019/10/19/KnhepD.png" alt="KnhepD.png"><br>列表的一个主要优点在于它可以包含多个字符串值，这使得用户可以键数据集中的同一个地方。</p><h4><span id="集合">集合</span></h4><p>Redis集合以无序的方式来存储多个各部相同的元素，用户可以快速的对集合执行添加元素操作，移除元素操作以及检查一个元素是否存在于集合里。</p><p><img src="https://s2.ax1x.com/2019/10/20/KMwNS1.png" alt="KMwNS1.png"></p><h4><span id="散列">散列</span></h4><p>Redis的散列可以让用户将多个键值对存储到一个Redis键里面。</p><p><img src="https://s2.ax1x.com/2019/10/20/KMBSDf.png" alt="KMBSDf.png"></p><p><img src="https://s2.ax1x.com/2019/10/20/KMDv0f.png" alt="KMDv0f.png"></p><h4><span id="有序集合">有序集合</span></h4><p>有序集合也存储着成员与分值之间的映射，并且提供了分值处理命令，以及根据分值大小有序地获取或扫描成员和分值地命令。</p><p><img src="https://s2.ax1x.com/2019/10/20/KMrf3j.png" alt="KMrf3j.png"></p><p><img src="https://s2.ax1x.com/2019/10/20/KMsozd.png" alt="KMsozd.png"></p><h4><span id="发布与订阅">发布与订阅</span></h4><p>发布与订阅地特定是订阅者负责订阅频道，发送者负责向频道发送二进制字符串消息。每当有消息被发送至给定频道时，频道地所有订阅者都会收到消息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">subscribe channel [channel...] //订阅给定的一个或多个频道</span><br><span class="line">unsubscribe [channle [channel...] ] //退订给定的一个或多个频道</span><br><span class="line">publish channel message //向给定频道发送消息</span><br><span class="line">psubscribe pattern [pattern ...] //订阅与给定模式相匹配的所有频道</span><br><span class="line">punsubscribh [pattern [pattern ...]] //退订给定的模式，如果执行时没有给定的任何模式，那么会退订所有模式</span><br></pre></td></tr></table></figure></p><h4><span id="redis事务">Redis事务</span></h4><p>Redis的基本事务需要用到MULTI命令和EXEC事务，这种事务可以让一个客户端在不被其它客户端打断的情况执行多个命令。<strong>被MULTI和EXEC包裹的命令会一条接着一条的执行，不会被其它命令打断</strong>。</p><h4><span id="键的过期时间">键的过期时间</span></h4><p>可以通过Redis的过期时间特性来让一个键在给定的时限之后自动被删除。<br><img src="https://s2.ax1x.com/2019/10/20/KM2BvQ.png" alt="KM2BvQ.png"></p><h2><span id="数据安全与性能保障">数据安全与性能保障</span></h2><h3><span id="持久化选项">持久化选项</span></h3><p>Redis提供了两种方案来实现数据的持久化，一种是<strong>快照</strong>，它可以将存在某一时刻的所有数据都写入磁盘。另一种方法叫做<strong>只追加文件*</strong>，他会在执行写命令时，键被执行的写命令复制到硬盘里面。</p><h3><span id="快照持久化">快照持久化</span></h3><p>Redis可以通过创造快照来获得存储在内存里面的数据子啊某个时间点上的副本。可以利用创建的快照进行数据的备份和创建具有相同数据的服务器。<br>创建快照的方法：</p><ol><li>通过向Redis发送BGSAVE命令，Redis会调用fork来创建一个子进程，然后子进程负责将快照写入硬盘，而父进程继续处理请求。</li><li>通过向Redis发送SAVE命令，在创建完快照之前将不再响应任何其它命令。</li><li>用户设置的save配置选项，如save 60 10000 ，从最近一次创建快照算起，达到60秒内插入10000次写入，这个条件被满足时，Redis会自动触发BGSAVE命令。</li><li>当Redis接收到SHUTDOWN命令接收到关闭服务器的请求时，或收到标准TERM信号时，会执行一个SAVE命令，阻塞所有客户端。</li><li>当一个Redis服务器连接到另一个Redis服务器的时候，并向对方发送SYNC命令来开始一次复制的时候，那么主服务器会执行BGSAVE命令。</li></ol><p>随着Redis所占用内存的大小的增加，其创建用于生成的快照的子进程的时间也会增加。但总的来所，Redis创建快照是非常的快的，一般以毫秒为单位。</p><h3><span id="aof持久化">AOF持久化</span></h3><p>AOF持久化就是将执行过的命令追加到AOF文件末尾，以此来实现数据变化的记录。因此Redis只需要从头到尾的执行以便AOF文件中的所有写命令，就能恢复，AOF所记录的数据集。</p><p><strong>文件同步：写文件的时候会调用操作系统的write()方法，写入的内容首先会被存放在缓冲区内，然后在之后的某个时刻，操作系统会把缓冲区内的数据写入到磁盘文件中，只有当数据写入到磁盘文件才，完成了数据的真正持久化，我们可以使用flush()方法来强制将缓冲区中的内容写入磁盘。</strong></p><p>同步选项<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">always //每个Redis命令写入都要同步磁盘</span><br><span class="line">ererysec //每秒执行一次同步，显示的将多个命令同步到硬盘</span><br><span class="line">no //让操作系统来决定什么时候同步</span><br></pre></td></tr></table></figure></p><p>同步的越频繁，写入性能越低，数据安全性越高，系统发生崩溃时丢失的数据越少。凡之亦然。</p><p>AOF持久化有一个非常致命的缺陷，那就是AOF文件的体积。</p><p>因为Redis会不断的向AOF文件中写入命令，这会导致文件的体积不断地增大。为了解决这个问题可以这样：</p><ol><li>使用BGREWRIEAOF命令可以通过移除APF中地冗余命令来重写AOF文件。它地工作原理和BGSAVE命令类似，也是使用子进程来完成。AOF持久化也可以通过哦设置auto-aof-rewrite-percentage选项和auto-aof-rewrite-min-size选项来自动执行BGREWRITEAOF.</li></ol><h2><span id="复制">复制</span></h2><p>复制可以让其它服务器拥有一个不断更新地数据副本，可以使得拥有数据副本地服务器可以处理客户端发送地读请求。Redis可以采用主从复制的策略。</p><p>当设置好主从复制之后，当客户端向主服务器进行写入时，从服务器都会实时的得到更新，这样客户端就可以向任意一各服务器发送读请求了。</p><h3><span id="redis复制的启动过程">Redis复制的启动过程</span></h3><p>因为redis服务器在连接之前需要执行BGSAVE命令，所以要提前设置好dir选项和dbfilename选项。对于从服务器必要要使用<code>SLAVEOF host port</code> 命令来让服务器开始复制一个新的主服务器。</p><p><img src="https://i.bmp.ovh/imgs/2019/10/dc36857f1e83df53.png" alt><br>Redis在复制期间也会尽可能地处理接收到地命令请求，但是如果主从服务器之间地带宽不足，或主服务器没有足够地内容来创建子进程和记录写命令地缓冲区，那么Reids处理命令地请求效率就会受到影响。</p><p><strong>从服务器在进行同步时，会丢弃自己之前地数据</strong><br><strong>Redis不支持主主复制</strong></p><p>当一个新地从服务器连接到已有地主服务器时，有时可以重用已有地快照文件。<br><img src="https://i.bmp.ovh/imgs/2019/10/18226cb39a1043d8.png" alt></p><p>因为从服务器和主服务器并没有什么特别地差距，所以从服务器也可以拥有自己地从服务器，并由此形成主从链。</p><p>从服务器从从服务器进行复制和从服务器从主服务器进行复制地区别在于：<br>假如从服务器X有从服务器Y<br>从服务器X在执行对快照文件的解释的时候，会断开它与从服务器Y之间的连接。</p><h2><span id="redis事务">Redis事务</span></h2><p>Redis中可以简单的使用MULTI和EXEC命令来处理一段互相一致的读操作和写操作。<br>在执行EXEC命令之前系统是不会执行任何操作的，这使得用户无法根据读取到的数据来做决定。而且在多个事务同时处理一个对象的时候通常需要二阶提交，所以如果事务不能以一致的形式读取数据，那么二阶提交将无法实现。</p><p><strong>因为对数据进行加锁，会造成长时间的等待，所以Redis会尽可能地减少客户端地等待时间，并不会在执行WATCH命令时进行加锁，相反地，Redis会在数据被其它客户端抢先修改了的情况下，通知执行WATCH操作的客户端，这种被称为乐观锁，而关系数据库实际执行的加锁操作被称为被guan</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;初识Redis&quot;&gt;&lt;a href=&quot;#初识Redis&quot; class=&quot;headerlink&quot; title=&quot;初识Redis&quot;&gt;&lt;/a&gt;初识Redis&lt;/h2&gt;&lt;p&gt;Redis是一个远程内存数据库。它是一个速度非常快的非关系型内存数据库。它可以存储键到五种类型的映射。并且可以将存储到内存中的数据持久化到磁盘。并且可以使用复制特性来提高读性能，使用客户端分片来提高写性能/&lt;/p&gt;
&lt;h3 id=&quot;Redis的独到之处&quot;&gt;&lt;a href=&quot;#Redis的独到之处&quot; class=&quot;headerlink&quot; title=&quot;Redis的独到之处&quot;&gt;&lt;/a&gt;Redis的独到之处&lt;/h3&gt;&lt;p&gt;Redis不同于我们常用的MySQL数据库的一个特性是它是非关系型数据库。简单的讲就是不会使用表。&lt;/p&gt;
&lt;p&gt;它和memcached的一大不同之处在于它支持多种不同的数据类型，而memcached只支持字符串键。&lt;/p&gt;
&lt;p&gt;Redis还有一个独特之处在于它是内存数据库。因为内存是易失性存储，所以不得不考虑持久化的问题。Redis的持久化提供了两种方案，一种是时间点转储，第二种方案就是将所有&lt;strong&gt;修改了数据库&lt;/strong&gt;的命令写入一个只追加的文件中，根据用户的设置可以选择从不同步、每秒同步一次或者没写入一个命令就同步一次。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud学习笔记三</title>
    <link href="http://yoursite.com/2019/10/19/SpringCloud%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89/"/>
    <id>http://yoursite.com/2019/10/19/SpringCloud学习笔记三/</id>
    <published>2019-10-19T06:59:56.000Z</published>
    <updated>2019-10-19T07:00:04.908Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="分布式配置中心-spring-cloud-config">分布式配置中心 Spring cloud config</span></h2><p>spring cloud config 是用来为分布式系统中的基础设施和微服务应用提供集中化的外部配置支持，它分为服务端和客户端，其中服务端被称为分布式配置中心，它是一个独立的微服务应用，用来链接仓库，并为客户端提供配置信息。</p><h3><span id="快速入门">快速入门</span></h3><h4><span id="搭建配置中心">搭建配置中心</span></h4><ol><li><p>创建工程，导入相关依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>在主程序类中开启sprong cloud config的服务端功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableConfigServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigServerApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ConfigServerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><a id="more"></a><ol start="3"><li><p>添加配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: config-service</span><br><span class="line">  cloud:</span><br><span class="line">    config:</span><br><span class="line">      server:</span><br><span class="line">        git:</span><br><span class="line">          uri: https://github.com/zofun/spring-cloud-config.git # 仓库的位置</span><br><span class="line">          username: </span><br><span class="line">          password: </span><br><span class="line">          search-paths: test/config-repo</span><br><span class="line">server:</span><br><span class="line">  port: 8090</span><br></pre></td></tr></table></figure></li><li><p>上传配置文件到GitHub仓库的test/config-repo目录下</p></li><li>通过url范围获取配置文件/{application}-{profile}.yml</li></ol><h4><span id="搭建spring-cooud-config客户端">搭建spring cooud config客户端</span></h4><ol><li><p>创建spring boot应用并添加相关依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>创建配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: didispace</span><br><span class="line">  cloud:</span><br><span class="line">    config:</span><br><span class="line">      profile: dev</span><br><span class="line">      label: master</span><br><span class="line">      uri: http://localhost:8090/</span><br><span class="line">server:</span><br><span class="line">  port: 7002</span><br></pre></td></tr></table></figure></li><li><p>写一个用来测试的RESTful接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RefreshScope</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;from&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String from;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/from"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">from</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> from;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3><span id="服务化配置中心">服务化配置中心</span></h3><h4><span id="服务端配置">服务端配置</span></h4><ol><li><p>在config-server中添加eureka相关的依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>配置相关参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    serviceUrl:</span><br><span class="line">      defaultZone: http://peer1:8083/eureka/</span><br></pre></td></tr></table></figure></li><li><p>编辑主类<br>添加<code>@EnableDiscoveryClient</code>注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableConfigServer</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigServerApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ConfigServerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4><span id="客户端配置">客户端配置</span></h4><ol><li><p>添加相关的依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>添加相关的配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: didispace</span><br><span class="line">  cloud:</span><br><span class="line">    config:</span><br><span class="line">      discovery:</span><br><span class="line">        enabled: true</span><br><span class="line">        service-id: config-service</span><br><span class="line">      profile: dev</span><br><span class="line">server:</span><br><span class="line">  port: 7002</span><br><span class="line"></span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    serviceUrl:</span><br><span class="line">      defaultZone: http://peer1:8083/eureka/</span><br></pre></td></tr></table></figure></li><li><p>修改主类，添加<code>@EnableDiscoveryClient</code>注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigClientApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ConfigClientApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3><span id="动态刷新配置">动态刷新配置</span></h3><p>改造config-client。</p><ol><li>在pom中增加<code>spring-boot-starter-actuator</code>监控模块，利用其中的/refresh端点实现来实现配置信息的重新获取与刷新<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li></ol><p>注意：springboot2.0之后默认是不开启/refresh端点的，需要手动开启<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">management:</span><br><span class="line">  endpoints:</span><br><span class="line">    web:</span><br><span class="line">      exposure:</span><br><span class="line">        include: &quot;*&quot;</span><br></pre></td></tr></table></figure></p><p>测试：</p><ol><li>访问<code>http://localhost:7002/from</code>查看配置信息</li><li>更新仓库中的配置文件</li><li>访问<code>http://localhost:7002/from</code>查看配置信息，没有改变</li><li>请求<code>http://localhost:7002//actuator/refresh</code></li><li>再次访问<code>http://localhost:7002/from</code>配置信息已经被改变了</li></ol><p>我们可以利用/refresh和github的webhooks来实现自动更新<br><img src="https://s2.ax1x.com/2019/10/16/KFII6x.png" alt="KFII6x.png"></p><h2><span id="消息总线-spring-cloud-bus">消息总线 spring cloud bus</span></h2><p>在微服务架构中，我们使用轻量级的消息代理来构建一个共用的消息主题让系统所有微服务都连接上来，由于该主题中产生的消息会被所有实例监听和消费，所以我们称他为消息总线。</p><h3><span id="消息代理">消息代理</span></h3><p>消息代理是一种消息验证、传输、路由的架构模式。他在应用程序之间起到通信调度并最小化应用之间的依赖的作用，使得应用程序之间能够高效的解耦通信过程。<br>使用消息代理的场景：</p><ol><li>将消息路由到一个或多个目的地。</li><li>将消息转化为其它的表现形式</li><li>执行消息的聚集、消息的分解。并将结果发送到它们的目的地。</li><li>调用web服务来检索数据。</li><li>响应事件或错误。</li><li>使用发布-订阅模式来提供内容或基于主题的消息路由。</li></ol><h3><span id="rabbitmq实现消息总线">RabbitMq实现消息总线</span></h3><h4><span id="基本概念">基本概念</span></h4><ol><li>Broker:消息队列服务器实体，负责接收消息生成者的消息，然后将消息发送至消息接收者或者其它的Broker</li><li>Exchange:消息交换机，是消息到达的第一个地方，消息通过它指定的路由规则分发到不同的消息队列中去。</li><li>Queue：消息队列。进入消息队列中消息进入逻辑上的等待消费的状态。</li><li>Binding:绑定：它的作用就是将Exchange和queue按照一定的路由规则绑定起来。也就是Exchange和Queue之间的虚拟连接。</li><li>Rounting Key：路由关键字，Exchange根据这个关键字进行消息投递</li><li>Virtual host: 虚拟主机。他是对Broker的虚拟划分。</li><li>Connection：连接，代表生成者、消费者、Broker之间进行通信的物理网络</li><li>Channel：消息通道，用于连接生成者和消费者的逻辑结构。</li><li>Producer：消息生产者，制造消息并发送消息的程序。</li><li>Consumer：消息消费者，接收消息并处理消息的地方</li></ol><h3><span id="简单使用">简单使用</span></h3><ol><li><p>添加相关依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>编写相关的配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: rabbitmq-hello</span><br><span class="line">  rabbitmq:</span><br><span class="line">    host: localhost</span><br><span class="line">    port: 5672</span><br><span class="line">    username: springcloud</span><br><span class="line">    password: 123456</span><br></pre></td></tr></table></figure></li><li><p>编辑消息生产者类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sender</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AmqpTemplate amqpTemplate;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String context=<span class="string">"hello"</span>+<span class="keyword">new</span> Date();</span><br><span class="line">        System.out.println(<span class="string">"sender:"</span>+context);</span><br><span class="line">        <span class="keyword">this</span>.amqpTemplate.convertAndSend(<span class="string">"hello"</span>,context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编辑消息消费类<br>实现对hello队列的消费</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(queues = <span class="string">"hello"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Receiver</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(String hello)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Receiver:"</span>+hello);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建配置类文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">rabbitConfig</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">helloQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><a href="https://imgchr.com/i/KmRpvR" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/10/19/KmRpvR.png" alt="KmRpvR.png"></a></p><h3><span id="整合spring-cloud-bus">整合spring cloud bus</span></h3><p>以之前的config-clent-eureka拓展</p><ol><li><p>添加<code>spring-cloud-starter-bus-amqp</code>依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>在配置文件中添加RabbitMQ相关的配置信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq:</span><br><span class="line">  host: localhost</span><br><span class="line">  port: 5672</span><br><span class="line">  username: springcloud</span><br><span class="line">  password: 123456</span><br></pre></td></tr></table></figure></li></ol><p>测试：<br>首先访问两个config-client-eureka的/from请求，会返回当前仓库中的配置文件的信息，，接着修改配置文件，访问其中一个项目的/bus/refresh，所有的项目的属性都会被刷新<br><img src="https://s2.ax1x.com/2019/10/19/Km2z8J.png" alt="Km2z8J.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;分布式配置中心-Spring-cloud-config&quot;&gt;&lt;a href=&quot;#分布式配置中心-Spring-cloud-config&quot; class=&quot;headerlink&quot; title=&quot;分布式配置中心 Spring cloud config&quot;&gt;&lt;/a&gt;分布式配置中心 Spring cloud config&lt;/h2&gt;&lt;p&gt;spring cloud config 是用来为分布式系统中的基础设施和微服务应用提供集中化的外部配置支持，它分为服务端和客户端，其中服务端被称为分布式配置中心，它是一个独立的微服务应用，用来链接仓库，并为客户端提供配置信息。&lt;/p&gt;
&lt;h3 id=&quot;快速入门&quot;&gt;&lt;a href=&quot;#快速入门&quot; class=&quot;headerlink&quot; title=&quot;快速入门&quot;&gt;&lt;/a&gt;快速入门&lt;/h3&gt;&lt;h4 id=&quot;搭建配置中心&quot;&gt;&lt;a href=&quot;#搭建配置中心&quot; class=&quot;headerlink&quot; title=&quot;搭建配置中心&quot;&gt;&lt;/a&gt;搭建配置中心&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;创建工程，导入相关依赖&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;artifactId&amp;gt;spring-cloud-config-server&amp;lt;/artifactId&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在主程序类中开启sprong cloud config的服务端功能&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@SpringBootApplication&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@EnableConfigServer&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ConfigServerApplication&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        SpringApplication.run(ConfigServerApplication.class, args);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="SpringCloud" scheme="http://yoursite.com/tags/SpringCloud/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud学习笔记二</title>
    <link href="http://yoursite.com/2019/10/15/SpringCloud%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/"/>
    <id>http://yoursite.com/2019/10/15/SpringCloud学习笔记二/</id>
    <published>2019-10-15T01:00:56.000Z</published>
    <updated>2019-10-15T01:02:26.178Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="服务容错保护hystrix">服务容错保护Hystrix</span></h2><p>在微服务架构中，我们将服务拆分为多个服务，通过远程调用的方式执行，很容易出现因为网络或服务本身问题而导致的调用故障和延迟，并且导致调用方的对外服务也出现延迟，若此时调用方的请求不断增加，最终就会出现因为等待故障方响应而形成任务积压，最终导致自身服务的瘫痪。</p><p>在分布式架构中，但某个服务单元发生故障之后，通过断路器的故障监测，向调用方返回一个响应，而不是长时间的等待。这样就不会使得线程因调用故障服务被长时间占用不释放，避免了故障在分布式系统中的蔓延。</p><p>Hystrix实现了断路器，线程隔离等一系列服务保护功能。<br><a id="more"></a></p><h2><span id="hystrix入门">Hystrix入门</span></h2><ol><li><p>导入相关依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>在主类上添加<code>@EnableCircuitBreaker</code>注册开启断路器功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@EnableCircuitBreaker</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RibbonConsumerApplication</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="function">RestTemplate <span class="title">restTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(RibbonConsumerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>改造service</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@HystrixCommand</span>(fallbackMethod = <span class="string">"helloFallback"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">helloService</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForEntity(<span class="string">"http://EUREKA-CLIENT-HELLO/hello"</span>,String.class).getBody();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">helloFallback</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"error"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>改造controller</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">   HelloService helloService;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/ribbon-consumer"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">helloConsumer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helloService.helloService();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试<br>首先启动eureka注册中心，然后分别启动两个EUREKA-CLIENT-HELLO服务，最后启动我们的服务消费者ribbon-consumer。<br>首先在服务都完好的情况下，我们请求ribbon-consumer，结果一切正常。随后我们关闭8084端口的EUREKA-CLIENT-HELLO服务。ribboon-consumer并没有出现长时间的等待和报错，而是调用了服务中的helloFallback方法。</p></li></ol><h3><span id="原理分析">原理分析</span></h3><p><img src="https://s2.ax1x.com/2019/10/09/u5LaCt.png" alt="u5LaCt.png"><br>hystrix的整个工作流：</p><ol><li>构造一个HystrixCommand或HystrixObservableCommand对象，用于封装请求，并在构造方法中配置请求被执行需要的参数。</li><li>执行命令。Hystrix提供了四种执行命令的方式。</li><li>判断是否使用缓存响应请求，若启用了缓存且缓存可用，直接使用缓存响应请求。</li><li>判断熔断器是否打开，如果打开，跳到第8步。</li><li>判断线程池/队列/信号是否已满，已满则跳到第8步</li><li>执行HystrixObservableCommand.construct()或HystrixCommand.run()如果执行失败或超时，跳到第8步，否则跳到第9步</li><li>统计熔断器监控指标</li><li>轴FallBack备用逻辑（服务降级）</li><li>返回请求响应</li></ol><p>执行命令的四种方法：<br>execute()和queue()适用于HystrixCommand对象，而observe()和toObservable()适用于HystrixObservableCommand对象。</p><ol><li>execute()<br>以同步阻塞的方式执行run，只支持接收一个值对象。hystrix会从线程池中去一个线程来执行run，并等待返回值。</li><li>queue()<br>以异步非阻塞方式执行run()，只支持接收一个值对象。调用queue()就返回一个用于接收执行结果的Future对象。若执行成功Future.get()返回单个返回值，但执行失败，如果没有重写fallback则抛出异常。</li><li>observe()<br>事件注册前执行run()/construct()，支持接收多个值对象，取决于发射源。调用observe()会返回一个hot Observable，也就是说，调用observe()自动触发执行run()/construct()，无论是否存在订阅者。</li></ol><p>如果继承的是HystrixCommand，hystrix会从线程池中取一个线程以非阻塞方式执行run()；如果继承的是HystrixObservableCommand，将以调用线程阻塞执行construct()。</p><ol start="4"><li>toObservable()<br>事件注册后执行run()/construct()，支持接收多个值对象，取决于发射源。调用toObservable()会返回一个cold Observable，也就是说，调用toObservable()不会立即触发执行run()/construct()，必须有订阅者订阅Observable时才会执行。</li></ol><p>如果继承的是HystrixCommand，hystrix会从线程池中取一个线程以非阻塞方式执行run()，调用线程不必等待run()；如果继承的是HystrixObservableCommand，将以调用线程堵塞执行construct()，调用线程需等待construct()执行完才能继续往下走。</p><h3><span id="依赖隔离">依赖隔离</span></h3><p>Hystrix使用“舱壁模式”来实现线程池的隔离，它会为每一个依赖服务创建一个独立的线程池，这样就算某个依赖服务出现延迟过高的情况，也只会对该依赖服务的调用产生影响，而不会拖慢其它的依赖服务。<br>通过实现对依赖服务的线程池隔离，可以带来如下优势：</p><ol><li>应用自身得到完全保护，不会受不可控的依赖服务影响。</li><li>可以有效的降低接入新服务的风险。如果新服务接入后运行不稳定或存在问题，不会隐形其它服务</li><li>当依赖的服务从失败恢复正常后，它的线程池能够很快的被清理并且能够马上恢复服务。</li><li>当依赖的服务出现配置错误时，线程池能够快速的反应此问题。</li><li>当依赖的服务出现很大的性能变动时，线程池监控指标信息可以反应出这样的变化。</li><li>每个专有的线程池都提供了内置的并发实现，可以利用它为同步的依赖服务构建异步访问。</li></ol><h3><span id="使用注解实现请求缓存">使用注解实现请求缓存</span></h3><ol><li><code>@CacheResult</code>该注解标记请求命令返回的结果应该被缓存，它必须与<code>@hystrixCommand</code>注解结合使用</li><li><code>@CacheRemove</code>该注解用来让请求命令的缓存失效，失效的缓存根据定义的key决定。</li><li><code>@CacheKey</code>该注解用来在请求命令的参数上标记，使其作为缓存的key之，如果没有标注则会使用所有参数。</li></ol><p>例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@CacheResult</span></span><br><span class="line">    <span class="meta">@HystrixCommand</span>(fallbackMethod = <span class="string">"helloFallback"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">helloService</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForEntity(<span class="string">"http://EUREKA-CLIENT-HELLO/hello"</span>,String.class).getBody();</span><br><span class="line">    &#125;</span><br><span class="line">`</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CacheResult</span>(cacheKeyMethod=<span class="string">"getUserByIdCacheKey"</span>)</span><br><span class="line"><span class="meta">@HystrixCommand</span>(fallbackMethod = <span class="string">"helloFallback"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getUserById</span><span class="params">(Long id)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> restTemplate.getForEntity(<span class="string">"http://EUREKA-CLIENT-HELLO/users/&#123;1&#125;"</span>,User.class,id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Long <span class="title">getUserByIdCacheKey</span><span class="params">(Long id)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CacheResult</span></span><br><span class="line"><span class="meta">@HystrixCommand</span>(fallbackMethod = <span class="string">"helloFallback"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getUserById</span><span class="params">(@CacheKey(<span class="string">"id"</span>)</span> Long id)</span>&#123;</span><br><span class="line"><span class="comment">//通过@CacheKey实现的方式更简单，但是器优先级比cacheKeyMethod的优先级低</span></span><br><span class="line">    <span class="keyword">return</span> restTemplate.getForEntity(<span class="string">"http://EUREKA-CLIENT-HELLO/users/&#123;1&#125;"</span>,User.class,id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@CacheKey注解除了可以指定方法方法参数作为缓存Key之外，还允许访问对象的内部属性作为缓存key</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CacheResult</span></span><br><span class="line"><span class="meta">@HystrixCommand</span>(fallbackMethod = <span class="string">"helloFallback"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getUserById</span><span class="params">(@CacheKey(<span class="string">"id"</span>)</span> User user)</span>&#123;</span><br><span class="line"><span class="comment">//通过@CacheKey实现的方式更简单，但是器优先级比cacheKeyMethod的优先级低</span></span><br><span class="line">    <span class="keyword">return</span> restTemplate.getForEntity(<span class="string">"http://EUREKA-CLIENT-HELLO/users/&#123;1&#125;"</span>,User.class,user.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缓存清理<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CacheResult</span></span><br><span class="line"><span class="meta">@HystrixCommand</span>(fallbackMethod = <span class="string">"helloFallback"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getUserById</span><span class="params">(@CacheKey(<span class="string">"id"</span>)</span> Long id)</span>&#123;</span><br><span class="line"><span class="comment">//通过@CacheKey实现的方式更简单，但是器优先级比cacheKeyMethod的优先级低</span></span><br><span class="line">    <span class="keyword">return</span> restTemplate.getForEntity(<span class="string">"http://EUREKA-CLIENT-HELLO/users/&#123;1&#125;"</span>,User.class,id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@CacheRemove</span>(commandKey=<span class="string">"getUserById"</span>)</span><br><span class="line"><span class="meta">@HystrixCommand</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(@CacheKey(<span class="string">"id"</span>)</span> User user)</span>&#123;</span><br><span class="line">    eturn restTemplate.getForEntity(<span class="string">"http://EUREKA-CLIENT-HELLO/users"</span>,User.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3><span id="使用注解实现请求合并器">使用注解实现请求合并器</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@HystrixCollapser</span>(batchMethod = <span class="string">"findAll"</span>,collapserProperties = &#123;</span><br><span class="line">            <span class="meta">@HystrixProperty</span>(name = <span class="string">"timerDelayInMilliseconds"</span>,value = <span class="string">"100"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">find</span><span class="params">(<span class="keyword">long</span> id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@HystrixCommand</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">findAll</span><span class="params">(List&lt;Long&gt; ids)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(<span class="string">"http://EUREKA-CLIENT-HELLO/users?ids=&#123;1&#125;"</span>,List.class, StringUtil.join(ids,<span class="string">","</span>));</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="声明式服务调用-spring-cloud-feign">声明式服务调用 Spring Cloud Feign</span></h2><h3><span id="使用feign">使用feign</span></h3><ol><li><p>添加相关依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-feign&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>修改主类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignConsumerApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(FeignConsumerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义HelloService接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient</span>(<span class="string">"EUREKA-CLIENT-HELLO"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function">String <span class="title">hello</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建一个ConsumerController</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerController</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    HelloService helloService;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/feign-consumer"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">helloConsumer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helloService.hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>添加相关配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: feign-consumer</span><br><span class="line">server:</span><br><span class="line">  port: 8088</span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http://localhost:8083/eureka</span><br></pre></td></tr></table></figure></li></ol><h3><span id="参数绑定">参数绑定</span></h3><ol><li><p>修改服务消费者Service类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient</span>(<span class="string">"EUREKA-CLIENT-HELLO"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function">String <span class="title">hello</span><span class="params">(@RequestHeader(<span class="string">"args"</span>)</span> String args)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>修改服务消费者Controller</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    HelloService helloService;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/feign-consumer"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">helloConsumer</span><span class="params">(String args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helloService.hello(args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>服务提供者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(@RequestHeader String args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello"</span>+ args;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><h3><span id="相关配置">相关配置</span></h3><p>在定义Feign客户端的时候，我们使用<code>@FeignCline</code>注解。在初始化过程中，SpringCloud Feign会根据该注解的name属性和value属性指定的服务名，自动的创建一个同名的Ribbon客户端。<br>可以根据Ribbon服务名，来进行配置.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EUREKA-CLIENT-HELLO.ribbon.ConnectTimeout=500</span><br><span class="line">EUREKA-CLIENT-HELLO.ribbon.ReadTimeout=2000</span><br><span class="line">EUREKA-CLIENT-HELLO.ribbon.OkToRetryOnAllOperations=true</span><br></pre></td></tr></table></figure></p><h3><span id="feign客户端服务降级逻辑">Feign客户端服务降级逻辑</span></h3><ol><li><p>继承HelloService接口，实现接口，实现服务降级逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServiceFallBack</span> <span class="keyword">implements</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(@RequestParam(<span class="string">"args"</span>)</span> String args) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"error "</span>+args;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在服务绑定接口中，通过fallback属性来指定对应的服务降级实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//fallback服务降级实现类</span></span><br><span class="line"><span class="meta">@FeignClient</span>(value = <span class="string">"EUREKA-CLIENT-HELLO"</span>,fallback = HelloServiceFallBack.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function">String <span class="title">hello</span><span class="params">(@RequestHeader(<span class="string">"args"</span>)</span> String args)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在配置文件中开启服务hystrix</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">feign:</span><br><span class="line">  hystrix:</span><br><span class="line">    enabled: true</span><br></pre></td></tr></table></figure></li></ol><h2><span id="api网关服务-spring-cloud-zuul">API网关服务 Spring Cloud Zuul</span></h2><p>API网关是一个更智能的应用服务器，它的存在就像整个微服务架构系统的门面一样，所有的外部客户端访问都需要经过他来进行调度和过滤。它除了要实现请求的路由、负载均衡、校验过滤等功能之外，还想需要完成对服务治理框架的结合，、请求转发时的熔断机制、服务的聚合等一系列高级功能。</p><h3><span id="zuul构建api网关">Zuul构建API网关</span></h3><ol><li><p>新建srpingboot工程，添加相关依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-netflix-zuul&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>编辑应用主类，开启Zuul API网关服务功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableZuulProxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApiGatewayApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ApiGatewayApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写配置信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: api-gateway</span><br><span class="line">server:</span><br><span class="line">  port: 6666</span><br></pre></td></tr></table></figure></li><li><p>配置路由<br>传统路由的配置方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">zuul:</span><br><span class="line">  routes: </span><br><span class="line">    apiAUrl: # 可以任意指定路由的名字</span><br><span class="line">      path: /api-a-utl/**</span><br><span class="line">      url: http://localhost:8080</span><br></pre></td></tr></table></figure></li></ol><p>面向服务的路由<br>通过整合Eureka，我们可以让路由的path不是映射到具体的utl，而是映射到某个具体的服务。</p><p>添加eureka客户端的的相关依赖<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p><p>修改配置文件整合eureka<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">zuul:</span><br><span class="line">  routes:</span><br><span class="line">    apiA:</span><br><span class="line">      path: /apia/**</span><br><span class="line">      serviceId: feign-consumer # 这里是服务的id</span><br><span class="line">    apiB:</span><br><span class="line">      path: /apib/**</span><br><span class="line">      serviceId: eureka-client-hello</span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http://localhost:8083/eureka</span><br></pre></td></tr></table></figure></p><h3><span id="请求过滤">请求过滤</span></h3><ol><li><p>编写过滤逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.apigateway;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.netflix.zuul.ZuulFilter;</span><br><span class="line"><span class="keyword">import</span> com.netflix.zuul.context.RequestContext;</span><br><span class="line"><span class="keyword">import</span> com.netflix.zuul.exception.ZuulException;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AccessFilter</span> <span class="keyword">extends</span> <span class="title">ZuulFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">filterType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取过滤器的类型</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"pre"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">filterOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取过滤器的顺序</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断该过滤器是否需要被执行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> ZuulException </span>&#123;</span><br><span class="line">        <span class="comment">//执行过滤逻辑</span></span><br><span class="line">        RequestContext context = RequestContext.getCurrentContext();</span><br><span class="line">        String args = context.getRequest().getParameter(<span class="string">"args"</span>);</span><br><span class="line">        <span class="comment">//这里模拟的过滤逻辑时参数为pass的才不会被过滤掉</span></span><br><span class="line">        <span class="keyword">if</span>(!<span class="string">"pass"</span>.equals(args))&#123;</span><br><span class="line">            System.out.println(<span class="string">"nopass"</span>);</span><br><span class="line">            context.setSendZuulResponse(<span class="keyword">false</span>);</span><br><span class="line">            context.setResponseStatusCode(<span class="number">401</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"pass"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在主类中配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AccessFilter <span class="title">accessFilter</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AccessFilter();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3><span id="路径匹配">路径匹配</span></h3><h4><span id="通配符">通配符</span></h4><table><thead><tr><th style="text-align:center">通配符</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">？</td><td style="text-align:center">匹配任意单个字符</td></tr><tr><td style="text-align:center">*</td><td style="text-align:center">匹配任意数量的字符</td></tr><tr><td style="text-align:center">**</td><td style="text-align:center">匹配任意数量的字符，支持多级目录</td></tr></tbody></table><h4><span id="忽略表达式">忽略表达式</span></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">zuul.ignored-patterns=/**/hello/**</span><br><span class="line">zuul.routes.api-a.path=/api-a/**</span><br><span class="line">zuul.routes.api-a.serviceid=hello-service</span><br></pre></td></tr></table></figure><h3><span id="过滤器详解">过滤器详解</span></h3><p>在Zuul中实现的过滤器必须包含四个基本特征：过滤类型、执行顺序、执行条件、具体操作。它们分别对应着<code>ZuulFilter</code>接口中定义的4个抽象方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">filterType</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">filterOrder</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">shouldFilter</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">Object <span class="title">run</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p><ol><li>filterType：该函数需要返回一个字符串来表示过滤器的类习惯。Zuul中定义了4种不同生命周期的过滤器类型<br>pre：可以在请求被录入之前调用<br>routing：在路由请求时被调用<br>post：在routing和error过滤器之后被调用<br>error： 在处理请求时发生错误时被调用</li><li>filterOrder: 通过int值来表示过滤器的执行顺序，数值越小优先级越高</li><li>shouldFilter：返回一个boolean值来判断该过滤器是否需要执行，我们可以通过此方法来指定过滤器的有效范围。</li><li>run: 过滤器的具体逻辑。</li></ol><p><img src="https://s2.ax1x.com/2019/10/14/KpGdJS.png" alt="KpGdJS.png"></p><p><img src="https://s2.ax1x.com/2019/10/14/KpYkH1.png" alt="KpYkH1.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;服务容错保护Hystrix&quot;&gt;&lt;a href=&quot;#服务容错保护Hystrix&quot; class=&quot;headerlink&quot; title=&quot;服务容错保护Hystrix&quot;&gt;&lt;/a&gt;服务容错保护Hystrix&lt;/h2&gt;&lt;p&gt;在微服务架构中，我们将服务拆分为多个服务，通过远程调用的方式执行，很容易出现因为网络或服务本身问题而导致的调用故障和延迟，并且导致调用方的对外服务也出现延迟，若此时调用方的请求不断增加，最终就会出现因为等待故障方响应而形成任务积压，最终导致自身服务的瘫痪。&lt;/p&gt;
&lt;p&gt;在分布式架构中，但某个服务单元发生故障之后，通过断路器的故障监测，向调用方返回一个响应，而不是长时间的等待。这样就不会使得线程因调用故障服务被长时间占用不释放，避免了故障在分布式系统中的蔓延。&lt;/p&gt;
&lt;p&gt;Hystrix实现了断路器，线程隔离等一系列服务保护功能。&lt;br&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="SpringCloud" scheme="http://yoursite.com/tags/SpringCloud/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud学习笔记一</title>
    <link href="http://yoursite.com/2019/10/09/SpringCloud%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/"/>
    <id>http://yoursite.com/2019/10/09/SpringCloud学习笔记一/</id>
    <published>2019-10-09T08:25:56.000Z</published>
    <updated>2019-10-09T08:26:14.109Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="简介">简介</span></h2><p>spring cloud是一个基于spring boot实现的微服务架构开发工具。它包含了多个子项目。</p><ul><li>spring cloud config： 配置管理工具，支持使用git存储配置内容，可以使用它实现应用配置的外部化存储，并支持客户端配置信息刷新、加密/解密配置内容等。</li><li>spring cloud Netflix： 核心组件<ul><li>Eureka：服务治理组件，包含服务注册中心、服务注册与发现机制的实现。</li><li>Hystrix：容错管理组件，实现断路器模式，帮助服务依赖中出现的延迟和为故障提供强大的容错能力。</li><li>Ribbon：客户端负载均衡的服务调用组件。</li><li>Feign： 基于Ribbon和Hystrix的声明式服务调用组件。</li><li>Zuul： 网关组件，提供智能路由、访问过滤等功能。</li><li>Archaius：外部化配置组件。</li></ul></li><li>spring cloud bus：事件、消息总线。</li></ul><a id="more"></a><h2><span id="单元测试">单元测试</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//待测试的Rest接口</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloContoller</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试代码</span></span><br><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner.class)</span><br><span class="line"><span class="meta">@WebAppConfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringbootApplicationTests</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MockMvc mvc;</span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        mvc= MockMvcBuilders.standaloneSetup(<span class="keyword">new</span> HelloContoller()).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helloApplicationTest</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        mvc.perform(MockMvcRequestBuilders.get(<span class="string">"/hello"</span>).accept(MediaType.APPLICATION_JSON))</span><br><span class="line">                .andExpect(status().isOk()).andDo(print()).andExpect(content().string(equalTo(<span class="string">"hello"</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="springboot-的属性加载顺序">springboot 的属性加载顺序</span></h2><ol><li>命令行中传入的参数，例如<code>java -jar xxx.jar --server.port=8888</code></li><li>SPRING_APPLICATION_JSON中的属性，SPRING_APPLICATION_JSON是以json格式配置在系统环境变量中的内容</li><li>java:comp/env中的NBDI属性</li><li>java的系统属性，可以通过System.getProperties()获得的内容</li><li>操作系统的环境变量</li><li>通过random.*配置的随机属性</li><li>位于当前应用jar包之外，针对不同{profile}环境的配置文件</li><li>位于当前应用jar包之内，针对不同{profile}环境的配置文件</li><li>位于当前应用jar包之外的application.properties和YAML中的配置内容</li><li>位于当前应用jar包之内的application.properties和YAML中的配置内容</li><li>使用@Configuration注解修改的类中，通过@PropertySource注解定义的属性</li><li>应用默认属性，使用SpringApplication.setDefaultProperties定义的内容。</li></ol><h2><span id="监控与管理">监控与管理</span></h2><p>在微服务架构中，将原本庞大的单体系统拆分为多个提供不同服务的应用，增加了应用部署的数量，提高了系统维护的复杂度。<br>为了让运维系统获取各个微服务应用的相关指标，以实现一些常规操作控制。springboot提供了一个特殊的依赖<code>spring-boot-starter-actuator</code>,使用该模块能够自动为springboot构建一系列用于监控的端点。</p><h3><span id="使用actuator">使用actuator</span></h3><ol><li><p>引入相关的依赖</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>启动应用<br>启动应用时，控制台会输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INFO 2560 --- [           main] o.s.b.a.e.web.EndpointLinksResolver      : Exposing 2 endpoint(s) beneath base path &apos;/actuator&apos;</span><br></pre></td></tr></table></figure></li></ol><p>我们访问<code>http://localhost:8082//actuator/</code>可以看到以json格式描述的访问各个端点的路径。</p><ol start="3"><li>访问端点获取系统信息<br>我们通过<code>http://localhost:8082//actuator/health</code>访问<code>health</code>端点,获取的信息如下：<code>{&quot;status&quot;:&quot;UP&quot;}</code>。在没有引入其它的组件前，从端点获取到的信息比较简单。</li></ol><h3><span id="actuator模块中实现的原生端点介绍">actuator模块中实现的原生端点介绍</span></h3><p>根据端点的作用，可以将原生端点分为三大类</p><ol><li>应用配置类：获取与springboot密切相关的配置类信息</li><li>度量指标类： 获取应用程序运行过程中用于监控的度量指标，如内存信息，线程池，HTTP请求统计等信息。</li><li>操作控制类：提供了应用程序的关闭等操作的功能。</li></ol><h2><span id="服务治理-spring-cloud-eureka">服务治理 Spring Cloud Eureka</span></h2><p>服务治理是微服务架构中最为核心和基础的模块。它主要用来实现各个微服务实例的自动化注册与发现。随着服务的增多，通过静态配置来实现服务的调用变得困难。为了解决微服务架构中的服务实例维护问题，通过使用服务注册和服务发现机制来实现对微服务应用实例的自动化管理。</p><h3><span id="服务注册">服务注册</span></h3><p>在服务治理框中，会使用一个注册中心。每个服务向注册中心登记自己提供的服务，其中包含主机与端口号、通信协议、版本号等一系列的信息。注册中心维护着一个服务清单。其中记录了所有注册过的服务的基本信息。</p><h3><span id="服务发现">服务发现</span></h3><p>得益于服务治理框架的运作，服务间的调用不再通过具体的实例地址来完成，而是通过向服务名发起请求调用实现。因此，服务调用方在调用相应的服务时，并不清楚服务的地址和端口等信息，仅仅知道服务名，这个时候就需要依赖注册中心，来获取相应服务名锁对应的服务。从注册中心获取到相应的服务列表后，依据一定的策略选取服务（负载均衡策略），来完成服务的调用。</p><h3><span id="eureka简介">Eureka简介</span></h3><p>Eureka既包含服务端组件，也包含客户端组件。Eureka的服务端组件充当注册中心的角色。和其它的服务注册中心一样，它也支持高可用的配置。它依托于强一致性提供良好的服务实例可用性。<br>Eureka客户端主要处理服务的注册与发现。客户端服务通过组解和参数配置的方式嵌入在客户端应用程序代码中。Eureka客户端向注册中心注册自身提供的服务并周期性的发生心跳来更新它的服务租约。</p><h3><span id="eureka的使用">Eureka的使用</span></h3><h4><span id="搭建eureka服务端">搭建Eureka服务端</span></h4><ol><li><p>导入相关的依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>在主类上添加<code>@EnableEurekaServer</code>注册</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaServerApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(EurekaServerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8083</span><br><span class="line"></span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    hostname: eureka-localhost # 服务端的实体名称</span><br><span class="line">  client:</span><br><span class="line">    register-with-eureka: false # 不向服务注册中心注册自身</span><br><span class="line">    fetch-registry: false # false表示自己就是注册中心，负责维护服务列表，不需要去检索服务</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/ # 设置与Eureka Server交互的地址查询服务和注册服务都需要依赖这个地址</span><br></pre></td></tr></table></figure></li><li><p>方法注册中心面板<br>通过链接<code>http://localhost:8083/</code>即可访问<br><img src="https://s2.ax1x.com/2019/10/06/ugN2tA.png" alt="ugN2tA.png"></p></li></ol><h4><span id="搭建eureka客户端">搭建Eureka客户端</span></h4><ol><li><p>导入相关的依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>修改配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8084</span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    serviceUrl:</span><br><span class="line">      defaultZone: http://localhost:8083/eureka/ # 注册目标</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: eureka-client01 # 对该应用起别名</span><br></pre></td></tr></table></figure></li><li><p>编辑启动类<br>添加一个<code>@EnableEurekaClient</code>注解即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaClientApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(EurekaClientApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在注册中心中，查看服务注册信息<br><img src="https://s2.ax1x.com/2019/10/06/ugdDXV.png" alt="ugdDXV.png"></p></li></ol><h3><span id="高可用注册中心">高可用注册中心</span></h3><p>Eureka Server的高可用实际上就是将自己作为服务向其它服务注册中心注册自己，这样就可以实现一组互相注册的注册中心，以实现服务清单的互相同步，达到高可用的效果。</p><h4><span id="实现一组高可用注册中心">实现一组高可用注册中心</span></h4><ol><li>分别配置两套配置文件<br>application-peer1.yml<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">8083</span></span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    hostname: peer1</span><br><span class="line">  client:</span><br><span class="line">    serviceUrl:</span><br><span class="line">      defaultZone: http:<span class="comment">//peer2:8085/eureka/</span></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: eureka-server</span><br></pre></td></tr></table></figure></li></ol><p>application-peer2.yml<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">8085</span></span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    hostname: peer2 # 服务端的实体名称</span><br><span class="line">  client:</span><br><span class="line">    serviceUrl:</span><br><span class="line">      defaultZone: http:<span class="comment">//peer1:8083/eureka/ # 设置与Eureka Server交互的地址查询服务和注册服务都需要依赖这个地址</span></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: eureka-server</span><br></pre></td></tr></table></figure></p><ol start="2"><li><p>修改系统的hosts文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 新增</span><br><span class="line">127.0.0.1 peer2</span><br><span class="line">127.0.0.1 peer1</span><br></pre></td></tr></table></figure></li><li><p>分别使用不同的配置文件启动服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java -jar eureka-server.jar --spring.profiles.active=peer1</span><br><span class="line">java -jar eureka-server.jar --spring.profiles.active=peer2</span><br></pre></td></tr></table></figure></li><li><p>分别查看两个注册中心<br><img src="https://s2.ax1x.com/2019/10/07/u2VbZT.png" alt="u2VbZT.png"><br><img src="https://s2.ax1x.com/2019/10/07/u2VqdU.png" alt="u2VqdU.png"></p></li></ol><p>###使用高可用的注册中心</p><ol><li><p>只需要在eureka的客户端的配置中心，添加多个注册中心的注册目标即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8084</span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    serviceUrl:</span><br><span class="line">      defaultZone: http://peer1:8083/eureka/,http://peer2:8085/eureka/#多个注册目标</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: eureka-client01</span><br></pre></td></tr></table></figure></li><li><p>查看注册中心的注册信息<br>服务的注册信息，两个注册中心均有<br><img src="https://s2.ax1x.com/2019/10/07/u2ZuOP.png" alt="u2ZuOP.png"></p></li></ol><h3><span id="搭建服务消费者">搭建服务消费者</span></h3><ol><li><p>添加相关的依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-ribbon&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>编写应用主类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RibbonConsumerApplication</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="function">RestTemplate <span class="title">restTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(RibbonConsumerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><code>@EnableEurekaClient</code>注解将该应用作为Eureka客户端使用<br><code>@LoadBalanced</code>注解开启客户端负载均衡</p><ol start="3"><li><p>编写Controller类<br>编写controller类来调用EUREKA-CLIENT-HELLO服务中提供了/hello接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/ribbon-consumer"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">helloConsumer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForEntity(<span class="string">"http://EUREKA-CLIENT-HELLO/hello"</span>,String.class).getBody();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写相关的配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 9000</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: ribbon-consumer</span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http://peer1:8083/eureka #注册中心地址</span><br></pre></td></tr></table></figure></li><li><p>启动应用<br>先启动注册中心，再启动两个EUREKA-CLIENT-HELLO服务提供者，最后启动服务消费者。</p></li></ol><h2><span id="eureka详解">Eureka详解</span></h2><h4><span id="eureka服务治理基础架构的三个核心要素">Eureka服务治理基础架构的三个核心要素</span></h4><ol><li>服务注册中心：Eureka提供的服务端，提供服务注册与发现的功能。</li><li>服务提供者： 提供服务的应用。只要遵循Eureka通信机制的应用都可以作为服务提供者。</li><li>服务消费者： 消费者应用从注册中心，获取所需要的服务信息的列表，从而让服务消费者知道从何处去调用其所需要的服务。</li></ol><h4><span id="服务治理机制">服务治理机制</span></h4><p><img src="https://s2.ax1x.com/2019/10/07/u2lJsJ.png" alt="u2lJsJ.png"></p><p>注册中心之间可以<strong>相互注册</strong>，以实现高可用的注册中心。<br><strong>服务提供者</strong>在启动时会通过发送Rest请求的方式将自己注册到Eureka服务器上，同时携带一些自身服务的信息。Eureka 服务端在接受到这些信息后，将信息存储到一个双层的map中，第一层是键服务名，第二层的键是具体服务的实例名。<br><strong>服务同步</strong>：因为高可用注册中心的使用，当服务提供者将服务信息注册到其中一个注册中心后，由于注册中心之间互相注册为服务，所以服务提供者的服务信息会在注册中心之间同步。服务同步过后，服务提供者提供的服务信息，可以从任意一格注册中心中获得。<br><strong>服务续约</strong>:在服务注册完成之后，服务提供者会维护一个心跳来告诉注册中心自己的状态，以免被Eureka服务器把其剔除。<br><strong>获取服务</strong>：当服务消费者启动时，它会发送一个Rest请求给注册中心去获取服务清单。在EUreka服务器中缓存者一份服务清单。<br><strong>服务调用</strong>:服务消费者在获取到服务清单后，会根据一个的负载均衡策略选择相应的服务。Eureka中有Region和zone的概念，一个Region中有多个zone，每个服务客户端都会注册到一个zone，在进行服务调用时，会优先选择同一个zone中的服务，如果同一个zone中服务访问不到就会去访问其它的zone。<br><strong>服务下线</strong>:当服务正常关闭后，服务实例会触发一个服务下线的Rest请求给Eureka服务器，Eureka服务器会更新服务的状态，并将下线事件传播出去。</p><p>服务注册中心：</p><ol><li>失效剔除<br>有些时候服务会不正常的下线，如内存溢出，网络故障等情况。Eureka会定时将那些没有正常续约的服务剔除掉。</li><li>自我保护<br>当Eureka服务器发现心跳失败的比例。在15分钟内是否低于85%，如果出现低于的情况（简单的讲就是在短时间内丢失了过多的实例的练级时就会触发自我保护），Eureka服务器会见当前的注册信息保护起来，这些注册信息不会过期，他会尽可能地保护这些注册信息。如果在这个阶段实例如果出现问题，那么客户端会很容易拿到实际已经不存在地服务实例，会出现调用失败。因此客户端必须要有容错机制。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 关闭自我保护机制</span><br><span class="line">eureka.server.enable-self-preservation=false</span><br></pre></td></tr></table></figure></li></ol><h2><span id="客户端负载均衡-spring-cloud-ribbon">客户端负载均衡 Spring Cloud Ribbon</span></h2><p>Spring Cloud Ribbon 是一个基于http和tcp的客户端负载均衡工具。<br>负载均衡是对系统的高可用，网络压力的缓解和处理能力扩容的重要手段之一。</p><h3><span id="服务端负载均衡">服务端负载均衡</span></h3><p>通常说的负载均衡是指服务端负载均衡，其中分为硬件负载均衡和软件负载均衡。<br>服务端负载均衡的架构一般如下图。<br><img src="https://s2.ax1x.com/2019/10/07/uR7tUS.png" alt="uR7tUS.png"></p><p>服务端负载均衡和客户端负载均衡的区别：<br>服务端负载均衡在负载均衡硬件或软件中需要维护一个服务清单，根据一定的负载均衡策略从服务清单中选择服务器。<br>而客户端负载均衡每个客户端节点存储一个服务清单。客户端负载均衡和服务端负载均衡的区别在于服务清单存储的位置。</p><h3><span id="使用ribbon">使用Ribbon</span></h3><p>得益于Ribbon的封装，使用客户端负载均衡的步骤大致只愮两步：</p><ol><li>服务提供者启动多个实例并注册到一个注册中心，或是多个相关联的注册中心。</li><li>服务消费者调用被@Loadbanced注解修饰过的RestTemplate来实现面向服务的负载均衡。</li></ol><h3><span id="resttemplate详解">RestTemplate详解</span></h3><h4><span id="get请求">GET请求</span></h4><ol><li><p>getForEntity函数，该方法的返回值是ResponseEntity，该对象是spring对http请求的封装。包含状态码、请求头，请求体等信息。<br>使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ResponseEntity&lt;String&gt; responseEntity=</span><br><span class="line"><span class="comment">//第一个参数是请求的地址，响应体会根据第二个参数转化为string，第三个参数会替换占位符&#123;1&#125;</span></span><br><span class="line">restTemplate.getForEntity(<span class="string">"http://USER-SERVICE/name?name=&#123;1&#125;"</span>,String.class,<span class="string">"tom"</span>);</span><br><span class="line">        String body=responseEntity.getBody();</span><br></pre></td></tr></table></figure></li><li><p><code>getForEntity(String url,Class responseType,Object ... urlVariables)</code>,该方法和之前的类似，后面的urlVariables是替换url中的占位符，实现参数绑定。</p></li><li><code>getForEntity(String url,Class responseType,Map urlVariables)</code>方法只是把参数绑定换成了map</li><li><code>getForEntity(URL url,Class responseType)</code>使用了URL类</li><li><code>getForObject(URL,Class responseType)</code>该方法多用于不关心除body之外的响应的情况。其它几个重载方法和getForEntity一致</li></ol><h4><span id="post请求">POST请求</span></h4><ol><li><code>postForEntity(String url,Object request,Class responseType)</code>方法的第二个参数作为请求的参数，它也有多个重载方法</li><li><code>postForObject(String url,Object requset,Class responseType)</code>它也有许多类似的重载方法</li><li><code>URL postForLocation(String url,Object request)</code>该方法实现了以post请求提交资源并返回新的URL</li></ol><p>还有一些put，delete请求相关的方法</p><h3><span id="负载均衡策略">负载均衡策略</span></h3><p><a href="https://imgchr.com/i/uhGTjx" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/10/08/uhGTjx.png" alt="uhGTjx.png"></a></p><h4><span id="randomrule">RandomRule</span></h4><p>该策略实行了从服务器示例清单中随机选择一个服务实例的功能。它使用一个生成的随机数作为UpList的索引值来选择具体的实例，同时具体的选择逻辑在一个while(server==null)循环之内。正常情况下每次选择都会选出一个服务实例，否则有可能存在并发bug。</p><h4><span id="roundrobinrule">RoundRobinRule</span></h4><p>该策略实现了按照线性轮询的方式依次选择每个服务实例的功能。它的内部维护了一个count计数器，记录循环的次数，如果循环了10次还没有选择到服务实例，那么就会停止尝试，并打印警告信息。</p><h4><span id="retryrule">RetryRule</span></h4><p>该策略实现了一个具备重试机制的实例选择功能。它内部还定义了IRule（fuzziness均衡策略的接口）对象，默认使用RoundRobinRule实例，它会在chose方法中反复尝试，直到时间超过时间阈值。</p><h4><span id="weightedresponsetimerule">WeightedResponseTimeRule</span></h4><p>该策略是对RoundRobinRule的拓展。增加了根据实例的运行情况来计算权重，并根据权重来选择实例。它主要实现了三个核心功能。<br>定时任务： 启动一个定时任务（默认30s一次）来计算每个服务实例权重。<br>权重计算： 它首先会获取每个实例的统计信息，累计每个实例的平均响应时间，得到总平均响应时间totalResponseTime。然后逐个计算每个实例的权重。其计算方法为<code>wightSoFar+totalResponseTime-实例的平均响应时间</code>wightSoFar的初始值为零，计算出的权重会累加到weightSoFar供下一次计算使用（即紧接着的那个实例的权重计算使用）。值得注意的是这里计算出来的权重只是各实例的权重区间的上限。并非某个实例的优先级。<br>实例选择： 首先生成一个[0,最大权重值)区间内的随机数，然后看随机数落到那个实例的权重区间内，就选择。</p><p>例：<br>假设有四个实例分别是A，B，C，D。它们的平均响应时间分别为：10，40，80，100<br>解：<br>总平均响应时间为：10+40+80+100=230<br>A：0+230-10=220<br>B；220+230-40=410<br>C： 410+230-80=560<br>D：560+230-100=690<br>得到权重区间：<br>A [0,220]<br>B (220,410]<br>C (410,560]<br>D (560,690]</p><p>在[0,690)区间内生成一个随机数，假设为230，那么落在实例B的区间内，因此选择B。</p><h4><span id="clientconfigenabledroundrobinrule">ClientConfigEnabledRoundRobinRule</span></h4><p>它内部本身没有实现特殊的策略，它内部定义了一个RoundRobinRule策略。我们一般不直接使用它，而是继承它实现高级策略。</p><h4><span id="bestavaliablerule">BestAvaliableRule</span></h4><p>它是继承自ClientConfigEnabledRoundRobinRule。它利用负载均衡器统计对象LoadBalancceStats，过滤掉故障的实例，选择并发请求数最小的实例。所以该策略的特性是选出最空闲的实例。同时该策略是严格依赖统计对象LoadBalanceStats，当该对象为空时，它会采用父类的线性轮询策略。</p><h4><span id="predicatebasedrule">PredicateBasedRule</span></h4><p>它是一个继承与ClientConfigEnabledRoundRobinRule的抽象策略。它的实现依赖于Predicate。它首先通过子类实现的Predicate逻辑来过滤掉一部分实例，然后再以线性轮询的方式从过滤的实例清单中选择一个。</p><h4><span id="avaliabilityfitteringrule">AvaliabilityFitteringRule</span></h4><p>该策略继承自PredicateBasedRule。它先以线性的方式选择一个实例，然后用过滤条件来判断该实例是否满足要求。若满足就直接使用该实例，若不满足就再其中过滤条件使用了AvailabilityPredicate.它是否过滤的主要依据以下几项内容（都要满足才不会被过滤）。</p><ol><li>是否故障，即断路器是否生效已断开。</li><li>实例的并发请求数大于阈值，莫尔尼值为(2^32)-1.该配置可以通过<clientname><namespace>.ActiveConnectionsLimit来修改</namespace></clientname></li></ol><h4><span id="zoneavoidancerule">ZoneAvoidanceRule</span></h4><p>它是PredicateBasedRule的具体实现类。它完全按照父类的先过滤清单，再轮询选择的逻辑。它采用组合条件进行过滤。ZoneAvoidancePredicate为主过滤条件，AvailabilityPredicate为次过滤条件的组合过滤条件。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;spring cloud是一个基于spring boot实现的微服务架构开发工具。它包含了多个子项目。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;spring cloud config： 配置管理工具，支持使用git存储配置内容，可以使用它实现应用配置的外部化存储，并支持客户端配置信息刷新、加密/解密配置内容等。&lt;/li&gt;
&lt;li&gt;spring cloud Netflix： 核心组件&lt;ul&gt;
&lt;li&gt;Eureka：服务治理组件，包含服务注册中心、服务注册与发现机制的实现。&lt;/li&gt;
&lt;li&gt;Hystrix：容错管理组件，实现断路器模式，帮助服务依赖中出现的延迟和为故障提供强大的容错能力。&lt;/li&gt;
&lt;li&gt;Ribbon：客户端负载均衡的服务调用组件。&lt;/li&gt;
&lt;li&gt;Feign： 基于Ribbon和Hystrix的声明式服务调用组件。&lt;/li&gt;
&lt;li&gt;Zuul： 网关组件，提供智能路由、访问过滤等功能。&lt;/li&gt;
&lt;li&gt;Archaius：外部化配置组件。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;spring cloud bus：事件、消息总线。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="SpringCloud" scheme="http://yoursite.com/tags/SpringCloud/"/>
    
  </entry>
  
  <entry>
    <title>九月学习总结</title>
    <link href="http://yoursite.com/2019/10/04/%E4%B9%9D%E6%9C%88%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/10/04/九月学习总结/</id>
    <published>2019-10-04T09:06:56.000Z</published>
    <updated>2019-10-04T09:10:53.630Z</updated>
    
    <content type="html"><![CDATA[<p>九月是实施学习计划的第一月。学习的任务已经圆满的完成了。有许多的收获，也发现了许多的问题。</p><h2><span id="存在的问题">存在的问题</span></h2><ol><li>在练习算法的时候缺乏深度的思考。在做完题后，也没有及时的阅读题解，寻求更加优秀的解答方案。</li><li>在本月任务完成后的那段时间，缺乏安排，学习效率很低。</li><li>在进行有针对性的学习的时候，对之前学习的东西缺乏巩固。</li><li>九月的学习有点少。</li><li>在确定任务的时候，有些缺乏考虑。比如NIO的学习的收益就很低，该直接学习Netty。</li><li>在后期学习的注意力不够集中。</li></ol><h2><span id="值得肯定的地方">值得肯定的地方</span></h2><ol><li>学习任务是严格按照计划完成了的，并且整理了读书笔记和脑图。</li><li>算法练习一直都在练习，并且对之前练习的算法进行了回顾。</li><li>在书籍不太合适的时候，能够及时的换符合实际情况的书籍来阅读。</li><li>并且完成技术学习的同时，能够很好的利用晚上的时间进行软考的复习。</li></ol><h2><span id="下一月的改进措施">下一月的改进措施</span></h2><ol><li>下一月要针对数据结构与算法进行练习，暂停leetcode的算法练习。将数据结构与算法的练习作为机动的学习任务。确保十月一整月都是忙碌的。</li><li>要加大软考的复习力度，确保软考一次通过。</li><li>注意课堂学习，特别是那些老师上课扯皮的课程，这学期的绩点必须起来。要利用好每天的零散时间进行复习。</li><li>忙起来，不给自己走神的时间。</li><li>适当的关注一些招聘的信息，确保大的方向是正确的。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;九月是实施学习计划的第一月。学习的任务已经圆满的完成了。有许多的收获，也发现了许多的问题。&lt;/p&gt;
&lt;h2&gt;&lt;span id=&quot;存在的问题&quot;&gt;存在的问题&lt;/span&gt;&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;在练习算法的时候缺乏深度的思考。在做完题后，也没有及时的阅读题解，寻求更加优秀的
      
    
    </summary>
    
    
    
      <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot使用数据库</title>
    <link href="http://yoursite.com/2019/09/29/SpringBoot%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>http://yoursite.com/2019/09/29/SpringBoot使用数据库/</id>
    <published>2019-09-29T08:12:56.000Z</published>
    <updated>2019-09-29T08:43:43.839Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="使用mysql">使用MySQL</span></h2><h3><span id="添加相应的依赖">添加相应的依赖</span></h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.15<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3><span id="实体建模">实体建模</span></h3><p>创建一些对象与数据库的表建立映射关系<br>假如数据库的E-R图如下：<br><img src="https://s2.ax1x.com/2019/09/28/u13XaF.png" alt="u13XaF.png"></p><a id="more"></a><p>我们根据E-R图得到相应的pojo<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span>(name =<span class="string">"user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Id</span>      <span class="comment">//定义记录的唯一标识</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY) <span class="comment">//设置为自动生成</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//日期类型必须进行格式化</span></span><br><span class="line">    <span class="meta">@DateTimeFormat</span>(pattern = <span class="string">"yyyy-MM-dd HH:mm:ss"</span>)</span><br><span class="line">    <span class="keyword">private</span> Date createdate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一对多关系</span></span><br><span class="line">    <span class="meta">@ManyToOne</span></span><br><span class="line">    <span class="meta">@JoinColumn</span>(name = <span class="string">"did"</span>)</span><br><span class="line">    <span class="meta">@JsonBackReference</span></span><br><span class="line">    <span class="keyword">private</span>  Deparment deparment;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义多对多关系</span></span><br><span class="line">    <span class="meta">@ManyToMany</span>(cascade = &#123;&#125;,fetch = FetchType.EAGER)</span><br><span class="line">    <span class="meta">@JoinTable</span>(name = <span class="string">"user_role"</span>,joinColumns = &#123;<span class="meta">@JoinColumn</span>(name = <span class="string">"user_id"</span>)&#125;,</span><br><span class="line">            inverseJoinColumns =&#123;<span class="meta">@JoinColumn</span>(name = <span class="string">"roles_id"</span>)&#125; )</span><br><span class="line">    <span class="keyword">private</span> List&lt;Role&gt; roles;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//getter setter</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span>(name = <span class="string">"role"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Role</span>  <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">//getter setter</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span>(name = <span class="string">"deparment"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Deparment</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span> <span class="comment">//定义为记录的唯一标识</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY) <span class="comment">//设置为自动生成</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">//getter setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得注意的是，这里出现了很多的注解，不过jpa注解都能查到。<br>常见的有@OneToOne @OneToMany @ManyToOne @ManyToMany @Join</p><p><a href="https://www.cnblogs.com/chbin/p/10640224.html" target="_blank" rel="noopener">一个总结得很好的博客</a></p><h3><span id="实体持久化">实体持久化</span></h3><p>实体持久化非常的简单，只用一个接口需要继承<code>JpaRepository&lt;T,ID&gt;</code>即可<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">User</span>,<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>它提供了许多的常用的方法：<br><img src="https://s2.ax1x.com/2019/09/28/u1wHfK.png" alt="u1wHfK.png"></p><h3><span id="配置文件">配置文件</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">      url: jdbc:mysql://localhost:3306/springboot_study?useSSL=FALSE&amp;serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;rewriteBatchedStatements=true</span><br><span class="line">      username: root</span><br><span class="line">      password: 123456</span><br><span class="line">  jpa:</span><br><span class="line">    database: mysql</span><br><span class="line">    show-sql: true</span><br><span class="line">    hibernate:</span><br><span class="line">      ddl-auto: update #使用Hibernate自动更新表的结构</span><br></pre></td></tr></table></figure><h3><span id="测试程序">测试程序</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringbootStudyApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RoleRepository roleRepository;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    DepartmentRepository departmentRepository;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Deparment deparment=<span class="keyword">new</span> Deparment();</span><br><span class="line">        deparment.setName(<span class="string">"开发部"</span>);</span><br><span class="line">        departmentRepository.save(deparment);</span><br><span class="line"></span><br><span class="line">        Role role=<span class="keyword">new</span> Role();</span><br><span class="line">        role.setName(<span class="string">"admin"</span>);</span><br><span class="line">        roleRepository.save(role);</span><br><span class="line"></span><br><span class="line">        User user=<span class="keyword">new</span> User();</span><br><span class="line">        user.setName(<span class="string">"小明"</span>);</span><br><span class="line">        user.setCreatedate(<span class="keyword">new</span> Date());</span><br><span class="line">        user.setDeparment(deparment);</span><br><span class="line"></span><br><span class="line">        List&lt;Role&gt; list = roleRepository.findAll();</span><br><span class="line">        user.setRoles(list);</span><br><span class="line"></span><br><span class="line">        userRepository.save(user);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序完美运行，数据库中的表也被自动的建好了<br><img src="https://s2.ax1x.com/2019/09/28/u10AXQ.png" alt="u10AXQ.png"></p><h2><span id="redis">Redis</span></h2><p>Redis是一种可以用于持久存储的缓存系统，是一个高性能的key-value数据库。</p><h3><span id="导入相应的依赖">导入相应的依赖</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--redis--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-redis&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--gson--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;gson&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.8.5&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3><span id="初始化redistemplate">初始化RedisTemplate</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String,String&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span></span>&#123;</span><br><span class="line">        StringRedisTemplate template=<span class="keyword">new</span> StringRedisTemplate(factory);</span><br><span class="line">        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer</span><br><span class="line">                =<span class="keyword">new</span> Jackson2JsonRedisSerializer(Object.class);</span><br><span class="line">        ObjectMapper om=<span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line">        template.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line">        <span class="keyword">return</span>  template;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="编写redis服务类">编写Redis服务类</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRedis</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String,String&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String key, Long time, User user)</span></span>&#123;</span><br><span class="line">        Gson gson=<span class="keyword">new</span> Gson();</span><br><span class="line">        redisTemplate.opsForValue().set(key,gson.toJson(user),time, TimeUnit.MINUTES);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String key, Long time, List&lt;User&gt; users)</span></span>&#123;</span><br><span class="line">        Gson gson=<span class="keyword">new</span> Gson();</span><br><span class="line">        redisTemplate.opsForValue().set(key,gson.toJson(users),time, TimeUnit.MINUTES);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">get</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">        Gson gson=<span class="keyword">new</span> Gson();</span><br><span class="line">        User user=<span class="keyword">null</span>;</span><br><span class="line">        String json = redisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="keyword">if</span>(!StringUtils.isEmpty(json))&#123;</span><br><span class="line">            user=gson.fromJson(json,User.class);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">        redisTemplate.opsForValue().getOperations().delete(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//只简单的实现几个方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="填写配置文件">填写配置文件</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">redis:</span><br><span class="line">  host: localhost</span><br><span class="line">  port: <span class="number">6379</span></span><br><span class="line">  pool:</span><br><span class="line">    max-active: <span class="number">8</span></span><br><span class="line">    max-idle: <span class="number">8</span></span><br><span class="line">    max-wait: -<span class="number">1</span></span><br><span class="line">    min-idle: <span class="number">0</span></span><br></pre></td></tr></table></figure><h3><span id="编写测试代码">编写测试代码</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RedisTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//省略创建并初始化user对象的过程</span></span><br><span class="line"></span><br><span class="line">    userRedis.add(String.valueOf(user.getId()),<span class="number">1L</span>,user);</span><br><span class="line"></span><br><span class="line">    User userFromRedis= userRedis.get(String.valueOf(user.getId()));</span><br><span class="line">    Assert.assertNotNull(userFromRedis);</span><br><span class="line">    System.out.println(userFromRedis.toString());</span><br><span class="line">    userRedis.delete(String.valueOf(user.getId()));</span><br><span class="line">    userFromRedis= userRedis.get(String.valueOf(user.getId()));</span><br><span class="line">    Assert.assertNull(userFromRedis);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="使用mongodb">使用mongoDB</span></h2><h3><span id="导入相关的依赖">导入相关的依赖</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--mongoDB--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-data-mongodb&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.pegdown&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;pegdown&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.2.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-hateoas&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.9.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3><span id="实体建模">实体建模</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Document</span>(collection = <span class="string">"student"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> String userId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span> <span class="meta">@Indexed</span>(unique=<span class="keyword">true</span>)</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PersistenceConstructor</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String userId, @NotNull String username, @NotNull String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userId = userId;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="文档持久化">文档持久化</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StudentRepository</span> <span class="keyword">extends</span> <span class="title">MongoRepository</span>&lt;<span class="title">Student</span>,<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="编写配置类">编写配置类</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableMongoRepositories</span>(basePackages = <span class="string">"com.example.springbootstudy.MongoDao"</span>)</span><br><span class="line"><span class="meta">@PropertySource</span>(<span class="string">"classpath:mongoDBTest.properties"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MongoDBConfig</span>  <span class="keyword">extends</span> <span class="title">AbstractMongoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Environment env;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MongoClient <span class="title">mongoClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ServerAddress serverAddress=<span class="keyword">new</span> ServerAddress(env.getRequiredProperty(<span class="string">"mongo.host"</span>));</span><br><span class="line">        List&lt;MongoCredential&gt; credentials=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MongoClient(serverAddress,credentials);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">getDatabaseName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> env.getProperty(<span class="string">"mongo.name"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="编写配置文件">编写配置文件</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># mongoDBTest.properties文件</span><br><span class="line">mongo.host=localhost</span><br><span class="line">mongo.name=test</span><br><span class="line">mongo.port=27017</span><br></pre></td></tr></table></figure><h3><span id="测试代码">测试代码</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mongoDBTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Student student=<span class="keyword">new</span> Student(<span class="string">"1"</span>,<span class="string">"12346"</span>,<span class="string">"小明"</span>);</span><br><span class="line">    studentRepository.save(student);</span><br><span class="line">    List&lt;Student&gt; list=studentRepository.findAll();</span><br><span class="line">    Assert.assertNotNull(list);</span><br><span class="line">    <span class="keyword">for</span>(Student stu:list)&#123;</span><br><span class="line">        System.out.println(stu.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;使用MySQL&quot;&gt;&lt;a href=&quot;#使用MySQL&quot; class=&quot;headerlink&quot; title=&quot;使用MySQL&quot;&gt;&lt;/a&gt;使用MySQL&lt;/h2&gt;&lt;h3 id=&quot;添加相应的依赖&quot;&gt;&lt;a href=&quot;#添加相应的依赖&quot; class=&quot;headerlink&quot; title=&quot;添加相应的依赖&quot;&gt;&lt;/a&gt;添加相应的依赖&lt;/h3&gt;&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;mysql&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;mysql-connector-java&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;8.0.15&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-data-jpa&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;实体建模&quot;&gt;&lt;a href=&quot;#实体建模&quot; class=&quot;headerlink&quot; title=&quot;实体建模&quot;&gt;&lt;/a&gt;实体建模&lt;/h3&gt;&lt;p&gt;创建一些对象与数据库的表建立映射关系&lt;br&gt;假如数据库的E-R图如下：&lt;br&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/09/28/u13XaF.png&quot; alt=&quot;u13XaF.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="SpingBoot" scheme="http://yoursite.com/tags/SpingBoot/"/>
    
  </entry>
  
  <entry>
    <title>如何让多个线程同时开始执行</title>
    <link href="http://yoursite.com/2019/09/22/%E5%A6%82%E4%BD%95%E8%AE%A9%E5%A4%9A%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%97%B6%E5%BC%80%E5%A7%8B%E6%89%A7%E8%A1%8C/"/>
    <id>http://yoursite.com/2019/09/22/如何让多个线程同时开始执行/</id>
    <published>2019-09-22T09:12:56.000Z</published>
    <updated>2019-10-09T08:37:08.063Z</updated>
    
    <content type="html"><![CDATA[<p>有些时候有这样的情况，需要多个线程同时开始执行任务。为了实现这样的需求，我大概想到了以下两种方式。<br>第一种方式是采用<code>CyclicBarrier</code>类来实现，让多个线程相互等待，直到达到一个屏障点，并且<code>CyclicBarrier</code>是可重用的。<br>第二种方案是使用<code>CountDownLatch</code>来实现，当计数器为0的时候，所有等待的线程都被唤醒，开始执行他们的任务。<br><a id="more"></a></p><h2><span id="cyclicbarrier的实现方式">CyclicBarrier的实现方式</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CyclicBarrierTest cyclicBarrierTest=<span class="keyword">new</span> CyclicBarrierTest();</span><br><span class="line">        cyclicBarrierTest.runThread();</span><br><span class="line">    &#125;</span><br><span class="line">    CyclicBarrier cyclicBarrier=<span class="keyword">new</span> CyclicBarrier(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个线程</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Thread <span class="title">createThread</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        Thread thread=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                    System.out.println(<span class="string">"thread"</span>+Thread.currentThread().getName()+<span class="string">"准备完毕"</span>+System.currentTimeMillis());</span><br><span class="line">                &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">catch</span> (BrokenBarrierException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.setName(<span class="string">"thread-"</span>+i);</span><br><span class="line">        <span class="keyword">return</span>  thread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runThread</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ExecutorService executorService= Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                executorService.submit(createThread(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="countdownlatch-的实现方式">CountDownLatch 的实现方式</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CountDownLatchTest countDownLatchTest=<span class="keyword">new</span> CountDownLatchTest();</span><br><span class="line">        countDownLatchTest.runThread();</span><br><span class="line">    &#125;</span><br><span class="line">    CountDownLatch countDownLatch=<span class="keyword">new</span> CountDownLatch(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个线程</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Thread <span class="title">createThread</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        Thread thread=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    countDownLatch.await();</span><br><span class="line">                    System.out.println(<span class="string">"thread"</span>+Thread.currentThread().getName()+<span class="string">"准备完毕"</span>+System.currentTimeMillis());</span><br><span class="line">                &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.setName(<span class="string">"thread-"</span>+i);</span><br><span class="line">        <span class="keyword">return</span>  thread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runThread</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ExecutorService executorService= Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                executorService.submit(createThread(i));</span><br><span class="line">                <span class="comment">//待等待的线程数减去一</span></span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="输出结果">输出结果</span></h2><p>两种方案的输出类似，10个线程同时开始工作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">threadpool-1-thread-2准备完毕1569143420252</span><br><span class="line">threadpool-1-thread-6准备完毕1569143420252</span><br><span class="line">threadpool-1-thread-8准备完毕1569143420252</span><br><span class="line">threadpool-1-thread-9准备完毕1569143420252</span><br><span class="line">threadpool-1-thread-7准备完毕1569143420252</span><br><span class="line">threadpool-1-thread-5准备完毕1569143420252</span><br><span class="line">threadpool-1-thread-3准备完毕1569143420252</span><br><span class="line">threadpool-1-thread-4准备完毕1569143420252</span><br><span class="line">threadpool-1-thread-1准备完毕1569143420252</span><br><span class="line">threadpool-1-thread-10准备完毕1569143420252</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有些时候有这样的情况，需要多个线程同时开始执行任务。为了实现这样的需求，我大概想到了以下两种方式。&lt;br&gt;第一种方式是采用&lt;code&gt;CyclicBarrier&lt;/code&gt;类来实现，让多个线程相互等待，直到达到一个屏障点，并且&lt;code&gt;CyclicBarrier&lt;/code&gt;是可重用的。&lt;br&gt;第二种方案是使用&lt;code&gt;CountDownLatch&lt;/code&gt;来实现，当计数器为0的时候，所有等待的线程都被唤醒，开始执行他们的任务。&lt;br&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>MySQL的锁机制</title>
    <link href="http://yoursite.com/2019/09/22/MySQL%E7%9A%84%E9%94%81%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2019/09/22/MySQL的锁机制/</id>
    <published>2019-09-22T08:22:56.000Z</published>
    <updated>2019-09-22T08:02:20.163Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="mysql锁的概述">MySQL锁的概述</span></h2><p>锁是计算机协调多个进程或线程并发访问某一资源的机制。<br>MySQL中不同的存储引擎支持不同的锁机制。InnoDB存储引擎支持行级锁和表级锁，默认情况下使用的是行级锁。MyISAM支持表级锁。<br>表级锁：开销小，加锁快，不会出现死锁，锁定粒度大，发生锁冲突的概览极高，并发度最低。<br>行级锁： 开销大，加锁满，会出现死锁，锁定粒度最小，发生锁冲突的概览最低，并发度也最高。<br>页面锁： 开销和加锁时间介于表锁和行锁之间，会出现死锁，锁定粒度介于表锁和行锁之间，并发度一般。</p><h2><span id="myisam表锁">MyISAM表锁</span></h2><p>MySQL的表级锁有两种模式：表共享读锁，表独占写锁。对MyISAM的读不会阻塞其它用户的读请求，但是会阻塞对同一表额写请求。当一个线程获得了一个表的写锁后，只有持有锁的线程可以对表进行更新操作。其它读写操作都会被阻塞。</p><h3><span id="如何加表锁">如何加表锁</span></h3><p>MyISAM在执行select操作之前会自动给涉及到的表加读锁。在执行更新操作（update，insert，delete）前，会自动给涉及到的表添加写锁。因此一般是不需要显示的去加锁的。<br>一般手动加锁是模拟事务：<br>比如：<br>检查两个表的合计金额是否相同，<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//这种写法显然可能会出现错误（第一条sql执行之后，可能会有金额变动）</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">sum</span>(total) <span class="keyword">from</span> orders;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">sum</span>(subtotal) <span class="keyword">from</span> order_detail;</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>采用加锁来实现模拟事务<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Loco tables orders read local,order_detail read local;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">sum</span>(total) <span class="keyword">from</span> orders;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">sum</span>(subtotal) <span class="keyword">from</span> order_detail;</span><br><span class="line"><span class="keyword">Unlock</span> <span class="keyword">tables</span>;</span><br></pre></td></tr></table></figure></p><p>值得注意的是在加锁时有一个<code>Local</code>关键字，其作用是在并发情况下，允许其它用户在表尾并发插入记录。</p><h3><span id="并发插入">并发插入</span></h3><p>总体而言MyISAN表的读写是串行的，但在一定的条件下，MyISAM表也支持查询和插入操作的并发进行。<br>MyISAM存储引擎中有一个系统变量<code>concurrent_insert</code>，专门用来控制并发插入的行为，其值分别为：0，1，2</p><p>0： 不允许并发插入<br>1： 如果MyISAM表中没有空洞（即表中间没有被删除的行），MyISAM允许在一个进程读表的同时，另一个进程从表尾插入记录，这也是默认值。<br>2： 无论MyISAM表中有无空洞，，都允许在表尾并发插入记录。</p><h3><span id="myisam的锁调度">MyISAM的锁调度</span></h3><p>如果一个进程请求某个MyISAM的读锁同时里一个进程也请求同一个表的写锁，<strong>那么写进程先获得锁。*不仅如此，如果读请求先到达等待队列，写请求后到，写锁也会被插入到读锁之前</strong>。因为MySQL认为写请求比读请求更加重要。正是如此，当有大量的更新操作时，查询操作很难获得读锁。当然可以通过一些设置来条件MyISAN的调度行为。</p><h2><span id="innodb锁">InnoDB锁</span></h2><p>InnoDB与MyISAN的最大不同在于：一是支持事务，二是采用行级锁。</p><h3><span id="事务及其acid属性">事务及其ACID属性</span></h3><p>事务是由一组SQL语句组成的逻辑处理单元。它具有以下性质：</p><ol><li>原子性：事务是一个原子操作，其对数据的修改，要么全部执行，要么全部都不执行。</li><li>一致性： 在事务的开始和完成时，数据都必须保持一致状态，这意味着所有相关的数据规则都必须应用于事务的修改，以保持其完整性；事务结束后，所有的内部数据结构也都必须都是正确的。</li><li>隔离性： 数据库系统提供一种一定的隔离机制，保证事务在不受外部并发操作影响的“独立”环境执行，这意味着事务处理过程中的中间状态对外部都是不可见的。</li><li>持久性： 事务完成之后，他对数据的修改是永久性的，即使系统出现故障也能保持。</li></ol><h3><span id="并发事务带来的问题">并发事务带来的问题</span></h3><ol><li>更新丢失：当两个或多个事务选择同一行，然后基于最初选定的值进行更新该行时，由于每个事务都不知道其它事务的存在，就会发生丢失更新问题，最后的更新覆盖了其它事务所做的更新。</li><li>脏读：一个事务正在对一条记录做修改，在这个事务提交前，这条记录的数据处于不一致状态，这是，如果另一个事务也来读取同一个记录，如果不加以控制，第二个事务读取了这些“脏”的数据。</li><li>不可重复读：一个事务在读取某些数据时，某些数据已经发生了改变，或某些数据已经被删除。</li><li>幻读：一个事务按相同的查询条件重新读取以前检索过的数据，却发现其它事务插入了满足其条件的新数据。</li></ol><h3><span id="事务的隔离级别">事务的隔离级别</span></h3><p>“更新丢失”是一种应该完全避免的，但不能仅仅依靠数据库，需要引用程序对更新的数据加必要的锁来解决。因此，防止更新丢失应该是应用的责任。</p><p>脏读，不可重复读，幻读都是数据库读一致性问题，必须由数据库提供一定的事务隔离机制来解决。<br>一般可以采取以下几种方式：</p><ol><li>在读取数据前，对其加锁，阻止其它事务对数据进行修改。</li><li>不加任何锁，通过一定机制生成一个数据请求时间点的一致性数据快照。并用这个快照来提供一定级别的一致性读。从用户角度来看，好像是提供了数据的多个版本，因此该技术也较数据多版本并发控制（MVCC，MCC）</li></ol><p>在MVCC中，读操作可以分成两类：快照读和当前读。快照读读取的是记录的可见版本，<strong>不用加锁</strong>。当前读，读取的是记录的最新版本，并且当前读返回的记录<strong>都会加锁</strong>。</p><p>哪些属于快照读，哪些属于当前读？</p><ol><li><p>简单的select操作，属于快照读</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> ?</span><br></pre></td></tr></table></figure></li><li><p>当前读：特殊的读操作，插入/更新/删除操作，属于当前读，需要加锁</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> ? <span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> ? <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">table</span> <span class="keyword">values</span> (…);</span><br><span class="line"><span class="keyword">update</span> <span class="keyword">table</span> <span class="keyword">set</span> ? <span class="keyword">where</span> ?;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> ?;</span><br></pre></td></tr></table></figure></li></ol><p>事务的隔离级别越严格，并发副作用越小。但付出的代价也越大。因为事务隔离的实质就是在一定程度上让事务“串行化”</p><p>四种隔离级别：<br><img src="https://s2.ax1x.com/2019/09/21/nz5pjS.png" alt="nz5pjS.png"></p><h3><span id="innodb的行锁模式即加锁方法">InnoDB的行锁模式即加锁方法</span></h3><p>共享锁（S）（读锁）：允许一个事务去读一行，阻止其它事务获得相同数据集的排他锁（其它事务只能加共享锁，不能加排他锁）。<br>排他锁（X）（写锁）：允许获取排他锁的事务其更新数据，阻止其它事务取得相同的数据集共享读锁和排他写锁。</p><p><strong>当一个事务对数据加上排他锁后，其它事务不能获取相同数据集的共享锁和排他锁，但是可以使用<code>select * from ..</code> 进行查询的，因为普通的查询没有任何锁机制，它根本就不需要获得锁，因此排他锁也无法阻止它</strong></p><p>为了允许行锁和表锁的共存，InnoDB还引入了意向锁（<strong>表锁</strong>）。<br>意向共享锁（IS）：事务打算给数据行加共享锁，必须在这之前获得该表的意向共享锁。<br>意向排他锁（IX）：事务打算给数据行加排他锁，必须在这之前获得该表的意向排他锁。</p><p>InnoDB行锁模式兼容性列表<br><img src="https://s2.ax1x.com/2019/09/22/ups0q1.png" alt="ups0q1.png"><br>如果事务请求的锁模式于当前的锁兼容，InnoDB就将请求的锁授予该事务，反之，如果两者不兼容，该事务就要等待锁释放。</p><p>意向锁是InnoDB自动加的，不需要人工干预<strong>对应更新操作，InnoDB会自动加上排他锁，但对于普通的select语句，InnoDB不会加任何锁</strong></p><h2><span id="innodb行锁的实现方式">InnoDB行锁的实现方式</span></h2><ol><li>在不通过索引进行查询的时候，InnoDB使用的是表锁，而不是行锁。</li><li>MySQL的行锁是针对索引加的锁，不是针对记录加的锁。如果使用相同的索引键仍然会出现锁冲突。</li><li>当表种有多个索引时，不同的事务可以使用不同的索引锁定不同的行。</li><li>即便在sql中使用了索引，但是MySQL的执行计划如果采用的是全表扫描的话，那么仍然将<strong>使用表锁</strong>。</li></ol><h2><span id="间隙锁next-key锁">间隙锁（Next-key锁）</span></h2><p>当使用范围条件进行检索数据并请求共享和排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁，对于键值条件在范围内但不存在的记录（间隙）也会加锁。</p><p>例如：<br>//假如emp表中有101条数据，且empid的值分别是1，2，3…100,101<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> empid &gt;<span class="number">100</span> <span class="keyword">for</span> <span class="keyword">update</span></span><br></pre></td></tr></table></figure></p><p>那么InnoDB不仅会对empid为101的进行加锁，empid 在100之后哪怕不存在的也会加锁。<br><strong>因此，在实际应用开发中，尤其是并发插入比较多的应用，我们需要尽量优化业务逻辑，进行使用相同条件来更新数据，避免使用范围条件</strong><br><strong>并且在使用等值条件时，如果记录不存在，也会使用间隙锁</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;MySQL锁的概述&quot;&gt;&lt;a href=&quot;#MySQL锁的概述&quot; class=&quot;headerlink&quot; title=&quot;MySQL锁的概述&quot;&gt;&lt;/a&gt;MySQL锁的概述&lt;/h2&gt;&lt;p&gt;锁是计算机协调多个进程或线程并发访问某一资源的机制。&lt;br&gt;MySQL中不同的存储引擎支持不同的锁机制。InnoDB存储引擎支持行级锁和表级锁，默认情况下使用的是行级锁。MyISAM支持表级锁。&lt;br&gt;表级锁：开销小，加锁快，不会出现死锁，锁定粒度大，发生锁冲突的概览极高，并发度最低。&lt;br&gt;行级锁： 开销大，加锁满，会出现死锁，锁定粒度最小，发生锁冲突的概览最低，并发度也最高。&lt;br&gt;页面锁： 开销和加锁时间介于表锁和行锁之间，会出现死锁，锁定粒度介于表锁和行锁之间，并发度一般。&lt;/p&gt;
&lt;h2 id=&quot;MyISAM表锁&quot;&gt;&lt;a href=&quot;#MyISAM表锁&quot; class=&quot;headerlink&quot; title=&quot;MyISAM表锁&quot;&gt;&lt;/a&gt;MyISAM表锁&lt;/h2&gt;&lt;p&gt;MySQL的表级锁有两种模式：表共享读锁，表独占写锁。对MyISAM的读不会阻塞其它用户的读请求，但是会阻塞对同一表额写请求。当一个线程获得了一个表的写锁后，只有持有锁的线程可以对表进行更新操作。其它读写操作都会被阻塞。&lt;/p&gt;
&lt;h3 id=&quot;如何加表锁&quot;&gt;&lt;a href=&quot;#如何加表锁&quot; class=&quot;headerlink&quot; title=&quot;如何加表锁&quot;&gt;&lt;/a&gt;如何加表锁&lt;/h3&gt;&lt;p&gt;MyISAM在执行select操作之前会自动给涉及到的表加读锁。在执行更新操作（update，insert，delete）前，会自动给涉及到的表添加写锁。因此一般是不需要显示的去加锁的。&lt;br&gt;一般手动加锁是模拟事务：&lt;br&gt;比如：&lt;br&gt;检查两个表的合计金额是否相同，&lt;br&gt;&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//这种写法显然可能会出现错误（第一条sql执行之后，可能会有金额变动）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;sum&lt;/span&gt;(total) &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; orders;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;sum&lt;/span&gt;(subtotal) &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; order_detail;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>高性能MySQL读书笔记一</title>
    <link href="http://yoursite.com/2019/09/21/%E9%AB%98%E6%80%A7%E8%83%BD%20MySQL%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%80/"/>
    <id>http://yoursite.com/2019/09/21/高性能 MySQL读书笔记一/</id>
    <published>2019-09-21T09:46:56.000Z</published>
    <updated>2019-09-21T09:47:46.382Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="索引基础">索引基础</span></h2><p>索引类似于书的目录。存储引擎在索引中找到对应值，然后再根据匹配的索引记录找到对应的数据行。<br>索引可以包含一个活多个列的值。如果索引包含多个列，那么列的顺序也十分重要，因为MySQL只能高校地利用索引地最左前缀列。</p><h2><span id="索引的类型">索引的类型</span></h2><p>索引有很多类型，MySQL的索引是在存储引擎层实现的，所以没有统一的索引标准。</p><h3><span id="b-tree索引">B-Tree索引</span></h3><p>大多少MySQL引擎都支持这种索引。他们的内部实现也是不同的，有些存储引擎使用T-Tree结构存储这种索引，有些使用B+Tree。当然性能也各有不同。<br>B-Tree通常意味着所有的值都是按顺序存储的，并且每一个叶子页到根的距离相同相同。<br>B-Tree索引能够加快访问数据的速度，因为存储引擎不再需要进行全表扫描来获取需要的数据，取而代之的是从索引的根节点开始进行搜索。<br><strong>B-Tree对索引是顺序组织存储的，所以很适合查找范围数据</strong><br>索引对多个值进行排序的依据是建表语句中定义的索引列的顺序进行排序的。<br>B-Tree索引适用于全键值、键值范围或键前缀查找。其中键前缀查找只适用于根据最左前缀的操作。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> People(</span><br><span class="line">    last_name <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    first_name <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    dob <span class="built_in">date</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    gender enum(<span class="string">'m'</span>,<span class="string">'f'</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    <span class="keyword">key</span>(last_name,first_name,dob)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>前面描述的索引对如下的类型的查询有效：</p><ol><li>全值匹配：指和索引中的所有列进行匹配</li><li>匹配最左前缀，即只使用索引的第一列。</li><li>匹配列前缀。页可以只匹配某一列的值的开头部分。比如查找以J开头的姓名的人。</li><li>匹配范围值。例如可以查找姓在Allen到Barrymore之间的人，这里也<strong>只能使用索引的第一列</strong></li><li>精确匹配某一列并范围匹配另外一列，比如索引可用于查找姓为Allen，并且名字以k开头的。</li><li>只访问索引的查询。即查询只需要访问索引，而无须访问数据行。</li></ol><p>因为索引树的节点是有序的，所以除了按值查找之外，索引还可以用于查询中的orber by操作。</p><p>使用B-Tree索引的限制：</p><ol><li>如果不是按照索引的最左类开始查找，则无法使用索引。</li><li>不能跳过索引中的列。</li><li>如果查询中有某个列的范围查询，则其右边说有列都无法使用索引进行优化查找。</li></ol><h2><span id="哈希索引">哈希索引</span></h2><p>哈希索引是基于哈希表实现的，只有精确匹配索引所有列的查询才有效。对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> Tabel testhash(</span><br><span class="line">    fname <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    lname <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    <span class="keyword">key</span> <span class="keyword">using</span> <span class="keyword">hash</span>(fname)</span><br><span class="line">) <span class="keyword">engine</span>=<span class="keyword">memory</span>;</span><br></pre></td></tr></table></figure><p>因为索引自身只需要存储对应的哈希值，所以索引的结构十分紧凑，这也让哈希索引查找的速度非常快。</p><p>哈希索引的限制：</p><ol><li>哈希索引只包含哈希值和行指针，而不存储字段值，所以不能使用索引中的值来避免读取行。</li><li>哈希索引数据并不是按照索引值顺序存储的，所以也就无法用于排序。</li><li>哈希索引不支持部分索引列匹配查找，因为哈希索引始终是使用索引列的全部内容来计算哈希值的。</li><li>哈希索引只支持等值比较查询。</li><li>访问哈希索引的数据非常快，除非有很多哈希冲突。</li><li>如果哈希冲突很多的话，一些索引维护操作的代价也会很高。</li></ol><p>innodb引擎有一个特殊的功能叫做“自适应哈希索引”。当innodb注意到某些索引值被使用的特杯频繁时，它会在内存中基于B-Tree索引之上再创建一个哈希索引。</p><p>如果存储引擎不支持哈希索引，则可以模拟像innodb一样哈希索引。</p><p>例如：<br><code>select id from url where url=&quot;http://www.mysql.com&quot;</code><br>这样的查询语句因为url本身很长，如果使用B-Tree来存储url，存储的内容就会很大，因为Url本身都很长。<br>优化方案：<br>删除原来URL列上的索引，新增一个被索引的url_crc列，使用crc32做哈希，就可以使用以下方式进行查询：<br><code>sekect id from url where url=&quot;http://www.mysql.com and url_cre=CRC32(&quot;http://www.mysql.com&quot;)</code><br>分析：因为MySQL优化器会使用选择性高而提交很小的基于url_crc列的索引来完成查找。如果有多个相同的索引值，再一一比较返回对应的行。当这样的缺陷在于需要维护哈希值。可以手动维护，也可以使用触发器来实现。</p><p><strong>为了处理哈希冲突必须在where子句中包含常量池。</strong><br>例如这样的语句在存在hash冲突时，是无法正常工作的。<br><code>sekect id from url where  url_cre=CRC32(&quot;http://www.mysql.com&quot;)</code></p><h2><span id="空间数据索引-r-tree">空间数据索引 R-Tree</span></h2><p>MyISAM表支持空间索引，可用作地理数据存储。和B-Tree索引不同，这类索引无须前缀查询。空间索引会从所有维度来索引数据。</p><h2><span id="全文索引">全文索引</span></h2><p>全文索引是一种特殊类型的索引，它查找的是文本中的关键词，而不是直接比较索引中的值。在相同的列上同时创建全文索引和基于值得B-Tree索引不会冲突，全文索引适用于MATCH AGAINST操作，而不是普通的where条件。</p><h2><span id="索引的优点">索引的优点</span></h2><p>索引可以让服务器快速的定位到表的指定位置。它还有许多其它的优点。<br>优点：</p><ol><li>索引大大减少了服务器需要扫描的数据量</li><li>索引可以帮助服务器避免排序和临时表</li><li>索引可以将随机IO变为顺序IO</li></ol><h2><span id="高性能的索引策略">高性能的索引策略</span></h2><p>正确的创建和使用索引是实现高性能查询的基础。</p><h3><span id="独立的列">独立的列</span></h3><p>如果查询中的列不是独立的，则MySQL就不会使用索引。“独立的列”是指索引不能是表达式的一部分，也不能是函数的参数。</p><p>例如：<br><code>select actor_id from sakila.actor where actor_id+1=5</code><br>这样的查询就无法利用actor列上的索引。我们应该养成简化where条件的习惯，始终将索引列单独放在比较符号的一侧。</p><h3><span id="前缀索引和索引的选择性">前缀索引和索引的选择性</span></h3><p>有时候需要索引很长的字符列，这回让索引变得大且慢。一个策略是前面提到过的们模拟哈希索引。通常可以索引开始的几个字符，这样可以大大的节约索引空间，从而提高索引效率，但这样也会降低索引的选择性。选择性高得索引可以帮助MySQL在查找是过滤掉更多的行。<br>找打合适的前缀长度非常的重要。</p><p>创建前缀索引的方式：<br><code>alter table sakila.city_demo add key(city(7))</code><br>前缀索引是一种能够使索引更小】更快的有效办法，但另一方面也有缺点；MySQL无法使用前缀索引做order by 和group by，也无法使用前缀索引做覆盖扫描。</p><p>有些时候后最索引也有用途（比如，找到某个域名的所有电子邮件地址），MySQL原生并不支持反向索引，但是<strong>可以把字符串反转后存储</strong>，并基于此建立前缀索引。</p><h3><span id="多列索引">多列索引</span></h3><p>在多个列上建立独立的单列索引大部分情况下并不能提高MySQL的查询性能。MySQL5.0之后引入了一种叫做“索引合并”的策略，一迪尼沟程度上可以使用表上的多个单列索引来定位指定的行。<br>在MySQL5.0之后，查询能够同时使用两个单列索引进行扫描，并将结果进行合并。这种算法有三种变种：or条件联合，and条件的相交，组合前两种情况的联合及相交。</p><p>索引合并策略有时候是一种优化的结果，但实际上更多时候说明表上的索引建的很糟糕。</p><ol><li>当出现服务器对多个索引做相交操作时，通常意味着需要一个包含所有相关列的多列索引。</li><li>当服务器需要对多个索引做联合操作时，通常需要耗费大量的CPU和内存资源。</li><li>优化器不会把合并索引的开销计算到查询成本中。</li></ol><h3><span id="选择合适的索引列顺序">选择合适的索引列顺序</span></h3><p>正确的顺序依赖于使用该索引的查询，并同时需要考虑如何更好的满足排序还分组的需要。<br>在一个多列B-Tree索引中，索引列的顺序意味着索引首先按照最左列进行排序，其次是第二列。</p><p>当不考虑排序和分组时，将选择性最高的列放在前面通常时很好的。这时候索引的作用只是用于优化where条件的查找。</p><h2><span id="聚簇索引">聚簇索引</span></h2><p>聚簇索引并不是一种单独的索引类型，而<strong>是一种数据存储的方式</strong>。<br>当表有聚簇索引时，它的数据行实际上存放在索引的叶子页中。因为时存储引擎负责实现索引，因此不是所有的存储引擎都支持聚簇索引。<br>在聚簇索引的存放中，叶子页包含了行的全部数据，但是节点页只包含了索引列。<br><img src="https://s2.ax1x.com/2019/09/17/nIKOW4.png" alt="nIKOW4.png"><br>InnoDB通过主键聚集数据，索引被索引的列就是主键列。<br>如果没有定义主键，InnoDB会选择一个唯一的非空索引代替。如果没有这样的索引，InnoDB会隐式的定义一个主键作为聚簇索引。</p><p>聚集的数据的优点：</p><ol><li>可以把相关的数据保存在一起。</li><li>数据访问更快。聚簇索引将索引和数据保存在同一个B-Tree中，因此从聚簇索引中获取数据通常要比非聚簇索引中查找更快。</li><li>使用覆盖索引扫描的查询可以直接使用页节点中的主键值。</li></ol><p>缺点：</p><ol><li>聚簇索引最大限度地提高了I/O密集型应用地性能，当如果数据全部都放在内存中，则访问地顺序就没有那么重要了，聚簇索引地优势也就没有了。</li><li>插入速度严重依赖插入顺序。</li><li>更新聚簇索引列地代价很高。</li><li>居于聚簇索引地表在插入新行，或者主键被更新导致需要移动行地时候，可能面临“页分裂”的问题。页分类会导致表占用更多的磁盘空间。</li><li>聚簇索引可能导致全表扫描变慢。</li><li>二级索引可能比想象的更要大，</li></ol><p>为什么二级索引需要两次索引查找？<br>二级索引保存的“行指针”的实质，二级索引叶子节点保存的不是指向行的物理位置的指针，而是行的主键值。这意味着通过二级索引查找行，存储引擎需要找到二级索引的叶子节点获得对应的主键值，然后根据这个值取聚簇索引中查找到对应的行。这样就做了两次B-Tree查找。对于InnoDB，自适应哈希索引能够减少这样的重复工作。</p><h3><span id="innodb和myisam的数据分布对比">innoDb和MyISAM的数据分布对比</span></h3><p><img src="https://s2.ax1x.com/2019/09/17/nI3uvQ.png" alt="nI3uvQ.png"></p><h3><span id="在innodb表中按主键顺序插入行">在InnoDB表中按主键顺序插入行</span></h3><p>如果正在使用InnoDB表并且没有什么数据需要聚簇，那么可以定义一个代理键作为主键。这样可以保证数据行是按顺序写入，对于根据主键做关联操作的性能也会更好。<br><strong>最好避免随机的聚簇索引，特别对于I/O密集型的应用。</strong></p><h2><span id="覆盖索引">覆盖索引</span></h2><p>如果一个索引包含所有需要查询的字段的值，我们就称之为“覆盖索引”。</p><p>覆盖索引可以极大的性能，如果查询只需要扫描索引而无需回表。<br>覆盖索引可以带来的好处：</p><ol><li>索引条目通常远小于数据行的大小，所以如果只需要读取索引，那么MySQL就会极大的减少数据访问量。</li><li>因为索引是按照列值顺序存储的，所以对于I/O密集型的范围查询会比随机从磁盘读取每一行数据的I/O要少得多。</li><li>一些存储引擎入MyISAM在内存中只缓存索引，数据则依赖于操作系统来缓存。因此范围数据得开销很大，使用覆盖索引可以避免这种开销。</li><li>由于InnoDB得聚簇索引，覆盖索引对InNoDB表特别有用。</li></ol><p>不是所有类型得索引都可以成为覆盖索引。覆盖索引必须要存储索引列得值，而哈希索引、空间索引和全文索引等都不存储索引列的值。</p><p>MySQL不能在索引中执行LIKE操作。</p><h2><span id="使用索引扫描来排序">使用索引扫描来排序</span></h2><p>MySQL有两种方式可以生成有序的结果：通过排序操作；或按索引顺序扫描。<br>扫描索引本身是很快的，因为只需要从一条索引记录移动到紧接着的下一条记录。<br><strong>但是如果索引不能覆盖查询所需的全部列，那就不得不每扫描一条索引记录就都回查询一次对应的行</strong></p><p>MySQL可以使用同一个索引既能满足排序，又用于查找行。</p><p>只有当索引的列顺序和order by子句的顺序完全一致，并且所有列的排序方向（倒序或正序）都一样时，没有申请完了才能够使用索引来对结果做排序。如果查询需要关联多个表，则只有当order by子句引用的字段全部为第一个表时，才能使用索引做排序。只有当order by子句的前导列为常量时，可以不满足索引的最左前缀的要求。</p><h2><span id="压缩前缀压缩索引">压缩（前缀压缩）索引</span></h2><p>MyISAM使用前缀压缩来减少索引的大小，从而让更多的索引可以放入内存中。<br>压缩块使用更少的空间，代价是某些操作可能更慢。因为每个值得压缩前缀都依赖于前面的值，所以MyISAM查找时无法在索引块使用二分查找而只能从头开始扫描。</p><h2><span id="冗余和重复索引">冗余和重复索引</span></h2><p>MySQL允许在相同列上创建多个索引，无论时有意的还是无意的。MySQL需要单独维护重复的索引，并且优化器在优化查询的时候也需要逐个的进行考虑，这回影响性能。</p><p>重复索引是指在相同的列上按照相同的顺序创建的相同类型的索引，发现后应该立即移除。</p><p>冗余索引和重复索引有一些不同。如果创建了索引（A，B），再创建索引（A）就是冗余索引，因为这只是前一个索引的前缀索引。<br>大多数情况下都不需要冗余索引，应该尽量拓展已有的索引而不是创建新索引。当也有时候处于性能方面的考虑需要冗余索引，因为拓展已有的索引会导致其变得太大，从而影响其它所用该索引的查询的性能。</p><h2><span id="未使用的索引">未使用的索引</span></h2><p>除了冗余索引和重复索引，可能还会有一些服务器永远用不到的索引，这样的索引完全是累赘，建议直接删除。</p><h2><span id="索引和锁">索引和锁</span></h2><p>索引可以让查询锁定更少的行，如果该查询从不访问那些不需要的行，那么就会锁定更少的行，从两个方面来看这对性能都有好处。<br>InoDB只有再访问行的时候才会对其加锁，而索引能够减少InnoDB访问的行数，从而减少锁的数量。</p><h2><span id="维护索引和表">维护索引和表</span></h2><p>损坏的索引会导致查询返回错误的结果或者莫须有的主键冲突等问题，严重时甚至还会导致数据库的崩溃。一些存储引擎可以使用<code>check table</code>来检查表的损坏，使用<code>repair table</code>命令来修复损坏的表。</p><h2><span id="更新索引统计信息">更新索引统计信息</span></h2><p>MySQL的查询优化器会通过两个API来了解存储引擎的索引值的分布信息，已决定如何使用索引。第一个API是<code>records_in</code>,通过向存储引擎传入两个边界值获取在这个范围大概有多少条记录。第二个API是info(),该接口返回各种数据类型的数据，包括索引的基数。</p><h2><span id="减少索引和数据的碎片">减少索引和数据的碎片</span></h2><p>B-Tree索引可能会碎片化，这会降低查询的效率。碎片化的索引可能会以很差或者无序的方式存储在磁盘上。B-Tree需要随机磁盘访问才能定位到叶子也，所以随机访问是不可避免的。如果叶子页在物理分布上是顺序且紧密的，那么查询的性能就会更好。</p><p>行碎片：<br>指数据行被存储为多个地方的多个片段中，即使查询只从索引中访问一行记录，行碎片也会导致性能下降。<br>行间碎片：<br>指逻辑上顺序的页，在磁盘上不是顺序存储的。<br>剩余空间碎片：<br>剩余空间碎片是指数据页中有大量的空闲空间。</p><h2><span id="总结">总结</span></h2><p>选择索引和利用索引的三条重要原则：</p><ol><li>单行访问是很慢的。</li><li>按顺序访问数据是很快的。</li><li>覆盖索引是很快的。如果一个索引包含了查询需要的所有列，那么存储引擎就不在需要回表查找行。</li></ol><p><strong>在编写查询语句时应该尽可能选择合适的索引以避免单行查找，尽可能地使用数据原生顺序从而避免额外地排序操作，并尽可能使用索引覆盖查询。</strong></p><h2><span id="优化数据访问">优化数据访问</span></h2><p>查询性能低下最基本地原因是访问地数据太多。大部分性能低下地查询都可以通过减少访问地数据量地方式进行优化。</p><p>分析步骤：</p><ol><li>确认应用程序是否在检索大量超过需要的数据。</li><li>确认MySQL服务器层是否在分析大量超过需要的数据行。</li></ol><h3><span id="是否向数据库请求了不需要的数据">是否向数据库请求了不需要的数据</span></h3><p>有些查询会请求超过实际需要的数据，然后这些多余恶的数据会被应用程序丢弃。<br>典型案例：</p><ol><li>查询不需要的记录。</li><li>多表关联时返回全部列</li><li>总是取出全部列</li><li>重复查询相同的数据</li></ol><h3><span id="mysql是否在扫描额外的记录">MySQL是否在扫描额外的记录</span></h3><p>衡量MySQL查询开销的三个指标：</p><ol><li>响应时间</li><li>扫描的行数</li><li>返回的行数</li></ol><p>一般MySQL能够使用如下三种方式应用where条件，由好到坏依次为：</p><ol><li>在索引中使用where条件来过滤不匹配的记录。这是在存储引擎层完成的，</li><li>使用覆盖索引扫描来返回记录，直接从索引中过滤不需要的记录并返回命中的结果。这是在MySQL服务层完成的，无需回表。</li><li>从数据表中返回数据，然后过滤不满足条件的记录。这是在MySQL服务层完成的。</li></ol><p>如果方向查询需要扫描大量的数据但只返回少数的行，通常可以使用以下方法去优化：</p><ol><li>使用索引覆盖扫描</li><li>该表库表结构，比如引入单独的汇总表。</li><li>重写复杂的查询，让MySQL优化器能够以更优的方式执行这个查询。</li></ol><h2><span id="重构查询的方式">重构查询的方式</span></h2><h3><span id="切分查询">切分查询</span></h3><p>有时候对于一个大查询我们需要“分而治之”，间大查询切分成小查询，每个查询完全一样，只是完成一小部分，每次只发返回一小部分查询结果。</p><p>比如在删除旧数据，间一个大的语句分解为几个小数据，可以避免一次性锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但是重要的查询。</p><h3><span id="分解关联查询">分解关联查询</span></h3><p>很多高性能的应用都会对关联查询进行分解。简单讲，就是可以对每个表进行一次单表查询，然后将结果在应用程序中进行关联。</p><p>用分解关联查询的方式重构查询的优势：</p><ol><li>让缓存的效率更高</li><li>将查询分解后，执行单个查询可以减少锁的竞争。</li><li>在应用层做关联，可以更容易对数据库进行拆分，更容易做到高性能和可拓展。</li><li>查询本身效率也可能回有所提升。</li><li>可以减少冗余记录的查询。</li><li>分解后相当于在应用层中实现了哈希关联，而不是使用MySQL的嵌套循环关联。</li></ol><h2><span id="查询执行的基础">查询执行的基础</span></h2><p>MySQL执行一个查询的过程。<br><img src="https://s2.ax1x.com/2019/09/20/nXZcWV.png" alt="nXZcWV.png"></p><h3><span id="mysql客户端服务器通信协议">MySQL客户端/服务器通信协议</span></h3><p>MySQL客户端和服务器之间的通信协议是“半双工”的，这意味着在任何一个时期，要么是由服务器向客户端发送数据，要么是由客户端向服务器发送数据，这两个动作不能同时发生。</p><p>这种协议让MySQL通信简单快速，但是也从很多地方限制了MySQL，一个明显的限制是，没办法继续宁流量控制。因此，在查询很长的数据时，参数<code>max_alllowed_packet</code>特别的重要。</p><h3><span id="一个查询的状态">一个查询的状态</span></h3><ol><li>Sleep：线程正在等待客户端发送新的请求</li><li>Query：线程正在执行查询或正在将结果发送给客户端</li><li>Locked：在MySQL服务器层，该线程正在等待表锁。</li><li>Analyzing and statstics ：线程正在收集存储引擎的统计信息，并生成查询的执行计划。</li><li>Copying to tmp table：线程正在执行查询，并将其结果集都复制到一个临时表中。</li><li>Sorting result:线程正在对结果集进行排序</li><li>Sending data:这种状态可能有多种可能，线程可能在多个状态之间传送数据，或者在生成结果集，或者向客户端返回数据。</li></ol><h3><span id="查询缓存">查询缓存</span></h3><p>在解析一个查询语句之前，如果查询缓存是打开的，那么MySQL会优先检查这个查询是否命中查询缓存中的数据。这个查询时通过一个对大小写敏感的哈希查找来实现的。</p><h3><span id="查询优化处理">查询优化处理</span></h3><p>查询优化处理包含多个子阶段：解析SQL、预处理、优化SQL执行计划。任何错误都可能终止查询。</p><ol><li>语法解析器和预处理<br>MySQL通过关键字将SQL语句进行解析，并生成一颗对应的“解析树”。MySQL解析器将使用MySQL语法规则验证和解析查询。<br>预处理器则会根据一些MySQL规则进一步检查解析器是否合法。下一步预处理器会验证权限。</li></ol><h3><span id="查询优化器">查询优化器</span></h3><p>优化器要将语法树转化为执行计划。MySQL使用基于成本的优化器，它尝试预测一个查询使用某种执行计划时的成本，并选择其中成本最小的一个。</p><p>有很多原因会导致MySQL优化器选择错误的执行计划：</p><ol><li>统计信息不准确。MySQL依赖存储引擎提供的统计信息来评估成本，但是又的存储引擎提供的信息时不准确的，又的偏差可能很大。</li><li>执行计划中的成本估算不等同于实际执行的成本。</li><li>MySQL的最优可能和你想想的最优不一样。</li><li>MySQL从不考虑并发执行的查询。</li><li>MySQL也并不是任何时候都是基于成本的优化。有时也会利用一些固定的规则。</li><li>MySQL不会考虑不受器控制的操作的成本，例如执行存储过程或者用户自定义行数的成本。</li></ol><p>优化策略简单的分为两种，一种时静态优化，一种时动态优化。静态优化可以直接对解析树进行分析，并完成优化，<strong>第一次完成之后旧一直有效</strong>，可认为这是一种“编译时优化“。<br>动态优化则和查询的上下文有关，也可能和其它很多因素有关。需要在<strong>每次查询时都进行重新评估</strong>，可以认为这是”运行时优化“。</p><p>MySQL能够处理的优化类型：</p><ol><li>重新定义关联表的顺序。</li><li>将外连接转化成为内连接。</li><li>使用等价变换规则</li><li>优化COUNT()\MIN()和MAX()</li><li>预估并转化为常数表达式</li><li>覆盖索引扫描</li><li>子查询优化</li><li>提前终止查询</li><li>等值传播</li><li>列表IN的比较</li></ol><h3><span id="数据和索引的统计信息">数据和索引的统计信息</span></h3><p>统计信息有存储引擎实现，不同的存储引擎可能会存储不同的统计信息。因为服务层没有任何统计信息，所以MySQL查询优化器在生成查询的执行计划时，需要向存储引擎获取相应的统计信息。</p><h3><span id="mysql如何执行关联查询">MySQL如何执行关联查询</span></h3><p>MySQL中关联一词所包含的含义比一般意义上理解的要更广泛。中的来说，MySQL认为<strong>任何一个查询都是一次”关联”</strong>，并不仅仅时一个查询需要到两个表匹配才叫关联，所以在MySQL中，每一个查询，每一个片段都可能是关联的。<br>在MySQL的概览中，每个查询都是一次关联，所以读取结果临时表也是一次关联。</p><p>MySQL关联执行的策略很简单，MySQL对任何关联都执行嵌套循环关联操作，集MySQL现在表中循环取出单条数据，然后再嵌套循环到下一个表中寻找匹配的行，依次下去，直到找到的所有表中匹配的行为止。</p><h3><span id="执行计划">执行计划</span></h3><p>MySQL并不会生成查询字节码来执行查询，MySQL生成的查询的一颗指令树，然后通过存储引擎执行完成这颗指令树并返回结果。</p><p>任何多表查询都可以用一棵树来表示：<br>例如执行一个四表的关联操作：<br><img src="https://s2.ax1x.com/2019/09/20/nvFd1S.png" alt="nvFd1S.png"></p><h3><span id="关联查询优化器">关联查询优化器</span></h3><p>关联查询优化器它决定了多个表关联时的顺序。通过多表关联时，可以有多种不同的关联顺序来获得相同的执行结果</p><h3><span id="排序优化">排序优化</span></h3><p>无论如何排序都是一个成本很高的操作，所以从性能角度考虑，应该尽可能避免排序或者尽可能避免对大量数据进行排序。</p><p>MySQL可以铜鼓索引进行排序，如果不能使用索引进行排序，且数据量较少的时候可以在排序缓存池中完成，如果排序缓存池一次装不下，就分块排序后放回磁盘，并进行合并。</p><p>新版本的MySQL使用的是单次传输排序。先读取查询所需要的所有列，然后再根据给定列进行排序，最后直接返回排序结果。</p><h3><span id="查询执行引擎">查询执行引擎</span></h3><p>再解析和优化阶段，MySQL将生成查询对应的执行计划，MySQL的查询执行引擎则根据这个计划来完成整个查询。MySQL只是简单的根据执行计划给出的指令逐步执行。在根据执行计划逐步执行的过程中，有大量的操作需要通过调用存储引擎实现的接口来完成。</p><h3><span id="返回结果给客户端">返回结果给客户端</span></h3><p>查询执行的最后一个阶段是将结果返回给客户端。即使查询不需要返回结果集给客户端，MySQL仍然会返回整个查询的一些信息，如该查询影响刀的行数。MySQL将结果集返回客户端是一个增量、、逐步返回的过程。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;索引基础&quot;&gt;&lt;a href=&quot;#索引基础&quot; class=&quot;headerlink&quot; title=&quot;索引基础&quot;&gt;&lt;/a&gt;索引基础&lt;/h2&gt;&lt;p&gt;索引类似于书的目录。存储引擎在索引中找到对应值，然后再根据匹配的索引记录找到对应的数据行。&lt;br&gt;索引可以包含一个活多个列的值。如果索引包含多个列，那么列的顺序也十分重要，因为MySQL只能高校地利用索引地最左前缀列。&lt;/p&gt;
&lt;h2 id=&quot;索引的类型&quot;&gt;&lt;a href=&quot;#索引的类型&quot; class=&quot;headerlink&quot; title=&quot;索引的类型&quot;&gt;&lt;/a&gt;索引的类型&lt;/h2&gt;&lt;p&gt;索引有很多类型，MySQL的索引是在存储引擎层实现的，所以没有统一的索引标准。&lt;/p&gt;
&lt;h3 id=&quot;B-Tree索引&quot;&gt;&lt;a href=&quot;#B-Tree索引&quot; class=&quot;headerlink&quot; title=&quot;B-Tree索引&quot;&gt;&lt;/a&gt;B-Tree索引&lt;/h3&gt;&lt;p&gt;大多少MySQL引擎都支持这种索引。他们的内部实现也是不同的，有些存储引擎使用T-Tree结构存储这种索引，有些使用B+Tree。当然性能也各有不同。&lt;br&gt;B-Tree通常意味着所有的值都是按顺序存储的，并且每一个叶子页到根的距离相同相同。&lt;br&gt;B-Tree索引能够加快访问数据的速度，因为存储引擎不再需要进行全表扫描来获取需要的数据，取而代之的是从索引的根节点开始进行搜索。&lt;br&gt;&lt;strong&gt;B-Tree对索引是顺序组织存储的，所以很适合查找范围数据&lt;/strong&gt;&lt;br&gt;索引对多个值进行排序的依据是建表语句中定义的索引列的顺序进行排序的。&lt;br&gt;B-Tree索引适用于全键值、键值范围或键前缀查找。其中键前缀查找只适用于根据最左前缀的操作。&lt;br&gt;&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;create&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;table&lt;/span&gt; People(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    last_name &lt;span class=&quot;built_in&quot;&gt;varchar&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;50&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    first_name &lt;span class=&quot;built_in&quot;&gt;varchar&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;50&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dob &lt;span class=&quot;built_in&quot;&gt;date&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    gender enum(&lt;span class=&quot;string&quot;&gt;&#39;m&#39;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&#39;f&#39;&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;key&lt;/span&gt;(last_name,first_name,dob)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程编程实战指南读书笔记四</title>
    <link href="http://yoursite.com/2019/09/16/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E6%8C%87%E5%8D%97%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E5%9B%9B/"/>
    <id>http://yoursite.com/2019/09/16/Java多线程编程实战指南读书笔记四/</id>
    <published>2019-09-16T02:15:56.000Z</published>
    <updated>2019-09-26T12:50:02.958Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="java运行时存储空间">java运行时存储空间</span></h2><p>Java运行时空间可以非位堆空间，栈空间和非堆空间<strong>。其中堆空间和非堆空间时被多个线程共享的</strong>，而栈空间则是线程的私有空间。每个线程都有自己<strong>私有的</strong>栈空间。<br>栈空间时为线程的执行而准备的一段固定大小的内存空间，栈空间时线程创建的时候非配的。线程的方法调用是利用栈帧。局部变量的变量之存储在栈空间中，基础类型变量和引用的类型的变量的变量值都是直接存储在栈帧中的。<br><strong>由于一个线程无法访问另一个线程的栈空间，所以线程堆局部变量以及对只能通过当前线程的局部变量才能访问的对象进行操作具有固有的线程安全性</strong><br>堆空间用于存储对象，它也时垃圾回收器工作的场所，即堆空间中没有可达引用的对象会被回收。<br>非堆空间用于存储常量以及类的元数据等，它是Java虚拟机系统的时候分配的一段可以动态扩容的内存空间。类的元数据包括类的静态变量、类有哪些方法以及这些方法的元数据（包括名称，参数和返回值等）<br><a id="more"></a></p><h2><span id="无状态对象">无状态对象</span></h2><p>对象是对操作和数据的封装，对象所包含的数据就被称为该对象的状态。如果一个类的同一个实例被多个线程共享并不会使这些线程存在共享状态，那么这个类及其任意一个实例就被称为无状态对象。</p><p>线程安全的本质来源于多个线程之间存在共享数据，因此无状态对象使线程安全的。</p><p>无状态对象具有线程安全性，这有两层含义：</p><ol><li>无状态对象的客户端代码在调用任何该对象的任何方法时都无须进行加锁。</li><li>其次无状态对象自身的方法实现也无需使用锁。</li></ol><p><strong>无状态对象不包含任何实例变量或者可更新静态变量，但是一个不包含任何实例变量或者静态变量却不一定是无状态对象。特殊情况下，不包含任何实例变量或者静态变量的类，其方法实现时仍然需要借助锁来保障线程安全。</strong></p><h2><span id="不可变对象">不可变对象</span></h2><p>不可变对象是指一经创建其就会保持不变的对象。不可变对象也具有固有的线程安全性。</p><p>严格意义的不可变对象需要满足的条件：</p><ol><li>类本身使用final修饰：防止通过创建子类来改变其定义的行为</li><li>所有字段都需要使用final修饰：确保字段值保持不变，更重要的是在多线程环境下保证了被修饰字段的初始化安全。</li><li>对象在此初始化过程中没有逸出</li><li>任何字段如果引用了其它状态可变的对象（如集合，数组）则这些字段必须是private修饰的。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个典型的不可变对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Canditiion</span> <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">Endpoint</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//引用了其它状态可变的对象,需要使用private修饰</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Endpoint&gt; endpoints;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> totalWeight;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Canditiion</span><span class="params">(Set&lt;Endpoint&gt; endpoints)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(Endpoint endpoint:endpoints)&#123;</span><br><span class="line">            sum+=endpoint.weight;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.totalWeight=sum;</span><br><span class="line">        <span class="keyword">this</span>.endpoints=endpoints;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;Endpoint&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ReadOnlyIterator.with(endpoints.interator);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然不可变对象自身的实例变量或者静态变量的值是不可变的，但是这些变量所引用的对象本身的状态可能是可变的。如果这些对象所包含的状态对外暴露的话，那么我们需要注意这些对象状态也不能被改变。</p><h3><span id="不可变对象的应用场景">不可变对象的应用场景</span></h3><ol><li>被建模对象的状态变化不频繁</li><li>同时对一组相关的数据进行写操作，因此需要保证原子性。</li><li>使用不可变对象作为安全可靠恶的Map键。</li></ol><h2><span id="线程特有对象">线程特有对象</span></h2><p>各个线程都创建一个自有的实例，一个实例只能被一个线程访问的对象就被称为线程<strong>特有对象</strong>。ThreadLocal<t>类相当于线程访问器线程特有对象的代理。线程通过这个对象可以创建并访问各自的线程特有对象。<br><img src="https://s2.ax1x.com/2019/09/13/nrHVBT.png" alt="nrHVBT.png"></t></p><p>ThreadLocal类的常用方法<br><img src="https://s2.ax1x.com/2019/09/13/nrOcyn.png" alt="nrOcyn.png"></p><p>ThreadLocal实例通常会被作为某个类的静态字段使用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个随机数生成器</span></span><br><span class="line"><span class="comment">//使用ThreadLocal避免锁的争用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> ThreadSpecilficSecureRandom&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> ThreadLocal&lt;SecureRandom&gt; SECURE_RANDOM</span><br><span class="line">            =<span class="keyword">new</span> ThreadLocal&lt;SecureRandom&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> SecureRandom <span class="title">initialValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">            SecureRandom srnd;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                srnd=SecureRandom.getInstance(<span class="string">"SHA1PRNG"</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (NoSuchAlgorithmException e)&#123;</span><br><span class="line">                srnd=<span class="keyword">new</span> SecureRandom();</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            srnd.nextBytes(<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">20</span>]);</span><br><span class="line">            <span class="keyword">return</span> srnd;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nexeInt</span><span class="params">(<span class="keyword">int</span> upperBound)</span></span>&#123;</span><br><span class="line">        SecureRandom random = SECURE_RANDOM.get();</span><br><span class="line">        <span class="keyword">return</span> random.nextInt(upperBound);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSeed</span><span class="params">(<span class="keyword">long</span> seed)</span></span>&#123;</span><br><span class="line">        SecureRandom random = SECURE_RANDOM.get();</span><br><span class="line">        random.setSeed(seed);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3><span id="线程特有对象的典型应用场景">线程特有对象的典型应用场景</span></h3><ol><li>需要使用非线程安全的对象，但不希望因此而引入锁。</li><li>使用线程安全对象，但希望避免其它使用锁的开销和相关问题。</li><li>隐式参数传递。线程特有对象在一个具体的线程中，他是线程全局可见的。</li><li>特定于线程的单例模式。</li></ol><h2><span id="装饰器模式">装饰器模式</span></h2><p>装饰器模式可以用来实现线程安全，其基本思想式为非线程安全对象创建一个相应的线程安全的外包装对象。客户端代码不直接访问非线程安全对象而实访问器外包装对象。</p><p>java.util.Conllections.synchroniezdX(X可以是set，list，map等)方法就是使用装饰器模式将指定的非线程安全的集合对象对外暴露为线程安全的对象。<br>使用装饰器模式装饰的线程安全的对象也要注意。他们返回的同步集合存在弊端，这些集合返回的Interator实例并不是线程安全的。所以我们<strong>需要给遍历操作加锁</strong>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正确的遍历同步集合</span></span><br><span class="line"> <span class="keyword">final</span> List&lt;String&gt; synchronizedList = Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;String&gt;());</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dump</span><span class="params">()</span></span>&#123;</span><br><span class="line">       Iterator&lt;String&gt; iterator = synchronizedList.iterator();</span><br><span class="line">       <span class="comment">//必须正确的加锁</span></span><br><span class="line">       <span class="keyword">synchronized</span>(synchronizedList)&#123;</span><br><span class="line">           <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">               System.out.println(iterator.next());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>对同步集合进行遍历操作时，我们需要<strong>以被遍历同步集合对象本身作为内部锁</strong>。这样做的实质是利用了内部锁的排他性，从而阻止了遍历过程中其它线程改变了同步集合的内部结构。这种不利用提高并发。</p><h2><span id="并发集合">并发集合</span></h2><p>java 1.5以后java.util.concurrent包中引入了一些线程安全的集合对象，他们被称为并发集合。<br><img src="https://s2.ax1x.com/2019/09/13/nsZjWd.png" alt="nsZjWd.png"><br>并发集合对象自身就支持对其进行线程安全的遍历操作。<br><strong>如果由多个线程需要对同一并发集合进行遍历操作，那么这些线程不适合共享同一个Iterator实例</strong><br>并发集合内部再保障其线程安全的时候通常不借助锁，而是使用CAS操作，或者对锁的使用进行了优化。</p><h2><span id="死锁">死锁</span></h2><p>如果两个或多个线程因相互等待对方而被永远暂停，那么我们就称这些线程产生了死锁。由于产生死锁的线程的生命周期状态永远是非运行状态，因此这些线程所要执行的任务也<strong>永远无法进展</strong>。</p><p><img src="https://s2.ax1x.com/2019/09/14/n6FwkQ.png" alt="n6FwkQ.png"></p><h3><span id="死锁产生的条件与规避">死锁产生的条件与规避</span></h3><p>可能产生死锁的必要非充分条件：</p><ol><li>资源互斥。涉及到的资源必须是独占的，即每个资源一次只能够杯一个线程使用。</li><li>资源不可抢夺。涉及的资源只能够杯其持有者主动释放，而无法杯资源的持有者和申请者之外的第三方线程所抢夺（被动释放）</li><li>占用并等待资源。涉及到的线程当前至少持有一个资源，并申请其它资源，如果需要等待其它线程释放资源，在等待过程中，线程不会释放其已经持有的资源。</li><li>循环等待资源。涉及到的形成必须在等待别的线程持有的资源，而这些线程又反过来在等待第一个线程所持有的资源。</li></ol><p>死锁的代码特征：<br><img src="https://s2.ax1x.com/2019/09/14/n6VAAO.png" alt="n6VAAO.png"></p><p><strong>一个线程在已经持有一个锁的情况下再次申请这个锁，并不会导致死锁。</strong>这是因为Java中的锁（包括内部锁和显式锁）都是可重入的。</p><h3><span id="规避死锁的方法">规避死锁的方法</span></h3><p>规避死锁只能从两个方面下手：消除“占用并等待资源”和消除“循环等待资源”。</p><p>几种方法：</p><ol><li>粗锁法。使用粗粒度的锁代替多个锁。从而消除“占用并等待资源”</li><li>锁排序法。相关线程使用全局同一的顺序申请锁。假设又多个线程需要申请资源（锁），呢吗我们只徐娅让这些线程一张一个全局统一的顺序区申请这些资源，就可以消除“循环等待资源”这个条件，从而规避死锁。</li><li>使用ReentrantLock.tryLock(long,TimeUnit)申请锁。它允许我们位锁的申请这个操作设定一个超时时间。可以避免线程无限制的等待，从而消除“占用并等待资源”</li><li>使用开放调用，在调用外部方法时不加锁</li><li>使用锁的替代品</li></ol><h2><span id="锁死">锁死</span></h2><p>等待线程由于唤醒其所需的条件永远无法成立，或者其它线程无法唤醒这个线程而一直处于非运行状态（线程并未终止）导致其任务一直无法进展。</p><h3><span id="信号丢失锁死">信号丢失锁死</span></h3><p>信号丢失锁死是由于没有相应的通知线程来唤醒等待线程而使得等待线程一直处于等待状态的一种活性故障。</p><p>信号丢失的典型例子：<br>等待线程在执行Object.wait()/Condition.await()前没有对保护条件进行判断，而此时保护条件时间上已经成立，然而此后可能并无其它线程更新相应保护条件涉及的共享遍历使其成立并通知等待线程。</p><h3><span id="嵌套监视器锁死">嵌套监视器锁死</span></h3><p>嵌套监视器锁死是嵌套锁导致等待线程永远无法被唤醒的一种活性故障，</p><p><img src="https://s2.ax1x.com/2019/09/14/n6IIiQ.png" alt="n6IIiQ.png"></p><p>等待线程在执行到monitorY.wait()的时候会被暂停并且其所持有的所monitorY会被释放，但是等待线程持有的外层锁monitorX并不会被释放掉。通知线程在唤醒等待线程后，monitorY所引导的临界区位于monitorX引导的临界区之内，因此通知线程必须向持有外层锁monitorX，而这个时候monitorX被其它线程持有，这个时候就通知线程就无法唤醒受保护的方法，这样就形成了锁实。</p><h2><span id="线程饥饿">线程饥饿</span></h2><p>线程饥饿是指线程<strong>一直无法获得其所需要的资源</strong>而导致其任务一直无法进展的一种活性故障。</p><p>把锁看作一种资源，那么我们不难发现死锁也是一种线程饥饿。失锁的结果是故障线程都无法获得其所需要的全部锁中的一个锁，导致使其任务一直无法进展。</p><p>线程饥饿的一个典型例子是在高争用的环境下使用非公平模式的读写锁。</p><h2><span id="活锁">活锁</span></h2><p>活锁是指线程一直处于运行状态，但是其任务却一直无法进展的一种活性故障。也就是说，产生活锁的线程一直在做无用功。</p><p>线程一直在申请其所需的资源而一直未申请成功，那么此时线程饥饿实际上就演变成为了活锁。</p><h2><span id="线程组">线程组</span></h2><p>线程组（ThreadGroup类）可以用来表示一组相似的线程。<br>Thread类有几个构造器允许我们在创建线程的时候指定线程所属的线程组，如果没有指定线程组，那么这个线程就属于其父线程所属的线程组。由于java虚拟机在创建main线程的时候会为其指定一个线程组，因此java平台中的任何一个线程都有一个线程组与之关联。<br><strong>线程组的设计有许多缺陷，现在已经用得很少</strong>。</p><h2><span id="线程的未捕获异常与监控">线程的未捕获异常与监控</span></h2><p>如果线程的run方法抛出未被捕获的异常，那么随着run方法的退出，相应的线程也提前终止。对于线程的这种异常终止，我们可以得知并做出补救。<br>Thread类内部定义了一个UncaughtExceptionHandler接口。该接口是在Thread类内部定义的。它只有一个方法：<br><code>void uncaughtException(Thread t,Throwable e)</code><br>该方法包含两个参数，一个是异常终止的线程本身，以及导致线程提前终止的异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadMonitorDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> inited=<span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> threadIndex=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">final</span> BlockingQueue&lt;String&gt; channel=<span class="keyword">new</span> ArrayBlockingQueue&lt;String&gt;(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ThreadMonitorDemo threadMonitor = <span class="keyword">new</span> ThreadMonitorDemo();</span><br><span class="line">        threadMonitor.init();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            threadMonitor.service(<span class="string">"message"</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        System.exit(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(inited)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"开始启动"</span>);</span><br><span class="line">        WokerThread thread=<span class="keyword">new</span> WokerThread();</span><br><span class="line">        thread.setName(<span class="string">"woker-"</span>+threadIndex++);</span><br><span class="line">        thread.setUncaughtExceptionHandler(<span class="keyword">new</span> ThreadMonitor());</span><br><span class="line">        thread.start();</span><br><span class="line">        inited=<span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(String message)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        channel.put(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ThreadMonitor</span> <span class="keyword">implements</span> <span class="title">Thread</span>.<span class="title">UncaughtExceptionHandler</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> </span>&#123;</span><br><span class="line">            System.out.println(t.getName()+<span class="string">"异常终止"</span>);</span><br><span class="line">            System.out.println(<span class="string">"启动替代线程"</span>);</span><br><span class="line">            inited=<span class="keyword">false</span>; <span class="comment">//重置启动标志</span></span><br><span class="line">            init();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">WokerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"工作线程开始工作"</span>);</span><br><span class="line">            String msg;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">                    msg=channel.take();</span><br><span class="line">                    process(msg);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"处理message:"</span>+message);</span><br><span class="line">            <span class="keyword">if</span>((<span class="keyword">int</span>)(Math.random()*<span class="number">100</span>)&lt;<span class="number">2</span>)&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"test"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            Utils.randomPauser(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="线程工厂">线程工厂</span></h2><p>从jdk1.5开始Java标准库提供了创建线程的工厂方法。ThreadFactory接口时工厂方法的模式的一个实例，它定义了如下工厂方法：<br><code>public Thread newThread(Runnable r)</code><br>我们可以在ThreadFactory.newThread方法中封装线程创建的逻辑，这使得我们能够以统一的方式未线程的创建、配置做一些非常有用的动作。</p><h2><span id="线程池">线程池</span></h2><p>线程是一种昂贵的资源，其开销包括以下几个方面：</p><ol><li>线程的创建和启动的开销</li><li>线程的销毁开销</li><li>线程的调度开销</li><li>一个系统能够创建的线程总是受限于该系统所拥有的处理器数目</li></ol><p>线程池的实现和一些对象池的实现不同，线程池内部可以预先创建一定数量的工作者线程，客户端代码并不需要向线程池借用线程而是将其需要执行的任务作为一个对象提交给线程池，线程池可能将这些任务缓冲在队列之中，而线程池内部的各个工作者向则不断地从队列中取出任务并执行。</p><p><img src="https://s2.ax1x.com/2019/09/15/nglvdJ.png" alt="nglvdJ.png"></p><p>java.util.concurrent.ThreadPpplExecutor类就是一个线程池，客户端代码可以调用<br><code>public Future&lt;?&gt; submint(Runnable task)</code></p><p>ThreadPoolexecutor中地参数数量最多地一个构造器<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor(<span class="keyword">int</span> corePoolSize, </span><br><span class="line">                    <span class="keyword">int</span> maximumPoolSize,</span><br><span class="line">                    <span class="keyword">long</span> keepAliveTime,</span><br><span class="line">                    TimeUnit unit, </span><br><span class="line">                    BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                    ThreadFactory threadFactory, </span><br><span class="line">                    RejectedExecutionHandler handler)</span><br></pre></td></tr></table></figure></p><p>其中workQueue是被称为工作队列地阻塞队列，corePoolSize用于指定线程池核心大小，maximumPoolSize用于指定最大线程池大小。keepAliveTime和unit何在一起用于指定线程池中空闲线程地最大存活时间。threadFactory指定用于创建工作者线程地的线程工厂。</p><p>在初始状态下，客户端每提交一个任务线程池就创建一个工作线程来处理任务，随着客户端不断地提交任务，当前线程池地大小也相应地增加。在当前线程池大小达到核心线程池大小地时候，新来地任务会被存入工作队列之中。<br>当工作队列满地时候，线程池会继续传教新地工作者线程，直到当前线程池带线啊哦达到最大线程池大小。<br>当线程池饱和时，即工作者队列满并且当前线程池大小达到最大线程池地大小地情况下，客户端试图提交地任务会被拒绝。Java标准库中引入了一个RejectedExecutionHandler接口用于封装被拒绝地任务地处理策略。接口地定义如下：<br><code>void rejectedExecution(Runnable r,ThreadpoolExecutor executor)</code><br><img src="https://s2.ax1x.com/2019/09/15/ng8xoQ.png" alt="ng8xoQ.png"></p><p>在当前线程池大小超过线程池核心大小地时候，超过线程池核心大小部分地工作者线程空闲时间达到keepAliveTime所指定地时间后就会被清理掉。</p><h3><span id="线程池的启动和关闭">线程池的启动和关闭</span></h3><p>ThreadPoolExecutor.prestartAllCoreThreads()则使得我们可以使线程池在未接受到任何任务的情况下预先创建并启动所有核心线程，这样可以减少任务被线程池处理时所需要的等待时间。</p><p>调用<code>ThreadPoolExecutor.shutdown()/shutdownNow()</code>方法可能用来关闭线程池。使用shutdown()关闭线程池的时候，已提交的任务会被继续执行，而新提交的任务会被拒绝。调用返回时线程池可能尚未关闭，因为其中还有任务没结束。</p><p>可以通过调用<code>ThreadPoolExecutor.awaitTermination(long timeout,TimeUnit unit)</code>来等待线程池关闭结束。<br>可以调用<code>ThreadPoolExecutor.shutdownNow()</code>来立即关闭线程池，正在执行的任务会被终止。</p><h3><span id="任务的处理结果-异常处理与取消">任务的处理结果、异常处理与取消</span></h3><p>如果客户端关心任务的处理结果，那么它可以使用ThreadPoolExecutor中另一个submit方法来提交任务。<br><code>public &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task)</code><br>task表示客户端需要提交的任务，其类型为java.util.concurrent.Callable。其接口定义为：<br><code>V call() throws Exception</code></p><p>上述submit方法的返回值类型为java.util.concurrent.Future.该接口的实例可以看作提交给线程池执行的任务的处理结果句柄，Future.get()方法可以用来获取task参数所指定的任务的处理结果。<br><code>V get() throws InterruptedException,ExecutionException</code><br>Future.get()被调用的时，如果相应的任务尚未执行完毕，法吗Future.get()会使当前线程暂停，直到相应的任务执行结束。</p><p><strong>客户端代码应该尽早地向线程池提交任务，并仅在需要相应任务地处理结果数据地那一刻才调用Future.get()方法</strong></p><h3><span id="线程池死锁">线程池死锁</span></h3><p>如果线程池中执行的任务在执行过程中又会向同一个线程池提交另外一个任务，而前一个任务的执行结果又依赖于后一个任务的执行结果，那么线程池中的所有工作者线程都处于等待其它任务的处理结果而这些任务仍在工作队列中等待执行，这时由于线程池中已经没有可以对工作队列中的任务进程任务的工作者线程，这种等待就会一直持续下去从而形成死锁。</p><p><strong>同一个线程池只能用于执行相互独立的任务。彼此有依赖关系的任务需要提交给不同的线程池执行以避免死锁</strong></p><h2><span id="同步计算与异步计算">同步计算与异步计算</span></h2><p>从多个任务的角度来看，任务可以是串行执行的，也可以是并发执行的。从单个任务的角度来看，任务的执行方式可以是同步的，也可以是异步的。</p><p><img src="https://s2.ax1x.com/2019/09/15/n2GVED.png" alt="n2GVED.png"></p><h2><span id="java-executor框架">Java Executor框架</span></h2><p>Runnable接口和Callable接口都是对任务处理逻辑的抽象。<br>java.util.concurrent.Executor接口则是对任务的执行进行的抽象。<br>该接口的定义为：<br><code>void execute(Runnable command)</code><br>其中command参数代表需要执行的任务，Executor接口使得任务的提交方，只需要知道它调用Executor.execute方法便可以使指定的任务被执行，而无需关心任务的具体执行细节。<br>解耦任务的提交与任务的具体执行细节在一定程度上能够屏蔽任务同步执行和异步执行的差异。<br>Executor接口比较简单，功能也十分有限，它只能为客户端代码执行任务，而无法将任务的处理结果返回给客户端代码。</p><h2><span id="使用工具类executors">使用工具类Executors</span></h2><p>实用工具类java.util.concurrent.Executors<br><img src="https://s2.ax1x.com/2019/09/15/n2adxJ.png" alt="n2adxJ.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;java运行时存储空间&quot;&gt;&lt;a href=&quot;#java运行时存储空间&quot; class=&quot;headerlink&quot; title=&quot;java运行时存储空间&quot;&gt;&lt;/a&gt;java运行时存储空间&lt;/h2&gt;&lt;p&gt;Java运行时空间可以非位堆空间，栈空间和非堆空间&lt;strong&gt;。其中堆空间和非堆空间时被多个线程共享的&lt;/strong&gt;，而栈空间则是线程的私有空间。每个线程都有自己&lt;strong&gt;私有的&lt;/strong&gt;栈空间。&lt;br&gt;栈空间时为线程的执行而准备的一段固定大小的内存空间，栈空间时线程创建的时候非配的。线程的方法调用是利用栈帧。局部变量的变量之存储在栈空间中，基础类型变量和引用的类型的变量的变量值都是直接存储在栈帧中的。&lt;br&gt;&lt;strong&gt;由于一个线程无法访问另一个线程的栈空间，所以线程堆局部变量以及对只能通过当前线程的局部变量才能访问的对象进行操作具有固有的线程安全性&lt;/strong&gt;&lt;br&gt;堆空间用于存储对象，它也时垃圾回收器工作的场所，即堆空间中没有可达引用的对象会被回收。&lt;br&gt;非堆空间用于存储常量以及类的元数据等，它是Java虚拟机系统的时候分配的一段可以动态扩容的内存空间。类的元数据包括类的静态变量、类有哪些方法以及这些方法的元数据（包括名称，参数和返回值等）&lt;br&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="并发编程" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
</feed>
