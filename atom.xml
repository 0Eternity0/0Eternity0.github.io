<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>个人博客</title>
  
  <subtitle>博观而约取 厚积而薄发</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-02-24T13:53:07.420Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>爱写代码的小书童</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Netty学习笔记二</title>
    <link href="http://yoursite.com/2020/02/24/Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/"/>
    <id>http://yoursite.com/2020/02/24/Netty学习笔记二/</id>
    <published>2020-02-24T13:52:00.000Z</published>
    <updated>2020-02-24T13:53:07.420Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="什么是tcp粘包和拆包">什么是TCP粘包和拆包？</span></h2><p>TCP是一个“流”协议，所谓流就是没有界限的一串数据。TCP协议会根据TCP缓冲区的实际情况对包进行划分，所以业务上的一个包，可能被TCP拆分为多个包发送（拆包），多个小的包也可能被TCP合并为一个包进行发送（粘包）。</p><h2><span id="tcp粘包和拆包发生的原因">TCP粘包和拆包发生的原因</span></h2><p>原因有三个：</p><ol><li>应用程序write写入的字节大小大于套接字缓冲区的大小</li><li>进行MSS（maximum segment size，最大分节大小，为TCP数据包每次传输的最大数据分段大小）大小的TCP分段</li><li>以太帧的payload大于MTU（maximum transmission unit，最大传输单元，由硬件规定）进行IP分片<a id="more"></a></li></ol><h2><span id="粘包问题的解决策略">粘包问题的解决策略</span></h2><p>由于底层的TCP无法理解上层的业务数据，所以在底层是无法保证数据包不被拆分和重组，这个问题只能通过上层的应用协议栈设计来解决。<br>一些解决方案如下：</p><ol><li>消息定长，每个报文的长度固定，如果不够，空位补空格。</li><li>在包尾增加回车换行符进行分割，如FTP协议。</li><li>将消息分为消息头和消息体，消息头中包含一个表示消息总长度的字段。</li><li>更复杂的应用层协议。</li></ol><h2><span id="如何使用netty解决粘包问题">如何使用Netty解决粘包问题</span></h2><p>解决粘包问题的关键就在于要解决服务器端每次读取数据长度的问题。可以使用自定义协议+编解码器来解决。</p><p>比如使用<code>LineBasedFrameDecoder</code>和<code>StringDecoder</code>来解决TCP粘包导致的读半包问题。<br>其原理就是依次遍历ByteBuf中的可读字节，判断是否有”\n”或者“\r\n”,如果有，就以此为结束位置，从可读索引到结束位置区间的字节就组成了一行。</p><p>上面是采用分隔符的方式，我们还可以通过实现自己的编解码器利用定长包来处理粘包。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XDecoder</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//包的长度</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PACKET_SIZE = <span class="number">220</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用来临时保留没有处理过的请求报文</span></span><br><span class="line">  ByteBuf tempMsg = Unpooled.buffer();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> ctx</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> in 请求的数据</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> out 将粘在一起的报文拆分后的结果保留起来</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    System.out.println(Thread.currentThread() + <span class="string">"收到了一次数据包，长度是："</span> + in.readableBytes());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并报文</span></span><br><span class="line">    ByteBuf message = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> tmpMsgSize = tempMsg.readableBytes();</span><br><span class="line">    <span class="comment">// 如果暂存有上一次余下的请求报文，则合并</span></span><br><span class="line">    <span class="keyword">if</span> (tmpMsgSize &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      message = Unpooled.buffer();</span><br><span class="line">      message.writeBytes(tempMsg);</span><br><span class="line">      message.writeBytes(in);</span><br><span class="line">      System.out.println(<span class="string">"合并：上一数据包余下的长度为："</span> + tmpMsgSize + <span class="string">",合并后长度为:"</span> + message.readableBytes());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      message = in;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> size = message.readableBytes();</span><br><span class="line">    <span class="comment">//判断当前包含几个数据包</span></span><br><span class="line">    <span class="keyword">int</span> counter = size / PACKET_SIZE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; counter; i++) &#123;</span><br><span class="line">      <span class="keyword">byte</span>[] request = <span class="keyword">new</span> <span class="keyword">byte</span>[PACKET_SIZE];</span><br><span class="line">      <span class="comment">// 每次从总的消息中读取220个字节的数据</span></span><br><span class="line">      message.readBytes(request);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 将拆分后的结果放入out列表中，交由后面的业务逻辑去处理</span></span><br><span class="line">      out.add(Unpooled.copiedBuffer(request));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果有多余的报文则存起来</span></span><br><span class="line">    size = message.readableBytes();</span><br><span class="line">    <span class="keyword">if</span> (size != <span class="number">0</span>) &#123;</span><br><span class="line">      System.out.println(<span class="string">"多余的数据长度："</span> + size);</span><br><span class="line">      <span class="comment">// 剩下来的数据放到tempMsg暂存</span></span><br><span class="line">      tempMsg.clear();</span><br><span class="line">      tempMsg.writeBytes(message.readBytes(size));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2><span id="channelpipeline和channelhandler">ChannelPipeline和ChannelHandler</span></h2><h3><span id="channelpipeline是什么它有什么作用">ChannelPipeline是什么，它有什么作用？</span></h3><p>ChannelPipeline是ChannleHandler的容器，它负责ChannelHandler的管理和事件拦截与调度。</p><h3><span id="channlepipeline的事件处理">ChannlePipeline的事件处理</span></h3><p>下面梳理一下，一个消息被ChannelPipeline的ChannelHandler链拦截和处理的全过程。</p><ol><li>底层的SocketChannel read方法读取到ByteBuf，触发了ChannelRead事件，由IO线程NioEventLoop调用ChannelPipeline的fireChannelRead方法，将消息传输到ChannelPipeline中。</li><li>消息依次被Headhandler、ChannelHandler1，ChannelHandler2…TailHandler拦截和处理，在整个过程中，任何的ChannelHandler都可以中断当前的流程，结束消息的传递。</li><li>调用ChannelHandlerContext的write方法发送消息，消息从TailHandler开始，逆着拦截链传递，最终被添加到消息发送缓冲区中，等待刷新和发送。</li></ol><p><img src="https://s2.ax1x.com/2020/02/24/38zJnP.png" alt="38zJnP.png"></p><p>netty中的事件分为inbound事件和outbound事件。inbound事件通常由IO线程触发，例如TCP链路建立事件，链路关闭事件、读事件、异常通知事件等。而OUtbound事件通常是由用户主动发起的网络IO操作，例如用户发起的连接操作，绑定操作、消息发送等操作。</p><h3><span id="如何自定义拦截器">如何自定义拦截器</span></h3><p>ChannelPipeline通过ChannelHandler接口来实现事件的拦截和处理。因为我们往往只需要关系ChannelHandler接口中的一些事件，因此一般继承ChannelHandlerAdapter类覆盖自己关心的方法即可。</p><h3><span id="pipeline是如何构建的">pipeline是如何构建的</span></h3><p>在使用ServerBootstrap或者Bootstrap启动服务端或者客户端时，Netty会为每个Channel连接创建一个独立的pipeline。</p><h3><span id="channelpipeline的主要特性">ChannelPipeline的主要特性</span></h3><ul><li>ChannelPipeline支持运行态动态的添加或者删除ChannelHandler。</li><li>ChannelPipeline是线程安全的，这意味着N个业务线程可以并发的操作ChannelPipeline而不存在多线程并发问题。但是ChannelHandler却不是线程安全的。</li></ul><h3><span id="channelpipeline源码分析">ChannelPipeline源码分析</span></h3><h4><span id="类继承关系图">类继承关系图</span></h4><p><img src="https://s2.ax1x.com/2020/02/24/3GgEB6.png" alt="3GgEB6.png"></p><h4><span id="实现原理">实现原理</span></h4><p>我们以这行代码为例，来看一下，一个ChannelHandler是如何添加到ChannelPipeline中的。<br><code>pipeline.addLast(new MyByteToLongDecoder());</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">addLast</span><span class="params">(EventExecutorGroup executor, ChannelHandler... handlers)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (handlers == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"handlers"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (ChannelHandler h: handlers) &#123;</span><br><span class="line">        <span class="keyword">if</span> (h == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        addLast(executor, <span class="keyword">null</span>, h);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法主要做了参数校验，实际上最终是调用了<code>addLast(executor, null, h);</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">addLast</span><span class="params">(EventExecutorGroup group, String name, ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> AbstractChannelHandlerContext newCtx;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123; <span class="comment">//进行了方法同步，是线程安全的体现</span></span><br><span class="line">        <span class="comment">//判断该handler是否以及添加过了</span></span><br><span class="line">            checkMultiplicity(handler);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个新的AbstractChannelHandlerContext</span></span><br><span class="line">            newCtx = newContext(group, filterName(name, handler), handler);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将当前的Context添加到AbstractChannelHandlerContext链表尾部</span></span><br><span class="line">            addLast0(newCtx);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If the registered is false it means that the channel was not registered on an eventLoop yet.</span></span><br><span class="line">            <span class="comment">// In this case we add the context to the pipeline and add a task that will call</span></span><br><span class="line">            <span class="comment">// ChannelHandler.handlerAdded(...) once the channel is registered.</span></span><br><span class="line">            <span class="keyword">if</span> (!registered) &#123;</span><br><span class="line">                newCtx.setAddPending();</span><br><span class="line">                callHandlerCallbackLater(newCtx, <span class="keyword">true</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            EventExecutor executor = newCtx.executor();</span><br><span class="line">            <span class="keyword">if</span> (!executor.inEventLoop()) &#123;</span><br><span class="line">                callHandlerAddedInEventLoop(newCtx, executor);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        callHandlerAdded0(newCtx);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是TCP粘包和拆包？&quot;&gt;&lt;a href=&quot;#什么是TCP粘包和拆包？&quot; class=&quot;headerlink&quot; title=&quot;什么是TCP粘包和拆包？&quot;&gt;&lt;/a&gt;什么是TCP粘包和拆包？&lt;/h2&gt;&lt;p&gt;TCP是一个“流”协议，所谓流就是没有界限的一串数据。TCP协议会根据TCP缓冲区的实际情况对包进行划分，所以业务上的一个包，可能被TCP拆分为多个包发送（拆包），多个小的包也可能被TCP合并为一个包进行发送（粘包）。&lt;/p&gt;
&lt;h2 id=&quot;TCP粘包和拆包发生的原因&quot;&gt;&lt;a href=&quot;#TCP粘包和拆包发生的原因&quot; class=&quot;headerlink&quot; title=&quot;TCP粘包和拆包发生的原因&quot;&gt;&lt;/a&gt;TCP粘包和拆包发生的原因&lt;/h2&gt;&lt;p&gt;原因有三个：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;应用程序write写入的字节大小大于套接字缓冲区的大小&lt;/li&gt;
&lt;li&gt;进行MSS（maximum segment size，最大分节大小，为TCP数据包每次传输的最大数据分段大小）大小的TCP分段&lt;/li&gt;
&lt;li&gt;以太帧的payload大于MTU（maximum transmission unit，最大传输单元，由硬件规定）进行IP分片
    
    </summary>
    
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Netty" scheme="http://yoursite.com/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>Netty学习笔记一</title>
    <link href="http://yoursite.com/2020/02/21/Netty%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/"/>
    <id>http://yoursite.com/2020/02/21/Netty学习笔记一/</id>
    <published>2020-02-21T13:30:00.000Z</published>
    <updated>2020-02-22T01:30:47.370Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="netty是是什么">Netty是是什么？</span></h2><p>Netty是基于NIO的客户，服务器端的编程框架，它提供了异步的、事件驱动的网络应用程序框架和工具，用以快速开发高性能、高可靠的网络服务器和客户端程序。</p><h2><span id="netty有什么特点">Netty有什么特点？</span></h2><p><img src="https://s2.ax1x.com/2020/02/19/3AHxQU.png" alt="3AHxQU.png"></p><a id="more"></a><h2><span id="io模型">IO模型</span></h2><h3><span id="bio">BIO</span></h3><p>同步阻塞IO，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理。适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中。<br>BIO是针对字节流和字符流的处理。</p><h3><span id="nio">NIO</span></h3><p>同步非阻塞，服务器实现模式为一个线程处理多个请求，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有IO请求就进行处理。适用于连接数目多且连接短的架构。<br>NIO是针对Channel和Buffer的处理。</p><h3><span id="aio">AIO</span></h3><p>异步非阻塞，AIO引入异步通道的概念，采用Proactor模式，简化了程序编写，有效的请求才启动线程，它的特点是由操作系统完成后才通知服务端程序启动线程去处理，一般适用于连接数较多且连接时间较长的应用。</p><h2><span id="通道channel和流有什么区别">通道（Channel）和流有什么区别？</span></h2><ul><li>通道是双向的，而流是单向的。</li><li>通道可以实现异步读写数据</li><li>通道可以从缓冲区读数据，也可以写数据到缓冲区。</li></ul><h2><span id="什么是零拷贝">什么是零拷贝？</span></h2><p>零拷贝是指计算机操作的过程中，CPU不需要为数据在内存之间的拷贝消耗资源。通常它是指计算机在网络上发送文件时，不需要将文件内容拷贝到用户空间，而直接在内核空间中传输到网络的方式，接收亦然。<br>零拷贝是网络编程的关键，许多性能优化都离不开。<br>在Java程序中常用的零拷贝有mmap（内存映射）和sendFile。<br>内存映射时间文件映射到内核缓冲区，同时用户空间可以共享内核空间的数据。<br>sendFile是linux2.1版本提供的一个新的函数，其原理是数据不经过用户态，直接从内核缓冲区直接进入到socket buffer，同时，由于和用户态完全无关，就减少了异常上下文切换。</p><p>NIO可以直接将一个通道中的数据传递（transferTo）到另一个通道，而不经过buffer实际就是零拷贝。</p><h2><span id="多路复用模式reactor和proactor是什么有什么区别">多路复用模式Reactor和Proactor是什么，有什么区别？</span></h2><p>在Reactor中，事件分离器负责等待文件描述符或者socket为读写操作准备就绪，然后将就绪事件传递给对应的处理器，最后由处理器负责完成实际的读写工作。本质就是IO事件触发时，通知我们主动去读取，也就是要我们主动将socket接收缓存中的数据读到应用进程内存中。<br>而在Proactor模式中，处理器或者事件分离器，只负责发起异步读写操作。IO操作本身由操作系统来完成。本质是当有数据包到达时，则写入到应用进程内的指定的buffer，然后通知我们接收了多少个字节。</p><p><strong>简单来讲就是Reactor关心就绪事件，比如可读了，就通知你。而Proactor关心的是完成，比如读完了，就通知你。</strong></p><h2><span id="为什么非阻塞io更快速-更经济">为什么非阻塞IO更快速、更经济？</span></h2><ul><li>非阻塞网络调用使得我们可以不比等待一个操作完成。</li><li>选择器使得我们能够使用更少的线程便可以监视许多连接上的事件。</li></ul><h2><span id="netty的核心组件">Netty的核心组件</span></h2><h3><span id="channel">Channel</span></h3><p>Channel是Java NIO的一个基本构造，它代表一个到实体的开发连接，如读操作和写操作。</p><h3><span id="回调">回调</span></h3><p>一个回调其实就是一个方法，一个指向已经被提供给另外一个方法的方法的引用。这使得后者可以在适当的时候调用前者。</p><h3><span id="future">Future</span></h3><p>Future提供了另一种子在操作完成时通知引用程序的方式。这个对象可以看作时一个异步操作的占位符；它将在未来的某个时刻完成，并提供对其结果的访问。<br>相比与jdk中的Future，Netty自己实现了ChannelFuture，用于在执行异步操作的时候使用。</p><h3><span id="事件和channelhandler">事件和Channelhandler</span></h3><p>Netty使用不同的事件来通知我们状态的改变或者是操作的状态。这使得我们能够基于已经发送的事件来触发适当的动作。</p><p>Netty是一个网络编程框架，所以事件是按照它们与入展或出站数据流的相关性进行分类的。可能由入站或相关的状态更改而触发的事件包括：</p><ul><li>连接被激活或连接失活</li><li>数据读取</li><li>用户事件</li><li>错误事件</li><li>打开或关闭到远程节点的连接</li><li>将数据写到或者冲刷到套接字</li></ul><h2><span id="channeleventloop和channelfuture">Channel，EventLoop和ChannelFuture</span></h2><p>Channel是对socket的封装，EventLoop是控制流、多线程处理、并发的封装。ChannelFuture是对异步通知的封装。</p><h3><span id="channel接口">Channel接口</span></h3><p>基本的IO操作依赖于底层的socket，而Netty的Channel提供了许多的API避免了直接使用Socket的复杂性。</p><h3><span id="eventloop接口">EventLoop接口</span></h3><p>EventLoop定义了Netty的核心抽象，用于处理连接的什么周期中所发送的事件。</p><p>Channel、EventLoop、Thread以及EventLoopGroup的关系是怎样的？</p><ul><li>EventLoopGroup可以包含多个EventLoopGroup</li><li>一个EventLoop只能与一个Thread绑定</li><li>一个Channel只能注册于一个EventLoop</li><li>一个EventLoop可能被给配给多个Channel</li></ul><h3><span id="channelfuture接口">ChannelFuture接口</span></h3><p>由于Netty中的IO操作都是异步的，因此一个操作可能不会立即返回，所以我们需要一种用于在之后的某个节点确定其结果的方法，为此Netty提供了ChannelFuture接口，其中addListener方法注册一个ChannelFutureListenerr，以便在某个操作完成时得到通知。</p><h2><span id="pipeline和channelpipeline">Pipeline和ChannelPipeline</span></h2><p>ChannelPipeline是一个Handler的集合，它负责处理和拦截inbound或者outbound的事件和操作。<br><img src="https://s2.ax1x.com/2020/02/21/3uj1Et.png" alt="3uj1Et.png"><br>入站事件和出站事件在一个双向链表中，入站事件会从链表头往后传递到最后入站的handler，出站事件会从链表尾往前传递到最前一个出站的handler。</p><h2><span id="netty所使用的io模型是什么">Netty所使用的IO模型是什么？</span></h2><p>Netty主要基于主从Reactors多线程模型。主从Reactors多线程模型有多个Reactor。<br><img src="https://s2.ax1x.com/2020/02/21/3n506f.png" alt></p><p>BossGroup和WorkerGroup是两组线程池，BoosGroup专门负责接收客户端连接，WorkerGroup专门负责网络读写操作。NIOEventloop表示一个不断循环执行处理任务的线程，每个NIOEventLoop都有一个selector，用于监听绑定在其上的socket网络通道。</p><ul><li>BossGroup线程维护Selector，只关注Accecpt</li><li>当接收到Accept事件就获取对应的SocketChannel，封装成NIOSocketChannel并注册到Worker线程（事件循环），并进行维护。</li><li>当Work而线程监听到selector中通道发送了自己该兴趣的事件后，就使用handler进行处理。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Netty是是什么？&quot;&gt;&lt;a href=&quot;#Netty是是什么？&quot; class=&quot;headerlink&quot; title=&quot;Netty是是什么？&quot;&gt;&lt;/a&gt;Netty是是什么？&lt;/h2&gt;&lt;p&gt;Netty是基于NIO的客户，服务器端的编程框架，它提供了异步的、事件驱动的网络应用程序框架和工具，用以快速开发高性能、高可靠的网络服务器和客户端程序。&lt;/p&gt;
&lt;h2 id=&quot;Netty有什么特点？&quot;&gt;&lt;a href=&quot;#Netty有什么特点？&quot; class=&quot;headerlink&quot; title=&quot;Netty有什么特点？&quot;&gt;&lt;/a&gt;Netty有什么特点？&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2020/02/19/3AHxQU.png&quot; alt=&quot;3AHxQU.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Netty" scheme="http://yoursite.com/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>挑战面试题一</title>
    <link href="http://yoursite.com/2020/02/13/%E6%8C%91%E6%88%98%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%80/"/>
    <id>http://yoursite.com/2020/02/13/挑战面试题一/</id>
    <published>2020-02-13T13:07:00.000Z</published>
    <updated>2020-02-13T13:08:17.153Z</updated>
    
    <content type="html"><![CDATA[<p><em>所有面试题都是从网上收集的，知识面比较广，可能有重复的题目。所有的答案都是我自己查阅资料加上自己的理解所写的，难免有不详之处，希望大家不吝赐教！</em></p><h3><span id="volatile的底层如何实现怎么就能保住可见性了">volatile的底层如何实现，怎么就能保住可见性了？</span></h3><p><code>volatile</code>关键字修饰的变量可以确保内存可见性，禁止指令重排序。<br><code>volatile</code>修饰的变量不允许线程内存cache缓存和重排序，线程读取数据的时候直接读取内存，同时<code>volatile</code>不会对变量加锁，因此性能会比<code>synchronized</code>好。<br>还有一种说法是：读取一个<code>volatile</code>关键字会使相应的处理器执行刷新处理器缓存的动作，写一个<code>volatile</code>关键字会使得相应的处理器执行冲刷处理器缓存的动作。</p><p>拓展：<br>假如我们有一个使用<code>volatile</code>的变量<code>instance</code>.有如下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">instance = <span class="keyword">new</span> Singleton();</span><br></pre></td></tr></table></figure></p><p>它的汇编代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x01a3de1d: movb $0x0,0x1104800(%esi);</span><br><span class="line">0x01a3de24: lock  addl $0x0,(%esp); //使用volatile修饰的变量会多这行</span><br></pre></td></tr></table></figure></p><p>使用<code>lock</code>前缀的指令会引发两件事情：</p><ul><li>将当前处理器缓存含的数据写回到系统内存</li><li>这个写回内存的操作回引起在其它CPU里缓存了该内存地址的数据无效</li></ul><a id="more"></a><h3><span id="线程池有哪些创建方式">线程池有哪些创建方式</span></h3><p>线程池的创建方式有两种：</p><ul><li>使用<code>ThreadPoolExecutor</code>类创建。使用该方法创建时，参数比较复杂可以参考<a href="https://zofun.github.io/2020/01/17/ThreadPoolExecutor%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">ThreadPoolExecutor源码分析 </a></li><li>使用<code>Executor</code>类。具体的创建方法可参考下一个问题。</li></ul><h3><span id="有哪些线程池的类型">有哪些线程池的类型</span></h3><ul><li><code>ExecutorService fixedExecutor = Executors.newFixedThreadPool(3);</code><br>定长线程池，每当提交一个任务就创建一个线程，知道达到线程池的最大数量，这时线程数量不再变化，当线程发送错误结束时，线程池会补充一个新的线程。</li><li><code>ExecutorService cachedExecutor = Executors.newCachedThreadPool();</code><br>可缓存的线程池，如果线程池的容量超过了任务数，自动回收空闲线程，任务增加时可以自动添加新线程，线程池的容量不限制。</li><li><code>ScheduledExecutorService scheduledExecutor = Executors.newScheduledThreadPool(3);</code><br>定长线程池，可执行周期性的任务</li><li><code>ExecutorService singleExecutor = Executors.newSingleThreadExecutor();</code><br>单线程线程池，线程异常结束，会创建一个新的线程，能确保任务按提交顺序执行</li><li><code>ScheduledExecutorService singleScheduledExecutor = Executors.newSingleThreadScheduledExecutor();</code><br>单线程可执行周期性任务的线程池。</li><li><code>ExecutorService workStealingExecutor = Executors.newWorkStealingPool();</code><br>任务窃取线程池，不保证执行顺序，适合任务耗时差异较大。</li></ul><h3><span id="线程池中linkedblockingqueue满了的话线程会怎么样">线程池中LinkedBlockingQueue满了的话，线程会怎么样</span></h3><p>需要分两种情况：</p><ol><li>如果当前运行的线程数大于核心线程数且小于最大线程数，那么就会新建线程。</li><li>如果当前运行的线程数已经达到了最大线程数，那么就会执行拒绝策略。</li></ol><p>拓展：<br>JDK内置了4种拒绝策略，我们也可以继承<code>RejectedExcutionHandler</code>实现自己的拒绝策略。<br>内置的4种拒绝策略分别是：</p><ul><li><code>AbortPolicy</code>：直接抛出异常（默认）</li><li><code>CallerRunsPolicy</code>：直接在execute方法的调用线程中运行拒绝的任务；如果执行程序已关闭，则会丢弃该任务。</li><li><code>DiscardPolicy</code>：直接丢弃任务。</li><li><code>DiscardOldestPolicy</code>:丢弃队列中等待时间最长的任务（即队头），然后运行当前的任务。</li></ul><h3><span id="线程池的底层原理和实现方法">线程池的底层原理和实现方法</span></h3><p>在线程池中每个线程都被封装成为了一个<code>Worker</code>对象。在线程池内部比较重要的两个属性是一个存放所有线程的<code>workers:HashSet</code>,和阻塞队列。当有任务提交的时候，首先会判断当前线程数是否小于核心线程数，如果当前线程数小于核心线程数，那么就创建一个新的线程(将任务和线程封装为一个<code>Worker</code>)并运行线程，否则将任务添加到等待队列，等待工作线程依次从队列中取出任务执行。如果等待队列已满且工作线程数已经达到最大线程数了，那么就会执行拒绝策略。</p><h3><span id="线程之间的交互方式有哪些">线程之间的交互方式有哪些？</span></h3><p>线程之间的通信方式有4种：</p><ul><li>共享变量</li><li>wait/notify机制</li><li>Lock/Condition机制</li><li>管道</li></ul><h3><span id="java锁机制都说一下~">Java锁机制，都说一下~</span></h3><p>Java提供了两种枷锁的方法：</p><ul><li>synchronized关键字</li><li>显示Lock</li></ul><p>拓展：<br>synchronized关键字的实现原理是通过JVM进入、退出对象监视器(Monitor)来实现对方法、同步块的同步的，而对象监视器的本质是依赖于操作系统的互斥锁Mutex Lock 实现的。从jdk1.6之后，对sychronized关键字进行了优化，为了能够减少获取和释放锁的消耗引入了偏向锁和轻量级锁。</p><p>引入偏向锁是为了避免在无多线程竞争的条件下的轻量级锁的执行路径。<br><strong>偏向锁的获取过程：</strong></p><ol><li>判断对象头的Mark Word标志是否处于偏向锁状态。</li><li>如果为偏向锁状态，继续判断线程ID是否指向当前线程。如果线程ID指向当前线程ID，则跳到5）</li><li>如果线程ID没有指向当前线程，则通过CAS操作竞争锁。如果竞争成功，则将线程ID设置为当前线程ID。</li><li>如果竞争失败，则等待到达全局安全点时，得到偏向锁的线程就会挂起，偏向锁升级为轻量级锁，然后被阻塞的线程继续执行。</li><li>执行同步代码。</li></ol><p><strong>偏向锁的释放过程</strong><br>偏向锁只由在遇到其它线程竞争偏向锁时，持有偏向锁的线程才会释放锁。</p><p>提出轻量级锁的目的是在没有多少线程竞争的前提下，减少传统的重量级锁锁使用所产生的性能消耗。</p><p><strong>轻量级锁的加锁过程：</strong></p><ol><li>首先通过对象头的mark word字段判断是否是无锁状态，如果是无锁状态，那么虚拟机会在当前线程的栈帧中建立一个名为锁记录的空间，用于存储锁对象目前的Mark Word的拷贝。</li><li>拷贝对象头中的mark word到锁记录中。</li><li>虚拟机尝试通过CAS将对象的Mark Word更新为指向当前线程的锁记录指针，并将当前线程的锁记录中的owner指向mark word。</li><li>如果更新成功，表明当前线程获得了该对象的锁，并且设置对象的Mark Word的为轻量级锁锁定状态。</li><li>如果更新失败，虚拟机会检查对象的mark word是否指向当前线程的栈帧，如果是则说明当前线程已经拥有了对象的锁。否则说明存在多个线程竞争锁，轻量级锁就升级为重量级锁（使用互斥量），修改锁标志位重量级锁，mark word中存储了指向互斥量的指针，后面等待的线程进入阻塞状态，当前线程使用自旋来获取锁。</li></ol><p>并且在1.6之后，还增加了<strong>自适应自旋</strong>，减少了CAS操作时自旋的成本。即如果某个锁自旋很少就成功获得，那么下一次就会减少自旋。</p><p>编译器还会进行<strong>锁消除</strong>优化，消除没有必要的加锁。<br>我们在编写代码的时候，尽量减少同步的范围，即<strong>锁粗化</strong>。</p><p>而显示Lock都是基于AQS实现的。比如：ReentrantLock。关于AQS我在另一篇博客中有详细介绍<a href="https://zofun.github.io/2020/01/10/ReentrantLock%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">AQS</a></p><h3><span id="除了responsebodycontroller层如何标准返回给前端所要的数据类型你会怎么实现">除了@ResponseBody，controller层如何标准返回给前端所要的数据类型？你会怎么实现？</span></h3><p>还可以自定义消息转化器，通过继承<code>AbstractHttpMessageConverter</code>重写其中的方法，并注入的Spring容器即可。</p><p><em>目前只想到了这一种</em></p><h3><span id="异常捕获处理">异常捕获处理</span></h3><p>Java异常Throwable分为两类，一类是Error，一类是Exception。Error是编程时需要避免的，程序无法处理的。而Exception就是我们平常需要处理异常。除了Exception下的RunTimeException及其子类都是可查异常，即编译器要求必须捕获的异常。<br>对于异常有三种处理方案：<br>一种是通过try，catch进行捕获，一种是定义方法的时候通过throws关键字声明，表明该方法不处理该异常，交由调用方处理。最后一种就是通过throw关键字抛出异常。</p><h3><span id="redis的缓存淘汰策略有哪些">Redis的缓存淘汰策略有哪些？</span></h3><p>Redis的缓存淘汰策略有6种，它们分别是：</p><ul><li>noeviction：不删除策略，达到最大内存限制时，如果需要更多的内存，直接返回错误信息。</li><li>allkeys-lru：对于所有的key优先删除最近最少使用的key。</li><li>allkeys-random：对于所有的key，随机删除一部分。</li><li>volatile-random：只限于设置了expore的部分，删除一部分expire的key</li><li>volatile-ttl：只限于设置了expire的部分，优先删除剩余时间（TTL）短的key。</li><li>volatile-lru：只限于色湖之了expore的部分，删除最近最少使用的key。</li></ul><h3><span id="java内存模型说一下">Java内存模型说一下</span></h3><p>Java内存分为：虚拟机栈，本地方法栈，程序计数器，方法区，堆区。</p><p>在JVM启动的时候首先会分配好方法区和堆区。程序计数器，虚拟机栈，本地方法栈都是线程私有的。</p><h3><span id="mybatis如何进行类型转换">mybatis如何进行类型转换</span></h3><p>Mybatis的</p><h3><span id="mybatis的xml有什么标签">mybatis的xml有什么标签</span></h3><p>定义sql语句的：insert，delete,updata,select<br>结果集映射的：resultMap<br>动态sql：foreach，if，choose<br>格式化输出：where，set，trim<br>配置关联关系：collection，association<br>定义sql片段：sql</p><h3><span id="mysql锁机制">MySQL锁机制</span></h3><p>以我们平常经常使用的innoDB存储引擎为例，主要有七种类型的锁： 共享/排他锁，意向锁，记录锁，间隙锁，临键锁，插入意向锁，自增锁。<br><a href="https://www.cnblogs.com/volcano-liu/p/9890832.html" target="_blank" rel="noopener">https://www.cnblogs.com/volcano-liu/p/9890832.html</a></p><h3><span id="如何修改linux的文件权限">如何修改linux的文件权限</span></h3><p>修改文件的权限可以使用<code>chmod</code>命令。<br>比如：设置text.txt所有人可读<br><code>chmod ugo+r file.txt</code><br>u表示文件拥有者，g表示与文件的拥有者同一组人，o表示其它以外的人，a表示所有人。<br>+，-表示增加，取消权限，=表示唯一设定<br>r读，w写，x可执行</p><h3><span id="jvm的回收算法">jvm的回收算法</span></h3><p>标记清除算法，标记整理算法，复制算法，分代收集算法。<br>标记清除算法首先标记需要回收的对象，在标记完成后同一回收。<br>标记整理算法首先标记出需要回收的对象，然后让存活的对象向一端移动，最后清除掉边界以外的部分。<br>复制算法将内存划分为大小相等的两个部分，每次只使用其中一部分，内存回收时将存活的对象复制到另一个部分，然后再把使用过的一半内存清理掉。<br>分代收集算法根据对象不同的存活周期将内存划分为几块，一般划分为新生代和老年代。然后再根据不同分代对象的特点选用不同的回收算法。</p><h3><span id="数据库有哪些索引">数据库有哪些索引？</span></h3><p>以我们常见的mysql为例，有5种索引。它们分别是主键索引，唯一索引，普通索引，全文索引，联合索引。</p><p>拓展：<br>当我们为表设置主键的时候，则该类就是主键索引。当然也可以在建表之后添加：<br><code>alter table table_name add primary key (colum_name)</code></p><p>普通索引一般是在建表后再添加：<br><code>alter table table_name add index index_name(colum_name1,colum_name2)</code></p><p>全文索引主要针对文本文件，在mysql5.6之前只有MyISAM支持，后来InnoDB也支持全文索引。</p><p>唯一索引可以有多个空值，但是不能重复。相比于主键，主键不能重复也不能有空值。</p><h3><span id="如何防止sql注入">如何防止sql注入</span></h3><p>使用预编译语句避免拼接sql，限制数据库权限，避免直接向用户显示错误信息</p><h3><span id="抽象类和接口有什么不同">抽象类和接口有什么不同</span></h3><ul><li>抽象类是用来继承而接口是用来实现的。</li><li>接口中的所有方法都必须是抽象方法，而抽象类中即可以包含抽象方法也可以包含非抽象的方法。</li><li>接口中声明的成员变量都是final的，而抽象类则没有限制。</li><li>接口中的方法默认是public的，而抽象类方法的访问权限可以任意指定。</li><li>类可以实现多个接口，但是只能继承一个抽象类。</li><li>抽象类可以在不实现接口方法的情况下实现接口。</li></ul><h3><span id="mysql间歇锁的实现原理">mysql间歇锁的实现原理</span></h3><p>间歇锁是innodb在可重复读提交下为了解决幻读问题而引入的锁机制，它是一种行锁。间隙锁会锁定一个范围但是不包含记录本身。<br>间隙锁会根据检索添加向左寻找最靠近检索条件的记录值A，作为左区间，向右寻找最靠近检索添加的记录值B作为右区间，即锁定的间隙为[A，记录），（记录，B]。<br><a href="https://www.jianshu.com/p/32904ee07e56" target="_blank" rel="noopener">https://www.jianshu.com/p/32904ee07e56</a></p><h3><span id="future的底层实现异步原理">future的底层实现异步原理</span></h3><p>Future表示异步的计算结果，它提供了检查计算结果是否完成的方法以及等待计算的完成，并获取计算的结果。计算完成后可以通过get方法获取，如果有必要可以阻塞该方法知道计算完成。</p><h3><span id="多线程讲一下futuretask">多线程讲一下，FutureTask</span></h3><p>Future表示一个任务的生命周期，是一个可取消的异步运算。FutureTask提供了Future的最基础的实现。它的内部有一个<code>Callable</code>任务，一个执行任务的线程，一个保存等待线程的栈，和一个用于保存结果或异常的<code>Object</code>对象.当调用get方法获取结果的时，如果任务未完成就假如等待栈中，知道计算完毕后唤醒。</p><h3><span id="乐观锁和悲观锁">乐观锁和悲观锁</span></h3><p>悲观锁采用“先取锁再访问”的保守策略，使用悲观锁会增加数据库的开销，还带来了死锁的分享。而乐观锁不会刻意去依赖锁，而是利用数据本身来保证数据恶的正确性。乐观锁的一种常见实现就是通过给数据加上版本号，类似CAS的思想。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;所有面试题都是从网上收集的，知识面比较广，可能有重复的题目。所有的答案都是我自己查阅资料加上自己的理解所写的，难免有不详之处，希望大家不吝赐教！&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&quot;volatile的底层如何实现，怎么就能保住可见性了？&quot;&gt;&lt;a href=&quot;#volatile的底层如何实现，怎么就能保住可见性了？&quot; class=&quot;headerlink&quot; title=&quot;volatile的底层如何实现，怎么就能保住可见性了？&quot;&gt;&lt;/a&gt;volatile的底层如何实现，怎么就能保住可见性了？&lt;/h3&gt;&lt;p&gt;&lt;code&gt;volatile&lt;/code&gt;关键字修饰的变量可以确保内存可见性，禁止指令重排序。&lt;br&gt;&lt;code&gt;volatile&lt;/code&gt;修饰的变量不允许线程内存cache缓存和重排序，线程读取数据的时候直接读取内存，同时&lt;code&gt;volatile&lt;/code&gt;不会对变量加锁，因此性能会比&lt;code&gt;synchronized&lt;/code&gt;好。&lt;br&gt;还有一种说法是：读取一个&lt;code&gt;volatile&lt;/code&gt;关键字会使相应的处理器执行刷新处理器缓存的动作，写一个&lt;code&gt;volatile&lt;/code&gt;关键字会使得相应的处理器执行冲刷处理器缓存的动作。&lt;/p&gt;
&lt;p&gt;拓展：&lt;br&gt;假如我们有一个使用&lt;code&gt;volatile&lt;/code&gt;的变量&lt;code&gt;instance&lt;/code&gt;.有如下代码：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;instance = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Singleton();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;它的汇编代码如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;0x01a3de1d: movb $0x0,0x1104800(%esi);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;0x01a3de24: lock  addl $0x0,(%esp); //使用volatile修饰的变量会多这行&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;lock&lt;/code&gt;前缀的指令会引发两件事情：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将当前处理器缓存含的数据写回到系统内存&lt;/li&gt;
&lt;li&gt;这个写回内存的操作回引起在其它CPU里缓存了该内存地址的数据无效&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Linux常用命令</title>
    <link href="http://yoursite.com/2020/02/12/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2020/02/12/Linux常用命令/</id>
    <published>2020-02-12T09:45:00.000Z</published>
    <updated>2020-02-12T09:46:03.030Z</updated>
    
    <content type="html"><![CDATA[<h3><span id="查找文件">查找文件</span></h3><p><code>find / -name filename.txt</code><br>查找/目录下名字为filename.txt的文件。</p><p><code>find / -iname filename.txt</code><br>忽略大小写。（忽略大小写都是在添加i）</p><p><code>find /usr/ -path &quot;*local*&quot;</code><br>匹配路径</p><p><a href="https://man.linuxde.net/find" target="_blank" rel="noopener">find</a></p><h3><span id="终止线程">终止线程</span></h3><p><code>kill -9 19979</code><br>强制终止线程号为19979的线程</p><p><a href="https://man.linuxde.net/kill" target="_blank" rel="noopener">kill</a></p><h3><span id="查看一个程序是否运行">查看一个程序是否运行</span></h3><p><code>ps -ef|grep tomcat</code><br>查看所有与tomcat相关的进程<br><a href="https://man.linuxde.net/ps" target="_blank" rel="noopener">ps</a><br><a href="https://man.linuxde.net/grep" target="_blank" rel="noopener">grep</a></p><h3><span id="查看所有的文件包含隐藏文件">查看所有的文件包含隐藏文件</span></h3><p><code>ls -a</code></p><h3><span id="创建和删除目录">创建和删除目录</span></h3><p><code>mkdir newfolder</code><br><code>rmdir deleteEmptyFilder</code></p><h3><span id="压缩和解压文件">压缩和解压文件</span></h3><p>压缩：<br><code>tar -czf test.tar.gz /test</code><br>解压:<br><code>tar -xvzf test.tar.gz</code></p><h3><span id="修改文件的权限">修改文件的权限</span></h3><p><code>chmod u+x,g+w,o-x filename.txt</code><br>r读取属性，w写入属性，x执行属性，u文件所有者，g与文件同组的用户，o其它用户。</p><h3><span id="删除文件包括其子文件">删除文件包括其子文件</span></h3><p><code>rm -rf deleteFile</code></p><h3><span id="移动文件">移动文件</span></h3><p><code>mv /temp/movefile /targetFolder</code></p><h3><span id="复制文件到指定的目录">复制文件到指定的目录</span></h3><p><code>cp -r sourceFolder targetFolder</code></p><h3><span id="查看文件尾10行">查看文件尾10行</span></h3><p><code>tail -n 10 file.txt</code></p><h3><span id="查看日志文件">查看日志文件</span></h3><p><code>tail -f logfile.log</code><br>该命令工会自动显示新增的内容。</p><h3><span id="查看线程个数">查看线程个数</span></h3><p><code>ps -Lf 端口号 |wc -l</code></p><p><a href="https://man.linuxde.net/ps" target="_blank" rel="noopener">ps</a></p><h3><span id="查看内存cpu占用命令">查看内存，CPU占用命令</span></h3><p><code>top</code> 查看CPU占用情况<br><code>free -m</code>查看内存占用情况<br><code>vmstat 3(间隔时间) 100（监控次数）</code>查看CPU和内存的占用</p><h3><span id="查看端口占用情况">查看端口占用情况</span></h3><p><code>netstat -anp |grep 3306</code> 查看特定端口3306的进程<br><code>lsof -i:3306</code> 查看某个端口是否被占用</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3&gt;&lt;span id=&quot;查找文件&quot;&gt;查找文件&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;code&gt;find / -name filename.txt&lt;/code&gt;&lt;br&gt;查找/目录下名字为filename.txt的文件。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;find / -iname filena
      
    
    </summary>
    
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC源码分析之一个请求的处理</title>
    <link href="http://yoursite.com/2020/02/06/SpringMVC%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E4%B8%80%E4%B8%AA%E8%AF%B7%E6%B1%82%E7%9A%84%E5%A4%84%E7%90%86/"/>
    <id>http://yoursite.com/2020/02/06/SpringMVC源码分析之一个请求的处理/</id>
    <published>2020-02-06T07:08:00.000Z</published>
    <updated>2020-02-06T07:08:34.091Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="概述">概述</span></h2><p>SpringMVC是一种web层的mvc框架，用于替代Servlet，主要用于处理和相应请求，获取表单参数，表单校验。使用SpringMVC可以简化编程。</p><h2><span id="springmvc底层的执行流程">SpringMVC底层的执行流程</span></h2><p>首先通过一张流传广泛的图，来了解一下大致的流程。<br><img src="https://s2.ax1x.com/2020/02/05/1rJAu4.png" alt="1rJAu4.png"><br><a id="more"></a></p><p>从这张图可以看出，整个请求的入口是<code>DispatcherServlet</code>类。之所以请求的入口会是这个类是因为我们在配置springmvc的时候在<code>web.xml</code>中，将所有的请求都交由<code>DispatcherServlet</code>处理了。<br>请求到达<code>DispatcherServlet</code>类首先由<code>void doService(HttpServletRequest request, HttpServletResponse response)</code>处理的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doService</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//省略了打印日志的代码</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//attributesSnapshot一个用于保存请求快照的map</span></span><br><span class="line">Map&lt;String, Object&gt; attributesSnapshot = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (WebUtils.isIncludeRequest(request)) &#123;</span><br><span class="line"><span class="comment">//如果包含请求，就将request中的所有的属性存放到map中</span></span><br><span class="line">attributesSnapshot = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">Enumeration&lt;?&gt; attrNames = request.getAttributeNames();</span><br><span class="line"><span class="keyword">while</span> (attrNames.hasMoreElements()) &#123;</span><br><span class="line">String attrName = (String) attrNames.nextElement();</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.cleanupAfterInclude || attrName.startsWith(<span class="string">"org.springframework.web.servlet"</span>)) &#123;</span><br><span class="line">attributesSnapshot.put(attrName, request.getAttribute(attrName));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将一些对象设置到request中</span></span><br><span class="line">request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, getWebApplicationContext());</span><br><span class="line">request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, <span class="keyword">this</span>.localeResolver);</span><br><span class="line">request.setAttribute(THEME_RESOLVER_ATTRIBUTE, <span class="keyword">this</span>.themeResolver);</span><br><span class="line">request.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*FlashMap中保存的是上次转发请求中的属性*/</span></span><br><span class="line">FlashMap inputFlashMap = <span class="keyword">this</span>.flashMapManager.retrieveAndUpdate(request, response);</span><br><span class="line"><span class="comment">/*首先判断FlashMap中是否有数据，如果有数据就先设置到inputFlashMap中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span> (inputFlashMap != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">/*如果inputFlashMap不为空，一般代表上一次请求（一般是重定向）</span></span><br><span class="line"><span class="comment">中设置了参数，那么就吧这些参数存放到当前请求的FlashMap中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap));</span><br><span class="line">&#125;</span><br><span class="line">request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, <span class="keyword">new</span> FlashMap());</span><br><span class="line">request.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, <span class="keyword">this</span>.flashMapManager);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//调用doDispatch</span></span><br><span class="line">doDispatch(request, response);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123;</span><br><span class="line"><span class="comment">// Restore the original attribute snapshot, in case of an include.</span></span><br><span class="line"><span class="keyword">if</span> (attributesSnapshot != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//恢复请求参数的快照</span></span><br><span class="line">restoreAttributesAfterInclude(request, attributesSnapshot);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过对<code>doService</code>方法源码的分析，我们可以知道整个方法所做了三件事情：</p><ol><li>快照请求中的属性到<code>attributesSnapshot</code></li><li>将一些组件设置到request中，方便之后使用</li><li>处理FlashMap</li><li>调用<code>doDispatch(request, response)</code> </li><li><code>doDispatch(request, response)</code> 调用完成后利用<code>attributesSnapshot</code>对request中的属性进行还原</li></ol><p><code>doService</code>还没有真正的进行请求的处理，它所做的事情只是一些准备工作。</p><p>下面我们看<code>doDispatch(request, response)</code>到底做了什么事情：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">HttpServletRequest processedRequest = request;</span><br><span class="line">HandlerExecutionChain mappedHandler = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">boolean</span> multipartRequestParsed = <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取异步请求处理器管理器</span></span><br><span class="line">WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">ModelAndView mv = <span class="keyword">null</span>;</span><br><span class="line">Exception dispatchException = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//判断是否是Multipart请求</span></span><br><span class="line">processedRequest = checkMultipart(request);</span><br><span class="line"><span class="comment">//判断是否有多部分请求</span></span><br><span class="line">multipartRequestParsed = (processedRequest != request);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 确定当前请求的处理程序</span></span><br><span class="line">mappedHandler = getHandler(processedRequest);</span><br><span class="line"><span class="keyword">if</span> (mappedHandler == <span class="keyword">null</span> || mappedHandler.getHandler() == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//如果每找到当前请求的处理程序</span></span><br><span class="line">noHandlerFound(processedRequest, response);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据Handler找到对应的HandleAdapter</span></span><br><span class="line">HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Process last-modified header, if supported by the handler.</span></span><br><span class="line"><span class="comment">//获取请求的类型</span></span><br><span class="line">String method = request.getMethod();</span><br><span class="line"><span class="keyword">boolean</span> isGet = <span class="string">"GET"</span>.equals(method);</span><br><span class="line"><span class="keyword">if</span> (isGet || <span class="string">"HEAD"</span>.equals(method)) &#123;</span><br><span class="line"><span class="keyword">long</span> lastModified = ha.getLastModified(request, mappedHandler.getHandler());</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Last-Modified value for ["</span> + getRequestUri(request) + <span class="string">"] is: "</span> + lastModified);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">new</span> ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用HanxlerAdapter处理请求，返回ModleAndView对象</span></span><br><span class="line">mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//设置默认视图名字</span></span><br><span class="line">applyDefaultViewName(request, mv);</span><br><span class="line"><span class="comment">//应用拦截器的后置处理方法</span></span><br><span class="line">mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">dispatchException = ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果处理</span></span><br><span class="line">processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line"><span class="comment">//触发完成后的回调</span></span><br><span class="line">triggerAfterCompletion(processedRequest, response, mappedHandler, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Error err) &#123;</span><br><span class="line"><span class="comment">//触发出现错误的回调</span></span><br><span class="line">triggerAfterCompletionWithError(processedRequest, response, mappedHandler, err);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line"><span class="comment">// Instead of postHandle and afterCompletion</span></span><br><span class="line"><span class="keyword">if</span> (mappedHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Clean up any resources used by a multipart request.</span></span><br><span class="line"><span class="keyword">if</span> (multipartRequestParsed) &#123;</span><br><span class="line">cleanupMultipart(processedRequest);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>doDispatch</code>的执行步骤大致可以分为三个部分：</p><ol><li>根据request找到对应的Handler</li><li>根据找到的Handler找到对应的HandlerAdapter</li><li>用HandlerAdapter调用Handler处理请求</li><li>调用processDispatcheResult方法处理Handler处理之后的结果</li></ol><p>这4个步骤内部又完成了许多非常复杂的操作。下面我们就依次解析。</p><p><strong>1. <code>doDispatch</code>是如何通过request找到对应的Handler的？</strong><br>寻找对应的Handler实际上是由<code>mappedHandler = getHandler(processedRequest);</code>完成的。</p><p>它的具体实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> HandlerExecutionChain <span class="title">getHandler</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (HandlerMapping hm : <span class="keyword">this</span>.handlerMappings) &#123;</span><br><span class="line">HandlerExecutionChain handler = hm.getHandler(request);</span><br><span class="line"><span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> handler;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>去掉了打印日志的代码后，逻辑显得非常的简单。遍历<code>handlerMappings</code>，尝试从每一个<code>HandlerMapping</code>获取handler，一旦拿到就直接返回。<br>这里又有一个疑问：<code>handlerMappings</code>到底是什么？<br>它的声明如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** List of HandlerMappings used by this servlet */</span></span><br><span class="line"><span class="keyword">private</span> List&lt;HandlerMapping&gt; handlerMappings;</span><br></pre></td></tr></table></figure></p><p>而<code>HandlerMapping</code>其实比较复杂。它的整个架构设计图如下：<br><img src="https://s2.ax1x.com/2020/02/05/1rOyIU.png" alt="1rOyIU.png"><br>它的顶层接口<code>HandlerMapping</code>如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HandlerMapping</span> </span>&#123;</span><br><span class="line">String PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE = HandlerMapping.class.getName() + <span class="string">".pathWithinHandlerMapping"</span>;</span><br><span class="line"></span><br><span class="line">String BEST_MATCHING_PATTERN_ATTRIBUTE = HandlerMapping.class.getName() + <span class="string">".bestMatchingPattern"</span>;</span><br><span class="line"></span><br><span class="line">String INTROSPECT_TYPE_LEVEL_MAPPING = HandlerMapping.class.getName() + <span class="string">".introspectTypeLevelMapping"</span>;</span><br><span class="line"></span><br><span class="line">String URI_TEMPLATE_VARIABLES_ATTRIBUTE = HandlerMapping.class.getName() + <span class="string">".uriTemplateVariables"</span>;</span><br><span class="line"></span><br><span class="line">String MATRIX_VARIABLES_ATTRIBUTE = HandlerMapping.class.getName() + <span class="string">".matrixVariables"</span>;</span><br><span class="line"></span><br><span class="line">String PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE = HandlerMapping.class.getName() + <span class="string">".producibleMediaTypes"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">HandlerExecutionChain <span class="title">getHandler</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>简单的讲就是<code>HandlerMapping</code>中的<code>getHandler</code>方法会返回一个<code>HandlerExecutionChain</code>对象，该对象封装了一个Handler处理对象和一些interctptors（拦截器）。<br>下面是一个<code>HandlerExecutionChain</code>对象的属性：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Object handler;</span><br><span class="line"><span class="keyword">private</span> HandlerInterceptor[] interceptors;</span><br><span class="line"><span class="keyword">private</span> List&lt;HandlerInterceptor&gt; interceptorList;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> interceptorIndex = -<span class="number">1</span>;</span><br></pre></td></tr></table></figure></p><p><strong>2. <code>doDispatch</code>是如何通过Handler找到HandlerAdapter的，以及什么是HandlerAdapter？</strong></p><p>实现用<code>Handler</code>获取<code>HandlerAdapter</code>的代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</span><br></pre></td></tr></table></figure></p><p>它的具体实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> HandlerAdapter <span class="title">getHandlerAdapter</span><span class="params">(Object handler)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (HandlerAdapter ha : <span class="keyword">this</span>.handlerAdapters) &#123;</span><br><span class="line"><span class="keyword">if</span> (ha.supports(handler)) &#123;</span><br><span class="line"><span class="keyword">return</span> ha;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ServletException(<span class="string">"No adapter for handler ["</span> + handler +</span><br><span class="line"><span class="string">"]: The DispatcherServlet configuration needs to include a HandlerAdapter that supports this handler"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>去掉打印日志的方法后，我们可以发现，这个方法和根据request获取Handler的方法非常的一致。因此我们将重点放在：什么是<code>HandlerAdapter</code>上。<br><code>HandlerAdapter</code>接口声明如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HandlerAdapter</span> </span>&#123;</span><br><span class="line"><span class="comment">//查看当前的HandlerAdapter是否支持该handler解析</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Object handler)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用Handler处理请求</span></span><br><span class="line"><span class="function">ModelAndView <span class="title">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">getLastModified</span><span class="params">(HttpServletRequest request, Object handler)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>之所以需要HandlerAdapter，是因为Handler的格式是不固定的，所以处理请求的时候需要HandlerAdapter做适配。</p><p>拿到<code>HandlerAdapter</code>，就可做处理请求了。<br><code>mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</code><br>处理请求后就拿到了一个<code>ModelAndView</code>对象。</p><p>具体的代码实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最终拿到了我们的Controller类</span></span><br><span class="line">Class&lt;?&gt; clazz = ClassUtils.getUserClass(handler);</span><br><span class="line"><span class="comment">//判断是否使用了@SessionAttributes</span></span><br><span class="line">Boolean annotatedWithSessionAttributes = <span class="keyword">this</span>.sessionAnnotatedClassesCache.get(clazz);</span><br><span class="line"><span class="keyword">if</span> (annotatedWithSessionAttributes == <span class="keyword">null</span>) &#123;</span><br><span class="line">annotatedWithSessionAttributes = (AnnotationUtils.findAnnotation(clazz, SessionAttributes.class) != <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">this</span>.sessionAnnotatedClassesCache.put(clazz, annotatedWithSessionAttributes);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (annotatedWithSessionAttributes) &#123;</span><br><span class="line"><span class="comment">// Always prevent caching in case of session attribute management.</span></span><br><span class="line">checkAndPrepare(request, response, <span class="keyword">this</span>.cacheSecondsForSessionAttributeHandlers, <span class="keyword">true</span>);</span><br><span class="line"><span class="comment">// Prepare cached set of session attributes names.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 禁用缓存</span></span><br><span class="line">checkAndPrepare(request, response, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Execute invokeHandlerMethod in synchronized block if required.</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.synchronizeOnSession) &#123;</span><br><span class="line">HttpSession session = request.getSession(<span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">if</span> (session != <span class="keyword">null</span>) &#123;</span><br><span class="line">Object mutex = WebUtils.getSessionMutex(session);</span><br><span class="line"><span class="keyword">synchronized</span> (mutex) &#123;</span><br><span class="line"><span class="keyword">return</span> invokeHandlerMethod(request, response, handler);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> invokeHandlerMethod(request, response, handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最终又来到了<code>invokehandlerMethod</code>方法了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ModelAndView <span class="title">invokeHandlerMethod</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">ServletHandlerMethodResolver methodResolver = getMethodResolver(handler);</span><br><span class="line"><span class="comment">//获取处理请求的方法</span></span><br><span class="line">Method handlerMethod = methodResolver.resolveHandlerMethod(request);</span><br><span class="line"><span class="comment">//创建各种组件</span></span><br><span class="line">ServletHandlerMethodInvoker methodInvoker = <span class="keyword">new</span> ServletHandlerMethodInvoker(methodResolver);</span><br><span class="line">ServletWebRequest webRequest = <span class="keyword">new</span> ServletWebRequest(request, response);</span><br><span class="line">ExtendedModelMap implicitModel = <span class="keyword">new</span> BindingAwareModelMap();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用方法拿到结果</span></span><br><span class="line">Object result = methodInvoker.invokeHandlerMethod(handlerMethod, handler, webRequest, implicitModel);</span><br><span class="line"><span class="comment">//获取ModelAndView</span></span><br><span class="line">ModelAndView mav =</span><br><span class="line">methodInvoker.getModelAndView(handlerMethod, handler.getClass(), result, implicitModel, webRequest);</span><br><span class="line"><span class="comment">//更新view中的属性</span></span><br><span class="line">methodInvoker.updateModelAttributes(handler, (mav != <span class="keyword">null</span> ? mav.getModel() : <span class="keyword">null</span>), implicitModel, webRequest);</span><br><span class="line"><span class="keyword">return</span> mav;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后调用<code>mappedHandler.applyPostHandle(processedRequest, response, mv);</code>进行后处理。后处理的过程就是调用所有的后置拦截器进行处理。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;SpringMVC是一种web层的mvc框架，用于替代Servlet，主要用于处理和相应请求，获取表单参数，表单校验。使用SpringMVC可以简化编程。&lt;/p&gt;
&lt;h2 id=&quot;SpringMVC底层的执行流程&quot;&gt;&lt;a href=&quot;#SpringMVC底层的执行流程&quot; class=&quot;headerlink&quot; title=&quot;SpringMVC底层的执行流程&quot;&gt;&lt;/a&gt;SpringMVC底层的执行流程&lt;/h2&gt;&lt;p&gt;首先通过一张流传广泛的图，来了解一下大致的流程。&lt;br&gt;&lt;img src=&quot;https://s2.ax1x.com/2020/02/05/1rJAu4.png&quot; alt=&quot;1rJAu4.png&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="源码" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="SpringMVC" scheme="http://yoursite.com/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC源码分析一</title>
    <link href="http://yoursite.com/2020/02/05/SpringMVC%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%80/"/>
    <id>http://yoursite.com/2020/02/05/SpringMVC源码分析一/</id>
    <published>2020-02-05T02:01:00.000Z</published>
    <updated>2020-02-05T02:01:51.292Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="什么是servlet">什么是Servlet？</span></h2><p>Servlet实际是Servcer+Applet的缩写，表示一个服务器应用。Servlet是JavaEE规范的一部分。</p><p>在Servlet3.1中，它的结构图如下：<br><img src="https://s2.ax1x.com/2020/01/31/18mZLV.png" alt="18mZLV.png"></p><a id="more"></a><p>Servlet接口定义如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Servlet</span></span>&#123;</span><br><span class="line">    <span class="comment">/*这个方法在容器启动的时候被容器调用，</span></span><br><span class="line"><span class="comment">    但是当load-on-startup设置为负数或者不设置的时候，</span></span><br><span class="line"><span class="comment">    是在Servlet第一次被用到的时候调用*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> nServletException</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*用于获取ServletConfig*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletConfig <span class="title">getServletConfig</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/*用于处理具体的请求*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req,ServletResponse res)</span> <span class="keyword">throws</span> ServletException,IOException</span>;</span><br><span class="line">    <span class="comment">/*获取Servlet的相关信息，如作者等，默认实现返回空串*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getServletInfo</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*在Servlet销毁的时候（关闭服务器）调用，用于释放资源，只会调用一次*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在<code>init(ServletConfig config)</code>调用的时候，需要一个<code>ServletConfig</code>对象，这个对象中存放了初始化Servlet的信息，其中一部分就来自于我们的配置文件中的<code>&lt;init-param&gt;</code><br>标签下的内容。<br><img src="https://s2.ax1x.com/2020/02/01/18gtns.png" alt="18gtns.png"></p><p>ServletConfig接口的定义如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ServletConfig</span></span>&#123;</span><br><span class="line">    <span class="comment">/*返回的就是我们配置的servlet-name*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getServletName</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/*这个地方返回的ServletContext代表的就是我们这个应用本身*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletContext <span class="title">getServletContext</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*用于获取init-param配置的参数*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getInitParameter</span><span class="params">(String name)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Enumeration&lt;String&gt; <span class="title">getInitParameterNames</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2><span id="tomcat的顶层结构">Tomcat的顶层结构</span></h2><p>Tomcat最顶层的是Server，代表整个服务器，Server中至少包含一个Service，用于提供具体的服务。一个Service主要包含两个部分，分别是Connector和Container。  Connector用于处理连接相关的事情，并提供Socket与request、response的转化，Container用于封装和管理Servlet，以及剧吐处理request请求。一个Service中可以有多个connectors，但是只有一个Container。<br><img src="https://s2.ax1x.com/2020/02/01/18hYTA.png" alt="18hYTA.png"></p><p>Tomcat中的server由org.apache.catalina.startup.Catalina来管理，它是整个Tomcat的管理类，它里面包含了load，start，stop方法，分别用来管理整个服务器的生命周期。load方法会根据conf/server.xml创建Server并调用Server的init方法进行初始化，start方法用于启动服务器，stop方法用于停止服务器。<br>在启动的时候会逐层调用这些方法。<br>Tomcat虽然由Catalina管理，但是Tomcat的main却在org.qpache.catalina.startup.Bootstrap中，Bootstrap的作用类似一个CatalinaAdaptor，具体的处理过程还是使用Catalina来进行的，这样将启动类和管理类分开，可以更加方便地拓展启动方式。</p><h3><span id="bootstrap的启动过程">Bootstrap的启动过程</span></h3><p>启动tomcat首先就是调用Bootstrap的main方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (daemonLock) &#123;</span><br><span class="line">            <span class="keyword">if</span> (daemon == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="comment">//初始化一个启动器</span></span><br><span class="line">                Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//创建了catalina实例，并且赋值给了catalinaDaemon变量</span></span><br><span class="line">                    bootstrap.init();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    handleThrowable(t);</span><br><span class="line">                    t.printStackTrace();</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                daemon = bootstrap;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// When running as a service the call to stop will be on a new</span></span><br><span class="line">                <span class="comment">// thread so make sure the correct class loader is used to</span></span><br><span class="line">                <span class="comment">// prevent a range of class not found exceptions.</span></span><br><span class="line">                Thread.currentThread().setContextClassLoader(daemon.catalinaLoader);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理main方法传入的命令</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String command = <span class="string">"start"</span>;</span><br><span class="line">            <span class="keyword">if</span> (args.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                command = args[args.length - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (command.equals(<span class="string">"startd"</span>)) &#123;</span><br><span class="line">                args[args.length - <span class="number">1</span>] = <span class="string">"start"</span>;</span><br><span class="line">               </span><br><span class="line">                daemon.load(args);</span><br><span class="line">                daemon.start();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (command.equals(<span class="string">"stopd"</span>)) &#123;</span><br><span class="line">                args[args.length - <span class="number">1</span>] = <span class="string">"stop"</span>;</span><br><span class="line">                daemon.stop();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (command.equals(<span class="string">"start"</span>)) &#123;</span><br><span class="line">             <span class="comment">//处理启动命令</span></span><br><span class="line">            <span class="comment">//这里的三个方法都调用了Catalina的相关方法</span></span><br><span class="line">                daemon.setAwait(<span class="keyword">true</span>);</span><br><span class="line">                daemon.load(args);</span><br><span class="line">                daemon.start();</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == daemon.getServer()) &#123;</span><br><span class="line">                    System.exit(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (command.equals(<span class="string">"stop"</span>)) &#123;</span><br><span class="line">                daemon.stopServer(args);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (command.equals(<span class="string">"configtest"</span>)) &#123;</span><br><span class="line">                daemon.load(args);</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == daemon.getServer()) &#123;</span><br><span class="line">                    System.exit(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                System.exit(<span class="number">0</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                log.warn(<span class="string">"Bootstrap: command \""</span> + command + <span class="string">"\" does not exist."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="comment">// Unwrap the Exception for clearer error reporting</span></span><br><span class="line">            <span class="keyword">if</span> (t <span class="keyword">instanceof</span> InvocationTargetException &amp;&amp;</span><br><span class="line">                    t.getCause() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                t = t.getCause();</span><br><span class="line">            &#125;</span><br><span class="line">            handleThrowable(t);</span><br><span class="line">            t.printStackTrace();</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h3><span id="catalina的启动过程">Catalina的启动过程</span></h3><p>通过对Bootstrap启动类的分析，我们可以知道，启动Catalina主要是通过以下三个方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置Server启动完成后是否立即进入等待状态的标志</span></span><br><span class="line">daemon.setAwait(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">//加载配置文件，创建并初始化Server</span></span><br><span class="line">daemon.load(args);</span><br><span class="line"><span class="comment">//启动服务器</span></span><br><span class="line">daemon.start();</span><br></pre></td></tr></table></figure></p><p>在Bootstrap中这三个方法的实现其实都是利用反射调用了Catalina中的相应的方法，我们直接查看Catalina中的实现。<br>下面我们依次看这三个方法的具体实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAwait</span><span class="params">(<span class="keyword">boolean</span> b)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//这个方法仅仅是设置了一个标志位，表示启动后是否立即进入等待状态</span></span><br><span class="line">    await = b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">load</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (loaded) &#123;</span><br><span class="line">    <span class="comment">//如果已经load过了，就返回</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置标志位，表示已经加载过了</span></span><br><span class="line">    loaded = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//用于记录启动耗时</span></span><br><span class="line">    <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//下面的代码都是用来创建Server的</span></span><br><span class="line">    initDirs();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Before digester - it may be needed</span></span><br><span class="line">    initNaming();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用Digester解析conf/server.xml文件创建了Server对象，</span></span><br><span class="line">    <span class="comment">//并赋值给了Server属性</span></span><br><span class="line">    <span class="comment">// Set configuration source</span></span><br><span class="line">    ConfigFileLoader.setSource(<span class="keyword">new</span> CatalinaBaseConfigurationSource(Bootstrap.getCatalinaBaseFile(), getConfigFile()));</span><br><span class="line">    File file = configFile();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create and execute our Digester</span></span><br><span class="line">    Digester digester = createStartDigester();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> (ConfigurationSource.Resource resource = ConfigFileLoader.getSource().getServerXml()) &#123;</span><br><span class="line">        InputStream inputStream = resource.getInputStream();</span><br><span class="line">        InputSource inputSource = <span class="keyword">new</span> InputSource(resource.getURI().toURL().toString());</span><br><span class="line">        inputSource.setByteStream(inputStream);</span><br><span class="line">        digester.push(<span class="keyword">this</span>);</span><br><span class="line">        digester.parse(inputSource);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.warn(sm.getString(<span class="string">"catalina.configFail"</span>, file.getAbsolutePath()), e);</span><br><span class="line">        <span class="keyword">if</span> (file.exists() &amp;&amp; !file.canRead()) &#123;</span><br><span class="line">            log.warn(sm.getString(<span class="string">"catalina.incorrectPermissions"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getServer().setCatalina(<span class="keyword">this</span>);</span><br><span class="line">    getServer().setCatalinaHome(Bootstrap.getCatalinaHomeFile());</span><br><span class="line">    getServer().setCatalinaBase(Bootstrap.getCatalinaBaseFile());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Stream redirection</span></span><br><span class="line">    initStreams();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start the new server</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        getServer().init();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (LifecycleException e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Boolean.getBoolean(<span class="string">"org.apache.catalina.startup.EXIT_ON_INIT_FAILURE"</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> java.lang.Error(e);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.error(sm.getString(<span class="string">"catalina.initError"</span>), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> t2 = System.nanoTime();</span><br><span class="line">    <span class="keyword">if</span>(log.isInfoEnabled()) &#123;</span><br><span class="line">        log.info(sm.getString(<span class="string">"catalina.init"</span>, Long.valueOf((t2 - t1) / <span class="number">1000000</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (getServer() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        load();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (getServer() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        log.fatal(sm.getString(<span class="string">"catalina.noServer"</span>));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start the new server</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//调用Server的start方法，启动服务器</span></span><br><span class="line">        getServer().start();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (LifecycleException e) &#123;</span><br><span class="line">        log.fatal(sm.getString(<span class="string">"catalina.serverStartFail"</span>), e);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            getServer().destroy();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (LifecycleException e1) &#123;</span><br><span class="line">            log.debug(<span class="string">"destroy() failed for failed Server "</span>, e1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> t2 = System.nanoTime();</span><br><span class="line">    <span class="keyword">if</span>(log.isInfoEnabled()) &#123;</span><br><span class="line">        log.info(sm.getString(<span class="string">"catalina.startup"</span>, Long.valueOf((t2 - t1) / <span class="number">1000000</span>)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册关闭钩爪代码</span></span><br><span class="line">    <span class="keyword">if</span> (useShutdownHook) &#123;</span><br><span class="line">        <span class="keyword">if</span> (shutdownHook == <span class="keyword">null</span>) &#123;</span><br><span class="line">            shutdownHook = <span class="keyword">new</span> CatalinaShutdownHook();</span><br><span class="line">        &#125;</span><br><span class="line">        Runtime.getRuntime().addShutdownHook(shutdownHook);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If JULI is being used, disable JULI's shutdown hook since</span></span><br><span class="line">        <span class="comment">// shutdown hooks run in parallel and log messages may be lost</span></span><br><span class="line">        <span class="comment">// if JULI's hook completes before the CatalinaShutdownHook()</span></span><br><span class="line">        LogManager logManager = LogManager.getLogManager();</span><br><span class="line">        <span class="keyword">if</span> (logManager <span class="keyword">instanceof</span> ClassLoaderLogManager) &#123;</span><br><span class="line">            ((ClassLoaderLogManager) logManager).setUseShutdownHook(</span><br><span class="line">                    <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//更加await的值确定是否进入等待状态</span></span><br><span class="line">    <span class="keyword">if</span> (await) &#123;</span><br><span class="line">        await();</span><br><span class="line">        stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个Server的启动过程如下，首先设置启动后是否进入等待的标志位，然后调用load方法来加载配置文件，创建Server对象，最后调用server对象的start方法来启动服务器，最后再注册服务器关闭的钩爪函数，根据之前设置的标志位决定是否进入等待状态。</p><h3><span id="server的启动过程">Server的启动过程</span></h3><p>Server接口中提供了<code>addServer(Server service)</code>，<code>removeService(Service service)</code>来添加和删除Service。Server的init方法和start方法，分配循环调用了每个Service的init方法和start方法以此来启动所有的Service。</p><p>Server的默认实现是<code>org/apache/catalina/core/StandardServer.java</code><br><code>class StandardServer extends LifecycleMBeanBase implements Server</code></p><p>Server继承了<code>LifecycleMBeanBase</code>，init和start方法就是在<code>LifecycleMBeanBase</code>的父类<code>LifecycleBase</code>中定义的。<br>StandardServer中的<code>initInternal</code>和<code>startInternal</code>方法就是Tomcate生命周期的管理方式。<br>这两个方法的内部主要就是向下面一样，依次调用所有的Service的相应的方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (servicesLock) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; services.length; i++) &#123;</span><br><span class="line">                services[i].start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p><h3><span id="service的启动过程">Service的启动过程</span></h3><p>Service的默认实现是<code>org.apache.catalina.core.StandardService</code>,<br><code>class StandardService extends LifecycleMBeanBase implements Service</code><br>它同样也是继承自<code>LifecycleMBeanBase</code>类的，所以init和start方法最终就会调用<code>initInternal</code>和<code>startInternal</code>方法。<br>这两个方法的具体实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">startInternal</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(log.isInfoEnabled())</span><br><span class="line">            log.info(sm.getString(<span class="string">"standardService.start.name"</span>, <span class="keyword">this</span>.name));</span><br><span class="line">        setState(LifecycleState.STARTING);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Start our defined Container first</span></span><br><span class="line">        <span class="keyword">if</span> (engine != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (engine) &#123;</span><br><span class="line">            <span class="comment">//调用engine的start方法</span></span><br><span class="line">                engine.start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (executors) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Executor executor: executors) &#123;</span><br><span class="line">                executor.start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mapperListener.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Start our defined Connectors second</span></span><br><span class="line">        <span class="keyword">synchronized</span> (connectorsLock) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Connector connector: connectors) &#123;</span><br><span class="line">                <span class="comment">// If it has already failed, don't try and start it</span></span><br><span class="line">                <span class="keyword">if</span> (connector.getState() != LifecycleState.FAILED) &#123;</span><br><span class="line">                    connector.start();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>以<code>startInternal</code>为例，<code>startInternal</code>和<code>initInternal</code>方法内部主要是调用container,executors,mapperListener,connectors的init和start方法。其中executors的作用主要是管理线程池。</p><p>整个Tomcat服务器的启动流程图如下：<br><img src="https://s2.ax1x.com/2020/02/01/1Gha80.png" alt="1Gha80.png"></p><h2><span id="tomcat的生命周期管理">Tomcat的生命周期管理</span></h2><p>Tomcat的生命周期管理是由<code>org.apache.catalina.lifecycle</code>接口来定义的。<br>该接口主要完成3件事情：</p><ol><li>定义了13个string类型的常量，用于LifecycleEvent事件的type属性，作用是区分组件发出的LifecycleEvent事件的状态。</li><li>定义了3个管理监听器的方法，addLifecycleListener,findLifecycleListeners和removeLifecycleListener.</li><li>定义了4个生命周期方法,init,start,stop,destory</li><li>定义了获取当前状态的两个方法getState和getStateName</li></ol><p>LifecycleBase是LifecycleBase接口的默认实现。而监听器的管理是由<code>LifecycleSupport</code>类来完成的。</p><p>以<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> LifecycleException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (LifecycleState.STARTING_PREP.equals(state) || LifecycleState.STARTING.equals(state) ||</span><br><span class="line">            LifecycleState.STARTED.equals(state)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">            Exception e = <span class="keyword">new</span> LifecycleException();</span><br><span class="line">            log.debug(sm.getString(<span class="string">"lifecycleBase.alreadyStarted"</span>, toString()), e);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (log.isInfoEnabled()) &#123;</span><br><span class="line">            log.info(sm.getString(<span class="string">"lifecycleBase.alreadyStarted"</span>, toString()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调整状态</span></span><br><span class="line">    <span class="keyword">if</span> (state.equals(LifecycleState.NEW)) &#123;</span><br><span class="line">        init();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state.equals(LifecycleState.FAILED)) &#123;</span><br><span class="line">        stop();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!state.equals(LifecycleState.INITIALIZED) &amp;&amp;</span><br><span class="line">            !state.equals(LifecycleState.STOPPED)) &#123;</span><br><span class="line">        invalidTransition(Lifecycle.BEFORE_START_EVENT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    </span><br><span class="line">        setStateInternal(LifecycleState.STARTING_PREP, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//调用相应的模板方法</span></span><br><span class="line">        startInternal();</span><br><span class="line">        <span class="keyword">if</span> (state.equals(LifecycleState.FAILED)) &#123;</span><br><span class="line">            <span class="comment">// This is a 'controlled' failure. The component put itself into the</span></span><br><span class="line">            <span class="comment">// FAILED state so call stop() to complete the clean-up.</span></span><br><span class="line">            stop();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!state.equals(LifecycleState.STARTING)) &#123;</span><br><span class="line">            <span class="comment">// Shouldn't be necessary but acts as a check that sub-classes are</span></span><br><span class="line">            <span class="comment">// doing what they are supposed to.</span></span><br><span class="line">            invalidTransition(Lifecycle.AFTER_START_EVENT);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            setStateInternal(LifecycleState.STARTED, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="comment">// This is an 'uncontrolled' failure so put the component into the</span></span><br><span class="line">        <span class="comment">// FAILED state and throw an exception.</span></span><br><span class="line">        handleSubClassException(t, <span class="string">"lifecycleBase.startFail"</span>, toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个方法的实现时，首先会判断当前状态和要处理的方法是否匹配，如果不匹配会执行相应的方法使其匹配，然后再调用相应的模板方法并设置状态。</p><h2><span id="container分析">Container分析</span></h2><p>Container时tomcat容器的接口。Container一共有4个子接口Engine、Host、Context、Wrapper和一个默认实现类ContainerBase.每个子接口都是一个容器。</p><p><img src="https://s2.ax1x.com/2020/02/01/1GXJVx.png" alt="1GXJVx.png"></p><p>Container的子容器Engine，Host，Context，Wrapper是逐层包含的关系。<br><img src="https://s2.ax1x.com/2020/02/01/1GXwxH.png" alt="1GXwxH.png"></p><ul><li>Engine：引擎，用于管理多个站点，一个Service最多只能由一个Engine。</li><li>Host：代表一个站点，也称为虚拟主机，通过配置host就可以添加站点。</li><li>Context：代表一个应用程序，对应着平时开发的一个程序，或WEB-INF下的一个web.xml文件</li><li>Wrapper：每个Wrapper封装着一个Servlet。</li></ul><h2><span id="connector分析">Connector分析</span></h2><p>Connector用于接收请求并将请求封装成Request和Response来具体处理，最底层是使用Socket来进行连接的，Request和Response是按照HTTP协议来封装的，所以Connecter同时实现了TCP/IP协议和HTTP协议，Request和Response封装完之后交给Container进行处理。Container就是Servlet的容器，Container处理完之后返回给Connector，最后Connector使用Socker将结果返回给客户端，这样整个请求就处理完成了。<br><img src="https://s2.ax1x.com/2020/02/02/1YM9Zn.png" alt="1YM9Zn.png"></p><p>Connector具体是使用ProtocolHandler来处理请求的，不同的ProtocolHandler代表不同的连接类型。ProtocolHandler里面有3个组件：Endpoint，Processor和Adapter。Endpoint用于处理底层的Socket网络连接，Processor用于将Endpoint接收到的Socket封装成为Request，Adapter负责将请求适配到Servlet容器进行具体的处理。</p><h2><span id="springmvc的启动过程">SpringMVC的启动过程</span></h2><h3><span id="springmvc的结构">SpringMVC的结构</span></h3><p><img src="https://s2.ax1x.com/2020/02/03/1NTGcj.png" alt="1NTGcj.png"></p><p>spring部分的EnvironmentAware和ApplicationContextAware接口，都是继承自Aware接口的，在spring中XXXAware接口表示对XXX可感知的，继承相应的接口然后实现setXXX方法，就可以拿到相应的对象。比如继承EnvironmentAware接口并实现setEnvironment就可以拿到spring中的Environment对象了，spring会自动注入。</p><p>而EnvironmentCapable接口就是告诉spring自己可以提供Environment，实现它其中唯一的一个方法<code>Environment getEnvironment()</code></p><p>而我们分析SpringMVC的启动过程主要就是分析HttpServletBean，FrameworkServlet，DispatcherServlet三个类。</p><h3><span id="httpservletbean">HttpServletBean</span></h3><p>通过之前的分析我们知道Servlet的创建首先会调用无参的init方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Initializing servlet '"</span> + getServletName() + <span class="string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set bean properties from init parameters.</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//将Servlet中配置的信息封装到pvs变量中</span></span><br><span class="line">PropertyValues pvs = <span class="keyword">new</span> ServletConfigPropertyValues(getServletConfig(), <span class="keyword">this</span>.requiredProperties);</span><br><span class="line">BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(<span class="keyword">this</span>);</span><br><span class="line">ResourceLoader resourceLoader = <span class="keyword">new</span> ServletContextResourceLoader(getServletContext());</span><br><span class="line">bw.registerCustomEditor(Resource.class, <span class="keyword">new</span> ResourceEditor(resourceLoader, getEnvironment()));</span><br><span class="line"><span class="comment">//模板方法，可以在子类调用，做一些初始化的工作。</span></span><br><span class="line">initBeanWrapper(bw);</span><br><span class="line"><span class="comment">//将配置的初始化值设置到DispatchcherServlet中</span></span><br><span class="line">bw.setPropertyValues(pvs, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">logger.error(<span class="string">"Failed to set bean properties on servlet '"</span> + getServletName() + <span class="string">"'"</span>, ex);</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Let subclasses do whatever initialization they like.</span></span><br><span class="line"><span class="comment">//模板方法，子类初始化的入口方法</span></span><br><span class="line">initServletBean();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Servlet '"</span> + getServletName() + <span class="string">"' configured successfully"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在HttpServletBean的init方法中，首先将Serlvet中配置的参数（封装到了pvs中）使用BeanWrapper（Spring提供的用来操作javaBean属性的工具，使用它可以直接修改一个对象的属性）设置到DispatcherServle的相关属性，然后调用模板方法initServletBean，子类就通过这个方法初始化。</p><h3><span id="frameworkserlvet">FrameworkSerlvet</span></h3><p>从HttpServletBean的init流程，我们可以知道FrameworkServlet的初始化入口方法应该是<code>initServletBean</code>.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">initServletBean</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">getServletContext().log(<span class="string">"Initializing Spring FrameworkServlet '"</span> + getServletName() + <span class="string">"'"</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.logger.isInfoEnabled()) &#123;</span><br><span class="line"><span class="keyword">this</span>.logger.info(<span class="string">"FrameworkServlet '"</span> + getServletName() + <span class="string">"': initialization started"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//初始化WebApplicationContext</span></span><br><span class="line"><span class="keyword">this</span>.webApplicationContext = initWebApplicationContext();</span><br><span class="line"><span class="comment">//调用模板方法，初始化FrameworkServlet</span></span><br><span class="line">initFrameworkServlet();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ServletException ex) &#123;</span><br><span class="line"><span class="keyword">this</span>.logger.error(<span class="string">"Context initialization failed"</span>, ex);</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (RuntimeException ex) &#123;</span><br><span class="line"><span class="keyword">this</span>.logger.error(<span class="string">"Context initialization failed"</span>, ex);</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.logger.isInfoEnabled()) &#123;</span><br><span class="line"><span class="keyword">long</span> elapsedTime = System.currentTimeMillis() - startTime;</span><br><span class="line"><span class="keyword">this</span>.logger.info(<span class="string">"FrameworkServlet '"</span> + getServletName() + <span class="string">"': initialization completed in "</span> +</span><br><span class="line">elapsedTime + <span class="string">" ms"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>用于初始化WebApplicationContext的<code>initWebApplicationContext();</code>方法的实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> WebApplicationContext <span class="title">initWebApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取rootContext</span></span><br><span class="line">WebApplicationContext rootContext =</span><br><span class="line">WebApplicationContextUtils.getWebApplicationContext(getServletContext());</span><br><span class="line">WebApplicationContext wac = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果已经通过构造方法设置了webApplicationContext</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.webApplicationContext != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// A context instance was injected at construction time -&gt; use it</span></span><br><span class="line">wac = <span class="keyword">this</span>.webApplicationContext;</span><br><span class="line"><span class="keyword">if</span> (wac <span class="keyword">instanceof</span> ConfigurableWebApplicationContext) &#123;</span><br><span class="line">ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) wac;</span><br><span class="line"><span class="keyword">if</span> (!cwac.isActive()) &#123;</span><br><span class="line"><span class="comment">// The context has not yet been refreshed -&gt; provide services such as</span></span><br><span class="line"><span class="comment">// setting the parent context, setting the application context id, etc</span></span><br><span class="line"><span class="keyword">if</span> (cwac.getParent() == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// The context instance was injected without an explicit parent -&gt; set</span></span><br><span class="line"><span class="comment">// the root application context (if any; may be null) as the parent</span></span><br><span class="line">cwac.setParent(rootContext);</span><br><span class="line">&#125;</span><br><span class="line">configureAndRefreshWebApplicationContext(cwac);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (wac == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// No context instance was injected at construction time -&gt; see if one</span></span><br><span class="line"><span class="comment">// has been registered in the servlet context. If one exists, it is assumed</span></span><br><span class="line"><span class="comment">// that the parent context (if any) has already been set and that the</span></span><br><span class="line"><span class="comment">// user has performed any initialization such as setting the context id</span></span><br><span class="line"><span class="comment">//当webApplicationContext已经存在ServletContext中时，</span></span><br><span class="line"><span class="comment">//通过配置在Servlet中的contextAttribute参数获取</span></span><br><span class="line">wac = findWebApplicationContext();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (wac == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// No context instance is defined for this servlet -&gt; create a local one</span></span><br><span class="line"><span class="comment">//如果webApplicationContext还没看有创建，则创建一个</span></span><br><span class="line">wac = createWebApplicationContext(rootContext);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.refreshEventReceived) &#123;</span><br><span class="line"><span class="comment">// Either the context is not a ConfigurableApplicationContext with refresh</span></span><br><span class="line"><span class="comment">// support or the context injected at construction time had already been</span></span><br><span class="line"><span class="comment">// refreshed -&gt; trigger initial onRefresh manually here.</span></span><br><span class="line"><span class="comment">//当contextRefreshedEvent事件没有触发时调用此模板方法</span></span><br><span class="line">onRefresh(wac);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.publishContext) &#123;</span><br><span class="line"><span class="comment">// Publish the context as a servlet context attribute.</span></span><br><span class="line"><span class="comment">//将ApplicatinoContext保存到ServletContext中</span></span><br><span class="line">String attrName = getServletContextAttributeName();</span><br><span class="line">getServletContext().setAttribute(attrName, wac);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line"><span class="keyword">this</span>.logger.debug(<span class="string">"Published WebApplicationContext of servlet '"</span> + getServletName() +</span><br><span class="line"><span class="string">"' as ServletContext attribute with name ["</span> + attrName + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> wac;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>initWebApplicationContext()</code>方法做了三件事情：</p><ol><li>获取spring的根容器rootContext</li><li>设置webApplicationContext并根据情况调用onRefresh方法</li><li>将webApplicationContext设置到ServletContext中</li></ol><h3><span id="dispatcherservlet">DispatcherServlet</span></h3><p>onRefresh方法时DispatcherServlet的入口方法。OnRefresh中简单的调用了initStrategies，在initStrategies中调用了9个初始化方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRefresh</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line">initStrategies(context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initStrategies</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line">initMultipartResolver(context);</span><br><span class="line">initLocaleResolver(context);</span><br><span class="line">initThemeResolver(context);</span><br><span class="line">initHandlerMappings(context);</span><br><span class="line">initHandlerAdapters(context);</span><br><span class="line">initHandlerExceptionResolvers(context);</span><br><span class="line">initRequestToViewNameTranslator(context);</span><br><span class="line">initViewResolvers(context);</span><br><span class="line">initFlashMapManager(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是Servlet？&quot;&gt;&lt;a href=&quot;#什么是Servlet？&quot; class=&quot;headerlink&quot; title=&quot;什么是Servlet？&quot;&gt;&lt;/a&gt;什么是Servlet？&lt;/h2&gt;&lt;p&gt;Servlet实际是Servcer+Applet的缩写，表示一个服务器应用。Servlet是JavaEE规范的一部分。&lt;/p&gt;
&lt;p&gt;在Servlet3.1中，它的结构图如下：&lt;br&gt;&lt;img src=&quot;https://s2.ax1x.com/2020/01/31/18mZLV.png&quot; alt=&quot;18mZLV.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="源码" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="SpringMVC" scheme="http://yoursite.com/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>对秒杀系统的一些思考</title>
    <link href="http://yoursite.com/2020/01/28/%E5%AF%B9%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/"/>
    <id>http://yoursite.com/2020/01/28/对秒杀系统的一些思考/</id>
    <published>2020-01-28T08:43:56.000Z</published>
    <updated>2020-01-28T13:51:03.504Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="秒杀系统的特点">秒杀系统的特点</span></h2><ul><li>高性能：秒杀涉及到大量的并发读和并发写，因此支持高并发访问这点非常的关键。</li><li>一致性：秒杀是有限数量的商品在同一时刻被很多倍的请求同时来减库存，在大并发更新的过程中都要保证数据的准确性。</li><li>高可用：秒杀时会在瞬间涌入大量的流量，为了避免系统宕机，保证高可用，需要做好流量限制。</li></ul><a id="more"></a><h2><span id="秒杀系统的优化思路">秒杀系统的优化思路</span></h2><h3><span id="后端优化">后端优化</span></h3><ol><li>限流：秒杀系统往往是多于商品数量数倍的请求来抢购，我们可以屏蔽掉无用的流量，允许少部分流量走后端。</li><li>削峰：秒杀请求在时间上高度集中于某一个时间点，随时的流量很容易压垮系统，因此需要对流量进行削峰处理，缓冲瞬时流量，尽量让服务器平缓的处理这些请求。</li><li>异步：将同步请求转化为异步请求，来提高并发量。</li><li>利用缓存：创建订单时，每次都需要先查询判断库存，只有少部分成功的请求才会创建订单，因此可以将商品信息放在缓存中，减少数据库查询。</li><li>负载均衡：利用Nginx进行负载均衡，减轻单个服务器的压力。</li></ol><h3><span id="前端优化">前端优化</span></h3><ol><li>限流：前端答题或验证码来分散用户的请求。</li><li>禁止重复提交：限定每个用户发起一次秒杀之后，需要等待才可以发起另一次请求，从而减少重复的用户请求。</li><li>本地标记：当用户成功秒杀到商品后，禁止用户再次提交请求。</li><li>动静分离：将前端静态数据直接缓存到离用户最近的地方，比如用户浏览器、CDN或者服务器的缓存中。</li></ol><h3><span id="防作弊优化">防作弊优化</span></h3><ol><li>隐藏秒杀接口：为了避免在秒杀开始之前被用户发现刷接口，因此需要用户在没到秒杀开始不能获取秒杀接口，只有秒杀开始了，才返回秒杀地址url和验证MD5，用户拿到这两个数据才可以进行秒杀。</li><li>对僵尸账号限制：对于一些僵尸账号，可以检测账号的活跃度或者等级信息来进行限制。当然也可以通过用户画像限制僵尸号。</li></ol><h2><span id="如何做好限流">如何做好限流</span></h2><p>在应对秒杀，大促销等高性能压力的场景时，为了保证系统的平稳运行，必须针对超过预期的流浪，通过预先设定的限流规则选择性的对某些请求进行限流“熔断”。</p><p>下面就介绍一下，我了解到的一些限流算法。</p><h3><span id="计数器算法">计数器算法</span></h3><p>通过一个计数器counter来统计一段时间内请求的数量，并且在指定的时间之后重置计数器。该算法实现简单，但是会出现<strong>临界问题</strong>。<br>比如，我们的限流规则是每秒不超过100次请求。假如，第一个1s的时间窗口内，请求集中到最后的10ms内，在第二个1s的时间窗口内，100次请求都集中在最开始的10ms内，那们实际上在短短的20ms内就集中的200次请求，那么很能就会压垮系统。</p><p>计数器限流算法的Redis Lua实现：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">-- 资源的唯一标识位</span></span><br><span class="line"><span class="keyword">local</span> key=KEYS[<span class="number">1</span>]</span><br><span class="line"><span class="comment">-- 限流大小</span></span><br><span class="line"><span class="keyword">local</span> limit=<span class="built_in">tonumber</span>(ARGV[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 获取当前的流量</span></span><br><span class="line"><span class="keyword">local</span> currentLimit=<span class="built_in">tonumber</span>(redis.call(<span class="string">'get'</span>,key) <span class="keyword">or</span> <span class="string">"0"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> currentLimit+<span class="number">1</span>&gt;limit <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 已经达到限流大小，返回0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="comment">-- 没有达到阈值value+1</span></span><br><span class="line">    redis.call(<span class="string">'INCRBY'</span>,key,<span class="number">1</span>)</span><br><span class="line">    <span class="comment">-- 设置过期时间</span></span><br><span class="line">    redis.call(<span class="string">'EXPIRE'</span>,key,<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> currentLimit+<span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><h3><span id="滑动窗口算法">滑动窗口算法</span></h3><p>滑动窗口算法是计数器算法的一种改进，将原来的一个时间窗口划分为多个时间窗口，并且不断向右滑动该窗口。流量经过滑动时间窗口整形之后，可以保证任意时间窗口内，都不会超过最大允许的限流值，从而流量曲线回更加平滑，可以部分解决上面提到的临界突发流量问题。<br>但是基于时间窗口的限流算法，只能在选定的时间粒度上限流，对选定时间粒度内的更加细粒度的访问频率不做限制。</p><h3><span id="令牌桶法">令牌桶法</span></h3><p>令牌桶法的工作流程如下；</p><ol><li>如果在t秒内限制请求的数量为n，那么每过t/n秒向桶内添加一个token。</li><li>如果令牌桶内的token的数量超过限制b，那么多于的token会被抛弃。</li><li>每次请求进入之时，需要先尝试从令牌桶中拿token，只有拿到了token才会处理接口请求，否则进行限流处理。</li></ol><p>基于Redis Lua的令牌桶限流算法实现：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 令牌的唯一标识</span></span><br><span class="line"><span class="keyword">local</span> bucketKey = KEYS[<span class="number">1</span>]</span><br><span class="line"><span class="comment">-- 上次请求的时间</span></span><br><span class="line"><span class="keyword">local</span> last_mill_request_key = KEYS[<span class="number">2</span>]</span><br><span class="line"><span class="comment">-- 令牌桶的容量</span></span><br><span class="line"><span class="keyword">local</span> limit = <span class="built_in">tonumber</span>(ARGV[<span class="number">1</span>])</span><br><span class="line"><span class="comment">-- 请求令牌的数量</span></span><br><span class="line"><span class="keyword">local</span> permits = <span class="built_in">tonumber</span>(ARGV[<span class="number">2</span>])</span><br><span class="line"><span class="comment">-- 令牌流入的速率</span></span><br><span class="line"><span class="keyword">local</span> rate = <span class="built_in">tonumber</span>(ARGV[<span class="number">3</span>])</span><br><span class="line"><span class="comment">-- 当前时间</span></span><br><span class="line"><span class="keyword">local</span> curr_mill_time = <span class="built_in">tonumber</span>(ARGV[<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 添加令牌</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 获取当前令牌的数量</span></span><br><span class="line"><span class="keyword">local</span> current_limit = <span class="built_in">tonumber</span>(redis.call(<span class="string">'get'</span>, bucketKey) <span class="keyword">or</span> <span class="string">"0"</span>)</span><br><span class="line"><span class="comment">-- 获取上次请求的时间</span></span><br><span class="line"><span class="keyword">local</span> last_mill_request_time = <span class="built_in">tonumber</span>(redis.call(<span class="string">'get'</span>, last_mill_request_key) <span class="keyword">or</span> <span class="string">"0"</span>)</span><br><span class="line"><span class="comment">-- 计算向桶里添加令牌的数量</span></span><br><span class="line"><span class="keyword">if</span> last_mill_request_time == <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line"><span class="comment">-- 如果是第一次请求，那么令牌桶初始化</span></span><br><span class="line"><span class="comment">-- 更新上次请求时间</span></span><br><span class="line">redis.call(<span class="string">"HSET"</span>, last_mill_request_key, curr_mill_time)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="comment">-- 计算应该添加的令牌的数量</span></span><br><span class="line"><span class="keyword">local</span> add_token_num = <span class="built_in">math</span>.<span class="built_in">floor</span>((curr_mill_time - last_mill_request_time) * rate)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 更新令牌的数量</span></span><br><span class="line"><span class="keyword">if</span> current_limit + add_token_num &gt; limit <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 如果当前的令牌数量已经超过了容量，多余的则抛弃</span></span><br><span class="line">    current_limit = limit</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">current_limit = current_limit + add_token_num</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">    <span class="comment">-- 更新令牌的数量</span></span><br><span class="line">redis.<span class="built_in">pcall</span>(<span class="string">"HSET"</span>,bucketKey, current_limit)</span><br><span class="line"><span class="comment">-- 设置过期时间</span></span><br><span class="line">redis.call(<span class="string">"EXPIRE"</span>, bucketKey, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 限流判断</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> current_limit - permits &lt; <span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 达到限流大小（令牌不够）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="comment">-- 没有达到限流大小</span></span><br><span class="line">current_limit = current_limit - permits</span><br><span class="line"><span class="comment">-- 更新令牌的数量</span></span><br><span class="line">redis.<span class="built_in">pcall</span>(<span class="string">"HSET"</span>, bucketKey, current_limit)</span><br><span class="line">    <span class="comment">-- 设置过期时间</span></span><br><span class="line">    redis.call(<span class="string">"EXPIRE"</span>, bucketKey, <span class="number">2</span>)</span><br><span class="line"><span class="comment">-- 更新上次请求的时间</span></span><br><span class="line">redis.call(<span class="string">"HSET"</span>, last_mill_request_key, curr_mill_time)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><h3><span id="漏桶法">漏桶法</span></h3><p>相比于令牌桶算法，漏桶法对于去令牌的频率也有限制，要按照t/n的固定速率来取令牌。</p><h3><span id="限流规则的合理性">限流规则的合理性</span></h3><p>限流规则包含三个部分：时间粒度，接口粒度，最大限流值。时间粒度的选择尤其重要。比如我们可以选择1秒钟不超过1000次，也可以选择10毫秒不超过10次。虽然看起来一致，但是实际的效果却大不系统。比如1秒钟不超过1000次，但是很可能1000次请求就集中在几毫秒内。但如果选择10毫秒不超过10次，会导致误杀许多不应该限流的请求。因此时间粒度的选择要根据实际情况，灵活调整。</p><h2><span id="如何利用好缓存">如何利用好缓存</span></h2><h3><span id="缓存可以解决哪些问题">缓存可以解决哪些问题</span></h3><ul><li><p>提升性能<br>在绝大多数的应用中，查询数据库都是非常耗时的。而很多时候其实都是读多写少的，这个时候正确的使用缓存可以极大的提升系统的性能。</p></li><li><p>缓解数据库压力<br>当用户请求增多的时候增多时，数据库的压力将大大增加，通过缓存能够大大降低数据库的压力。</p></li></ul><p>因此我们可以看出，缓存使用于那些读多写少的情况。还使用于一些对性能要求高的场景，比如秒杀。</p><h2><span id="缓存的三种模式">缓存的三种模式</span></h2><h3><span id="cache-aside-更新模式">Cache Aside 更新模式</span></h3><p>这种工作模式是比较常见的工作模式了。<br>其具体的流程是：</p><ul><li>失效：应用程序先从cache中取数据，如果没有拿到，则从数据库中取数据，成功后放到缓存中。</li><li>命中：应用程序从cache中取数据，取到后返回。</li><li>更新：先把数据存到数据库中，成功后再让缓存失效。</li></ul><p><img src="https://s2.ax1x.com/2020/01/28/1MZjMD.png" alt="1MZjMD.png"></p><h4><span id="注意点">注意点</span></h4><ol><li><strong>先更新数据库，再更新缓存可能会出现并发写操作导致脏数据</strong>。这种方法其实是实际应用中推荐的，但是理论上仍然存在问题。假如，有两个线程再同时并发的进行更新，先更新数据库的反而后更新缓存，那么就可能导致缓存中的数据是脏数据。</li><li><strong>先更新缓存，再更新数据库，这个逻辑是错误的，因为并发的读和写可能导致脏数据</strong>，假如，有两个线程同时并发的进行更新，一个线程删除了缓存，此时第二个线程来读取缓存，没有命中，然后从数据库中取出老数据，并更新回缓存。这个时候第一个线程也把数据库更新了。这个时候缓存中数据就是过期的就数据了。</li></ol><h3><span id="readwrite-through更新模式">Read/Write Through更新模式</span></h3><p>在Read/Write Through更新模式中，应用程序只需要维护缓存，数据库的维护由缓存来代理。</p><p><img src="https://s2.ax1x.com/2020/01/28/1Mmtc8.png" alt="1Mmtc8.png"><br>这种模式相较于 Cache Aside模式，缓存的维护工作不再由调用方负责了，而是由缓存服务自己来加载。</p><h3><span id="write-behind-caching-更新模式">Write Behind Caching 更新模式</span></h3><p>Write Behind Caching更新模式就是在更新数据时，只更新缓存，不更新数据库，缓存会异步的批量的更新数据库。这样的好处在于可以合并多次更新，是直接的内存操作。但是问题在于，数据不再是强一致的，而且可能丢失。</p><p><img src="https://s2.ax1x.com/2020/01/28/1MmLuD.png" alt="1MmLuD.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;秒杀系统的特点&quot;&gt;&lt;a href=&quot;#秒杀系统的特点&quot; class=&quot;headerlink&quot; title=&quot;秒杀系统的特点&quot;&gt;&lt;/a&gt;秒杀系统的特点&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;高性能：秒杀涉及到大量的并发读和并发写，因此支持高并发访问这点非常的关键。&lt;/li&gt;
&lt;li&gt;一致性：秒杀是有限数量的商品在同一时刻被很多倍的请求同时来减库存，在大并发更新的过程中都要保证数据的准确性。&lt;/li&gt;
&lt;li&gt;高可用：秒杀时会在瞬间涌入大量的流量，为了避免系统宕机，保证高可用，需要做好流量限制。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="项目" scheme="http://yoursite.com/tags/%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>JVM之G1和CMS收集器</title>
    <link href="http://yoursite.com/2020/01/27/JVM%E4%B9%8BG1%E5%92%8CCMS%E6%94%B6%E9%9B%86%E5%99%A8/"/>
    <id>http://yoursite.com/2020/01/27/JVM之G1和CMS收集器/</id>
    <published>2020-01-27T08:43:56.000Z</published>
    <updated>2020-01-27T08:43:55.500Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="cms垃圾回收器">CMS垃圾回收器</span></h1><h2><span id="什么是cms垃圾回收器cms回收器的特点">什么是CMS垃圾回收器，CMS回收器的特点</span></h2><p>CMS即Concurrent Mark Sweep，是一款并发的、使用标记-清除算法的针对老年代的垃圾回收器。如果老年代使用CMS垃圾回收器，需要添加虚拟机参数<code>-XX:+UseConcMarkSweepGC</code><br>CMS垃圾回收器GC过程暂停短，适合对时延要求较高的服务，用户线程不允许长时间的停顿的场景。但是容易造成严重的内存碎片化，且对CPU资源非常的敏感，无法处理浮动垃圾，可能出现<code>Concurrent Mode Failure</code>失败而导致Full GC产生。</p><a id="more"></a><h2><span id="cms垃圾回收器的工作流程与原理">CMS垃圾回收器的工作流程与原理</span></h2><p>CMS垃圾回收器的工作需要经历初始标记、并发标记、重新标记、并发清除四个步骤。</p><ol><li>初始标记<br>初始标记的对象为：</li></ol><ul><li>标记老年代中所有GC Roots引用的对象</li><li>老年代中被年轻代中存活的对象引用的对象。</li></ul><p><img src="https://s2.ax1x.com/2020/01/27/1nrd4P.png" alt="1nrd4P.png"><br>由于需要对所有的对象进行标记，为了避免在标记过程中对象状态发生改变，所以需要Stop the world即停止所有用户线程，但是整个标记的过程耗时较短。</p><ol start="2"><li><p>并发标记<br>从初始标记阶段找到GC Roots开始进行Tracing，找到所有的存活对象。<br><img src="https://s2.ax1x.com/2020/01/27/1nsnKg.png" alt="1nsnKg.png"><br>并发标记阶段会与用户线程同时进行，因此会有一些对象的引用状态发生改变。</p></li><li><p>重新标记<br>标记在并发标记阶段引用发生变化的对象，如果发现对象的引用发生变化，则JVM会标记堆的这个区域为Dirty Card。<br><img src="https://s2.ax1x.com/2020/01/27/1nsyRK.png" alt="1nsyRK.png"><br>那些能够从Dirty Card达到的对象也被标记为存活，当标记完成后，这个Dirty Card区域就会消失。<br><img src="https://s2.ax1x.com/2020/01/27/1nsgMD.png" alt="1nsgMD.png"><br>该阶段是一个并发阶段，能够与用户线程同时运行，不会中断它们。</p></li><li><p>并发清除<br>清除那些未被标记的对象回收内存空间。<br><img src="https://s2.ax1x.com/2020/01/27/1nsTRf.png" alt="1nsTRf.png"></p></li></ol><h1><span id="g1垃圾回收器">G1垃圾回收器</span></h1><h2><span id="什么是g1回收器g1回收器的特点">什么是G1回收器，G1回收器的特点</span></h2><p>G1回收器(Garbage First).可以通过<code>-XX+UseG1GC</code>.G1垃圾回收器以关注延迟为目标、服务器短应用的垃圾收集器。G1的设置原则是“首先收集尽可能多的垃圾”，因此G1并不会等内存耗尽或者快耗尽的时候开始垃圾收集，而是在内部采用了启发式算法，在老年代中找出具有高回收收益的分区进行收集。同时G1可以根据用户设置的暂停时间目标自动跳转年轻代和总堆大小，暂停目标越短年轻代空间越小、总空间就越大。</p><h2><span id="g1的内存模型">G1的内存模型</span></h2><p>G1采用自动分区(Region)的思路，将内存划分为一个个相等大小的内存分区，回收时则以分区为单位进行回收，存活的对象复制到另一个空闲分区中。由于都是以相等大小获得分区为单位进行操作，因此G1天然就是一种压缩方案。这些reding最后又被分别标记为Eden，Survivor和old，这里只是逻辑分区不是物理表示<br>。在这之外还有Humongous Regin，巨型对象分区，巨型对象会独占一个或多个连续分区，确定巨型对象分区空间需要扫描整个堆，因此应用程序应该避免生成巨型对象。</p><h2><span id="g1工作的流程">G1工作的流程</span></h2><ol><li><p>RSet的维护<br>RSet即已ji’yi。在串行和并行收集器中，GC通过整个堆扫描，来去顶对象是否处于可达路径中。然而G1为了避免整堆扫描时的Stop the world，它在每个分区记录了一个已记忆集合，内部类似一个方向指针，记录引用分区对象的卡片索引。当要回收该分区时，通过扫描分区的RSet，来确定引用本分区内的对象是否存活，进而确定本分区的对象存活情况。</p></li><li><p>初始标记<br>初始标记负责标记所有能直接可达的根对象(虚拟机栈对象，全局对象，本地方法栈对象)。在初始标记过程之中需要暂停用户线程(Stop the world).G1一般利用年轻代STW时间段完成初始标记。初始标记时并发执行的，直到所有的分区处理完。</p></li><li>并发标记<br>并发标记和应用线程并发执行，每个线程每次只扫描一个分区，从而标记出存活对象图。</li><li>最终标记<br>最终标记是最后一个标记阶段。在该阶段中，G1需要一个暂停的时间，区处理剩下的SATB日志缓冲区和所有更新，找出所有未被访问的存活对象，同时完成存活数据统计。这个阶段也是并行执行的。</li><li>筛选回收<br>该阶段主要进行Rset梳理，启发式算法会根据活跃度和RSet尺寸对分区定义不同等级，同时RSet数理也有助于发现无用的引用。参数-XX:+PrintAdaptiveSizePolicy可以开启打印启发式算法决策细节；整理堆分区，识别所有空闲分区，即发现无存活对象的分区。该分区可在清理阶段直接回收为混合收集周期识别回收收益高(基于释放空间和暂停目标)的老年代分区集合；无需等待下次收集周期。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;CMS垃圾回收器&quot;&gt;&lt;a href=&quot;#CMS垃圾回收器&quot; class=&quot;headerlink&quot; title=&quot;CMS垃圾回收器&quot;&gt;&lt;/a&gt;CMS垃圾回收器&lt;/h1&gt;&lt;h2 id=&quot;什么是CMS垃圾回收器，CMS回收器的特点&quot;&gt;&lt;a href=&quot;#什么是CMS垃圾回收器，CMS回收器的特点&quot; class=&quot;headerlink&quot; title=&quot;什么是CMS垃圾回收器，CMS回收器的特点&quot;&gt;&lt;/a&gt;什么是CMS垃圾回收器，CMS回收器的特点&lt;/h2&gt;&lt;p&gt;CMS即Concurrent Mark Sweep，是一款并发的、使用标记-清除算法的针对老年代的垃圾回收器。如果老年代使用CMS垃圾回收器，需要添加虚拟机参数&lt;code&gt;-XX:+UseConcMarkSweepGC&lt;/code&gt;&lt;br&gt;CMS垃圾回收器GC过程暂停短，适合对时延要求较高的服务，用户线程不允许长时间的停顿的场景。但是容易造成严重的内存碎片化，且对CPU资源非常的敏感，无法处理浮动垃圾，可能出现&lt;code&gt;Concurrent Mode Failure&lt;/code&gt;失败而导致Full GC产生。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM之垃圾回收</title>
    <link href="http://yoursite.com/2020/01/26/JVM%E4%B9%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    <id>http://yoursite.com/2020/01/26/JVM之垃圾回收/</id>
    <published>2020-01-26T13:47:56.000Z</published>
    <updated>2020-01-26T13:51:22.009Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="需要回收的区域">需要回收的区域</span></h2><p>JVM的运行时内存可以分为5个区域：程序计数器，虚拟机栈，本地方法栈，方法区，堆区。其中程序计数器，虚拟机栈，本地方法栈都是与线程同生共死的，因此不要进行垃圾回收。垃圾回收主要关注的堆区和方法区。</p><a id="more"></a><h2><span id="如何判断一个对象是否还存活">如何判断一个对象是否还存活</span></h2><h3><span id="引用计数算法">引用计数算法</span></h3><p>引用计数是垃圾回收器中的早期策略。这种方法，堆中的每个实例都有一个引用计数。当一个对象被创建的时候，就会为给该实例分配一个计数器，这个计数器的初始值为1.当任何其它变量被赋值为这个对象的引用的时候，计数器加1，但当一个对象实例的某个引用超过了生命周期或者被设置为一个新值的时候，对象实例的引用计数器减1.当计数器的值为0的时候，就可以认为其所对应的对象已经“死亡”了。垃圾回收器就可以对其进行回收了。</p><h4><span id="优缺点">优缺点</span></h4><p>优点：引用计数器可以很快的执行，交织再程序运行中。<br>缺点：无法检测出循环引用，循环引用计数器永不为0。</p><h3><span id="可达性分析">可达性分析</span></h3><p>可达性分析算法是从离散数学图论中引入的，程序把所有的引用关系看作一个图，从一个GC ROOT开始，寻找对应的引用节点，找到这个节点以后，继续寻找这个节点的引用节点，当所有的引用节点寻找完毕之后，剩余的节点则被认为是没有被引用到的节点，即“死亡”的对象。</p><p>那么可以被作为GC Roots的对象包括那些呢？</p><ul><li>虚拟机栈中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中引用的对象</li></ul><p>这个算法的思路就是沿着一系列的GC roots作为起点向下搜索，当一个对象不可达，那么就判定为可回收的。</p><p>当然被可达性分析判定为可回收，需要经历两次标记的过程。如果对象在可达性分析后发现不可达，那它会被第一标记并进行一次筛选，筛选的条件就是此对象是否有需要执行的<code>finalize()</code>方法，如果有，那么会调用一次（最多一次）<code>finalize()</code>方法，可以通过<code>finalize()</code>方法来拯救一次被回收的对象。</p><p>两次标记分别是：</p><ol><li>通过GC Roots对象是否可达，如果对象不可达. </li><li>待回收的对象是否需要执行<code>finalize()</code>方法。在<code>finalize()</code>方法中没有于引用链建立关联关系的，将被进行第二次标记。</li></ol><p>只有两次标记都成功的对象，才会被真正的回收。</p><h2><span id="java中的引用">Java中的引用</span></h2><p>在Java引用中，将引用分为强引用、软引用、弱引用、虚引用4种。这四种引用的强度依次减弱。</p><ul><li>强引用：强引用是程序代码种普遍存在的，类似于<code>Object obj=new Object()</code>。只要强引用还存在，垃圾回收器就永远不会回收掉被引用的对象。</li><li>软引用：用来描述一些有用但并非必须的对象。对于软引用关联的对象，在系统将要发生内存溢出异常之前，将会把这些对象列入回收范围之中进行第二次回收。如果这次回收之后还没有足够的内存，才会抛出内存溢出。</li><li>弱引用：也是描述非必须对象的，但是它的强度比软引用要弱，被弱引用关联的对象只能生存到下一次垃圾回收器发生之前。当垃圾回收器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。</li><li>虚引用:虚引用是最弱的一种引用，一个对象是否存在虚引用，完全不会影响其生存时间，也无法通过虚引用来获取一个对象实例。它的作用是能在这个对象被回收器回收时收到一个系统通知。</li></ul><p><strong>无论是引用计数器算法还是可达性分析算法，都是针对于强引用的</strong></p><p>什么是引用？<br>如果reference类型的数据中存储的是数值代表的是另一块内存的起始地址，那么称这块内存代表着一个引用。</p><h2><span id="方法区的垃圾回收">方法区的垃圾回收</span></h2><p>方法区回收的内容主要有两类：一类是废弃的常量，另一类是无用的类。对于废弃的常量可以通过可达性分析来判断是否可以回收。<br>但是无用的类需要同时满足以下几个条件：</p><ul><li>该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例</li><li>加载该类的ClassLoader(类加载器)已经被回收</li><li>该类对应的java.lang.Class对象无法在任何地方被引用，无法在任何地方通过反射来访问该类的方法。</li></ul><h2><span id="堆中的垃圾回收">堆中的垃圾回收</span></h2><p>Java堆中存放着几乎所有的对象实例，也是垃圾回收器工作的主要目标。</p><h3><span id="常用的垃圾回收算法">常用的垃圾回收算法、</span></h3><h4><span id="引用计数器法">引用计数器法</span></h4><p>这个算法在之前已经介绍过来。这种算法实现简单，效率高可以于程序交织运行，但是不能解决循环依赖的问题。因此主流的JVM并没有采用引用计数器法来管理内存。</p><h4><span id="标记-清除算法mark-sweep">标记-清除算法(Mark-Sweep)</span></h4><p>标记清除算法分为两个阶段：分别为标记阶段和清除阶段。<br>标记阶段：<br>采用可达性分析算法来判断对象的存活情况，并对需要清除的对象进行标记。<br>清除阶段：<br>清除阶段扫描整个堆内存，清除掉被标记的对象。</p><p>该算法实现简单，在存活对象较多的情况下效率非常的高，但是因为其直接回收对象不会对内存进行整理，因此会造成内存的碎片。</p><h4><span id="复制算法">复制算法</span></h4><p>复制算法将整个堆内存划分为大小相等的两个部分，每次只使用其中一块。当一块内存用完了，就将还存活的对象赋值到另一块内存中，然后再把已经使用的一半内存之情清理掉。这样就解决了标记-清除算法的产生碎片的问题。</p><p>这种算法实现简单，运行高效且很好的解决了内存碎片的问题。但是降低了内存的利用率，因为同一时间只能有效利用一半的内存。</p><h4><span id="标记-整理mark-compact算法">标记-整理(Mark-compact)算法</span></h4><p>该算法首先会对需要回收的算法进行一次标记，然后将存活的对象移向一段（整理），移动过后，清理掉边界以外的内存。（<strong>先标记再移动最后清除</strong>）</p><p>标记整理算法也解决了标记清除算法的内存碎片问题，但是因为存在对象移动的开销，因此效率较低。</p><h4><span id="分代收集算法generational-collection">分代收集算法（Generational Collection）</span></h4><p>分代收集算法是目前大部分JVM采用的垃圾收集器算法。它的核心思想是根据对象存活的生命周期将内存划分为若干个不同的区域。一般划分为老年代（Tenured Generation）和新生代(Young Generation)，在堆区之外还有一个永久代(Permanet Generation)。</p><p>老年代的特点是每次垃圾回收只有少量的对象需要回收，而新生代的特点是每次垃圾回收时都有大量的对象需要被回收。然后根据不同代的特点来采用合适的收集算法。</p><p>对于新生代，目前主流的是采用<strong>复制算法</strong>，因为新生代中每次都会回收绝大多数的对象，因此需要复制的对象较少。但是不是按照1：1的比例还划分新生代空间的。一般来说将新生代划分为一块较大的Eden空间和两块较大的Survivor空间(8:1:1),每次使用Eden和其中一块Survivor，当进行回收时，将Eden和Survivor中还存活的对象复制到另一个Survivor空间中，然后清理掉Eden和刚才使用过的Survivor空间。</p><p>所有新生成的对象首先存放在年轻代中。年轻代的目标就是尽可能块的收集掉那些生命周期短的对象。回收时，首先将eden区中存活的对象复制到一个survivor0区中，然后清空eden区，当survivor0区满了之后，就会将survivor0区和eden区中存活的对象复制到survivor1区，然后清空eden和这个survivor0区，然后将survivior0区和survivor1区交换。当survivor1区不足以存放eden和survivior0中存活的对象时，就会将存活对象存放到老年代。若是老年代也满了就会触发一次Full GC（Major GC），也就是新生代，老年代都进行回收。新生代中发生的GC也叫做Minor GC，Minor GC发生的频率比较高。</p><p>对于老年代，因为每次需要回收的内存的数量较少，因此一般采用标记整理算法。</p><h2><span id="常见的垃圾回收器">常见的垃圾回收器</span></h2><h3><span id="serial收集器">Serial收集器</span></h3><p>新生代单线程收集器，标记和清理都是单线程，优点是简单高效。采用的是复制算法。是client级别默认的GC方式，可以通过<code>-XX:+UseSerialGC</code>来强制指定。</p><h3><span id="serial-old">Serial Old</span></h3><p>老年代单线程收集器，是Serial收集器的老年代版本。采用的是标记-整理算法。</p><h3><span id="parnew收集器">parNew收集器</span></h3><p>新生代收集器，可以认为是Serial收集器的多线程版本，在多核CPU环境下有着比Serial更好的表现。</p><h3><span id="parallel-scavenge收集器">Parallel Scavenge收集器</span></h3><p>并行收集器，追求高吞吐量，高效利用CPU。采用的是停止-复制算法。适合后台引用等对交互响应要求不高的场景。是Service级别默认采用的GC方式，可用<code>-XX:+UseParallelGC</code>来强制指定，用<code>-XX:ParallelGCThread=4</code>来指定线程数。</p><h3><span id="parallel-old收集器">Parallel Old收集器</span></h3><p>Parallel Scavenge收集器的老年代版本，并行收集器，吞吐量优先。</p><h3><span id="cmsconcurrnet-mark-sweep收集器">CMS（concurrnet mark sweep）收集器</span></h3><p>高并发，低停顿，追求最短GC回收停顿时间，CPU占用比较高，停顿时间短，多和CPU追求高响应时间的选择。采用的是标记-清理算法。</p><h2><span id="gc是生命时候触发的">GC是生命时候触发的</span></h2><p>由于对对象进行了分代处理，因此垃圾回收的区域，时间也不一样。GC有两种类型： Scavenge GC 和 Full GC。</p><h3><span id="scavenge-gc">Scavenge GC</span></h3><p>一般情况下，当新对象生成，并在eden申请空间失败是，就会触发Scavenge GC，对Eden区域进行GC，清除非存活对象，并且把尚且存活的对象移动到Survivor区。然后整理Survivor的两个区。这种GC仅仅是在年轻代的Eden区进行，不会影响到老年代。因为Eden区空间不大，且大部分对象都是从Eden区开始的，因此Eden区的GC非常的频繁。</p><h3><span id="full-gc">Full GC</span></h3><p>对整个堆进行整理。因为Full GC需要对整个堆进行整理。因此比Scavenge GC要慢，因此应该要尽可能减少Full GC的次数。导致Full GC的原因有以下几种：</p><ul><li>老年代写满</li><li>持久代写满</li><li>system.gc()被显式调用</li><li>上一次GC之后堆区各域的分配策略动态变化。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;需要回收的区域&quot;&gt;&lt;a href=&quot;#需要回收的区域&quot; class=&quot;headerlink&quot; title=&quot;需要回收的区域&quot;&gt;&lt;/a&gt;需要回收的区域&lt;/h2&gt;&lt;p&gt;JVM的运行时内存可以分为5个区域：程序计数器，虚拟机栈，本地方法栈，方法区，堆区。其中程序计数器，虚拟机栈，本地方法栈都是与线程同生共死的，因此不要进行垃圾回收。垃圾回收主要关注的堆区和方法区。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM之概述</title>
    <link href="http://yoursite.com/2020/01/25/JVM%E4%B9%8B%E6%A6%82%E8%BF%B0/"/>
    <id>http://yoursite.com/2020/01/25/JVM之概述/</id>
    <published>2020-01-25T08:54:56.000Z</published>
    <updated>2020-01-25T08:49:58.937Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="什么是java虚拟机">什么是java虚拟机？</span></h2><p>虚拟机是一种抽象化的计算机，通过在实际上的计算机上仿真模拟各种计算机功能来实现的。Java虚拟机有自己完善的硬件架构，如处理器、堆栈、寄存器等，还具有相应的指令体系。<strong>JVM屏蔽了与具体操作系统平台相关的信息</strong>，使得Java程序只需要生成在java虚拟机上运行的目标代码，就可以在多种平台上不加修改地运行。做到了一次编译到处运行。<br>在JVM启动之后，它实际上就是一个操作系统中的进程。</p><h2><span id="jvm的体系结构">JVM的体系结构</span></h2><p><img src="https://s2.ax1x.com/2020/01/17/1SuGSU.png" alt="1SuGSU.png"><br><a id="more"></a></p><h3><span id="类装载器">类装载器</span></h3><h4><span id="什么是类加载机制">什么是类加载机制？</span></h4><p>JVM把描述类信息的class文件加载到内存，并对数据进行校验，转换解析和初始化，最终形成可以被虚拟机直接使用的java类型的过程就是JVM的类加载机制。</p><h4><span id="类加载机制的意义是什么">类加载机制的意义是什么？</span></h4><p>在java语言里，类型的加载、连接和初始化都是在运行时通过类加载机制完成的，这种机制虽然会增加性能的开销，但是也成就了java的灵活性。<br>例子：</p><ol><li>用户可以编写一个面向接口的应用程序，可以等到运行时再指定实际的实现类。</li><li>用户可以实现自己的类加载器，让一个本地运行的程序可以通过网络等方式从其它地方加载二进制流作为程序代码的一部分。</li></ol><h4><span id="一个类的生命周期">一个类的生命周期</span></h4><p>一个类从被加载到JVM到卸载出内存需要经历如下过程。</p><ul><li>加载（Loading）<br>通过一个类的全限定名，来获取此类的二进制流。将这个字节流所代表的静态存储结构转化为方法区的运行时数据区。在内存中生成一个代表这个类的java.lang.class对象，作为方法区这个类的各种数据的访问入口。</li><li>验证 (Verification)<br>验证主要确保Class文件二进制流中所包含的信息是否符合虚拟机的要求，是否会危害虚拟机的运行。验证主要包括，文件格式校验，元数据验证，字节码验证等工作。</li><li>准备 (Preparation)<br>准备阶段是正式为类变量（static修饰的变量）分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区进行分配。这里所说的初始值通常来值数据的零值。<br><code>public static int value=123;</code>这还代码在准备阶段后，<code>value</code>的值为0，而不是123.</li><li>解析 (Resolution)<br>解析过程是将虚拟机常量池中的符号引用替换为直接引用的过程。</li></ul><ul><li>符号引用：符号引用以一组符号来描述所引用的符号。</li><li>直接引用：是可以直接指向目标的指针，相对偏移量或者是一个间接定位到目标的句柄。</li></ul><ul><li>初始化 (Initialization)</li><li>使用 (Using)</li><li>卸载 (Unloading)<br>其中验证，准备和解析可以统称为连接（Linking）。</li></ul><p>需要立即对类进行初始化的5种情况：</p><ul><li>遇到new，getstatic,putstatic或invokestatic这四条指令的时候，如果类没有进行初始化，则需要进行初始化。简单来讲就是我们在java代码中，使用new关键字实例化对象的时候，读取或设置一个类的静态字段的时候（被final修饰，已经在编译期把结果放入常量池的静态字段除外），已经调用一个类的静态方法的时候。</li><li>使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有初始化，那么需要先触发其初始化。</li><li>如果初始化一个类的时候，发现它的父类还没有进行过初始化的时候，则需要触发器父类进行初始化。</li><li>当虚拟机启动时，用户需要指定一个执行的主类，虚拟机会先初始化这个主类。</li><li>当使用JDK1.7的动态语言支持时，如果java.lang.invoke.MethodHeanle实例最后的结果为REF_getStatic，REF_putStaic,REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。</li></ul><p>以上五种情况为对类的主动引用。还存在对类的被动引用：</p><ul><li>通过子类去引用父类的静态字段，不会导致子类初始化<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderStudy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//通过子类去引用父类的静态字段</span></span><br><span class="line">        System.out.println(SubClass.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"superClass init"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> val=<span class="number">123</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"subclass init"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">superClass init</span><br><span class="line">123</span><br></pre></td></tr></table></figure></p><ul><li>通过数组定义来引用类，不会触发此类的初始化<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderStudy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//通过数组引用的类不会对类进行初始化。</span></span><br><span class="line">       SuperClass[] arr=<span class="keyword">new</span> SuperClass[<span class="number">10</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"superClass init"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> val=<span class="number">123</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"subclass init"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>没有任何的输出，说明没有对SuperClass类进行初始化。</p><ul><li>常量在编译时会存入调用类的常量池中，因此不会触发定义常量的类的初始化。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderStudy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//通过数组引用的类不会对类进行初始化。</span></span><br><span class="line">        System.out.println(SuperClass.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"superClass init"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> val=<span class="number">123</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"subclass init"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有任何的输出。<br>可见并没有初始化该常量的定义类。</p><h4><span id="类加载器">类加载器</span></h4><p>类加载器的工作就是：“通过一个类的全限定名来获取此类的二进制字节流”<br><strong>比较两个类是否相等，只有在这两个类是由同一个类加载器加载的前提下从才有意义</strong></p><p>一共有四种类加载器：</p><ul><li>启动类加载器（Bootstrap ClassLoader），这个类加载器是使用C++编写的，这个类主要负责将存放在&lt;JAVA_HOME&gt;/lib目录中，或者-Xbootclasspath参数所指定的路径中的。并且是由虚拟机识别的类库加载到虚拟机内存中。</li><li>拓展类加载器（Extension ClassLoader）：这个类加载器负责加载&lt;JAVA_HOME&gt;/lib/ext目录中的，或者被jave.ext.dirs系统变量所指定的路径中的所有类库。开发者可以直接使用类加载器。</li><li>应用类加载器（application Classloader），这个类加载器负责加载用户路径（ClassPath）上所指定的类库。</li><li>自定义类加载器，我们可以继承<code>ClassLoader</code>实现自己的类加载器。</li></ul><h4><span id="双亲委派机制">双亲委派机制</span></h4><p>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此。因此只有当父加载器反馈无法完成这个加载请求时，子加载器才会尝试自己去加载。</p><p>双亲委派机制使得类随着它的加载器具备了一种带有优先级的层次关系。实现了沙箱安全。</p><h3><span id="执行引擎">执行引擎</span></h3><h4><span id="什么是jvm执行引擎">什么是JVM执行引擎</span></h4><p>java编写的代码（.java文件）Java编译器(java compiler)编译为Java字节码(.class)文件。类加载器负责转载编译后的字节码，并加载到运行时数据区中，然后执行引擎执行这些字节码。<br>执行引擎按照字节码指令来执行相应的任务。因为字节码计算机是无法直接运行的，所以需要将其转化为能够被计算机执行的及其语言。这个过程JVM执行引擎有两种方案。一种是解释执行：即一条条读取，解释并执行字节码指令。这种方案加载快，但执行较慢。另一种是即时编译(Just-In-Time):在合适的时候，即时编译器会将整段的字节码编译为本地代码（编译后的本地代码缓存在cache中），然后自己执行本地代码。编译后的代码，比解释执行更加的快。但编译的过程比较耗时。</p><p>因此内置了JIT编译器的JVM都会检查方法的执行频率，如果一个方法的执行频率超过一个特定的值的话，那么这个方法就会被编译成本地代码。</p><p>JVM规范并没有定义执行引擎到底要如何区执行。因此JVM的提供者通过使用不同的技术以及不同的类型的JIT编译器来提高执行引擎的效率，</p><p>大部分的JIT编译器会将字节码转化为一个中间层表达式，然后进行优化，最后再把这种表示转化为本地代码。</p><p>Oracle Hotspot VM使用了一种叫做热点编译器的JIT编译器。它会通过分析代码的调用频数，寻找代码热点，然后会把热点代码编译为本地代码。如果代码不再是热点了，那么就会将本地代码从cache中移除，继续使用解释执行的方案。</p><h3><span id="运行时数据区">运行时数据区</span></h3><p>JVM在执行java程序的时候会它管理的内存分为若干个不同的数据区域，这些区域有着不同的用途。<br>运行时数据区可以分为方法区，堆区，虚拟机栈，本地方法栈，程序计数器。</p><h4><span id="程序计数器">程序计数器</span></h4><p>程序计数器是一块较小的内存空间，可以看作当前线程所执行的字节码的行号指示器。通过修改程序计数器的值，可以实现跳转执行等功能。它是线程私有的。<br>如果线程正在执行一个java方法，这个计数器记录的就是正在执行的虚拟机字节码指令的地址。如果正在执行的是native方法，那么这个计数器则为null。</p><p>此块区域是唯一一个在JVM规范中没有规定的任何OutOfMemoryError情况的区域。</p><h4><span id="java虚拟机栈">Java虚拟机栈</span></h4><p>线程私有的，生命周期和线程相同，虚拟机栈描述的是<strong>Java方法</strong>执行的内存模型。我们知道函数的调用是通过栈来完成的，每个方法在执行的时候都会开辟一个栈帧，方法中的局部变量其实就是存放在栈帧中。<br>在JVM规范中，对此区域规定了两种异常情况：如果线程请求的栈深度超过了虚拟机允许的最大深度，那么就会抛出StackOverflowError异常；如果允许虚拟机栈可以动态拓展时，无法申请到足够的内存，就会抛出OutOfMemoryError异常。</p><h4><span id="本地方法栈">本地方法栈</span></h4><p>本地方法栈所发挥的作用其实和虚拟机栈的作用是非常相似的。只不过本地方法栈描述的是<strong>native方法</strong>执行的内存模型。在虚拟即规范中没有对本地方法栈中方法使用的语言与数据结构做出强制规定，因此具体的虚拟机可以自由的实现本地方法栈。本地方法栈也会抛出StatkcOverflowError和OutOfMemoryError异常。它同样也是线程私有的。</p><h4><span id="方法区">方法区</span></h4><p>方法区是线程共享的，它主要存储已被JVM加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。<br>运行时常量池也是方法区的一部分，它主要存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。</p><h4><span id="堆">堆</span></h4><p>堆是线程共享的。它是JVM中最大的一块内存区域，在虚拟机启动的时候就已经创建了。这块区域的目的就是存放对象实例和数组，几乎所有的对象实例都在这里分配。堆区是垃圾收集管理最主要的区域。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是java虚拟机？&quot;&gt;&lt;a href=&quot;#什么是java虚拟机？&quot; class=&quot;headerlink&quot; title=&quot;什么是java虚拟机？&quot;&gt;&lt;/a&gt;什么是java虚拟机？&lt;/h2&gt;&lt;p&gt;虚拟机是一种抽象化的计算机，通过在实际上的计算机上仿真模拟各种计算机功能来实现的。Java虚拟机有自己完善的硬件架构，如处理器、堆栈、寄存器等，还具有相应的指令体系。&lt;strong&gt;JVM屏蔽了与具体操作系统平台相关的信息&lt;/strong&gt;，使得Java程序只需要生成在java虚拟机上运行的目标代码，就可以在多种平台上不加修改地运行。做到了一次编译到处运行。&lt;br&gt;在JVM启动之后，它实际上就是一个操作系统中的进程。&lt;/p&gt;
&lt;h2 id=&quot;JVM的体系结构&quot;&gt;&lt;a href=&quot;#JVM的体系结构&quot; class=&quot;headerlink&quot; title=&quot;JVM的体系结构&quot;&gt;&lt;/a&gt;JVM的体系结构&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2020/01/17/1SuGSU.png&quot; alt=&quot;1SuGSU.png&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>mybatis源码分析之缓存机制</title>
    <link href="http://yoursite.com/2020/01/23/mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2020/01/23/mybatis源码分析之缓存机制/</id>
    <published>2020-01-23T08:11:56.000Z</published>
    <updated>2020-01-23T08:12:06.444Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="概述">概述</span></h2><p>mybatis提供了缓存机制减轻数据库压力，提高数据库性能。mybatis的缓存分为两级：一级缓存、二级缓存。<br>一级缓存时<code>SqlSession</code>级别的缓存，缓存的数据只在<code>SqlSession</code>内有效。<br>二级缓存时<code>mapper</code>级别的缓存，同一个<code>namespace</code>共用一个缓存，所以对<code>SqlSession</code>是共享的。<br><a id="more"></a><br><img src="https://s2.ax1x.com/2020/01/23/1VSh0s.png" alt="1VSh0s.png"></p><h2><span id="一级缓存">一级缓存</span></h2><p>一级缓存默认是开启状态的。<br><img src="https://s2.ax1x.com/2020/01/23/1VSrkt.png" alt="1VSrkt.png"></p><h3><span id="一级缓存的生命周期">一级缓存的生命周期</span></h3><ul><li>mybatis在开启一个数据库会话的时，会创建一个新的<code>SqlSession</code>对象，<code>SqlSession</code>对象中会持有一个<code>Executor</code>对象，<code>Executor</code>对象中持有一个新的<code>PerpetualCache</code>对象；当会话结束时<code>SqlSession</code>对象及其内部的<code>Executor</code>对象还有<code>perpetualChache</code>对象也会被释放掉。</li><li>在<code>SqlSession</code>调用了<code>close()</code>方法，会释放掉一级缓存<code>PerpetualCache</code>对象，一级缓存将不可使用。</li><li>如果<code>SqlSession</code>调用了<code>clearCache()</code>，会清空<code>PerpetualCache</code>对象中的数据（缓存数据），但是一级缓存仍然是可用的，只是之前的数据被清空了。</li><li><code>SqlSession</code>中执行了任何一个update操作，都会清空<code>perpetualCache</code>对象的数据，但是该对象可以继续使用。</li></ul><h3><span id="如何判断两次查询时完全相同的">如何判断两次查询时完全相同的？</span></h3><p>mybaits认为，对于两次查询，如果以下条件都完全一样，那么就任务它们时完全相同的两次查询。</p><ul><li>传入的statementId</li><li>查询时要求的结果集的结果的范围</li><li>查询传递给JDBC的sql语句字符串</li><li>传递给java.sql.Statement要设置的参数值。<h2><span id="二级缓存">二级缓存</span></h2>mybatis的二级缓存是application级别的缓存，它可以提高数据库查询的效率，以提高应用的性能。<br>二级缓存默认是不开启的。如果需要开启二级缓存，需要进行配置，并且要求返回的pojo必须是可序列化的。<br>如果开启了二级缓存：</li><li>映射语句文件中的所有select语句将会被缓存</li><li>映射语句文件中的所有insert，update和delete语句会刷新缓存。</li><li>缓存会使用默认的LRU算法来回收。</li><li>根据时间表，缓存不会以任何时间顺序来刷新。</li><li>缓存会存储列表集合或对象的1024个引用。</li><li>缓存会被视为可读可写的缓存，意味着对象检索式不共享的，而且可以安全的被调用者修改，不干扰其它调用者或线程所做的潜在修改。</li></ul><h3><span id="如何开启二级缓存">如何开启二级缓存</span></h3><ol><li>首先查询返回的pojo类必须要实现<code>Serializable</code>即可，表示式可序列化的。</li><li>在对应的mapper文件中开启缓存。<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span> <span class="attr">eviction</span>=<span class="string">"LRU"</span> <span class="attr">readOnly</span>=<span class="string">"true"</span> <span class="attr">flushInterval</span>=<span class="string">"6000"</span> <span class="attr">size</span>=<span class="string">"1024"</span>/&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p><code>cache</code>标签有几个属性需要注意：</p><ul><li>eviction:设置缓存的清除策略，默认值为LRU<ul><li><code>LRU</code>:最近最少使用：移除最长时间不被使用的对象。</li><li><code>FIFO</code>：先进先出：按对象进入缓存的顺序来移除 它们</li><li><code>SOFT</code>:软引用：基于垃圾回收器状态和软引用规则移除对象。</li><li><code>WEAK</code>:弱引用：更积极的基于浪迹回收器状态和如弱引用规则移除对象。</li></ul></li><li>flushInterval：刷新间隔，默认清空下为不设置，自会在特定语句时刷新缓存</li><li>size：引用数目，默认是1024</li><li>readOnly：只读属性，设置为只读的比可写的性能更高，避免了对缓存对象的拷贝。</li></ul><ol start="3"><li>在全局配置文件中开启二级缓存<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"cacheEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;mybatis提供了缓存机制减轻数据库压力，提高数据库性能。mybatis的缓存分为两级：一级缓存、二级缓存。&lt;br&gt;一级缓存时&lt;code&gt;SqlSession&lt;/code&gt;级别的缓存，缓存的数据只在&lt;code&gt;SqlSession&lt;/code&gt;内有效。&lt;br&gt;二级缓存时&lt;code&gt;mapper&lt;/code&gt;级别的缓存，同一个&lt;code&gt;namespace&lt;/code&gt;共用一个缓存，所以对&lt;code&gt;SqlSession&lt;/code&gt;是共享的。&lt;br&gt;
    
    </summary>
    
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="mybatis" scheme="http://yoursite.com/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>mybatis源码分析之插件机制</title>
    <link href="http://yoursite.com/2020/01/22/mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E6%8F%92%E4%BB%B6%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2020/01/22/mybatis源码分析之插件机制/</id>
    <published>2020-01-22T13:24:56.000Z</published>
    <updated>2020-01-22T13:28:42.236Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="概述">概述</span></h2><p>mybatis插件又被称为拦截器，mybaits采用责任链模式，通过动态代理组织多个插件，通过这些插件可以改变mybatis的默认行为。mybatis允许在映射语句执行的某一点进行拦截调用。默认情况下，mybatis使用允许使用插件来拦截方法的调用包括：</p><a id="more"></a><ul><li>Executor是mybatis的内部缓存，它负责调用statementHandler操作数据库，并把结果集通过ResultSetHandler进行自动映射，另外，它还处理了二级缓存的操作。</li><li>StatementHandler是mybatis直接和数据库执行sql脚本的对象，另外它也实现lemybatis的一级缓存。</li><li>ParameterHandler是mybatis实现sql入参设置的对象。</li><li>ResultSetHandler是mybatis把ResultSet结果集映射成POJO的接口对象。</li></ul><h2><span id="拦截器的原理是什么">拦截器的原理是什么</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Executor <span class="title">newExecutor</span><span class="params">(Transaction transaction, ExecutorType executorType)</span> </span>&#123;</span><br><span class="line">   executorType = executorType == <span class="keyword">null</span> ? defaultExecutorType : executorType;</span><br><span class="line">   executorType = executorType == <span class="keyword">null</span> ? ExecutorType.SIMPLE : executorType;</span><br><span class="line">   Executor executor;</span><br><span class="line">   <span class="keyword">if</span> (ExecutorType.BATCH == executorType) &#123;</span><br><span class="line">     executor = <span class="keyword">new</span> BatchExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ExecutorType.REUSE == executorType) &#123;</span><br><span class="line">     executor = <span class="keyword">new</span> ReuseExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     executor = <span class="keyword">new</span> SimpleExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (cacheEnabled) &#123;</span><br><span class="line">     executor = <span class="keyword">new</span> CachingExecutor(executor);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   executor = (Executor) interceptorChain.pluginAll(executor);</span><br><span class="line">   <span class="keyword">return</span> executor;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> ParameterHandler <span class="title">newParameterHandler</span><span class="params">(MappedStatement mappedStatement, Object parameterObject, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">   ParameterHandler parameterHandler = mappedStatement.getLang().createParameterHandler(mappedStatement, parameterObject, boundSql);</span><br><span class="line">   parameterHandler = (ParameterHandler) interceptorChain.pluginAll(parameterHandler);</span><br><span class="line">   <span class="keyword">return</span> parameterHandler;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> StatementHandler <span class="title">newStatementHandler</span><span class="params">(Executor executor, MappedStatement mappedStatement, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">   StatementHandler statementHandler = <span class="keyword">new</span> RoutingStatementHandler(executor, mappedStatement, parameterObject, rowBounds, resultHandler, boundSql);</span><br><span class="line">   statementHandler = (StatementHandler) interceptorChain.pluginAll(statementHandler);</span><br><span class="line">   <span class="keyword">return</span> statementHandler;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> ResultSetHandler <span class="title">newResultSetHandler</span><span class="params">(Executor executor, MappedStatement mappedStatement, RowBounds rowBounds, ParameterHandler parameterHandler,</span></span></span><br><span class="line"><span class="function"><span class="params">     ResultHandler resultHandler, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">   ResultSetHandler resultSetHandler = <span class="keyword">new</span> DefaultResultSetHandler(executor, mappedStatement, parameterHandler, resultHandler, boundSql, rowBounds);</span><br><span class="line">   resultSetHandler = (ResultSetHandler) interceptorChain.pluginAll(resultSetHandler);</span><br><span class="line">   <span class="keyword">return</span> resultSetHandler;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>通过这几段代码我们不难看出，四大接口皆通过调用<code>interceptorChain</code>的<code>pluginAll</code>方法来对对象进行进一步的处理。</p><p>我们查看<code>interceptorChain</code>类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterceptorChain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一个拦截器集合</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">pluginAll</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Interceptor interceptor : interceptors) &#123;</span><br><span class="line">    <span class="comment">//调用所有的插件对target进行进一步的处理</span></span><br><span class="line">      target = interceptor.plugin(target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptor</span><span class="params">(Interceptor interceptor)</span> </span>&#123;</span><br><span class="line">    interceptors.add(interceptor);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;Interceptor&gt; <span class="title">getInterceptors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Collections.unmodifiableList(interceptors);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么对对象进行进一步加工的拦截器的结构又是怎样的呢。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进行拦截是要执行的方法</span></span><br><span class="line">  <span class="function">Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line">    <span class="comment">//用于封装目标对象，可以返回代理对象或者对象本身</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Object <span class="title">plugin</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Plugin.wrap(target, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="comment">//用于获取自定义相关属性</span></span><br><span class="line">  <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// NOP</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2><span id="如何开发一个插件">如何开发一个插件</span></h2><p>一个官方推荐的插件开发方式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Intercepts</span>(&#123;<span class="meta">@Signature</span>(type = Executor.class, method = <span class="string">"query"</span>,</span><br><span class="line">        args = &#123;MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class&#125;)&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Object target = invocation.getTarget(); <span class="comment">//被代理对象</span></span><br><span class="line">        Method method = invocation.getMethod(); <span class="comment">//代理方法</span></span><br><span class="line">        Object[] args = invocation.getArgs(); <span class="comment">//方法参数</span></span><br><span class="line">        <span class="comment">// do something ...... 方法拦截前执行代码块</span></span><br><span class="line">        Object result = invocation.proceed();</span><br><span class="line">        <span class="comment">// do something .......方法拦截后执行代码块</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">plugin</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Plugin.wrap(target, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3><span id="编写一个简单的拦截器">编写一个简单的拦截器</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Intercepts</span>(&#123;<span class="meta">@Signature</span>(type = Executor.class,method = <span class="string">"update"</span>,args = &#123;MappedStatement.class, Object.class&#125;)&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPlugin</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"拦截到了"</span>);</span><br><span class="line">    <span class="keyword">return</span> invocation.proceed();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">plugin</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Plugin.wrap(target,<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时我们在全局配置文件中对我们编写的拦截器进行注册。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugins&gt;</span><br><span class="line">  &lt;plugin interceptor=<span class="string">"example.MyPlugin"</span>/&gt;</span><br><span class="line">&lt;/plugins&gt;</span><br></pre></td></tr></table></figure></p><p>这段代码就会拦截<code>Executor</code>的<code>int update(MappedStatement ms, Object parameter)</code>方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;mybatis插件又被称为拦截器，mybaits采用责任链模式，通过动态代理组织多个插件，通过这些插件可以改变mybatis的默认行为。mybatis允许在映射语句执行的某一点进行拦截调用。默认情况下，mybatis使用允许使用插件来拦截方法的调用包括：&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="mybatis" scheme="http://yoursite.com/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>FutureTask源码分析</title>
    <link href="http://yoursite.com/2020/01/21/FutureTask%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2020/01/21/FutureTask源码分析/</id>
    <published>2020-01-21T08:30:56.000Z</published>
    <updated>2020-01-22T13:25:49.158Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="概述">概述</span></h2><p>Future表示一个任务的生命周期，是一个可取消的异步运算，可以把它看作是一个异步操作的结果的占位符，它将在未来的某个时刻完成，并提供对结果的访问。<br>FutureTask为Future提供了基础实现，如获取任务执行结果何取消任务等。如果尚未完成，获取任务执行结果的线程会被阻塞，一旦执行结束，任务就不能被重启或取消。FutureTask常用来封装Clallable和Runnable，也可以作为一个任务提交到线程池中执行。</p><a id="more"></a><p>FutureTask内部维护了一个由<code>volatule</code>修饰的int型变量-state，待变当前任务的运行状态，state有7种状态。</p><ul><li>NEW:新建</li><li>COMPLETING:完成</li><li>NORMAL:正常运行</li><li>EXCEPTIONAL：异常退出</li><li>CANCELLED：任务取消</li><li>INTERRUPTING：线程中断中。</li><li>INTERRUPTED:线程已中断</li></ul><p><img src="https://s2.ax1x.com/2020/01/20/1iXcB8.png" alt="1iXcB8.png"></p><h2><span id="源码分析">源码分析</span></h2><h3><span id="继承体系">继承体系</span></h3><p><img src="https://s2.ax1x.com/2020/01/20/1iXgHS.png" alt="1iXgHS.png"></p><h3><span id="核心属性">核心属性</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 内部持有的callable任务，运行完毕后置为空*/</span></span><br><span class="line"><span class="keyword">private</span> Callable&lt;V&gt; callable;</span><br><span class="line"><span class="comment">/** 从get()中返回的结果或抛出的异常 */</span></span><br><span class="line"><span class="keyword">private</span> Object outcome; <span class="comment">// non-volatile, protected by state reads/writes</span></span><br><span class="line"><span class="comment">/** 运行callable的线程*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Thread runner;</span><br><span class="line"><span class="comment">/** 使用treiber栈保存等待的线程*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> WaitNode waiters;</span><br></pre></td></tr></table></figure><h3><span id="重要方法分析">重要方法分析</span></h3><h4><span id="fun方法">fun方法</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//新建任务，CAS替换runner（运行Callable的线程）为当前线程</span></span><br><span class="line">       <span class="keyword">if</span> (state != NEW ||</span><br><span class="line">           !UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, runnerOffset,</span><br><span class="line">                                        <span class="keyword">null</span>, Thread.currentThread()))</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           Callable&lt;V&gt; c = callable;</span><br><span class="line">           <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; state == NEW) &#123;</span><br><span class="line">               V result;</span><br><span class="line">               <span class="keyword">boolean</span> ran;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">//调用Callable的call方法，并记录结果</span></span><br><span class="line">                   result = c.call();</span><br><span class="line">                   ran = <span class="keyword">true</span>;</span><br><span class="line">               &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                   result = <span class="keyword">null</span>;</span><br><span class="line">                   ran = <span class="keyword">false</span>;</span><br><span class="line">                   setException(ex);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (ran)<span class="comment">//设置执行结果</span></span><br><span class="line">                   set(result);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="comment">// runner must be non-null until state is settled to</span></span><br><span class="line">           <span class="comment">// prevent concurrent calls to run()</span></span><br><span class="line">           runner = <span class="keyword">null</span>;</span><br><span class="line">           <span class="comment">// state must be re-read after nulling runner to prevent</span></span><br><span class="line">           <span class="comment">// leaked interrupts</span></span><br><span class="line">           <span class="keyword">int</span> s = state;</span><br><span class="line">           <span class="keyword">if</span> (s &gt;= INTERRUPTING)</span><br><span class="line">               handlePossibleCancellationInterrupt(s);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>运行任务，如果任务状态为NEW状态，则利用CAS修改为当前线程，执行完毕后调用<code>set</code>方法设置执行的结果。</p><h4><span id="set方法">set方法</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(V v)</span> </span>&#123;</span><br><span class="line"><span class="comment">//设置为完成态</span></span><br><span class="line">    <span class="keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, NEW, COMPLETING)) &#123;</span><br><span class="line">        <span class="comment">//设置结果</span></span><br><span class="line">        outcome = v;</span><br><span class="line">        <span class="comment">//设置为最终状态</span></span><br><span class="line">        UNSAFE.putOrderedInt(<span class="keyword">this</span>, stateOffset, NORMAL); <span class="comment">// final state</span></span><br><span class="line">        finishCompletion();<span class="comment">//执行结束，唤醒等待结果的线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>set方法主要是修改状态为完成态，获得结果，设置为结束状态。然后调用<code>finishCompletion</code>方法唤醒等待结果的线程。</p><h4><span id="finishcompletion">finishCompletion</span></h4><p>该方法的主要作用就是唤醒所有等待结果的线程来取结果了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finishCompletion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// assert state &gt; COMPLETING;</span></span><br><span class="line">       <span class="keyword">for</span> (WaitNode q; (q = waiters) != <span class="keyword">null</span>;) &#123;</span><br><span class="line">       <span class="comment">//移除等待的线程</span></span><br><span class="line">           <span class="keyword">if</span> (UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, waitersOffset, q, <span class="keyword">null</span>)) &#123;              </span><br><span class="line">               <span class="keyword">for</span> (;;) &#123;<span class="comment">//自旋遍历等待队列</span></span><br><span class="line">                   Thread t = q.thread;</span><br><span class="line">                   <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                       q.thread = <span class="keyword">null</span>;</span><br><span class="line">                       <span class="comment">//唤醒park阻塞的线程</span></span><br><span class="line">                       LockSupport.unpark(t);</span><br><span class="line">                   &#125;</span><br><span class="line">                   WaitNode next = q.next;</span><br><span class="line">                   <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   q.next = <span class="keyword">null</span>; <span class="comment">// unlink to help gc</span></span><br><span class="line">                   q = next;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   <span class="comment">//调用任务完成的回调函数，可拓展</span></span><br><span class="line">       done();</span><br><span class="line">       <span class="comment">//任务执行完毕后将callable设置为null</span></span><br><span class="line">       callable = <span class="keyword">null</span>;        <span class="comment">// to reduce footprint</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><h4><span id="get方法">get方法</span></h4><p>get方法是去获取结果，如果运行还没有结果，那么就会阻塞。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = state;</span><br><span class="line">    <span class="keyword">if</span> (s &lt;= COMPLETING)</span><br><span class="line">    <span class="comment">//任务还未完成，到阻塞队列中去等待</span></span><br><span class="line">        s = awaitDone(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">    <span class="keyword">return</span> report(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个地方调用<code>awaitDone</code>方法</p><h4><span id="report方法"><code>report</code>方法</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">report</span><span class="params">(<span class="keyword">int</span> s)</span> <span class="keyword">throws</span> ExecutionException </span>&#123;</span><br><span class="line">       Object x = outcome;</span><br><span class="line">       <span class="keyword">if</span> (s == NORMAL)</span><br><span class="line">       <span class="comment">//如果是正常结束的，就返回结果</span></span><br><span class="line">           <span class="keyword">return</span> (V)x;</span><br><span class="line">       <span class="keyword">if</span> (s &gt;= CANCELLED)</span><br><span class="line">       <span class="comment">//如果是被取消的，那返回异常</span></span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> CancellationException();</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> ExecutionException((Throwable)x);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4><span id="awaitdone方法">awaitDone方法</span></h4><p><code>awaitDone</code>方法用于等待任务完成，或者因为任务中断或超时而终止。返回任务的完成状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">awaitDone</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//获取任务返回的结果的最后期限</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> deadline = timed ? System.nanoTime() + nanos : <span class="number">0L</span>;</span><br><span class="line">        WaitNode q = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> queued = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            <span class="comment">//如果线程中断，移除等待</span></span><br><span class="line">                removeWaiter(q);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> s = state;</span><br><span class="line">            <span class="keyword">if</span> (s &gt; COMPLETING) &#123;<span class="comment">//如果任务已经完成</span></span><br><span class="line">                <span class="keyword">if</span> (q != <span class="keyword">null</span>)</span><br><span class="line">                <span class="comment">//置空等待节点线程</span></span><br><span class="line">                    q.thread = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">return</span> s;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s == COMPLETING) <span class="comment">// cannot time out yet</span></span><br><span class="line">                Thread.yield();<span class="comment">//线程让出CPU时间</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (q == <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">//将q设置为等待节点</span></span><br><span class="line">                q = <span class="keyword">new</span> WaitNode();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!queued)</span><br><span class="line">            <span class="comment">//cas修改awit</span></span><br><span class="line">                queued = UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, waitersOffset,</span><br><span class="line">                                                     q.next = waiters, q);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (timed) &#123;</span><br><span class="line">                nanos = deadline - System.nanoTime();</span><br><span class="line">                <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                <span class="comment">//如果已经超时，则移除等待节点</span></span><br><span class="line">                    removeWaiter(q);</span><br><span class="line">                    <span class="keyword">return</span> state;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//阻塞当前线程</span></span><br><span class="line">                LockSupport.parkNanos(<span class="keyword">this</span>, nanos);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;Future表示一个任务的生命周期，是一个可取消的异步运算，可以把它看作是一个异步操作的结果的占位符，它将在未来的某个时刻完成，并提供对结果的访问。&lt;br&gt;FutureTask为Future提供了基础实现，如获取任务执行结果何取消任务等。如果尚未完成，获取任务执行结果的线程会被阻塞，一旦执行结束，任务就不能被重启或取消。FutureTask常用来封装Clallable和Runnable，也可以作为一个任务提交到线程池中执行。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="源码" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis源码分析之执行器</title>
    <link href="http://yoursite.com/2020/01/19/MyBatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E6%89%A7%E8%A1%8C%E5%99%A8/"/>
    <id>http://yoursite.com/2020/01/19/MyBatis源码分析之执行器/</id>
    <published>2020-01-19T03:13:56.000Z</published>
    <updated>2020-01-19T03:14:59.109Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="概述">概述</span></h2><p>执行器是Mybatis的核心接口之一，接口层提供的相关数据库操作都是基于<code>Executor</code>的子类实现的。<br><img src="https://s2.ax1x.com/2020/01/18/19CPiQ.png" alt="19CPiQ.png"></p><a id="more"></a><h2><span id="执行器是如何创建的">执行器是如何创建的</span></h2><p>首先祭出Mybatis的基本使用的代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String resource = <span class="string">"example/mybatis-config.xml"</span>;</span><br><span class="line">    <span class="comment">// 加载配置文件 并构建SqlSessionFactory对象</span></span><br><span class="line">    InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">    SqlSessionFactory factory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">    <span class="comment">// 从SqlSessionFactory对象中获取 SqlSession对象</span></span><br><span class="line">    SqlSession sqlSession = factory.openSession();</span><br><span class="line">    <span class="comment">// 执行操作</span></span><br><span class="line">    User user=<span class="keyword">new</span> User();</span><br><span class="line">    user.setId(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    User u= (User)sqlSession.selectOne(<span class="string">"getUser"</span>, user);</span><br></pre></td></tr></table></figure></p><p>在mybatis启动的时候，我们需要通过<code>SqlSessionFactoryBuilder</code>对象，调用其<code>build</code>方法来获取<code>SqlSessionFactory</code>对象。通过<code>SqlSessionFactory</code>对象的<code>openSession</code>方法来获取<code>SqlSession</code>对象。实际上执行器的创建就是在调用<code>openSession</code>方法的时候创建的。</p><p>通过源代码可以发现<code>openSession</code>方法背后实际调用的是<code>openSessionFromDataSource</code>这个方法。其具体实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> SqlSession <span class="title">openSessionFromDataSource</span><span class="params">(ExecutorType execType, TransactionIsolationLevel level, <span class="keyword">boolean</span> autoCommit)</span> </span>&#123;</span><br><span class="line">    Transaction tx = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">/*从包含所有配置信息的configuration中获取Environment对象</span></span><br><span class="line"><span class="comment">    Environment中包含了连接数据库的所有信息，包括driver，url，username，passowrd，TransactionFactory等众多的与数据库连接相关的信息</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">      <span class="keyword">final</span> Environment environment = configuration.getEnvironment();</span><br><span class="line">      </span><br><span class="line">      <span class="comment">/**这段代码的作用就是简单的从Environment中取出TransactionFactory对象*/</span></span><br><span class="line">      <span class="keyword">final</span> TransactionFactory transactionFactory = getTransactionFactoryFromEnvironment(environment);</span><br><span class="line">      <span class="comment">/*调用TransactionFactory的newTransaction获取Transaction对象，Transaction对象其实也非常的简单，它是对数据库连接Connection，DataSource，TransactionIsolationLevel（事务隔离级别），autoCommit（是否自动提交）的封装，内部还有利用connection提交事务，回滚事务等一系列方法。拿到了Transaction对象，就拥有了最基础的数据库操作途径*/</span></span><br><span class="line">      tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);</span><br><span class="line">      <span class="comment">/*newExecutor方法会根据执行器的类型（execType）选择创建不同的执行器，</span></span><br><span class="line"><span class="comment">      newExecutor内部就是简单的判断</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="keyword">final</span> Executor executor = configuration.newExecutor(tx, execType);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">/*拿到用于操作数据库的执行器，包含所有配置信息的Configuration对象等信息后，就可以将这些信息封装成为SqlSession</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> DefaultSqlSession(configuration, executor, autoCommit);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      closeTransaction(tx); <span class="comment">// may have fetched a connection so lets call close()</span></span><br><span class="line">      <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">"Error opening session.  Cause: "</span> + e, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      ErrorContext.instance().reset();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>总结一下整个获取Executor的流程：</p><ol><li>从封装了所有的配置信息中<code>Configuration</code>获取包含连接数据库等信息的<code>Environment</code>对象。将<code>Environment</code>封装得到<code>TransactionFactory</code>。然后将<code>Environment</code>中的与连接数据库之间相关的<code>dataSource</code>(即我们在配置文件中dataSource节点下配置的那些信息)和事务隔离级别，是否自动提交三个信息封装，就得到了<code>Transaction</code>对象，<code>Transaction</code>对象中除了这些信息之外，还包含操作数据库的一些最最基本的操作。</li><li>有了<code>Transaction</code>和执行器类型，就可以通过<code>newExecutor</code>方法创建<code>Executor</code>.<code>newExecutor</code>方法内部就会根据执行器类别的不同，创建不同的执行器。</li></ol><h2><span id="三大执行器在实现上有什么不同">三大执行器在实现上有什么不同</span></h2><h3><span id="简单执行器simpleexecutor">简单执行器SimpleExecutor</span></h3><p>Mybatis默认情况下是使用<code>SimpleExecutor</code>的。</p><p>查询方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">doQuery</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    Configuration configuration = ms.getConfiguration();</span><br><span class="line">    StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//每次执行都会调用prepareStatement创建新的Statement对象</span></span><br><span class="line">    stmt = prepareStatement(handler, ms.getStatementLog());</span><br><span class="line">    <span class="keyword">return</span> handler.query(stmt, resultHandler);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    closeStatement(stmt);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们可以发现<code>SimpleExecutor</code>的一大特点在于其每次执行查询的时候，都会创建一个新的<code>Statement</code>对象。</p><h4><span id="复用执行器reuseexecutor">复用执行器ReuseExecutor</span></h4><p>在<code>ReuseExecutor</code>之中有且仅有一个属性:<br><code>private final Map&lt;String, Statement&gt; statementMap = new HashMap&lt;&gt;();</code><br>它的作用，就是缓存<code>Statement</code>，以便复用<code>Statement</code>.<br>我们通过其<code>doQuery</code>方法来查看其到底是如何进行<code>Statement</code>复用的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">doQuery</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  Configuration configuration = ms.getConfiguration();</span><br><span class="line">  StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">  Statement stmt = prepareStatement(handler, ms.getStatementLog());</span><br><span class="line">  <span class="keyword">return</span> handler.query(stmt, resultHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个方法的实现看似和<code>SimpleExecutor</code>类似，其实玄机在于<code>prepareStatement</code>的实现。具体实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Statement <span class="title">prepareStatement</span><span class="params">(StatementHandler handler, Log statementLog)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  Statement stmt;</span><br><span class="line">  BoundSql boundSql = handler.getBoundSql();</span><br><span class="line">  <span class="comment">//这个地方得到的sql已经是可以直接到数据库中查询的sql了</span></span><br><span class="line">  String sql = boundSql.getSql();</span><br><span class="line">  <span class="keyword">if</span> (hasStatementFor(sql)) &#123; <span class="comment">//从缓存statement的map中查找是否有缓存</span></span><br><span class="line">    stmt = getStatement(sql);<span class="comment">//直接从缓存中获取statement</span></span><br><span class="line">    <span class="comment">//为Transaction设置一个过期时间</span></span><br><span class="line">    applyTransactionTimeout(stmt);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">//没有缓存则获取连接，创建Statement</span></span><br><span class="line">    Connection connection = getConnection(statementLog);</span><br><span class="line">    stmt = handler.prepare(connection, transaction.getTimeout());</span><br><span class="line">    putStatement(sql, stmt);</span><br><span class="line">  &#125;</span><br><span class="line">  handler.parameterize(stmt);</span><br><span class="line">  <span class="keyword">return</span> stmt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从源码中我们可以看出<code>ReuseStatement</code>之所以称为Reuse是因为，其内部拥有一个缓存<code>Statement</code>的map，其中缓存键为待执行的sql。</p><h3><span id="批量执行器batchexecutor">批量执行器BatchExecutor</span></h3><p><code>BatchExecutor</code>内部的属性稍微的多一些；<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//存储匹配的Statement</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Statement&gt; statementList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"> <span class="comment">//存储执行的结果</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> List&lt;BatchResult&gt; batchResultList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"> <span class="comment">//当前正在执行的sql</span></span><br><span class="line"> <span class="keyword">private</span> String currentSql;</span><br><span class="line"> <span class="comment">//当前正在使用的Statement</span></span><br><span class="line"> <span class="keyword">private</span> MappedStatement currentStatement;</span><br></pre></td></tr></table></figure></p><p>我们通过<code>doUpdate</code>方法，来分析其特点。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doUpdate</span><span class="params">(MappedStatement ms, Object parameterObject)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">   <span class="keyword">final</span> Configuration configuration = ms.getConfiguration();</span><br><span class="line">   <span class="keyword">final</span> StatementHandler handler = configuration.newStatementHandler(<span class="keyword">this</span>, ms, parameterObject, RowBounds.DEFAULT, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">   <span class="keyword">final</span> BoundSql boundSql = handler.getBoundSql();</span><br><span class="line">   <span class="keyword">final</span> String sql = boundSql.getSql();</span><br><span class="line">   <span class="keyword">final</span> Statement stmt;</span><br><span class="line">   <span class="keyword">if</span> (sql.equals(currentSql) &amp;&amp; ms.equals(currentStatement)) &#123;</span><br><span class="line">     <span class="comment">//如果当前要执行的sql与之前执行的sql相同，则复用statement</span></span><br><span class="line">     <span class="comment">//注意此时currentSql还未更新，所以currentSql实际是上次执行的sql</span></span><br><span class="line">     <span class="keyword">int</span> last = statementList.size() - <span class="number">1</span>;</span><br><span class="line">     <span class="comment">//获取最后一个statement，复用statement</span></span><br><span class="line">     stmt = statementList.get(last);</span><br><span class="line">     <span class="comment">//设置超时时间</span></span><br><span class="line">     applyTransactionTimeout(stmt);</span><br><span class="line">     <span class="comment">//设置参数</span></span><br><span class="line">     handler.parameterize(stmt);<span class="comment">//fix Issues 322</span></span><br><span class="line">     <span class="comment">//获取批量执行结果对象</span></span><br><span class="line">     BatchResult batchResult = batchResultList.get(last);</span><br><span class="line">     batchResult.addParameterObject(parameterObject);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="comment">//创建新的statement对象</span></span><br><span class="line">     Connection connection = getConnection(ms.getStatementLog());</span><br><span class="line">     stmt = handler.prepare(connection, transaction.getTimeout());</span><br><span class="line">     handler.parameterize(stmt);    <span class="comment">//fix Issues 322</span></span><br><span class="line">     currentSql = sql;</span><br><span class="line">     currentStatement = ms;</span><br><span class="line">     statementList.add(stmt);</span><br><span class="line">     batchResultList.add(<span class="keyword">new</span> BatchResult(ms, sql, parameterObject));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//执行jdbc批量添加sql，并执行</span></span><br><span class="line">   handler.batch(stmt);</span><br><span class="line">   <span class="keyword">return</span> BATCH_UPDATE_RETURN_VALUE;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>通过源代码我们也可以发现，其实BatchExecute内部也可以“复用”statement，前提是当前执行的sql和之前的一致。最后将sql交由jdbc去批量执行。</p><h2><span id="mybatis是如何利用执行器取操作数据的">mybatis是如何利用执行器取操作数据的</span></h2><p>我们以默认的<code>SimpleExecutor</code>执行器为例，来观察mybatis到底是如何执行sql的。</p><p>我们从这行代码出发，观察背后的执行逻辑：<br><code>User u= (User)sqlSession.selectOne(&quot;getUser&quot;, user);</code></p><p><code>selectOne</code>方法其实可以理解为特殊的<code>selectList</code>。<code>selectOne</code>方法实际上也是调用的<code>selectList</code>方法，然后从返回的list中取第一条数据即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">selectList</span><span class="params">(String statement, Object parameter, RowBounds rowBounds)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">/*这里的statement参数的值就是getUser,getMappedStatement方法就是简单的从configuration对象中的一个存储Statement的map中取出对应的MappedStatement。这个MappedStatement对象中，存储了Mapeper.xml中的信息，和对应接口的全路径*/</span></span><br><span class="line">      MappedStatement ms = configuration.getMappedStatement(statement);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">/*调用executor的query方法之前，还需要对参数进行简单的包装，如果参数是list或array或collection就会放到map中，进行说明（标识参数的类型），简单类型就不做任何的处理。然后调用query方法。query方法到底做了什么处理，可以看query的具体实现：</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      </span><br><span class="line">      <span class="keyword">return</span> executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">"Error querying database.  Cause: "</span> + e, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      ErrorContext.instance().reset();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>query方法的具体实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line"><span class="comment">/*这里的BoundSql包括sql（参数替换为？，还不能直接执行），parameterMappings，parameterObject，additionalParameters，metaParameters等数据*/</span></span><br><span class="line">  BoundSql boundSql = ms.getBoundSql(parameterObject);</span><br><span class="line">  <span class="comment">/*计算缓存键*/</span></span><br><span class="line">  CacheKey key = createCacheKey(ms, parameterObject, rowBounds, boundSql);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/*调用了另一个重载方法*/</span></span><br><span class="line">  <span class="keyword">return</span> query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>query的重载方法如下；<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">      <span class="comment">//尝试从MappedStatement中获取缓存Cache</span></span><br><span class="line">    Cache cache = ms.getCache();</span><br><span class="line">    <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;<span class="comment">//缓存不为为空</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*这个方法起清除了CachingExecutor中的TransactionalCacheManager中的Cache*/</span></span><br><span class="line">      flushCacheIfRequired(ms);</span><br><span class="line">      <span class="comment">//如果MappedStatement开启缓存的，且结果处理器为空</span></span><br><span class="line">      <span class="keyword">if</span> (ms.isUseCache() &amp;&amp; resultHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        ensureNoOutParams(ms, boundSql);</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        <span class="comment">//从缓存中获取结果</span></span><br><span class="line">        List&lt;E&gt; list = (List&lt;E&gt;) tcm.getObject(cache, key);</span><br><span class="line">        <span class="keyword">if</span> (list == <span class="keyword">null</span>) &#123;<span class="comment">//结果为空，就会重新去数据库中查询</span></span><br><span class="line">          list = delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">          tcm.putObject(cache, key, list); <span class="comment">// issue #578 and #116</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*去数据库中查询数据的重担就落到delegate.query*/</span></span><br><span class="line">    <span class="keyword">return</span> delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>最终来到了<code>BaseExecutor</code>类中的<code>query</code>方法了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line"><span class="comment">//获取boundSql</span></span><br><span class="line">  BoundSql boundSql = ms.getBoundSql(parameter);</span><br><span class="line">  <span class="comment">//计算缓存键</span></span><br><span class="line">  CacheKey key = createCacheKey(ms, parameter, rowBounds, boundSql);</span><br><span class="line">  <span class="keyword">return</span> query(ms, parameter, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>还是调用了另一个重载的<code>query</code>方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">   ErrorContext.instance().resource(ms.getResource()).activity(<span class="string">"executing a query"</span>).object(ms.getId());</span><br><span class="line">   <span class="keyword">if</span> (closed) &#123;<span class="comment">//确保执行器此时是开启状态</span></span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">"Executor was closed."</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (queryStack == <span class="number">0</span> &amp;&amp; ms.isFlushCacheRequired()) &#123;</span><br><span class="line">   <span class="comment">//如果queryStatck==0且需要清理cache就刷新Cache</span></span><br><span class="line">     clearLocalCache();</span><br><span class="line">   &#125;</span><br><span class="line">   List&lt;E&gt; list;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     queryStack++;</span><br><span class="line">     <span class="comment">//如果结果处理器为null，那么还是尝试去缓存中取一取</span></span><br><span class="line">     list = resultHandler == <span class="keyword">null</span> ? (List&lt;E&gt;) localCache.getObject(key) : <span class="keyword">null</span>;</span><br><span class="line">     <span class="keyword">if</span> (list != <span class="keyword">null</span>) &#123;</span><br><span class="line">       handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;<span class="comment">//没有从缓存中拿到数据，就从数据库中查询</span></span><br><span class="line">       list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">     queryStack--;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (queryStack == <span class="number">0</span>) &#123;</span><br><span class="line">     <span class="keyword">for</span> (DeferredLoad deferredLoad : deferredLoads) &#123;</span><br><span class="line">       deferredLoad.load();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// issue #601</span></span><br><span class="line">     deferredLoads.clear();</span><br><span class="line">     <span class="keyword">if</span> (configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) &#123;</span><br><span class="line">       <span class="comment">// issue #482</span></span><br><span class="line">       clearLocalCache();</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> list;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>我们次这个方法中可以发现，开始还是会尝试取缓存中直接取缓存的数据，如果缓存中没有取到数据，那么就会调用<code>queryFromDatabase</code>方法去数据库中查询。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">queryFromDatabase</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">   List&lt;E&gt; list;</span><br><span class="line">   <span class="comment">//标记当前查询正在进行，对缓存进行占位</span></span><br><span class="line">   localCache.putObject(key, EXECUTION_PLACEHOLDER);</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//最终到数据库中查询是交给这个方法的</span></span><br><span class="line">     list = doQuery(ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">   <span class="comment">//出现异常，清除查询正在进行的标记（取消占位）</span></span><br><span class="line">     localCache.removeObject(key);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//将结果缓存到缓存中去</span></span><br><span class="line">   localCache.putObject(key, list);</span><br><span class="line">   <span class="keyword">if</span> (ms.getStatementType() == StatementType.CALLABLE) &#123;</span><br><span class="line">   <span class="comment">//如果是存储过程，那么就单独在缓存一份参数数据</span></span><br><span class="line">     localOutputParameterCache.putObject(key, parameter);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> list;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>这个方法又将查询的任务委派给了<code>SimpleExecutor</code>类下的<code>doQuery</code>方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">doQuery</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    Configuration configuration = ms.getConfiguration();</span><br><span class="line">    StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">    stmt = prepareStatement(handler, ms.getStatementLog());</span><br><span class="line">    <span class="comment">//查询最终又落到了heanler的query方法上</span></span><br><span class="line">    <span class="keyword">return</span> handler.query(stmt, resultHandler);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    closeStatement(stmt);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(Statement statement, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> delegate.query(statement, resultHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法最后来到了<code>PreparedStatementHandler</code>类下的<code>query</code>方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(Statement statement, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line"><span class="comment">//获取PreparedStatement方法，jdbc的预编译执行就是使用的PareparedStatement</span></span><br><span class="line">  PreparedStatement ps = (PreparedStatement) statement;</span><br><span class="line">  <span class="comment">//这里其实就是jdbc方法了，从数据库中查询了</span></span><br><span class="line">  ps.execute();</span><br><span class="line">  <span class="keyword">return</span> resultSetHandler.handleResultSets(ps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;执行器是Mybatis的核心接口之一，接口层提供的相关数据库操作都是基于&lt;code&gt;Executor&lt;/code&gt;的子类实现的。&lt;br&gt;&lt;img src=&quot;https://s2.ax1x.com/2020/01/18/19CPiQ.png&quot; alt=&quot;19CPiQ.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="mybatis" scheme="http://yoursite.com/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>LinkedTransferQueue源码分析</title>
    <link href="http://yoursite.com/2020/01/18/LinkedTransferQueue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2020/01/18/LinkedTransferQueue源码分析/</id>
    <published>2020-01-18T13:03:56.000Z</published>
    <updated>2020-01-18T13:04:53.289Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="概述">概述</span></h2><p><code>LinkedTransferQueue</code>是单向链表结构的无界阻塞队列。它通过CAS和<code>LockSupport</code>来实现线程安全的。<br>它采用一种预占模式，意思是当消费者线程取元素时，如果队列为空，那就生成一个节点（节点元素为null）入队，然后消费者线程被等待在这个节点上，后面生产者线程入队时发现一个元素为null的节点，就会直接将元素填充到该节点，并唤醒该节点等待的线程，被唤醒的消费者线程取走元素并返回。</p><a id="more"></a><p><code>LinkedTransferQueue</code>在实现上有几个特点：</p><ul><li>双重队列：<code>LinkedTransferQueue</code>的<code>Node</code>存储了一个<code>isData</code>的字段，用来区分该节点代表的是数据还是请求，称为双重队列机制。</li><li>松弛度：为了节省CAS操作的开销，<code>LinkedTransferQueue</code>为了节省CAS的开销，<code>LinkedTransferQueue</code>不会立即取更新head/tail,而是需要等到ehad/tail与最近一个未匹配节点之间的距离超过一个松弛度阈值的时候，才会更新。</li><li>节点自链接：已匹配的节点的next引用会指向自身。如果在遍历时遇到一个自链节点，那就表明当前线程已经滞后于另外一个更新head的兴奋啊从，此时就需要重新获取head来遍历。</li></ul><p><img src="https://s2.ax1x.com/2020/01/18/1pyD7d.png" alt="1pyD7d.png"></p><h2><span id="源码分析">源码分析</span></h2><h3><span id="继承体系">继承体系</span></h3><p><img src="https://s2.ax1x.com/2020/01/18/1pyRc8.png" alt="1pyRc8.png"></p><h3><span id="重要属性">重要属性</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/** 队列头，第一次入列之前为空*/</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 队列尾节点，第一次添加节点之前为空 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 累计到一定的次数再清除无效的node */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> sweepVotes;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** sweepVote的阈值 */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SWEEP_THRESHOLD = <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**当前驱节点正在处理，当前节点再阻塞之前的自旋次数*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FRONT_SPINS   = <span class="number">1</span> &lt;&lt; <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**当前驱节点正在处理，当前节点再阻塞之前的自旋次数*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CHAINED_SPINS = FRONT_SPINS &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NOW   = <span class="number">0</span>; <span class="comment">// for untimed poll, tryTransfer</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ASYNC = <span class="number">1</span>; <span class="comment">// for offer, put, add</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SYNC  = <span class="number">2</span>; <span class="comment">// for transfer, take</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIMED = <span class="number">3</span>; <span class="comment">// for timed poll, tryTransfer</span></span><br></pre></td></tr></table></figure><h3><span id="重要方法解析">重要方法解析</span></h3><h4><span id="xfer方法">xfer方法</span></h4><p>入队/出队方法都是由<code>xfer</code>来实现，所以我们这里只对<code>xfer</code>进行解析<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">xfer</span><span class="params">(E e, <span class="keyword">boolean</span> haveData, <span class="keyword">int</span> how, <span class="keyword">long</span> nanos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (haveData &amp;&amp; (e == <span class="keyword">null</span>))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        Node s = <span class="keyword">null</span>;                        <span class="comment">// the node to append, if needed</span></span><br><span class="line"></span><br><span class="line">        retry:</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;                            <span class="comment">// restart on append race</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (Node h = head, p = h; p != <span class="keyword">null</span>;) &#123; <span class="comment">// find &amp; match first node</span></span><br><span class="line">            <span class="comment">//从head开始一直向后匹配</span></span><br><span class="line">                <span class="keyword">boolean</span> isData = p.isData;</span><br><span class="line">                Object item = p.item;</span><br><span class="line">                <span class="keyword">if</span> (item != p &amp;&amp; (item != <span class="keyword">null</span>) == isData) &#123;<span class="comment">//有效节点</span></span><br><span class="line">                    <span class="keyword">if</span> (isData == haveData)  </span><br><span class="line">                    <span class="comment">//节点与此次操作模式一致，无法匹配</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">if</span> (p.casItem(item, e)) &#123; <span class="comment">//匹配成功，cas修改为指定元素</span></span><br><span class="line">                        <span class="keyword">for</span> (Node q = p; q != h;) &#123;</span><br><span class="line">                            Node n = q.next;  <span class="comment">// update by 2 unless singleton</span></span><br><span class="line">                            <span class="keyword">if</span> (head == h &amp;&amp; casHead(h, n == <span class="keyword">null</span> ? q : n)) &#123;                   <span class="comment">//更新head为匹配节点的next节点</span></span><br><span class="line">                            </span><br><span class="line">                            <span class="comment">//旧head节点指向自身等待回收</span></span><br><span class="line">                                h.forgetNext(); </span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;                 <span class="comment">// advance and retry</span></span><br><span class="line">                            <span class="comment">//cas失败，重新获取head</span></span><br><span class="line">                            <span class="keyword">if</span> ((h = head)   == <span class="keyword">null</span> ||</span><br><span class="line">                                (q = h.next) == <span class="keyword">null</span> || !q.isMatched())</span><br><span class="line"><span class="comment">//如果head的next节点未被匹配，跳出循环，不更新head，即松弛度小于2</span></span><br><span class="line">                                <span class="keyword">break</span>;        <span class="comment">// unless slack &lt; 2</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//唤醒节点上等待的线程</span></span><br><span class="line">                        LockSupport.unpark(p.waiter);</span><br><span class="line">                        <span class="keyword">return</span> LinkedTransferQueue.&lt;E&gt;cast(item);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//匹配失败，继续向后查找节点</span></span><br><span class="line">                Node n = p.next;</span><br><span class="line">                p = (p != n) ? n : (h = head); <span class="comment">// Use head if p offlist</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//未找到匹配节点，吧当前节点假如到队列尾</span></span><br><span class="line">            <span class="keyword">if</span> (how != NOW) &#123;                 <span class="comment">// No matches available</span></span><br><span class="line">                <span class="keyword">if</span> (s == <span class="keyword">null</span>)</span><br><span class="line">                    s = <span class="keyword">new</span> Node(e, haveData);</span><br><span class="line">                <span class="comment">//将新节点s添加到队列尾并返回s的前驱节点</span></span><br><span class="line">                Node pred = tryAppend(s, haveData);</span><br><span class="line">                <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">                <span class="comment">//与其它不同模式线程竞争是失败重新循环</span></span><br><span class="line">                    <span class="keyword">continue</span> retry;           <span class="comment">// lost race vs opposite mode</span></span><br><span class="line">                <span class="keyword">if</span> (how != ASYNC)<span class="comment">//同步操作，等待匹配</span></span><br><span class="line">                    <span class="keyword">return</span> awaitMatch(s, pred, e, (how == TIMED), nanos);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> e; <span class="comment">// not waiting</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p><code>xfer</code>方法的基本执行流程：</p><ol><li>从head开始往后遍历匹配，找到一个节点模式和本次操作不同的未匹配的节点进行匹配。</li><li>匹配成功的节点CAS修改匹配节点的item未给定的元素e</li><li>如果此时所匹配节点向后移动，则cas更新head节点为匹配节点的next节点，旧head节点连接指向自身等待被回收。如果cas失败，并且松弛度大于等于2，旧需要重新获取head。</li><li>匹配成功，唤醒匹配节点p的灯箱线程waiter，返回匹配的item。</li><li>如果在上述操作中没有找到匹配节点，则根据参数<code>how</code>的不同做不同的处理</li></ol><ul><li>NOW:立即返回</li><li>SYNC：通过<code>tryAppend</code>方法插入一个新的节点s到队列尾，然后自旋或阻塞当前线程知道节点被匹配或取消返回。</li><li>ASYNC：通过<code>tryAppend</code>方法插入一个新的节点s到队列尾，异步直接返回</li><li>TIMED：通过<code>tryAppend</code>反复插入一个新系欸但到队列尾，然后通过自旋或阻塞当前线程直到节点被匹配或取消或等待超时时返回。</li></ul><h4><span id="tryappend方法">tryAppend方法</span></h4><p>尝试添加节点s作为尾节点<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">tryAppend</span><span class="params">(Node s, <span class="keyword">boolean</span> haveData)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Node t = tail, p = t;;) &#123;        <span class="comment">// move p to last node and append</span></span><br><span class="line">            Node n, u;                        <span class="comment">// temps for reads of next &amp; tail</span></span><br><span class="line">            <span class="keyword">if</span> (p == <span class="keyword">null</span> &amp;&amp; (p = head) == <span class="keyword">null</span>) &#123; <span class="comment">//链表未初始化</span></span><br><span class="line">                <span class="keyword">if</span> (casHead(<span class="keyword">null</span>, s)) <span class="comment">//将s作为head节点</span></span><br><span class="line">                    <span class="keyword">return</span> s;                 <span class="comment">// initialize</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p.cannotPrecede(haveData))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;                  <span class="comment">// lost race vs opposite mode</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((n = p.next) != <span class="keyword">null</span>)    <span class="comment">// not last; keep traversing</span></span><br><span class="line">                p = p != t &amp;&amp; t != (u = tail) ? (t = u) : <span class="comment">// stale tail</span></span><br><span class="line">                    (p != n) ? n : <span class="keyword">null</span>;      <span class="comment">// restart if off list</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!p.casNext(<span class="keyword">null</span>, s))</span><br><span class="line">                p = p.next;                   <span class="comment">// re-read on CAS failure</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (p != t) &#123;                 <span class="comment">// update if slack now &gt;= 2</span></span><br><span class="line">                    <span class="keyword">while</span> ((tail != t || !casTail(t, s)) &amp;&amp;</span><br><span class="line">                           (t = tail)   != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                           (s = t.next) != <span class="keyword">null</span> &amp;&amp; <span class="comment">// advance and retry</span></span><br><span class="line">                           (s = s.next) != <span class="keyword">null</span> &amp;&amp; s != t);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>该方法添加给定节点s到队列尾并返回s的前继节点，失败时（与其它不同模式线程竞争失败）返回null，没有前继节点返回自身。</p><h4><span id="awaitmatch方法">awaitMatch方法</span></h4><p>自旋/让步/阻塞，直到给定节点s匹配到或a放弃匹配。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">awaitMatch</span><span class="params">(Node s, Node pred, E e, <span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> deadline = timed ? System.nanoTime() + nanos : <span class="number">0L</span>;</span><br><span class="line">        Thread w = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> spins = -<span class="number">1</span>; <span class="comment">// initialized after first item and cancel checks</span></span><br><span class="line">        ThreadLocalRandom randomYields = <span class="keyword">null</span>; <span class="comment">// bound if needed</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Object item = s.item;</span><br><span class="line">            <span class="keyword">if</span> (item != e) &#123;                  <span class="comment">// matched</span></span><br><span class="line">                <span class="comment">// assert item != s;</span></span><br><span class="line">                s.forgetContents();           <span class="comment">// avoid garbage</span></span><br><span class="line">                <span class="keyword">return</span> LinkedTransferQueue.&lt;E&gt;cast(item);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((w.isInterrupted() || (timed &amp;&amp; nanos &lt;= <span class="number">0</span>)) &amp;&amp;</span><br><span class="line">                    s.casItem(e, s)) &#123; <span class="comment">//取消匹配，item指向自身</span></span><br><span class="line">                unsplice(pred, s); <span class="comment">//解除s节点和前继节点的连接</span></span><br><span class="line">                <span class="keyword">return</span> e;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (spins &lt; <span class="number">0</span>) &#123;                  <span class="comment">// establish spins at/near front</span></span><br><span class="line">                <span class="keyword">if</span> ((spins = spinsFor(pred, s.isData)) &gt; <span class="number">0</span>)</span><br><span class="line">                    randomYields = ThreadLocalRandom.current();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (spins &gt; <span class="number">0</span>) &#123;             <span class="comment">// spin</span></span><br><span class="line">                --spins;</span><br><span class="line">                <span class="keyword">if</span> (randomYields.nextInt(CHAINED_SPINS) == <span class="number">0</span>)</span><br><span class="line">                    Thread.yield();           <span class="comment">// occasionally yield</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s.waiter == <span class="keyword">null</span>) &#123;</span><br><span class="line">                s.waiter = w;                 <span class="comment">// request unpark then recheck</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (timed) &#123;</span><br><span class="line">                nanos = deadline - System.nanoTime();</span><br><span class="line">                <span class="keyword">if</span> (nanos &gt; <span class="number">0L</span>)</span><br><span class="line">                    LockSupport.parkNanos(<span class="keyword">this</span>, nanos);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>当前操作作为同步操作时，会调用<code>awaitMatch</code>方法阻塞等待匹配，成功返回匹配节点item，返回失败返回给定参数e。在等待期间如果线程被中断或等待超时，则取消p，并调用<code>upsplice</code>方法解除节点，和其前继节点的链接。</p><h4><span id="unsplice方法">unsplice方法</span></h4><p>解除给定已经被删除/取消节点和前继节点的链接，可能会延迟解除。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">unsplice</span><span class="params">(Node pred, Node s)</span> </span>&#123;</span><br><span class="line">       s.forgetContents(); <span class="comment">// forget unneeded fields</span></span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * See above for rationale. Briefly: if pred still points to</span></span><br><span class="line"><span class="comment">        * s, try to unlink s.  If s cannot be unlinked, because it is</span></span><br><span class="line"><span class="comment">        * trailing node or pred might be unlinked, and neither pred</span></span><br><span class="line"><span class="comment">        * nor s are head or offlist, add to sweepVotes, and if enough</span></span><br><span class="line"><span class="comment">        * votes have accumulated, sweep.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">if</span> (pred != <span class="keyword">null</span> &amp;&amp; pred != s &amp;&amp; pred.next == s) &#123;</span><br><span class="line">           Node n = s.next;</span><br><span class="line">           <span class="keyword">if</span> (n == <span class="keyword">null</span> ||</span><br><span class="line">               (n != s &amp;&amp; pred.casNext(s, n) &amp;&amp; pred.isMatched())) &#123;</span><br><span class="line">               <span class="comment">//解除s节点的链接</span></span><br><span class="line">               <span class="keyword">for</span> (;;) &#123;               <span class="comment">// check if at, or could be, head</span></span><br><span class="line">                   Node h = head;</span><br><span class="line">                   <span class="keyword">if</span> (h == pred || h == s || h == <span class="keyword">null</span>)</span><br><span class="line">                       <span class="keyword">return</span>;          <span class="comment">// at head or list empty</span></span><br><span class="line">                   <span class="keyword">if</span> (!h.isMatched())</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   Node hn = h.next;</span><br><span class="line">                   <span class="keyword">if</span> (hn == <span class="keyword">null</span>)</span><br><span class="line">                       <span class="keyword">return</span>;          <span class="comment">// now empty</span></span><br><span class="line">                   <span class="keyword">if</span> (hn != h &amp;&amp; casHead(h, hn))<span class="comment">//更新head</span></span><br><span class="line">                       h.forgetNext();  <span class="comment">// advance head</span></span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (pred.next != pred &amp;&amp; s.next != s) &#123; <span class="comment">// recheck if offlist</span></span><br><span class="line">                   <span class="keyword">for</span> (;;) &#123;           <span class="comment">// sweep now if enough votes</span></span><br><span class="line">                       <span class="keyword">int</span> v = sweepVotes;</span><br><span class="line">                       <span class="keyword">if</span> (v &lt; SWEEP_THRESHOLD) &#123;</span><br><span class="line">                           <span class="keyword">if</span> (casSweepVotes(v, v + <span class="number">1</span>))</span><br><span class="line">                               <span class="keyword">break</span>;</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="keyword">else</span> <span class="keyword">if</span> (casSweepVotes(v, <span class="number">0</span>)) &#123;</span><br><span class="line">                           sweep();</span><br><span class="line">                           <span class="keyword">break</span>;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><h4><span id="sweep">sweep</span></h4><p>解除从头不遍历时遇到的已经被匹配的节点的链接<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sweep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Node p = head, s, n; p != <span class="keyword">null</span> &amp;&amp; (s = p.next) != <span class="keyword">null</span>; ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!s.isMatched())</span><br><span class="line">                <span class="comment">// Unmatched nodes are never self-linked</span></span><br><span class="line">                p = s;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((n = s.next) == <span class="keyword">null</span>) <span class="comment">// trailing node is pinned</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s == n)    <span class="comment">// stale</span></span><br><span class="line">                <span class="comment">// No need to also check for p == s, since that implies s == n</span></span><br><span class="line">                p = head;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p.casNext(s, n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;&lt;code&gt;LinkedTransferQueue&lt;/code&gt;是单向链表结构的无界阻塞队列。它通过CAS和&lt;code&gt;LockSupport&lt;/code&gt;来实现线程安全的。&lt;br&gt;它采用一种预占模式，意思是当消费者线程取元素时，如果队列为空，那就生成一个节点（节点元素为null）入队，然后消费者线程被等待在这个节点上，后面生产者线程入队时发现一个元素为null的节点，就会直接将元素填充到该节点，并唤醒该节点等待的线程，被唤醒的消费者线程取走元素并返回。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="源码" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>ConcurrentLinkedQueue源码分析</title>
    <link href="http://yoursite.com/2020/01/17/ConcurrentLinkedQueue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2020/01/17/ConcurrentLinkedQueue源码分析/</id>
    <published>2020-01-17T08:54:56.000Z</published>
    <updated>2020-01-17T08:55:14.421Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="概述">概述</span></h2><p><code>ConcurrentLinkedQueue</code>是一个单向链表结构的无界并发队列。通过CAS来实现并发安全。内存一致性遵循对<code>ConcurrentLinkedQueue</code>的插入插入操作先行于访问会或移除操作。</p><a id="more"></a><h2><span id="源码分析">源码分析</span></h2><h3><span id="继承体系">继承体系</span></h3><p><img src="https://s2.ax1x.com/2020/01/17/lzPOQP.png" alt="lzPOQP.png"></p><h3><span id="重要属性">重要属性</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;E&gt; head;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;E&gt; tail;</span><br></pre></td></tr></table></figure><p><code>ConcurrentLinkedQueue</code>中只有两个属性。</p><h3><span id="重要方法分析">重要方法分析</span></h3><h4><span id="offer方法">offer方法</span></h4><p><code>offer</code>方法用于向队列尾部添加节点。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">       checkNotNull(e);</span><br><span class="line">       <span class="comment">//创建新的节点</span></span><br><span class="line">       <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (Node&lt;E&gt; t = tail, p = t;;) &#123;<span class="comment">//自旋</span></span><br><span class="line">           Node&lt;E&gt; q = p.next; <span class="comment">//p实际上指向尾节点</span></span><br><span class="line">           <span class="keyword">if</span> (q == <span class="keyword">null</span>) &#123; <span class="comment">//尾节点下一个为null</span></span><br><span class="line">               <span class="comment">// p is last node</span></span><br><span class="line">               <span class="keyword">if</span> (p.casNext(<span class="keyword">null</span>, newNode)) &#123; <span class="comment">//CAS插入</span></span><br><span class="line">                   <span class="comment">// Successful CAS is the linearization point</span></span><br><span class="line">                   <span class="comment">// for e to become an element of this queue,</span></span><br><span class="line">                   <span class="comment">// and for newNode to become "live".</span></span><br><span class="line">                   <span class="keyword">if</span> (p != t) <span class="comment">//tail之后至少有两个节点才修改tail</span></span><br><span class="line">                       casTail(t, newNode);  <span class="comment">// CAS替换尾节点</span></span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">// Lost CAS race to another thread; re-read next</span></span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (p == q)<span class="comment">//p节点指向自身，说明p是自链节点</span></span><br><span class="line">               <span class="comment">// We have fallen off list.  If tail is unchanged, it</span></span><br><span class="line">               <span class="comment">// will also be off-list, in which case we need to</span></span><br><span class="line">               <span class="comment">// jump to head, from which all live nodes are always</span></span><br><span class="line">               <span class="comment">// reachable.  Else the new tail is a better bet.</span></span><br><span class="line">               <span class="comment">//如果tail节点被其它线程修改，此时需要从head节点开始向</span></span><br><span class="line">               <span class="comment">//后遍历，因为从head开始可达所有的live节点</span></span><br><span class="line">               p = (t != (t = tail)) ? t : head;</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">               <span class="comment">// Check for tail updates after two hops.</span></span><br><span class="line">               <span class="comment">//继续向后查找，如果tail节点变化，重新获取tail。</span></span><br><span class="line">               p = (p != t &amp;&amp; t != (t = tail)) ? t : q;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>整个方法的执行流程如下：</p><ol><li>从<code>tail</code>节点先后自旋查找next为null的节点，也就是最后一个节点（因为tail节点并不是每次都更新，所以我们取到tail节点可能并不是最后一个节点）</li><li>通过CAS插入新增节点</li></ol><p>为什么<code>tail</code>可能不是指向最后一个节点呢？<br>因为其实并不是每次操作都会更新<code>head/tail</code>节点。而是使用了一个松弛阈值，具体的体现是在<code>if (p != t)</code>（p初始是等于<code>tail</code>的，p伴随着每次查找都会后移）。如果向后查找了一次以上，再加上新增的节点，说明<code>tail</code>之后有两个（或以上）的节点了，才会通过CAS更新<code>tail</code></p><h4><span id="poll方法">poll方法</span></h4><p><code>poll</code>方法移除队列中的头节点并返回。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       restartFromHead:</span><br><span class="line">       <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">       <span class="comment">//从head开始先后查找第一个live节点</span></span><br><span class="line">           <span class="keyword">for</span> (Node&lt;E&gt; h = head, p = h, q;;) &#123;</span><br><span class="line">               E item = p.item;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (item != <span class="keyword">null</span> &amp;&amp; p.casItem(item, <span class="keyword">null</span>)) &#123;</span><br><span class="line">               <span class="comment">//找到第一个不为null的节点，通过CAS设置item为null</span></span><br><span class="line">                   <span class="comment">// Successful CAS is the linearization point</span></span><br><span class="line">                   <span class="comment">// for item to be removed from this queue.</span></span><br><span class="line">                   <span class="keyword">if</span> (p != h) <span class="comment">// 跳两个以上的节点才修改head</span></span><br><span class="line">                       updateHead(h, ((q = p.next) != <span class="keyword">null</span>) ? q : p);</span><br><span class="line">                   <span class="keyword">return</span> item;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> ((q = p.next) == <span class="keyword">null</span>) &#123; <span class="comment">//队列已空</span></span><br><span class="line">                   updateHead(h, p);<span class="comment">//CAS修改head为p</span></span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> (p == q) <span class="comment">//p为自链节点，重新获取head循环</span></span><br><span class="line">                   <span class="comment">//跳转到restartFromHead继续循环</span></span><br><span class="line">                   <span class="keyword">continue</span> restartFromHead; </span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">                   p = q; <span class="comment">//先后查找</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>这个方法的流程：<br>从head开始向后查找第一个live(item不为null的节点)节点。通过CAS修改节点的live为null。返回当前的节点的item。这个地方也是跳两个以上节点时才会更新<code>head</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;&lt;code&gt;ConcurrentLinkedQueue&lt;/code&gt;是一个单向链表结构的无界并发队列。通过CAS来实现并发安全。内存一致性遵循对&lt;code&gt;ConcurrentLinkedQueue&lt;/code&gt;的插入插入操作先行于访问会或移除操作。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="源码" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>ThreadPoolExecutor源码分析</title>
    <link href="http://yoursite.com/2020/01/17/ThreadPoolExecutor%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2020/01/17/ThreadPoolExecutor源码分析/</id>
    <published>2020-01-17T08:54:56.000Z</published>
    <updated>2020-02-06T13:05:10.784Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="概述">概述</span></h2><p>任务是一组逻辑工作单元，而线程则是是任务异步执行的机制。通过线程池就可以简化线程的管理工作。<br>ThreadPoolExecutor是线程池的核心实现。线程池中预先提供了指定数量的可重用的线程，使用线程池避免了线程创建和终止的开销，节省了系统的资源。并且线程池维护了一些基础的数据统计，方便了线程的监控和管理。</p><a id="more"></a><h2><span id="线程池的基本使用">线程池的基本使用</span></h2><h3><span id="参数解释">参数解释</span></h3><p>线程池的创建的需要指定非常的参数，我们需要理解每个参数的含义.我们就以参数最多的构造器为例，来解释每个参数的含义。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor(<span class="keyword">int</span> corePoolSize,</span><br><span class="line">                   <span class="keyword">int</span> maximumPoolSize,</span><br><span class="line">                   <span class="keyword">long</span> keepAliveTime,</span><br><span class="line">                   TimeUnit unit,</span><br><span class="line">                   BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                   ThreadFactory threadFactory,</span><br><span class="line">                   RejectedExecutionHandler handler)</span><br></pre></td></tr></table></figure></p><p><code>corePoolSize</code> 核心线程数。<br><code>maximumPoolSize</code>最大线程数。<br>这里需要注意：当一个新的任务提交给线程池之后：</p><ul><li>如果当前运行线程的数量小于核心线程数，无论有无空闲的线程，都换创建新的线程。</li><li>如果当前运行的线程数大于核心线程数，小于最大线程数，只有当等待队列满之后，才会新建线程。</li><li>如果等待队列已满，且线程数已达到最大线程数，那么就会根据指定的拒绝策略进行处理了。</li></ul><p><code>keepAliveTime</code>线程最大空闲时间：如果当前线程池中多于核心线程数的线程如果超过最大空闲时间就会被终止。</p><p><code>unit:TimeUnit</code>时间单位。<br><code>workQueue</code>线程等待队列。<br><code>threadFactory</code>线程创建工厂。<br><code>RejectedExecutionHandler</code>:拒绝策略。当线程池已经关闭或者已经达到饱和状态，新提交的任务会被拒绝。一共有4种拒绝策略：</p><ul><li><code>AbortPolicy</code>:默认策略，在需要拒绝任务时，抛出<code>RejectedExecutionException</code></li><li><code>CallerRunsPolicy</code>:直接在execute方法的调用线程种运行被拒绝的任务，如果线程池已经关闭，任务将被丢弃。</li><li><code>DiscardPolicy</code>：直接丢弃任务</li><li><code>DiscardOldestPolicy</code>:丢弃队列中等待时间最长的任务，并执行当前提交的任务，如果线程池被关闭，任务将被丢弃。</li><li>我们也可以自己继承<code>RejectedExcutionHandler</code>自定义自己的拒绝策略，拒绝策略的运行需要指定线程池和队列的容量。</li></ul><h3><span id="生命周期">生命周期</span></h3><p>线程池一共有5种状态：</p><ul><li>Running：可以接收新的任务和队列任务</li><li>shutdown：不接受新的任务，但是会运行队列任务。</li><li>stop：不接受新的任务，也不会运行队列任务，并且中断正在运行的任务。</li><li>tidying：所有任务都已经终止，<code>workCount</code>为0，当前池状态为tidying时会运行运行<code>terminated()</code>方法</li><li>terminated，<code>terminated()</code>方法执行完毕。</li></ul><p><img src="https://s2.ax1x.com/2020/01/19/1C7IpT.png" alt="1C7IpT.png"></p><h2><span id="源码分析">源码分析</span></h2><p><img src="https://s2.ax1x.com/2020/01/19/1CHiBd.png" alt="1CHiBd.png"></p><h3><span id="重要属性">重要属性</span></h3><p><code>ThreadPoolExecutor</code>内部有一个非常重要的内部类<code>Worker</code>，它继承自AQS实现了<code>Runnable</code>接口,实现了不可重入的互斥锁。在线程池种持有一个Work集合，一个worker对应一个工作想，当线程池启动时，对应的worker会执行池种的任务，执行任务完毕后会从阻塞列表中获取一个新的任务继续执行。</p><p><code>Worker</code>内部维护了三个变量，用于记录每个工作线程的工作状态。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 工作线程 */</span></span><br><span class="line"><span class="keyword">final</span> Thread thread;</span><br><span class="line"><span class="comment">/** 初始运行任务 */</span></span><br><span class="line">Runnable firstTask;</span><br><span class="line"><span class="comment">/**任务完成计数*/</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">long</span> completedTasks;</span><br></pre></td></tr></table></figure></p><p>内部的属性：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*当核心参数数已满，新增任务的存储队列*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*线程池运行期间的锁*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*工作池线程*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> HashSet&lt;Worker&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*awaitTermination的等待队列*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition termination = mainLock.newCondition();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*最大线程池数量*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> largestPoolSize;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*已完成的任务数*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> completedTaskCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*线程创建工厂*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> ThreadFactory threadFactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*拒绝处理器*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> RejectedExecutionHandler handler;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*最大闲置时间*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> keepAliveTime;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*是否允许核心线程超时*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> allowCoreThreadTimeOut;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*核心线程数*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> corePoolSize;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*最大线程数*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> maximumPoolSize;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*拒绝策略，默认的拒绝策略为AbortPolicy，即直接抛出异常*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> RejectedExecutionHandler defaultHandler =</span><br><span class="line">    <span class="keyword">new</span> AbortPolicy();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*针对shutdown和shutdownNow的运行权限许可*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> RuntimePermission shutdownPerm =</span><br><span class="line">    <span class="keyword">new</span> RuntimePermission(<span class="string">"modifyThread"</span>);</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*高3位标识线程池的运行状态，低29位表示线程池中的任务数*/</span>    </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br></pre></td></tr></table></figure></p><h3><span id="重要方法解析">重要方法解析</span></h3><h4><span id="execute方法">execute方法</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">       <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">       <span class="comment">//线程池中的线程数小于核心线程数</span></span><br><span class="line">       <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">           <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))<span class="comment">//添加到工作线程集合</span></span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           c = ctl.get();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//线程正在运行，添加到等待队列</span></span><br><span class="line">       <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">           <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">           <span class="comment">//如果池的状态shutdown，移除任务，执行拒绝策略</span></span><br><span class="line">           <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">               reject(command);<span class="comment">//执行拒绝策略</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)<span class="comment">//工作线程位空，添加新的工作线程</span></span><br><span class="line">               addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))<span class="comment">//再次尝试添加任务</span></span><br><span class="line">       <span class="comment">//再次尝试还是失败，就会根据拒绝策略进行处理了</span></span><br><span class="line">           reject(command);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>提交一个任务到线程池，任务不一定会立即执行。提交的任务可以在一个新的线程中执行，也可能在已存在线程中执行。如果由于池关闭或池容量已经饱和导致任务无法提交，那么就根据拒绝策略来处理提交过来的任务。</p><ol><li>如果正在运行的线程数少于<code>corePoolSize</code>,那么就会通过<code>addWorker</code>方法尝试开启一个新的线程并把提交的任务作为它的<code>firstTask</code>运行，<code>addWorker</code>会检查<code>ctl</code>的状态来判断是否可以添加新的线程。</li><li>如果<code>addWorker</code>执行失败（返回false），那么就会把任务添加到等待队列。这里需要对<code>ctl</code>进行双重检查。</li><li>如果不能任务不能入队，那么就会再次尝试增加一个新的线程，如果添加失败，就意味着池关闭或已经饱和，这个时候就会根据拒绝策略来进行处理。</li></ol><h4><span id="addworker方法">addWorker方法</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; <span class="comment">//自旋，判断可以添加节点的前提条件</span></span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);<span class="comment">//线程运行的状态码</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查线程池的状态</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">               firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">               ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;<span class="comment">//检查工作线程数是否饱和</span></span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);<span class="comment">//获取工作线程数</span></span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">            <span class="comment">//可以添加新的线程，更新ctl中关于新线程的表示</span></span><br><span class="line">            <span class="comment">//跳出自旋</span></span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            c = ctl.get();  <span class="comment">// 更新ctl失败，重新读取ctl</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">    Worker w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//创建新的工作线程</span></span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            mainLock.lock();<span class="comment">//加锁，准备添加新的工作线程</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">                <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">                <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">                <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line"></span><br><span class="line">                <span class="comment">//重新加成sunState</span></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                    workers.add(w);<span class="comment">//添加工作线程</span></span><br><span class="line">                    <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;<span class="comment">//更新最大池容量</span></span><br><span class="line">                    workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                t.start();<span class="comment">//添加成功，启动线程</span></span><br><span class="line">                workerStarted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">        <span class="comment">//添加失败，回滚操作</span></span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="runworker方法">runWorker方法</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">        Thread wt = Thread.currentThread();</span><br><span class="line">        Runnable task = w.firstTask;</span><br><span class="line">        w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">        w.unlock(); <span class="comment">// 允许中断</span></span><br><span class="line">        <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//如果work的firstTask为null，就调用getTask从队列中取任务</span></span><br><span class="line">            <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                w.lock();<span class="comment">//加锁</span></span><br><span class="line">                <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                     (Thread.interrupted() &amp;&amp;</span><br><span class="line">                      runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                    !wt.isInterrupted())</span><br><span class="line">                    <span class="comment">//中断线程</span></span><br><span class="line">                    wt.interrupt();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//执行任务的前逻辑</span></span><br><span class="line">                    beforeExecute(wt, task);</span><br><span class="line">                    Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        task.run();<span class="comment">//执行任务</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                        thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                        thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                        thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//执行任务后逻辑，自定义任务</span></span><br><span class="line">                        afterExecute(task, thrown);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    task = <span class="keyword">null</span>;</span><br><span class="line">                    w.completedTasks++; <span class="comment">//完成的任务数加一</span></span><br><span class="line">                    w.unlock(); <span class="comment">//解锁</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//处理工作线程退出逻辑</span></span><br><span class="line">            processWorkerExit(w, completedAbruptly);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>runWorker</code>是工作线程运行的核心方法，循环从队列中获取任务并执行。工作线程启动后，会首先运行内部持有的任务<code>firstTask</code>.如果<code>firstTask</code>为null，那么就会循环调用<code>getTask</code>方法从队列中获取任务执行。在任务执行前后可以调用<code>beforeExecute</code>和<code>afterWxecute</code>处理执行前后的逻辑。如果线程池的状态正在停止，那么需要确保线程被中断，否则需要确保线程没有被中断。</p><h4><span id="gettask方法">getTask方法</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);<span class="comment">//获取runState</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">        <span class="comment">//线程池已经关闭或等待队列为null</span></span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> wc = workerCountOf(c);<span class="comment">//获取工作线程的数wokerCount</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Are workers subject to culling?</span></span><br><span class="line">        <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">            &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))<span class="comment">//修改ctl工作线程数减一</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Runnable r = timed ?</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                workQueue.take();<span class="comment">//出队，直到得带元素可用</span></span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            timedOut = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">            timedOut = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="processworkerexit方法">processWorkerExit方法</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processWorkerExit</span><span class="params">(Worker w, <span class="keyword">boolean</span> completedAbruptly)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (completedAbruptly) <span class="comment">// If abrupt, then workerCount wasn't adjusted</span></span><br><span class="line">       <span class="comment">//如果任务线程被中断，则工作线程数量减一</span></span><br><span class="line">           decrementWorkerCount();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">       mainLock.lock(); <span class="comment">//加锁</span></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">//更新完成任务数</span></span><br><span class="line">           completedTaskCount += w.completedTasks;</span><br><span class="line">           <span class="comment">//移除工作线程</span></span><br><span class="line">           workers.remove(w);</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           mainLock.unlock();<span class="comment">//解锁</span></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       tryTerminate();<span class="comment">//尝试终止线程池</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">       <span class="keyword">if</span> (runStateLessThan(c, STOP)) &#123;<span class="comment">//线程池尚未完全停止</span></span><br><span class="line">           <span class="keyword">if</span> (!completedAbruptly) &#123;<span class="comment">//工作线程非异常退出</span></span><br><span class="line">           <span class="comment">//获取当前核心线程数</span></span><br><span class="line">               <span class="keyword">int</span> min = allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize;</span><br><span class="line">               <span class="keyword">if</span> (min == <span class="number">0</span> &amp;&amp; ! workQueue.isEmpty())</span><br><span class="line">               <span class="comment">//如果允许空闲工作线程等待任务，且任务队列不为空，则min为1</span></span><br><span class="line">                   min = <span class="number">1</span>;</span><br><span class="line">               <span class="keyword">if</span> (workerCountOf(c) &gt;= min)</span><br><span class="line">                   <span class="keyword">return</span>; <span class="comment">// replacement not needed</span></span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//继续尝试添加新的工作线程</span></span><br><span class="line">           addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>工作线程处理完所有的任务之后，调用池方法处理工作线程退出逻辑，为已经死亡的工作线程执行相关的清除操作。此方法会从线程池中内的工作线程集合中移除当前线程，并会尝试终止线程池。<br>在下面这几种情况下，可能会替换当前工作线程：</p><ol><li>用户任务执行异常导致线程退出</li><li>工作线程数少于<code>corePoolSize</code></li><li>等待队列不为空，但是没有工作线程</li></ol><h4><span id="tryterminate方法">tryTerminate方法</span></h4><p>该方法的主要作用就是尝试终止线程池。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">tryTerminate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">           <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">           <span class="keyword">if</span> (isRunning(c) ||</span><br><span class="line">               runStateAtLeast(c, TIDYING) ||</span><br><span class="line">               (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           <span class="keyword">if</span> (workerCountOf(c) != <span class="number">0</span>) &#123; <span class="comment">// Eligible to terminate</span></span><br><span class="line">               interruptIdleWorkers(ONLY_ONE);<span class="comment">//中断空闲线程</span></span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">           mainLock.lock();</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//线程池已经关闭，等待队列为空，并且工作线程等于0，更新池状态为TINDYING</span></span><br><span class="line">               <span class="keyword">if</span> (ctl.compareAndSet(c, ctlOf(TIDYING, <span class="number">0</span>))) &#123;</span><br><span class="line">                   <span class="keyword">try</span> &#123;</span><br><span class="line">                   </span><br><span class="line">                   <span class="comment">//线程池终止操作，需要自定义实现</span></span><br><span class="line">                       terminated();</span><br><span class="line">                   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                       ctl.set(ctlOf(TERMINATED, <span class="number">0</span>));</span><br><span class="line">                       <span class="comment">//唤醒等待池结束的线程</span></span><br><span class="line">                       termination.signalAll();</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">return</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">               mainLock.unlock();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// else retry on failed CAS</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>该方法用于尝试终止线程池，<code>shutDown</code>,<code>shutdownNoe</code>,<code>remove</code>中局势通过此方法来终止线程池的。此方法必须在人恶化可能导致终止的行为之后被调用。一如减少工作线程数，移除队列中的任务，或者是在工作线程运行完毕后处理工作线程退出逻辑方法<code>processWorkerExit</code>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;任务是一组逻辑工作单元，而线程则是是任务异步执行的机制。通过线程池就可以简化线程的管理工作。&lt;br&gt;ThreadPoolExecutor是线程池的核心实现。线程池中预先提供了指定数量的可重用的线程，使用线程池避免了线程创建和终止的开销，节省了系统的资源。并且线程池维护了一些基础的数据统计，方便了线程的监控和管理。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="源码" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>ConcurrentSkipListMap源码分析</title>
    <link href="http://yoursite.com/2020/01/16/ConcurrentSkipListMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2020/01/16/ConcurrentSkipListMap源码分析/</id>
    <published>2020-01-16T12:31:56.000Z</published>
    <updated>2020-01-16T12:32:14.766Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="概述">概述</span></h2><p><code>ConcurrentSkipListMap</code>是一个线程安全的有序的哈希表，并发安全主要由CAS来实现。内部的使用了跳表这种数据结构。<code>ConcurrentSkipListSet</code>的底层是基于<code>ConcurrentSkipListMap</code>实现的。</p><a id="more"></a><h2><span id="跳表skip-list">跳表（Skip List）</span></h2><p>跳表可以做到比较稳定的插入，查询与删除。理论插入查询删除的算法时间复杂度为O(logN).<br>跳表其实是从链表之上改进而来的。我们知道在链表中查询，插入的时间复杂度都为O(n).如果我们可以在多个节点之间跳跃，就可以提高效率。</p><p>链表的结构如下；<br><img src="https://s2.ax1x.com/2020/01/16/ljDHVf.png" alt="ljDHVf.png"><br>改进后得到：<br><img src="https://s2.ax1x.com/2020/01/16/ljrddf.png" alt="ljrddf.png"><br>如果层次更多的话，那么结构如下；<br><img src="https://s2.ax1x.com/2020/01/16/ljrcyn.png" alt="ljrcyn.png"></p><p>跳表的查询：<br>假如我们要查询11.从最上面一层出发，发现11大于5小于13，那么确定了大致区间。进入第二层，发现11大于9小于13，区间缩小。进入第三层，依次查找，最终找到11这个节点。<br><img src="https://s2.ax1x.com/2020/01/16/ljslmq.png" alt="ljslmq.png"></p><p>插入与查询的过程也非常的类似，首先找到在最底层合适的位置，然后再随机是否向上拓展。</p><p>删除同样也需要查找，然后再从下至上依次删除。</p><h2><span id="concurrentskiplistmap源码分析">ConcurrentSkipListMap源码分析</span></h2><h3><span id="重要属性">重要属性</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 跳表最底一层的链表的头节点。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object BASE_HEADER = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 跳表最高层的头节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> HeadIndex&lt;K,V&gt; head;</span><br></pre></td></tr></table></figure><p><code>ConcurrentSkipListMap</code>的跳表实现：<br><img src="https://s2.ax1x.com/2020/01/16/lj6TSg.png" alt="lj6TSg.png"></p><p>数据存储由三个内部类实现：<br><code>Node</code>:存储键值对， 单向链表节点。<br><code>Index</code>:跳表中的索引节点，包含了向右的指针和向下的指针，和节点。<br><code>HeadIndex</code>：跳表的头，继承至Index，包含了层次信息。</p><h3><span id="重要方法">重要方法</span></h3><h4><span id="put方法">put方法</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>)<span class="comment">//不支持null键</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">return</span> doPut(key, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从<code>put</code>方法中，我们可以知道<code>ConcurrentSkipListMap</code>不支持null键。</p><p>实际的put工作由<code>doPut</code>方法完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">doPut</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">       Node&lt;K,V&gt; z;             <span class="comment">// added node</span></span><br><span class="line">       <span class="keyword">if</span> (key == <span class="keyword">null</span>) <span class="comment">//不支持空键</span></span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">       Comparator&lt;? <span class="keyword">super</span> K&gt; cmp = comparator;</span><br><span class="line">       outer: <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">       <span class="comment">//找到指定key节点的前驱节点</span></span><br><span class="line">           <span class="keyword">for</span> (Node&lt;K,V&gt; b = findPredecessor(key, cmp), n = b.next;;) &#123;</span><br><span class="line">               <span class="keyword">if</span> (n != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   Object v; <span class="keyword">int</span> c;</span><br><span class="line">                   Node&lt;K,V&gt; f = n.next;</span><br><span class="line">                   <span class="keyword">if</span> (n != b.next)               <span class="comment">// inconsistent read</span></span><br><span class="line">                       <span class="comment">//读不一致，跳出整个循环</span></span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   <span class="keyword">if</span> ((v = n.value) == <span class="keyword">null</span>) &#123;   <span class="comment">// n is deleted</span></span><br><span class="line">                       n.helpDelete(b, f);<span class="comment">//帮助清楚已删除的节点</span></span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">if</span> (b.value == <span class="keyword">null</span> || v == n) <span class="comment">// b is deleted</span></span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   <span class="keyword">if</span> ((c = cpr(cmp, key, n.key)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                   <span class="comment">//当前key大于n.key，继续向后查找</span></span><br><span class="line">                       b = n;</span><br><span class="line">                       n = f;</span><br><span class="line">                       <span class="keyword">continue</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                       <span class="comment">//更新value，返回更新前的值</span></span><br><span class="line">                       <span class="keyword">if</span> (onlyIfAbsent || n.casValue(v, value)) &#123;</span><br><span class="line">                           <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) V vv = (V)v;</span><br><span class="line">                           <span class="keyword">return</span> vv;</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="keyword">break</span>; <span class="comment">// restart if lost race to replace value</span></span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="comment">// else c &lt; 0; fall through</span></span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="comment">//新建一个节点，插入的哦b和b.next之间</span></span><br><span class="line">               z = <span class="keyword">new</span> Node&lt;K,V&gt;(key, value, n);</span><br><span class="line">               <span class="keyword">if</span> (!b.casNext(n, z))</span><br><span class="line">                   <span class="keyword">break</span>;         <span class="comment">// restart if lost race to append to b</span></span><br><span class="line">               <span class="keyword">break</span> outer;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> rnd = ThreadLocalRandom.nextSecondarySeed();</span><br><span class="line">       <span class="comment">//使用随机数来决定是否更新层级</span></span><br><span class="line">       <span class="keyword">if</span> ((rnd &amp; <span class="number">0x80000001</span>) == <span class="number">0</span>) &#123; <span class="comment">// test highest and lowest bits</span></span><br><span class="line">           <span class="keyword">int</span> level = <span class="number">1</span>, max;</span><br><span class="line">           <span class="comment">//计算跳表的level</span></span><br><span class="line">           <span class="keyword">while</span> (((rnd &gt;&gt;&gt;= <span class="number">1</span>) &amp; <span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">               ++level;</span><br><span class="line">           Index&lt;K,V&gt; idx = <span class="keyword">null</span>;</span><br><span class="line">           HeadIndex&lt;K,V&gt; h = head;</span><br><span class="line">           <span class="comment">//构建index的逻辑</span></span><br><span class="line">           <span class="keyword">if</span> (level &lt;= (max = h.level)) &#123; <span class="comment">//不需要增加层级</span></span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= level; ++i)</span><br><span class="line">                   idx = <span class="keyword">new</span> Index&lt;K,V&gt;(z, idx, <span class="keyword">null</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> &#123; <span class="comment">// try to grow by one level 需要增加新层级</span></span><br><span class="line">               level = max + <span class="number">1</span>; <span class="comment">// hold in array and later pick the one to use</span></span><br><span class="line">               <span class="comment">//构建一个长度为level+1的index数组</span></span><br><span class="line">               <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)Index&lt;K,V&gt;[] idxs =</span><br><span class="line">                   (Index&lt;K,V&gt;[])<span class="keyword">new</span> Index&lt;?,?&gt;[level+<span class="number">1</span>];</span><br><span class="line">               <span class="comment">//从下至上构建HeadIndex</span></span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= level; ++i)</span><br><span class="line">                   idxs[i] = idx = <span class="keyword">new</span> Index&lt;K,V&gt;(z, idx, <span class="keyword">null</span>);</span><br><span class="line">               <span class="keyword">for</span> (;;) &#123; <span class="comment">//自旋</span></span><br><span class="line">                   h = head;</span><br><span class="line">                   <span class="comment">//保存head之前的层级</span></span><br><span class="line">                   <span class="keyword">int</span> oldLevel = h.level;</span><br><span class="line">                   <span class="keyword">if</span> (level &lt;= oldLevel) <span class="comment">// lost race to add level</span></span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   HeadIndex&lt;K,V&gt; newh = h;</span><br><span class="line">                   Node&lt;K,V&gt; oldbase = h.node;</span><br><span class="line">                   <span class="keyword">for</span> (<span class="keyword">int</span> j = oldLevel+<span class="number">1</span>; j &lt;= level; ++j)</span><br><span class="line">                       newh = <span class="keyword">new</span> HeadIndex&lt;K,V&gt;(oldbase, newh, idxs[j], j);</span><br><span class="line">                   <span class="keyword">if</span> (casHead(h, newh)) &#123;</span><br><span class="line">                       h = newh;</span><br><span class="line">                       idx = idxs[level = oldLevel];</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// find insertion points and splice in 插入index</span></span><br><span class="line">           splice: <span class="keyword">for</span> (<span class="keyword">int</span> insertionLevel = level;;) &#123;</span><br><span class="line">               <span class="keyword">int</span> j = h.level;</span><br><span class="line">               <span class="keyword">for</span> (Index&lt;K,V&gt; q = h, r = q.right, t = idx;;) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (q == <span class="keyword">null</span> || t == <span class="keyword">null</span>)</span><br><span class="line">                       <span class="keyword">break</span> splice;</span><br><span class="line">                   <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">                       Node&lt;K,V&gt; n = r.node;</span><br><span class="line">                       <span class="comment">// compare before deletion check avoids needing recheck</span></span><br><span class="line">                       <span class="keyword">int</span> c = cpr(cmp, key, n.key);</span><br><span class="line">                       <span class="keyword">if</span> (n.value == <span class="keyword">null</span>) &#123;</span><br><span class="line">                           <span class="keyword">if</span> (!q.unlink(r))</span><br><span class="line">                               <span class="keyword">break</span>;</span><br><span class="line">                           r = q.right;</span><br><span class="line">                           <span class="keyword">continue</span>;</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="keyword">if</span> (c &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                           q = r;</span><br><span class="line">                           r = r.right;</span><br><span class="line">                           <span class="keyword">continue</span>;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">if</span> (j == insertionLevel) &#123;</span><br><span class="line">                       <span class="keyword">if</span> (!q.link(r, t))</span><br><span class="line">                           <span class="keyword">break</span>; <span class="comment">// restart</span></span><br><span class="line">                       <span class="keyword">if</span> (t.node.value == <span class="keyword">null</span>) &#123;</span><br><span class="line">                           findNode(key);</span><br><span class="line">                           <span class="keyword">break</span> splice;</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="keyword">if</span> (--insertionLevel == <span class="number">0</span>)</span><br><span class="line">                           <span class="keyword">break</span> splice;</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">if</span> (--j &gt;= insertionLevel &amp;&amp; j &lt; level)</span><br><span class="line">                       t = t.down;</span><br><span class="line">                   q = q.down;</span><br><span class="line">                   r = q.right;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这个方法的实现非常的复杂。但大致可以分为两个步骤；</p><ol><li>通过自旋查找索引位置，更新或插入给定的节点元素。在遍历查找的过程中，也会帮助清楚已经删除的节点。具体的流程如下：</li></ol><ul><li>首先通过<code>findPredecessor</code>方法，从最底一层找到key节点的前驱节点b，从这个节点开始先后查找合适位置插入。</li><li>如果在查找的过程中，发现了已删除的节点，那么会调用<code>helpDelete</code>方法帮助清除节点。</li></ul><ol start="2"><li>通过随机的方式，确定是否更新跳表层级。随机的过程大致如下：首先生成一个随机数<code>rnd</code>,如果<code>rnd</code>为正偶数，那么就会进行下一步的判断，计算<code>rnd</code>从第2位开始有多少个连续的1，如果连续1的数量小于等于旧表层级，则不需要增加跳表层级，只需要更新<code>index</code>,否则旧需要更新跳表层级。</li></ol><h4><span id="remove方法">remove方法</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> doRemove(key, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>remove</code>实际上是调用了<code>doRemove</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">doRemove</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">       Comparator&lt;? <span class="keyword">super</span> K&gt; cmp = comparator;</span><br><span class="line">       outer: <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">       <span class="comment">//找到指定key的前驱节点</span></span><br><span class="line">           <span class="keyword">for</span> (Node&lt;K,V&gt; b = findPredecessor(key, cmp), n = b.next;;) &#123;</span><br><span class="line">               Object v; <span class="keyword">int</span> c;</span><br><span class="line">               <span class="keyword">if</span> (n == <span class="keyword">null</span>)</span><br><span class="line">                   <span class="keyword">break</span> outer;</span><br><span class="line">               Node&lt;K,V&gt; f = n.next;</span><br><span class="line">               <span class="keyword">if</span> (n != b.next)                    <span class="comment">// inconsistent read</span></span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               <span class="keyword">if</span> ((v = n.value) == <span class="keyword">null</span>) &#123;        <span class="comment">// n is deleted</span></span><br><span class="line">                   n.helpDelete(b, f); <span class="comment">//帮助清除，已经删除的节点</span></span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (b.value == <span class="keyword">null</span> || v == n)      <span class="comment">// b is deleted</span></span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               <span class="keyword">if</span> ((c = cpr(cmp, key, n.key)) &lt; <span class="number">0</span>)</span><br><span class="line">                   <span class="keyword">break</span> outer;</span><br><span class="line">               <span class="keyword">if</span> (c &gt; <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="comment">//继续向右寻找</span></span><br><span class="line">                   b = n;</span><br><span class="line">                   n = f;</span><br><span class="line">                   <span class="keyword">continue</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (value != <span class="keyword">null</span> &amp;&amp; !value.equals(v))</span><br><span class="line">                   <span class="keyword">break</span> outer;</span><br><span class="line">               <span class="keyword">if</span> (!n.casValue(v, <span class="keyword">null</span>)) <span class="comment">//找打了指定的节点将value置null</span></span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">                   <span class="comment">//添加删除标识，彻底从链表上删除</span></span><br><span class="line">               <span class="keyword">if</span> (!n.appendMarker(f) || !b.casNext(n, f))</span><br><span class="line">                   findNode(key);                  <span class="comment">// retry via findNode</span></span><br><span class="line">               <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">//删除n节点对应的index</span></span><br><span class="line">                   findPredecessor(key, cmp);      <span class="comment">// clean index</span></span><br><span class="line">                   <span class="keyword">if</span> (head.right == <span class="keyword">null</span>)</span><br><span class="line">                   <span class="comment">//减少跳表的层级</span></span><br><span class="line">                       tryReduceLevel();</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) V vv = (V)v;</span><br><span class="line">               <span class="keyword">return</span> vv; <span class="comment">//返回对应的value</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>整个方法的流程大致如下：</p><ol><li>首先找到需要删除节点的前系欸但，如果在查找的过程中发现已经删除的节点，那么旧帮助清除节点</li><li>子啊找打需要删除的节点时，不会理解移除它，而是会通过CAS添加一个删除标识，然后再利用CAS来解除链接，如果途中CAS执行失败，那么就会调用<code>findNode</code>来删除有删除标记的节点。</li><li>最后检查<code>head.right</code>如果已经被移除了，那么就会调用<code>tryReduceLevel</code>方法尝试对跳表进行降级操作（只有层级大于三才可以降级）。</li></ol><h4><span id="get方法">get方法</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> doGet(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以发现，实际完成get操作的是<code>doGet</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">doGet</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        Comparator&lt;? <span class="keyword">super</span> K&gt; cmp = comparator;</span><br><span class="line">        outer: <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//从最底层查找指定key节点的前驱节点</span></span><br><span class="line">            <span class="keyword">for</span> (Node&lt;K,V&gt; b = findPredecessor(key, cmp), n = b.next;;) &#123;</span><br><span class="line">                Object v; <span class="keyword">int</span> c;</span><br><span class="line">                <span class="keyword">if</span> (n == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">break</span> outer;</span><br><span class="line">                Node&lt;K,V&gt; f = n.next;</span><br><span class="line">                <span class="keyword">if</span> (n != b.next)                <span class="comment">// inconsistent read</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> ((v = n.value) == <span class="keyword">null</span>) &#123;    <span class="comment">// n is deleted</span></span><br><span class="line">                <span class="comment">//节点n已经被删除了，帮助清除已经删除的节点</span></span><br><span class="line">                    n.helpDelete(b, f);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (b.value == <span class="keyword">null</span> || v == n)  <span class="comment">// b is deleted</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> ((c = cpr(cmp, key, n.key)) == <span class="number">0</span>) &#123;<span class="comment">//检查k是否相等</span></span><br><span class="line">                    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) V vv = (V)v;</span><br><span class="line">                    <span class="keyword">return</span> vv;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (c &lt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span> outer;</span><br><span class="line">                <span class="comment">//未找到合适节点，继续向后查找</span></span><br><span class="line">                b = n;</span><br><span class="line">                n = f;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;&lt;code&gt;ConcurrentSkipListMap&lt;/code&gt;是一个线程安全的有序的哈希表，并发安全主要由CAS来实现。内部的使用了跳表这种数据结构。&lt;code&gt;ConcurrentSkipListSet&lt;/code&gt;的底层是基于&lt;code&gt;ConcurrentSkipListMap&lt;/code&gt;实现的。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="源码" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Spring事务基础</title>
    <link href="http://yoursite.com/2020/01/15/Spring%E4%BA%8B%E5%8A%A1%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2020/01/15/Spring事务基础/</id>
    <published>2020-01-15T13:35:56.000Z</published>
    <updated>2020-01-16T02:57:44.004Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="事务的acid">事务的ACID</span></h2><ul><li>Atomicity原子性：事务是一个原子操作，由一些列动作组成，事务的原子性确保动作要么全部完成，要么都不完成。</li><li>Consistency一致性：一旦事务完成，系统必须确保它锁建模的业务处于一致的状态，而不是部分完成或部分失败。</li><li>Isolation隔离性：可能有许多事务会同时处理相同的数据，因此每个事务都应该与其它事务隔离开来，防止数据破坏。</li><li>Durability持久性：一旦事务完成，无论系统发生什么故障，它的结果都不应该受到影响，这样就能从任何系统崩溃中恢复过来，通常情况下，事务的结果会被持久化到存储器中。</li></ul><a id="more"></a><h2><span id="spring事务的核心接口">Spring事务的核心接口</span></h2><p><img src="https://s2.ax1x.com/2020/01/15/lOHA2t.png" alt="lOHA2t.png"><br>Spring并不直接管理事务，而是提供多种事务管理器，它将事务管理委托给持久化框架。</p><h2><span id="事务的属性">事务的属性</span></h2><p>事务的属性是：传播行为，隔离规则，回滚规则，是否只读，事务超时。</p><h3><span id="事务的传播行为">事务的传播行为</span></h3><p>当一个事务方法嗲调用另一个事务方法的时候，必须指定事务应该如何传播。<br>Spring定义了七种传播行为：</p><ul><li>PROPAGATION_REQUIRED:表示当前方法必须运行在事务中，如果当前事务存在，方法将会在该事务中运行。否则，会启动一个新的事务。</li><li>PROPAGATION_SUPPORTS:表示当前方法不需要事务上下文，但是如果存在当前事务的话，那么该方法会在这个事务中运行。</li><li>PROPAGATION_MANDATORY:表示该方法必须在事务中运行，如果当前事务不存在的话，则会抛出一个异常。</li><li>PROPAGATION_REQUIRED_NEW:表示当前方法必须运行在它自己的事务中。一个新事务将被启动。如果存在当前事务，那么该方法执行期间，当前事务会被挂起。</li><li>PROPAGATION_NOT_SUPPORTED:表示该方法不应该运行在事务中，如果存在当前事务，在该方法运行期间，当前事务将被挂起。</li><li>PROPAGATION_NEVER:当前方法不应该运行在事务上下文环节中。如果当前正有一个事务在运行，则会抛出异常。</li><li>PROPAGATION_NESTED:表示当前已经存在一个事务，那么该方法将会在嵌套事务中运行。嵌套的事务可以独立于当前事务进行单独地提交或回滚。</li></ul><h2><span id="spring的隔离级别">Spring的隔离级别</span></h2><ul><li>DEFAULT:默认的隔离级别，使用数据库默认的事务隔离级别。</li><li>未提交读：允许读取未提交的读，可能导致脏读，不可重复读，幻读。</li><li>已提交读：允许读取已提交读，可能导致不可重复读，幻读。</li><li>可重复读：不能更新另一个事务修改但未提交的数据，可能引起幻读。</li><li>串行化：序列执行效率低。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;事务的ACID&quot;&gt;&lt;a href=&quot;#事务的ACID&quot; class=&quot;headerlink&quot; title=&quot;事务的ACID&quot;&gt;&lt;/a&gt;事务的ACID&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Atomicity原子性：事务是一个原子操作，由一些列动作组成，事务的原子性确保动作要么全部完成，要么都不完成。&lt;/li&gt;
&lt;li&gt;Consistency一致性：一旦事务完成，系统必须确保它锁建模的业务处于一致的状态，而不是部分完成或部分失败。&lt;/li&gt;
&lt;li&gt;Isolation隔离性：可能有许多事务会同时处理相同的数据，因此每个事务都应该与其它事务隔离开来，防止数据破坏。&lt;/li&gt;
&lt;li&gt;Durability持久性：一旦事务完成，无论系统发生什么故障，它的结果都不应该受到影响，这样就能从任何系统崩溃中恢复过来，通常情况下，事务的结果会被持久化到存储器中。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>CopyOnWriteArrayList,CopyOnWriteArraySet源码分析</title>
    <link href="http://yoursite.com/2020/01/15/CopyOnWriteArrayList,CopyOnWriteArraySet%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2020/01/15/CopyOnWriteArrayList,CopyOnWriteArraySet源码分析/</id>
    <published>2020-01-15T03:21:56.000Z</published>
    <updated>2020-01-15T03:32:50.347Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="概述">概述</span></h2><p><code>CopyOnWriteArrayList</code>是一个线程安全的<code>ArrayList</code>，通过内部的<code>volatile</code>数组和显示锁ReentrantLock来实现线程安全。<code>CopyOnWriteArraySet</code>的底层也是基于<code>CopyOnWriteArrayList</code>实现的。<code>CopyOnWriteArrayList</code>更适合于读多写少的环节。</p><a id="more"></a><h2><span id="copyonwritearraylist源码分析">CopyOnWriteArrayList源码分析</span></h2><h3><span id="核心属性">核心属性</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** The lock protecting all mutators */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">transient</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="comment">/** 用于存储元素的volatile修饰的内部数组 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Object[] array;</span><br></pre></td></tr></table></figure><p>它的内部属性也非常的简单,值得注意的是array是通过volatile修饰的。</p><h3><span id="重要方法分析">重要方法分析</span></h3><h4><span id="add方法">add方法</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();<span class="comment">//加锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//拿到原数组</span></span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        <span class="comment">//将原数组拷贝到原长度+1的新数组中</span></span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//将元素加入</span></span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        <span class="comment">//用新数组替代原数组</span></span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//解锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这段代码我们可以看出<code>CopyOnWriteArrayList</code>每次添加元素都是直接创建一个长度为原数组长度加一的新数组，然后将该旧数组的数据复制到新数组中。然后将待添加的元素添加到新数组的最后一个位置。最后将旧数组用新数组替换掉。</p><h3><span id="get">get</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> get(getArray(), index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> E <span class="title">get</span><span class="params">(Object[] a, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (E) a[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>get方法非常的简单，不过我们需要注意一点<strong>get方法并没有做同步</strong>。</p><p>通过看了add和get两个方法的实现。我们可以发现add是使用了同步的，而get没有使用同步。在这个地方我的理解是：get之所以不需要同步，这是因为get的读取，本质上是“快照读”。add方法z每次都要复制一份，因为这样写操作不会影响读的。</p><p>至于为什么add要加锁，这个也非常好理解，因为如果不加锁的话，会出现更新丢失。</p><h2><span id="copyonwritearrayset源码分析">CopyOnWriteArraySet源码分析</span></h2><h3><span id="核心属性">核心属性</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> CopyOnWriteArrayList&lt;E&gt; al;</span><br></pre></td></tr></table></figure><p><code>CopyOnWriteArraySet</code>内部其实只有一个<code>CopyOnWriteArrayList</code>.</p><h3><span id="重要方法">重要方法</span></h3><h4><span id="add方法">add方法</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> al.addIfAbsent(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addIfAbsent</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    Object[] snapshot = getArray();</span><br><span class="line">    <span class="comment">//如果数组中已经存在e，则返回false，否则调用addIfAbsent</span></span><br><span class="line">    <span class="keyword">return</span> indexOf(e, snapshot, <span class="number">0</span>, snapshot.length) &gt;= <span class="number">0</span> ? <span class="keyword">false</span> :</span><br><span class="line">        addIfAbsent(e, snapshot);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addIfAbsent</span><span class="params">(E e, Object[] snapshot)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();<span class="comment">//加锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] current = getArray();<span class="comment">//拿到当前的数组</span></span><br><span class="line">        <span class="keyword">int</span> len = current.length;</span><br><span class="line">        <span class="keyword">if</span> (snapshot != current) &#123;</span><br><span class="line">            <span class="comment">// Optimize for lost race to another addXXX operation</span></span><br><span class="line">            <span class="keyword">int</span> common = Math.min(snapshot.length, len);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; common; i++)</span><br><span class="line">                <span class="keyword">if</span> (current[i] != snapshot[i] &amp;&amp; eq(e, current[i]))</span><br><span class="line">                <span class="comment">//在添加过程中有其它线程插入的元素</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (indexOf(e, current, common, len) &gt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(current, len + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//将当前元素加入到了新数组的最后一个位置</span></span><br><span class="line">        newElements[len] = e; </span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//作用就是在数组中查找是否o已经存在，包括null</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o, Object[] elements,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">int</span> index, <span class="keyword">int</span> fence)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//如果o为空，遍历找到数组中第一个同样为空的位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; fence; i++)</span><br><span class="line">            <span class="keyword">if</span> (elements[i] == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//如果o不为空，则找到与之相等的元素的位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; fence; i++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elements[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//数组中没有该元素，返回-1</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个插入过程：</p><ul><li>调用<code>indexOf</code>方法，查看快照数组中是否已经有该元素了（包括null），如果已经有该元素了，那么返回false，否则进行调用<code>addIfAbsent</code>添加元素</li><li><code>addIfAbsent</code>方法全程加锁。首先将之前的快照与当前数组快照进行比较，如果当前数组快照相较于之前数组快照已经发送了改变，那么说明已经有线程完成了添加，那么当前线程竞争失败，直接返回false（为了避免之前线程更新丢失）。如果没有改变。那么就复制一个长度是原数组长度加一的数组，然后将元素添加到尾部，更新数组。</li></ul><p>通过源码我们可以知道，<code>CopyOnWriteArraySet</code>允许加入null。并且<code>CopyOnWriteArraySet</code>保证元素不重复，就是简简单单的遍历查找一遍。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;&lt;code&gt;CopyOnWriteArrayList&lt;/code&gt;是一个线程安全的&lt;code&gt;ArrayList&lt;/code&gt;，通过内部的&lt;code&gt;volatile&lt;/code&gt;数组和显示锁ReentrantLock来实现线程安全。&lt;code&gt;CopyOnWriteArraySet&lt;/code&gt;的底层也是基于&lt;code&gt;CopyOnWriteArrayList&lt;/code&gt;实现的。&lt;code&gt;CopyOnWriteArrayList&lt;/code&gt;更适合于读多写少的环节。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="源码" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
</feed>
