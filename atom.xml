<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>个人博客</title>
  
  <subtitle>博观而约取 厚积而薄发</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-04-12T12:58:20.090Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>zofun</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JVM之分代收集算法</title>
    <link href="http://yoursite.com/2020/04/12/JVM%E4%B9%8B%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2020/04/12/JVM之分代收集算法/</id>
    <published>2020-04-12T11:52:00.000Z</published>
    <updated>2020-04-12T12:58:20.090Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="对象分类">对象分类</span></h2><p>JVM将对象分成不同的分代，然后根据每个分代的特点采取不同的垃圾回收算法。</p><ul><li>新生代：朝生夕灭的对象，比如方法的局部变量。</li><li>老年代：存活的比较久，但是还是要死的对象。比如缓存对象，单例对象等。</li><li>永久代：对象生成后几乎不灭的对象，例如加载过的类对象。</li></ul><p>永久代是在方法区/元空间。新生代和老年代是在堆区。</p><a id="more"></a><h2><span id="新生代的垃圾回收">新生代的垃圾回收</span></h2><p>新生代采用的是复制算法，因为新生代对象的存活率比价低，因此可以不使用50%的内存作为空闲。一般的，使用两块10%的内存作为空闲和活动空间，而另外80%的内存，则是用来分配给新建的对象的。一旦发生GC，就将10%的活动区间与另外的80%中内存转移到10%的空闲区间中，接下来90%的内存会被释放，以此类推。</p><p><img src="https://s1.ax1x.com/2020/04/11/GHH8fg.png" alt="GHH8fg.png"></p><h3><span id="hotspot实现的复制算法流程">HotSpot实现的复制算法流程</span></h3><ol><li>当Eden区满的时候，会触发第一次Minor gc，把还存活的对象复制到Survivor From区；当Eden区再次触发Minor gc的时候，会扫描Eden 区和Survivor From区，将存活的对象复制到Survivor To区，然后将Eden区和From区清空。</li><li>当后续Eden区又发生了Minor gc的时候，会堆Eden和To区域进行垃圾回收，存活的对象复制到From区域，并将Eden区和To区域清空。</li><li>部分对象会在From和To区域中复制来复制去，如此交换15次（可配置），最终如果还是存活，就存入到老年代。</li></ol><h3><span id="一个对象的内存分配过程">一个对象的内存分配过程</span></h3><p><img src="https://s1.ax1x.com/2020/04/12/GLtsG4.png" alt="GLtsG4.png"></p><h3><span id="什么是空间分配担保机制">什么是空间分配担保机制</span></h3><p>当发生minor gc的时候，JVM会首先检查老年代最大的可用连续空间是否运行大于最大新生代所有对象的总和，如果大于，那么这次YGC是安全的，如果不大于的话，JVM就需要判断HandlerpromotionFailure是否运行空间分配担保。</p><p>新生代采用的是复制算法，S0和S1始终只使用其中一块内存，当出现YGC后大部分的对象仍然存活的话，就需要老年代进行分配担保，把Survior区无法容纳的对象直接晋升到老年代。</p><p>那么这种空间分配担保的前提是老年代还有容纳的空间，一共有多少对象会活下来，再实际完成内存回收之前是无法明确知道的，所以只好取之前每次回收晋升到老年代对象容量的平均值最为经验值，与老年代的剩余空间做比较，决定是否进行Major GC来让老年代腾出更多的空间。</p><h3><span id="新生代收集器">新生代收集器</span></h3><h4><span id="serial收集器">Serial收集器</span></h4><p>它是一个单线程收集器，并且在工作的时候，需要暂停所有的工作线程（STW)，直到它收集结束。</p><p>优点：简单而高效，对于限定单个CPU的环境来说，Serial收集器由于没有线程切换的开销，效率较高。</p><p>缺点：需要停止用户线程。</p><p>适用环境：client模式下的默认新生代收集器。</p><h4><span id="parnew收集器">ParNew收集器</span></h4><p>它其实是Serial收集器的多线程版本，只能在新生代中使用。该收集器的并行度和CPU数量相同。</p><p>适用环境：Server模式下的默认新生代收集器。</p><h4><span id="parallel-scavenge收集器">Parallel Scavenge收集器</span></h4><p>它也是一种并行的新生代垃圾收集器。采用的是复制算法。</p><p>它的特点是可以达成一个可控的吞吐量。</p><h2><span id="老年代">老年代</span></h2><p>老年代一般采用的标记清除算法。标记清除算法可以分为两个步骤：</p><ul><li>标记过程：找到所有的可能访问的对象，做个指定的标记。</li><li>清除过程：遍历堆内存，把未标记的对象进行回收。</li></ul><h3><span id="老年代收集器">老年代收集器</span></h3><h4><span id="serial-old收集器">Serial Old收集器</span></h4><p>它是一个单线程的收集器，采用的标记整理算法，。</p><h4><span id="parallel-old收集器">Parallel Old收集器</span></h4><p>Pareller Old收集器的老年代版本，使用多线程和“标记-整理”算法。</p><p>在注重吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge加Paralllel Old收集器。</p><h4><span id="cms收集器">CMS收集器</span></h4><p>CMS是老年代收集器，在收集过程中可以与用户线程并发操作。CMS牺牲了系统的吞吐量来追求收集速度，适合追求垃圾收集速度的服务器上。</p><p>CMS处理过程有七个步骤：</p><ul><li>初始标记，会导致STW</li><li>并发标记，与用户线程同时运行</li><li>预清理，与用户线程同时运行</li><li>可被终止的预清理，与用户线程同时运行</li><li>重新标记，会导致STW</li><li>并发清除，与用户线程同时运行</li><li>并发重置状态等待下次CMS的触发，与用户线程同时运行。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;对象分类&quot;&gt;&lt;a href=&quot;#对象分类&quot; class=&quot;headerlink&quot; title=&quot;对象分类&quot;&gt;&lt;/a&gt;对象分类&lt;/h2&gt;&lt;p&gt;JVM将对象分成不同的分代，然后根据每个分代的特点采取不同的垃圾回收算法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;新生代：朝生夕灭的对象，比如方法的局部变量。&lt;/li&gt;
&lt;li&gt;老年代：存活的比较久，但是还是要死的对象。比如缓存对象，单例对象等。&lt;/li&gt;
&lt;li&gt;永久代：对象生成后几乎不灭的对象，例如加载过的类对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;永久代是在方法区/元空间。新生代和老年代是在堆区。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>并发编程之volatile</title>
    <link href="http://yoursite.com/2020/04/10/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8Bvolatile/"/>
    <id>http://yoursite.com/2020/04/10/并发编程之volatile/</id>
    <published>2020-04-10T11:52:00.000Z</published>
    <updated>2020-04-10T11:52:36.541Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="volatile的定义和实现原理">volatile的定义和实现原理</span></h2><p>在Java语言规范中将volatile定义如下：Java编程语言允许线程访问共享变量，为了确保共享变量能被准确和一致的更新，线程应该通过排他锁单独获得这个变量。Java语言提供了volatile，在某型情况下比使用锁更加方便。如果一个字段被声明为volatile，Java线程内存模型确保所有线程看到这个变量的值是一致的。</p><a id="more"></a><p>当我们对有volatile修饰的变量进行写操作的时候，会在下一行汇编加一个<code>Lock</code>指令。</p><p><code>Lock</code>前缀的指令在多核处理器下会引起两件事情；</p><ol><li>将当前处理器缓存行写回到系统内存</li><li>这个写回的操作会使其它CPU里缓存了该内存地址的数据无效。</li></ol><h2><span id="volatile的内存语义">volatile的内存语义</span></h2><p><strong>锁的happens-before规则保证释放锁和获取锁的两个线程之间的内存可见性</strong>，这意味着对一个volatile变量的读，总是能看到对这个volatile变量最后的写入。</p><p><strong>锁的语义决定了临界区代码的执行具有原子性。</strong>这意味着，即使使64位的long型和double型变量，只要它使volatile变量，最该变量的读/写具有原子性。</p><p>volatile变量自身具有以下特性：</p><ul><li>可见性。对一个volatile变量的读，总是能看到对这个volatile变量最后的写入。</li><li>原子性：对任意单个volatile变量的读/写具有原子性，当类似于volatile++这种复合操作不具有原子性。</li></ul><p><strong>volatile写的内存语义</strong>如下：</p><ul><li>当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存。</li></ul><p><strong>volatile读的内存语义</strong>如下：</p><ul><li>当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效。</li></ul><h3><span id="volatile内存语义的实现">volatile内存语义的实现</span></h3><p>为了实现volatile内存语义，JMM会分别限制这两种类型的重排序。为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。</p><ul><li>在每个volatile写操作之前插入一个StoreStore屏障</li><li>在每个volatile写操作的后面插入一个StoreLoad屏障</li><li>在每个volatile读操作的后面插入一个LoadLoad屏障</li><li>在每个volatile读操作的后面插入一个LoadStore屏障。</li></ul><h2><span id="volatile的使用优化">volatile的使用优化</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 队列中的头部节点 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> f?inal PaddedAtomicReference&lt;QNode&gt; head;</span><br><span class="line"><span class="comment">/** 队列中的尾部节点 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> f?inal PaddedAtomicReference&lt;QNode&gt; tail;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PaddedAtomicReference</span> &lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AtomicReference</span> <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"><span class="comment">// 使用很多4个字节的引用追加到64个字节</span></span><br><span class="line">Object p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, pa, pb, pc, pd, pe;</span><br><span class="line">PaddedAtomicReference(T r) &#123;</span><br><span class="line"><span class="keyword">super</span>(r);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicReference</span> &lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> V value;</span><br><span class="line"><span class="comment">// 省略其他代码</span></span><br><span class="line">｝</span><br></pre></td></tr></table></figure><p>在上面这段代码中，通过追加字节来优化系统的性能。这是因为在目前多少的CPU中，缓存行的宽度为64字节，如果队列头节点和尾节点都不足64字节的话，那么处理器就会将头接点和尾节点读入同一个缓存行中，当一个处理器试图修改头节点的时候，将会把整个缓存行锁定，在缓存一致性的机制的作用下，会导致其它处理器不能访问自己高速缓存中的尾节点。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;volatile的定义和实现原理&quot;&gt;&lt;a href=&quot;#volatile的定义和实现原理&quot; class=&quot;headerlink&quot; title=&quot;volatile的定义和实现原理&quot;&gt;&lt;/a&gt;volatile的定义和实现原理&lt;/h2&gt;&lt;p&gt;在Java语言规范中将volatile定义如下：Java编程语言允许线程访问共享变量，为了确保共享变量能被准确和一致的更新，线程应该通过排他锁单独获得这个变量。Java语言提供了volatile，在某型情况下比使用锁更加方便。如果一个字段被声明为volatile，Java线程内存模型确保所有线程看到这个变量的值是一致的。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>多线程之连续打印ABC</title>
    <link href="http://yoursite.com/2020/04/07/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E8%BF%9E%E7%BB%AD%E6%89%93%E5%8D%B0ABC/"/>
    <id>http://yoursite.com/2020/04/07/多线程之连续打印ABC/</id>
    <published>2020-04-07T02:50:00.000Z</published>
    <updated>2020-04-07T02:50:10.239Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="题目">题目</span></h2><p>实例化三个线程，一个线程打印a，一个线程打印b，一个线程打印c，三个线程同时执行，要求打印出10个连着的abc。</p><p>问题为三线程间的同步唤醒操作，主要的目的就是使程序按ThreadA-&gt;ThreadB-&gt;ThreadC-&gt;ThreadA循环执行三个线程</p><a id="more"></a><h3><span id="使用两个锁来实现">使用两个锁来实现</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RcSyncPrinter</span>  </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Printer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Object preLock;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Object lock;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> printChar;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Printer</span><span class="params">(Object preLock, Object lock, <span class="keyword">char</span> printChar)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.preLock = preLock;</span><br><span class="line">            <span class="keyword">this</span>.lock = lock;</span><br><span class="line">            <span class="keyword">this</span>.printChar = printChar;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (preLock)&#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">                        System.out.println(printChar);</span><br><span class="line">                        lock.notifyAll();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(i &lt; <span class="number">10</span> - <span class="number">1</span>)&#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="comment">// 通过preLock等待被唤醒</span></span><br><span class="line">                            preLock.wait();</span><br><span class="line"></span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Object lockA = <span class="keyword">new</span> Object();</span><br><span class="line">        <span class="keyword">final</span> Object lockB = <span class="keyword">new</span> Object();</span><br><span class="line">        <span class="keyword">final</span> Object lockC = <span class="keyword">new</span> Object();</span><br><span class="line">        Printer printerA = <span class="keyword">new</span> Printer(lockC, lockA,  <span class="string">'A'</span>);</span><br><span class="line">        Printer printerB = <span class="keyword">new</span> Printer(lockA, lockB, <span class="string">'B'</span>);</span><br><span class="line">        Printer printerC = <span class="keyword">new</span> Printer(lockB, lockC, <span class="string">'C'</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(printerA).start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(printerB).start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(printerC).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> RcSyncPrinter syncPrinter = <span class="keyword">new</span> RcSyncPrinter();</span><br><span class="line">        syncPrinter.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="使用一个锁和状态变量实现推荐写法">使用一个锁和状态变量实现(推荐写法)</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RcSyncPrinter</span>  </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//状态变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Printer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//打印锁</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Object lock;</span><br><span class="line">        <span class="comment">//打印状态</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> printState;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> nextPrintState;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> printChar;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Printer</span><span class="params">(Object lock, <span class="keyword">int</span> printState, <span class="keyword">int</span> nextPrintState, <span class="keyword">char</span> printChar)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.lock = lock;</span><br><span class="line">            <span class="keyword">this</span>.printState = printState;</span><br><span class="line">            <span class="keyword">this</span>.nextPrintState = nextPrintState;</span><br><span class="line">            <span class="keyword">this</span>.printChar = printChar;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">                    <span class="keyword">while</span> (state!=printState)&#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            lock.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(printChar);</span><br><span class="line">                    state=nextPrintState;</span><br><span class="line">                    lock.notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">        Printer printerA = <span class="keyword">new</span> Printer(lock, <span class="number">1</span>, <span class="number">2</span>, <span class="string">'A'</span>);</span><br><span class="line">        Printer printerB = <span class="keyword">new</span> Printer(lock, <span class="number">2</span>, <span class="number">3</span>, <span class="string">'B'</span>);</span><br><span class="line">        Printer printerC = <span class="keyword">new</span> Printer(lock, <span class="number">3</span>, <span class="number">1</span>, <span class="string">'C'</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(printerA).start();</span><br><span class="line">        <span class="comment">//Thread.sleep(1000);</span></span><br><span class="line">        <span class="keyword">new</span> Thread(printerB).start();</span><br><span class="line">        <span class="comment">//Thread.sleep(1000);</span></span><br><span class="line">        <span class="keyword">new</span> Thread(printerC).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> RcSyncPrinter syncPrinter = <span class="keyword">new</span> RcSyncPrinter();</span><br><span class="line">        syncPrinter.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="通过一个reentrantlock和三个conditon实现推荐">通过一个ReentrantLock和三个conditon实现(推荐)</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RcSyncPrinter</span>  </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Printer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">private</span> ReentrantLock lock;</span><br><span class="line">       <span class="keyword">private</span> Condition thisCondition;</span><br><span class="line">       <span class="keyword">private</span> Condition  nextCondition;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> printChar;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Printer</span><span class="params">(ReentrantLock lock, Condition thisCondition, Condition nextCondition, <span class="keyword">char</span> printChar)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.lock = lock;</span><br><span class="line">            <span class="keyword">this</span>.thisCondition = thisCondition;</span><br><span class="line">            <span class="keyword">this</span>.nextCondition = nextCondition;</span><br><span class="line">            <span class="keyword">this</span>.printChar = printChar;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                    System.out.println(printChar);</span><br><span class="line">                    nextCondition.signalAll();</span><br><span class="line">                    <span class="keyword">if</span> (i &lt; <span class="number">9</span>) &#123;</span><br><span class="line">                        thisCondition.await();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        <span class="keyword">final</span> Condition conditionA = lock.newCondition();</span><br><span class="line">        <span class="keyword">final</span> Condition conditionB = lock.newCondition();</span><br><span class="line">        <span class="keyword">final</span> Condition conditionC = lock.newCondition();</span><br><span class="line">        <span class="keyword">final</span> Object lockA = <span class="keyword">new</span> Object();</span><br><span class="line">        <span class="keyword">final</span> Object lockB = <span class="keyword">new</span> Object();</span><br><span class="line">        <span class="keyword">final</span> Object lockC = <span class="keyword">new</span> Object();</span><br><span class="line">        Printer printerA = <span class="keyword">new</span> Printer(lock, conditionA,conditionB,<span class="string">'A'</span>);</span><br><span class="line">        Printer printerB = <span class="keyword">new</span> Printer(lock, conditionB, conditionC,<span class="string">'B'</span>);</span><br><span class="line">        Printer printerC = <span class="keyword">new</span> Printer(lock, conditionC, conditionA,<span class="string">'C'</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(printerA).start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(printerB).start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(printerC).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> RcSyncPrinter syncPrinter = <span class="keyword">new</span> RcSyncPrinter();</span><br><span class="line">        syncPrinter.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;实例化三个线程，一个线程打印a，一个线程打印b，一个线程打印c，三个线程同时执行，要求打印出10个连着的abc。&lt;/p&gt;
&lt;p&gt;问题为三线程间的同步唤醒操作，主要的目的就是使程序按ThreadA-&amp;gt;ThreadB-&amp;gt;ThreadC-&amp;gt;ThreadA循环执行三个线程&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>算法之DFS</title>
    <link href="http://yoursite.com/2020/04/05/%E7%AE%97%E6%B3%95%E4%B9%8BDFS/"/>
    <id>http://yoursite.com/2020/04/05/算法之DFS/</id>
    <published>2020-04-05T12:06:00.000Z</published>
    <updated>2020-04-05T12:07:03.122Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="dfs">DFS</span></h2><p>深度优先搜索是在得到一个新节点时立即堆新节点进行遍历。DFS常用来求解这种可达性问题。</p><p>在实现DFS时需要考虑以下两个问题：</p><ul><li>栈，使用栈来保存当前节点信息，当遍历新节点返回时能够继续遍历当前节点。可以使用递归栈。</li><li>标记：需要记录那些节点已经遍历过了。</li></ul><h3><span id="695-岛屿的最大面积">695. 岛屿的最大面积</span></h3><p>给定一个包含了一些 0 和 1 的非空二维数组 grid 。</p><p>一个 岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在水平或者竖直方向上相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。</p><p>找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为 0 。)</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[[0,0,1,0,0,0,0,1,0,0,0,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,1,1,1,0,0,0],</span><br><span class="line"> [0,1,1,0,1,0,0,0,0,0,0,0,0],</span><br><span class="line"> [0,1,0,0,1,1,0,0,1,0,1,0,0],</span><br><span class="line"> [0,1,0,0,1,1,0,0,1,1,1,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,0,0,0,1,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,1,1,1,0,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,1,1,0,0,0,0]]</span><br></pre></td></tr></table></figure><p>对于上面这个给定矩阵应返回 6。注意答案不应该是 11 ，因为岛屿只能包含水平或垂直的四个方向的 1 。</p><h4><span id="解法">解法</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[][] direction=&#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">  <span class="keyword">int</span> m,n;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(grid.length==<span class="number">0</span>||grid[<span class="number">0</span>].length==<span class="number">0</span>)&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      m=grid.length;</span><br><span class="line">      n=grid[<span class="number">0</span>].length;</span><br><span class="line">      <span class="keyword">int</span> maxArea=<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">              maxArea=Math.max(maxArea,dfs(grid,i,j));</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> maxArea;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] grid,<span class="keyword">int</span> r,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(r&lt;<span class="number">0</span>||r&gt;m||c&lt;<span class="number">0</span>||c&gt;n||grid[r][c]==<span class="number">0</span>)&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">int</span> area=<span class="number">1</span>; <span class="comment">//（r，c）为陆地</span></span><br><span class="line">      grid[r][c]=<span class="number">0</span>;<span class="comment">//标记为已经遍历</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span>[] d : direction) &#123;</span><br><span class="line">        area+=dfs(grid, r+d[<span class="number">0</span>], c+d[<span class="number">1</span>]);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> area;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/max-area-of-island/" target="_blank" rel="noopener">leetcode原题地址</a></p><a id="more"></a><h3><span id="200-岛屿的数量">200. 岛屿的数量</span></h3><p>给定一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">11000</span><br><span class="line">11000</span><br><span class="line">00100</span><br><span class="line">00011</span><br><span class="line"></span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/number-of-islands/" target="_blank" rel="noopener">leetcode原题地址</a></p><h4><span id="解法">解法</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[][] direction=&#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">  <span class="keyword">int</span> m,n;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(grid.length==<span class="number">0</span>||grid[<span class="number">0</span>].length==<span class="number">0</span>)&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      m=grid.length;</span><br><span class="line">      n=grid[<span class="number">0</span>].length;</span><br><span class="line">      <span class="keyword">int</span> isLand=<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">              <span class="keyword">if</span> (grid[i][j]!=<span class="string">'0'</span>)&#123;</span><br><span class="line">                  dfs(grid,i,j);</span><br><span class="line">              &#125;</span><br><span class="line">              isLand++;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> isLand;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] grid,<span class="keyword">int</span> r,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(r&lt;<span class="number">0</span>||r&gt;=m||c&lt;<span class="number">0</span>||c&gt;=n||grid[r][c]==<span class="string">'0'</span>)&#123;</span><br><span class="line">          <span class="keyword">return</span> ;</span><br><span class="line">      &#125;</span><br><span class="line">      grid[r][c]=<span class="string">'0'</span>;<span class="comment">//标记为已经遍历</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span>[] d : direction) &#123;</span><br><span class="line">        dfs(grid, r+d[<span class="number">0</span>], c+d[<span class="number">1</span>]);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3><span id="朋友圈">朋友圈</span></h3><p>班上有 N 名学生。其中有些人是朋友，有些则不是。他们的友谊具有是传递性。如果已知 A 是 B 的朋友，B 是 C 的朋友，那么我们可以认为 A 也是 C 的朋友。所谓的朋友圈，是指所有朋友的集合。</p><p>给定一个 N * N 的矩阵 M，表示班级中学生之间的朋友关系。如果M[i][j] = 1，表示已知第 i 个和 j 个学生互为朋友关系，否则为不知道。你必须输出所有学生中的已知的朋友圈总数。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">[[1,1,0],</span><br><span class="line"> [1,1,0],</span><br><span class="line"> [0,0,1]]</span><br><span class="line">输出: 2 </span><br><span class="line">说明：已知学生0和学生1互为朋友，他们在一个朋友圈。</span><br><span class="line">第2个学生自己在一个朋友圈。所以返回2.</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/friend-circles/" target="_blank" rel="noopener">leetcode原题地址</a></p><h4><span id="解法">解法</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="keyword">int</span>[][] M)</span> </span>&#123;</span><br><span class="line">    n=M.length;</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span>[] hasVisited=<span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!hasVisited[i])&#123;</span><br><span class="line">            dfs(M,hasVisited,i);</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] arr,<span class="keyword">boolean</span>[] hasVisited,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    hasVisited[i]=<span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;n;k++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i][k]==<span class="number">1</span>&amp;&amp;!hasVisited[k])&#123;</span><br><span class="line"></span><br><span class="line">            dfs(arr,hasVisited,k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="130-被围绕的区域">130. 被围绕的区域</span></h3><p>给定一个二维的矩阵，包含 ‘X’ 和 ‘O’（字母 O）。</p><p>找到所有被 ‘X’ 围绕的区域，并将这些区域里所有的 ‘O’ 用 ‘X’ 填充。</p><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X X X X</span><br><span class="line">X O O X</span><br><span class="line">X X O X</span><br><span class="line">X O X X</span><br></pre></td></tr></table></figure><p>运行你的函数后，矩阵变为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X X X X</span><br><span class="line">X X X X</span><br><span class="line">X X X X</span><br><span class="line">X O X X</span><br></pre></td></tr></table></figure><p>解释:</p><p>被围绕的区间不会存在于边界上，换句话说，任何边界上的 ‘O’ 都不会被填充为 ‘X’。 任何不在边界上，或不与边界上的 ‘O’ 相连的 ‘O’ 最终都会被填充为 ‘X’。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。</p><p><a href="https://leetcode-cn.com/problems/surrounded-regions/" target="_blank" rel="noopener">leetcode原题地址</a></p><h4><span id="解法">解法</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> m;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span>[][] direction=&#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (board == <span class="keyword">null</span> || board.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        m = board.length;</span><br><span class="line">        n = board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            dfs(board, i, <span class="number">0</span>);</span><br><span class="line">            dfs(board, i, n - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dfs(board, <span class="number">0</span>, i);</span><br><span class="line">            dfs(board, m - <span class="number">1</span>, i);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">'T'</span>) &#123;</span><br><span class="line">                    board[i][j] = <span class="string">'O'</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (board[i][j] == <span class="string">'O'</span>) &#123;</span><br><span class="line">                    board[i][j] = <span class="string">'X'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (r &lt; <span class="number">0</span> || r &gt;= m || c &lt; <span class="number">0</span> || c &gt;= n || board[r][c] != <span class="string">'O'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;board[r][c] = <span class="string">'T'</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] d : direction) &#123;</span><br><span class="line">            dfs(board, r + d[<span class="number">0</span>], c + d[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3><span id="417-太平洋大西洋水流问题">417. 太平洋大西洋水流问题</span></h3><p>给定一个 m x n 的非负整数矩阵来表示一片大陆上各个单元格的高度。“太平洋”处于大陆的左边界和上边界，而“大西洋”处于大陆的右边界和下边界。</p><p>规定水流只能按照上、下、左、右四个方向流动，且只能从高到低或者在同等高度上流动。</p><p>请找出那些水流既可以流动到“太平洋”，又能流动到“大西洋”的陆地单元的坐标。</p><p>提示：</p><pre><code>输出坐标的顺序不重要m 和 n 都小于150</code></pre><p>示例：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">给定下面的 5x5 矩阵:</span><br><span class="line"></span><br><span class="line">  太平洋 ~   ~   ~   ~   ~ </span><br><span class="line">       ~  1   2   2   3  (5) *</span><br><span class="line">       ~  3   2   3  (4) (4) *</span><br><span class="line">       ~  2   4  (5)  3   1  *</span><br><span class="line">       ~ (6) (7)  1   4   5  *</span><br><span class="line">       ~ (5)  1   1   2   4  *</span><br><span class="line">          *   *   *   *   * 大西洋</span><br><span class="line"></span><br><span class="line">返回:</span><br><span class="line"></span><br><span class="line">[[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] (上图中带括号的单元).</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/pacific-atlantic-water-flow/" target="_blank" rel="noopener">leetcode原题地址</a></p><h4><span id="解法">解法</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> m, n;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[][] matrix;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[][] direction = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pacificAtlantic(<span class="keyword">int</span>[][] matrix) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ret = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    m = matrix.length;</span><br><span class="line">    n = matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">this</span>.matrix = matrix;</span><br><span class="line">    <span class="keyword">boolean</span>[][] canReachP = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">    <span class="keyword">boolean</span>[][] canReachA = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        dfs(i, <span class="number">0</span>, canReachP);</span><br><span class="line">        dfs(i, n - <span class="number">1</span>, canReachA);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        dfs(<span class="number">0</span>, i, canReachP);</span><br><span class="line">        dfs(m - <span class="number">1</span>, i, canReachA);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (canReachP[i][j] &amp;&amp; canReachA[i][j]) &#123;</span><br><span class="line">                ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                list.add(i);</span><br><span class="line">                list.add(j);</span><br><span class="line">                ret.add(list);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> c, <span class="keyword">boolean</span>[][] canReach)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (canReach[r][c]) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    canReach[r][c] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] d : direction) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextR = d[<span class="number">0</span>] + r;</span><br><span class="line">        <span class="keyword">int</span> nextC = d[<span class="number">1</span>] + c;</span><br><span class="line">        <span class="keyword">if</span> (nextR &lt; <span class="number">0</span> || nextR &gt;= m || nextC &lt; <span class="number">0</span> || nextC &gt;= n</span><br><span class="line">                || matrix[r][c] &gt; matrix[nextR][nextC]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(nextR, nextC, canReach);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;DFS&quot;&gt;&lt;a href=&quot;#DFS&quot; class=&quot;headerlink&quot; title=&quot;DFS&quot;&gt;&lt;/a&gt;DFS&lt;/h2&gt;&lt;p&gt;深度优先搜索是在得到一个新节点时立即堆新节点进行遍历。DFS常用来求解这种可达性问题。&lt;/p&gt;
&lt;p&gt;在实现DFS时需要考虑以下两个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;栈，使用栈来保存当前节点信息，当遍历新节点返回时能够继续遍历当前节点。可以使用递归栈。&lt;/li&gt;
&lt;li&gt;标记：需要记录那些节点已经遍历过了。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;695-岛屿的最大面积&quot;&gt;&lt;a href=&quot;#695-岛屿的最大面积&quot; class=&quot;headerlink&quot; title=&quot;695. 岛屿的最大面积&quot;&gt;&lt;/a&gt;695. 岛屿的最大面积&lt;/h3&gt;&lt;p&gt;给定一个包含了一些 0 和 1 的非空二维数组 grid 。&lt;/p&gt;
&lt;p&gt;一个 岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在水平或者竖直方向上相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。&lt;/p&gt;
&lt;p&gt;找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为 0 。)&lt;/p&gt;
&lt;p&gt;示例 1:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[[0,0,1,0,0,0,0,1,0,0,0,0,0],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; [0,0,0,0,0,0,0,1,1,1,0,0,0],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; [0,1,1,0,1,0,0,0,0,0,0,0,0],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; [0,1,0,0,1,1,0,0,1,0,1,0,0],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; [0,1,0,0,1,1,0,0,1,1,1,0,0],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; [0,0,0,0,0,0,0,0,0,0,1,0,0],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; [0,0,0,0,0,0,0,1,1,1,0,0,0],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; [0,0,0,0,0,0,0,1,1,0,0,0,0]]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;对于上面这个给定矩阵应返回 6。注意答案不应该是 11 ，因为岛屿只能包含水平或垂直的四个方向的 1 。&lt;/p&gt;
&lt;h4 id=&quot;解法&quot;&gt;&lt;a href=&quot;#解法&quot; class=&quot;headerlink&quot; title=&quot;解法&quot;&gt;&lt;/a&gt;解法&lt;/h4&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[][] direction=&amp;#123;&amp;#123;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&amp;#125;,&amp;#123;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&amp;#125;,&amp;#123;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&amp;#125;,&amp;#123;-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&amp;#125;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; m,n;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;maxAreaOfIsland&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[][] grid)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(grid.length==&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;||grid[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;].length==&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      m=grid.length;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      n=grid[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;].length;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; maxArea=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;i&amp;lt;m;i++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;j&amp;lt;n;j++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              maxArea=Math.max(maxArea,dfs(grid,i,j));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; maxArea;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;dfs&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[][] grid,&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; r,&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; c)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(r&amp;lt;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;||r&amp;gt;m||c&amp;lt;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;||c&amp;gt;n||grid[r][c]==&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; area=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;//（r，c）为陆地&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      grid[r][c]=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;//标记为已经遍历&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[] d : direction) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        area+=dfs(grid, r+d[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;], c+d[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; area;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/max-area-of-island/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;leetcode原题地址&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法之栈和队列</title>
    <link href="http://yoursite.com/2020/04/04/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    <id>http://yoursite.com/2020/04/04/算法之栈和队列/</id>
    <published>2020-04-04T13:29:00.000Z</published>
    <updated>2020-04-04T12:53:26.089Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="栈和队列">栈和队列</span></h2><h3><span id="232用栈实现队列">232.用栈实现队列</span></h3><p>使用栈实现队列的下列操作：</p><pre><code>push(x) -- 将一个元素放入队列的尾部。pop() -- 从队列首部移除元素。peek() -- 返回队列首部的元素。empty() -- 返回队列是否为空。</code></pre><p>示例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MyQueue queue = <span class="keyword">new</span> MyQueue();</span><br><span class="line"></span><br><span class="line">queue.push(<span class="number">1</span>);</span><br><span class="line">queue.push(<span class="number">2</span>);  </span><br><span class="line">queue.peek();  <span class="comment">// 返回 1</span></span><br><span class="line">queue.pop();   <span class="comment">// 返回 1</span></span><br><span class="line">queue.empty(); <span class="comment">// 返回 false</span></span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/implement-queue-using-stacks/" target="_blank" rel="noopener">leetcode原题地址</a></p><a id="more"></a><h4><span id="解法">解法</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; in;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; out;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Initialize your data structure here.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            in=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">            out=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Push element x to the back of queue.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        in.push(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Removes the element from in front of queue and returns that element.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(out.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span> (!in.isEmpty())&#123;</span><br><span class="line">                out.push(in.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> out.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get the front element.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(out.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span> (!in.isEmpty())&#123;</span><br><span class="line">                out.push(in.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> out.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns whether the queue is empty.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> in.isEmpty()&amp;&amp;out.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="225-用队列实现栈">225. 用队列实现栈</span></h3><p>使用队列实现栈的下列操作：</p><pre><code>push(x) -- 元素 x 入栈pop() -- 移除栈顶元素top() -- 获取栈顶元素empty() -- 返回栈是否为空</code></pre><p>注意:</p><pre><code>你只能使用队列的基本操作-- 也就是 push to back, peek/pop from front, size, 和 is empty 这些操作是合法的。你所使用的语言也许不支持队列。 你可以使用 list 或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。你可以假设所有操作都是有效的（例如, 对一个空的栈不会调用 pop 或者 top 操作）。</code></pre><p><a href="https://leetcode-cn.com/problems/implement-stack-using-queues/" target="_blank" rel="noopener">leetcode原题地址</a></p><h4><span id="解法">解法</span></h4><p>在将一个元素 x 插入队列时，为了维护原来的后进先出顺序，需要让 x 插入队列首部。而队列的默认插入顺序是队列<br>尾部，因此在将 x 插入队列尾部之后，需要让除了 x 之外的所有元素出队列，再入队列。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Queue&lt;Integer&gt; queue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        queue=<span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Push element x onto stack. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        queue.add(x);</span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size-<span class="number">1</span>;i++ )&#123;</span><br><span class="line">            queue.add(queue.poll());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Removes the element on top of the stack and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> queue.poll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Get the top element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> queue.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns whether the stack is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> queue.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="155-最小栈">155. 最小栈</span></h3><p>设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。</p><pre><code>push(x) -- 将元素 x 推入栈中。pop() -- 删除栈顶的元素。top() -- 获取栈顶元素。getMin() -- 检索栈中的最小元素。</code></pre><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MinStack minStack = new MinStack();</span><br><span class="line">minStack.push(-2);</span><br><span class="line">minStack.push(0);</span><br><span class="line">minStack.push(-3);</span><br><span class="line">minStack.getMin();   --&gt; 返回 -3.</span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();      --&gt; 返回 0.</span><br><span class="line">minStack.getMin();   --&gt; 返回 -2.</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/min-stack/" target="_blank" rel="noopener">leetcode原题地址</a></p><h4><span id="解法">解法</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stack;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; minStack;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> min;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        minStack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        min=Integer.MAX_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        stack.push(x);</span><br><span class="line">        min=Math.min(min,x);</span><br><span class="line">        minStack.push(min);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        minStack.pop();</span><br><span class="line">        stack.pop();</span><br><span class="line">        min=minStack.isEmpty()?Integer.MAX_VALUE:minStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="20-有效的括号">20. 有效的括号</span></h3><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</p><p>有效字符串需满足：</p><pre><code>左括号必须用相同类型的右括号闭合。左括号必须以正确的顺序闭合。</code></pre><p>注意空字符串可被认为是有效字符串。</p><p><a href="https://leetcode-cn.com/problems/valid-parentheses/" target="_blank" rel="noopener">leetcode原题地址</a></p><h4><span id="解法">解法</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">       </span><br><span class="line">       Stack&lt;Character&gt; stack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;chars.length;i++)&#123;</span><br><span class="line">           <span class="keyword">char</span> ch=chars[i];</span><br><span class="line">           <span class="keyword">if</span>(ch==<span class="string">'('</span>||ch==<span class="string">'&#123;'</span>||ch==<span class="string">'['</span>)&#123;</span><br><span class="line">               stack.push(ch);</span><br><span class="line">           &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">if</span>(stack.isEmpty())&#123;</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">char</span> cStack = stack.pop();</span><br><span class="line">               <span class="keyword">boolean</span> b1 = ch == <span class="string">')'</span> &amp;&amp; cStack != <span class="string">'('</span>;</span><br><span class="line">               <span class="keyword">boolean</span> b2 = ch == <span class="string">']'</span> &amp;&amp; cStack != <span class="string">'['</span>;</span><br><span class="line">               <span class="keyword">boolean</span> b3 = ch == <span class="string">'&#125;'</span> &amp;&amp; cStack != <span class="string">'&#123;'</span>;</span><br><span class="line">               <span class="keyword">if</span> (b1 || b2 || b3) &#123;</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3><span id="739-每日温度">739. 每日温度</span></h3><p>根据每日 气温 列表，请重新生成一个列表，对应位置的输出是需要再等待多久温度才会升高超过该日的天数。如果之后都不会升高，请在该位置用 0 来代替。</p><p>例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。</p><p>提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。</p><p><a href="https://leetcode-cn.com/problems/daily-temperatures/" target="_blank" rel="noopener">leetcode原题地址</a></p><h4><span id="解法">解法</span></h4><p>在遍历数组时用栈把数组中的数存起来，如果当前遍历的数比栈顶元素来的大，说明栈顶元素的下一个比它大的数就是当前元素。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] dailyTemperatures(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line">    Stack&lt;Integer&gt; indexs=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] result=<span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span> (!indexs.isEmpty()&amp;&amp;arr[i]&gt;arr[indexs.peek()])&#123;</span><br><span class="line">            <span class="keyword">int</span> preIndex=indexs.pop();</span><br><span class="line">            result[preIndex]=i-preIndex;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        indexs.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="503-下一个更大的元素ii">503. 下一个更大的元素Ⅱ</span></h3><p>给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,1]</span><br><span class="line">输出: [2,-1,2]</span><br><span class="line">解释: 第一个 1 的下一个更大的数是 2；</span><br><span class="line">数字 2 找不到下一个更大的数； </span><br><span class="line">第二个 1 的下一个最大的数需要循环搜索，结果也是 2。</span><br></pre></td></tr></table></figure><p>注意: 输入数组的长度不会超过 10000。</p><p><a href="https://leetcode-cn.com/problems/next-greater-element-ii/" target="_blank" rel="noopener">leetcode原题地址</a></p><h4><span id="解法">解法</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] nextGreaterElements(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] result=<span class="keyword">new</span>  <span class="keyword">int</span>[nums.length];</span><br><span class="line">    Arrays.fill(result,-<span class="number">1</span>);</span><br><span class="line">    Stack&lt;Integer&gt; stack=<span class="keyword">new</span> Stack();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length*<span class="number">2</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> num=nums[i%nums.length];</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()&amp;&amp;num&gt;nums[stack.peek()])&#123;</span><br><span class="line">            result[stack.pop()]=num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i&lt;nums.length)&#123;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;栈和队列&quot;&gt;&lt;a href=&quot;#栈和队列&quot; class=&quot;headerlink&quot; title=&quot;栈和队列&quot;&gt;&lt;/a&gt;栈和队列&lt;/h2&gt;&lt;h3 id=&quot;232-用栈实现队列&quot;&gt;&lt;a href=&quot;#232-用栈实现队列&quot; class=&quot;headerlink&quot; title=&quot;232.用栈实现队列&quot;&gt;&lt;/a&gt;232.用栈实现队列&lt;/h3&gt;&lt;p&gt;使用栈实现队列的下列操作：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;push(x) -- 将一个元素放入队列的尾部。
pop() -- 从队列首部移除元素。
peek() -- 返回队列首部的元素。
empty() -- 返回队列是否为空。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;示例:&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;MyQueue queue = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; MyQueue();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;queue.push(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;queue.push(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;queue.peek();  &lt;span class=&quot;comment&quot;&gt;// 返回 1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;queue.pop();   &lt;span class=&quot;comment&quot;&gt;// 返回 1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;queue.empty(); &lt;span class=&quot;comment&quot;&gt;// 返回 false&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/implement-queue-using-stacks/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;leetcode原题地址&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法之链表</title>
    <link href="http://yoursite.com/2020/04/03/%E7%AE%97%E6%B3%95%E4%B9%8B%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2020/04/03/算法之链表/</id>
    <published>2020-04-03T13:29:00.000Z</published>
    <updated>2020-04-03T13:29:08.270Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="链表">链表</span></h2><h3><span id="160-相交链表">160. 相交链表</span></h3><p>编写一个程序，找到两个单链表相交的起始节点。</p><p><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/" target="_blank" rel="noopener">leetcode原题地址</a></p><h4><span id="解法">解法</span></h4><p>设 A 的长度为 a + c，B 的长度为 b + c，其中 c 为尾部公共部分长度，可知 a + c + b = b + c + a。<br>当访问 A 链表的指针访问到链表尾部时，令它从链表 B 的头部开始访问链表 B；同样地，当访问 B 链表的指针访问<br>到链表尾部时，令它从链表 A 的头部开始访问链表 A。这样就能控制访问 A 和 B 两个链表的指针能同时访问到交<br>点  .</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这道题的意思是必定有相交的</span></span><br><span class="line">    ListNode curA=headA;</span><br><span class="line">    ListNode curB=headB;</span><br><span class="line">    <span class="keyword">while</span> (curA!=curB)&#123;</span><br><span class="line">        curA=(curA==<span class="keyword">null</span>)?headB:curA.next;</span><br><span class="line">        curB=(curB==<span class="keyword">null</span>)?headA:curB.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> curA;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h3><span id="206-反转链表">206. 反转链表</span></h3><p>反转一个单链表。</p><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure><p>进阶:<br>你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</p><p><a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener">leetcode原题地址</a></p><h4><span id="解法">解法</span></h4><ol><li>递归解法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="keyword">null</span>||head.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode next=head.next;</span><br><span class="line">    <span class="comment">//反转 1-&gt;2-&gt;3 就可以看成 反转（2-&gt;3）+1</span></span><br><span class="line">    ListNode node = reverseList(head.next);</span><br><span class="line">    <span class="comment">//next.next就是反转后的链表的尾节点</span></span><br><span class="line">    next.next=head;</span><br><span class="line">    <span class="comment">//head是两个链表合并后的最后一个节点，因此heae.next需要设置尾null</span></span><br><span class="line">    head.next=<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>头插法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">      ListNode tmpHead=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">while</span> (head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">          ListNode next=head.next;</span><br><span class="line">          head.next=tmpHead.next;</span><br><span class="line">          tmpHead.next=head;</span><br><span class="line">          head=next;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>  tmpHead.next;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>直接反转法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">     ListNode pre=<span class="keyword">null</span>;</span><br><span class="line">     ListNode cur=head;</span><br><span class="line">     ListNode next=<span class="keyword">null</span>;</span><br><span class="line">     <span class="keyword">while</span> (cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">         next=cur.next;</span><br><span class="line">         <span class="comment">//反转</span></span><br><span class="line">         cur.next=pre;</span><br><span class="line">         <span class="comment">//pre后移</span></span><br><span class="line">         pre=cur;</span><br><span class="line">         <span class="comment">//后移</span></span><br><span class="line">         cur=next;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> pre;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3><span id="21-合并两个有序链表">21. 合并两个有序链表</span></h3><p>将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">leetcode原题地址</a></p><h4><span id="解法">解法</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l1==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(l2==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(l1.val&lt;l2.val)&#123;</span><br><span class="line">        l1.next=mergeTwoLists(l1.next,l2);</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        l2.next=mergeTwoLists(l1,l2.next);</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上是递归解法，也可以使用非递归。</p><h3><span id="83-删除排序链表中的重复元素">83. 删除排序链表中的重复元素</span></h3><p>给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。</p><p>示例 1:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span></span><br><span class="line">输出: <span class="number">1</span>-&gt;<span class="number">2</span></span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">3</span></span><br><span class="line">输出: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span></span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/" target="_blank" rel="noopener">leetcode原题地址</a></p><h4><span id="解法">解法</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>||head.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        head.next=deleteDuplicates(head.next);</span><br><span class="line">        <span class="keyword">return</span> head.val==head.next.val?head.next:head;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3><span id="19-删除链表的倒数第n个节点">19. 删除链表的倒数第N个节点</span></h3><p>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.</span><br><span class="line"></span><br><span class="line">当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.</span><br></pre></td></tr></table></figure><p>说明：</p><p>给定的 n 保证是有效的。</p><p>进阶：</p><p>你能尝试使用一趟扫描实现吗？</p><p><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noopener">leetcode原题地址</a></p><h4><span id="解法">解法</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       ListNode fast=head;</span><br><span class="line">       ListNode slow=head;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">           fast=fast.next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(fast==<span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> head;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">while</span> (fast.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           fast=fast.next;</span><br><span class="line">           slow=slow.next;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       slow.next=slow.next.next;</span><br><span class="line">       <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3><span id="34-两两交换链表中的节点">34. 两两交换链表中的节点</span></h3><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p><p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3.</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/" target="_blank" rel="noopener">leetcode原题地址</a></p><h4><span id="解法">解法</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">       ListNode node = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">       node.next = head;</span><br><span class="line">       ListNode pre = node;</span><br><span class="line">       <span class="keyword">while</span> (pre.next != <span class="keyword">null</span> &amp;&amp; pre.next.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">           ListNode l1 = pre.next, l2 = pre.next.next;</span><br><span class="line">           ListNode next = l2.next;</span><br><span class="line">           l1.next = next;</span><br><span class="line">           l2.next = l1;</span><br><span class="line">           pre.next = l2;pre = l1;</span><br><span class="line">       &#125; </span><br><span class="line">       <span class="keyword">return</span> node.next;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3><span id="445-两数相加ii">445. 两数相加Ⅱ</span></h3><p>给定两个非空链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储单个数字。将这两数相加会返回一个新的链表。</p><p>你可以假设除了数字 0 之外，这两个数字都不会以零开头。</p><p>进阶:</p><p>如果输入链表不能修改该如何处理？换句话说，你不能对列表中的节点进行翻转。</p><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: (7 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">输出: 7 -&gt; 8 -&gt; 0 -&gt; 7</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/add-two-numbers-ii/" target="_blank" rel="noopener">leetcode原题地址</a></p><h4><span id="解法">解法</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       Stack&lt;Integer&gt; stackA = buildStack(l1);</span><br><span class="line">       Stack&lt;Integer&gt; stackB = buildStack(l2);</span><br><span class="line">       ListNode tmpHead=<span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">       <span class="keyword">int</span> carry=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span> (!stackA.isEmpty()||!stackB.isEmpty()||carry!=<span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> A =stackA.isEmpty()?<span class="number">0</span>: stackA.pop();</span><br><span class="line">            <span class="keyword">int</span> B =stackB.isEmpty()?<span class="number">0</span>: stackB.pop();</span><br><span class="line">            ListNode node = <span class="keyword">new</span> ListNode((A + B+carry) % <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">            carry=(A+B+carry)/<span class="number">10</span>;</span><br><span class="line">            node.next=tmpHead.next;</span><br><span class="line">            tmpHead.next=node;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> tmpHead.next;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> Stack&lt;Integer&gt; <span class="title">buildStack</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">       Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">       <span class="keyword">while</span> (head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           stack.push(head.val);</span><br><span class="line">           head=head.next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> stack;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3><span id="725-分隔链表">725. 分隔链表</span></h3><p>给定一个头结点为 root 的链表, 编写一个函数以将链表分隔为 k 个连续的部分。</p><p>每部分的长度应该尽可能的相等: 任意两部分的长度差距不能超过 1，也就是说可能有些部分为 null。</p><p>这k个部分应该按照在链表中出现的顺序进行输出，并且排在前面的部分的长度应该大于或等于后面的长度。</p><p>返回一个符合上述规则的链表的列表。</p><p>举例： 1-&gt;2-&gt;3-&gt;4, k = 5 // 5 结果 [ [1], [2], [3], [4], null ]</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">root = [1, 2, 3], k = 5</span><br><span class="line">输出: [[1],[2],[3],[],[]]</span><br><span class="line">解释:</span><br><span class="line">输入输出各部分都应该是链表，而不是数组。</span><br><span class="line">例如, 输入的结点 root 的 val= 1, root.next.val = 2, \root.next.next.val = 3, 且 root.next.next.next = null。</span><br><span class="line">第一个输出 output[0] 是 output[0].val = 1, output[0].next = null。</span><br><span class="line">最后一个元素 output[4] 为 null, 它代表了最后一个部分为空链表。</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">root = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], k = 3</span><br><span class="line">输出: [[1, 2, 3, 4], [5, 6, 7], [8, 9, 10]]</span><br><span class="line">解释:</span><br><span class="line">输入被分成了几个连续的部分，并且每部分的长度相差不超过1.前面部分的长度大于等于后面部分的长度。</span><br></pre></td></tr></table></figure><p>提示:</p><pre><code>root 的长度范围： [0, 1000].输入的每个节点的大小范围：[0, 999].k 的取值范围： [1, 50].</code></pre><p><a href="https://leetcode-cn.com/problems/split-linked-list-in-parts/" target="_blank" rel="noopener">leetcode原题地址</a></p><h4><span id="解法">解法</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode[] splitListToParts(ListNode root, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">int</span> N = <span class="number">0</span>;</span><br><span class="line">        ListNode cur = root;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;N++;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">int</span> mod = N % k;</span><br><span class="line">        <span class="keyword">int</span> size = N / k;</span><br><span class="line">        ListNode[] ret = <span class="keyword">new</span> ListNode[k];</span><br><span class="line">        cur = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; cur != <span class="keyword">null</span> &amp;&amp; i &lt; k; i++) &#123;</span><br><span class="line">            ret[i] = cur;</span><br><span class="line">            <span class="keyword">int</span> curSize = size + (mod-- &gt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; curSize - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">            ListNode next = cur.next;</span><br><span class="line">            cur.next = <span class="keyword">null</span>;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;链表&quot;&gt;&lt;a href=&quot;#链表&quot; class=&quot;headerlink&quot; title=&quot;链表&quot;&gt;&lt;/a&gt;链表&lt;/h2&gt;&lt;h3 id=&quot;160-相交链表&quot;&gt;&lt;a href=&quot;#160-相交链表&quot; class=&quot;headerlink&quot; title=&quot;160. 相交链表&quot;&gt;&lt;/a&gt;160. 相交链表&lt;/h3&gt;&lt;p&gt;编写一个程序，找到两个单链表相交的起始节点。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/intersection-of-two-linked-lists/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;leetcode原题地址&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;解法&quot;&gt;&lt;a href=&quot;#解法&quot; class=&quot;headerlink&quot; title=&quot;解法&quot;&gt;&lt;/a&gt;解法&lt;/h4&gt;&lt;p&gt;设 A 的长度为 a + c，B 的长度为 b + c，其中 c 为尾部公共部分长度，可知 a + c + b = b + c + a。&lt;br&gt;当访问 A 链表的指针访问到链表尾部时，令它从链表 B 的头部开始访问链表 B；同样地，当访问 B 链表的指针访问&lt;br&gt;到链表尾部时，令它从链表 A 的头部开始访问链表 A。这样就能控制访问 A 和 B 两个链表的指针能同时访问到交&lt;br&gt;点  .&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; ListNode &lt;span class=&quot;title&quot;&gt;getIntersectionNode&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(ListNode headA, ListNode headB)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//这道题的意思是必定有相交的&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ListNode curA=headA;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ListNode curB=headB;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (curA!=curB)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        curA=(curA==&lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;)?headB:curA.next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        curB=(curB==&lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;)?headA:curB.next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; curA;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法之动态规划</title>
    <link href="http://yoursite.com/2020/03/31/%E7%AE%97%E6%B3%95%E4%B9%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>http://yoursite.com/2020/03/31/算法之动态规划/</id>
    <published>2020-03-31T14:11:00.000Z</published>
    <updated>2020-03-31T14:11:54.392Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="动态规划">动态规划</span></h2><p>动态规划和递归都是见原问题拆成多个子问题然后求解，它们之间最本质的区别是，动态规划保存了子问题的解，避免重复计算。</p><h3><span id="70-爬楼梯">70. 爬楼梯</span></h3><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p>注意：给定 n 是一个正整数。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入： 2</span><br><span class="line">输出： 2</span><br><span class="line">解释： 有两种方法可以爬到楼顶。</span><br><span class="line"></span><br><span class="line">1.  1 阶 + 1 阶</span><br><span class="line">2.  2 阶</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入： 3</span><br><span class="line">输出： 3</span><br><span class="line">解释： 有三种方法可以爬到楼顶。</span><br><span class="line"></span><br><span class="line">1.  1 阶 + 1 阶 + 1 阶</span><br><span class="line">2.  1 阶 + 2 阶</span><br><span class="line">3.  2 阶 + 1 阶</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/climbing-stairs/" target="_blank" rel="noopener">leetcode原题地址</a></p><a id="more"></a><h4><span id="解法">解法</span></h4><p>这道题是一道非常经典的题。我们今天尝试使用动态规划来解它。<br>$$<br>dp[n]=dp[n-1]+dp[n-2]<br>$$<br>到达第n阶楼梯的走法等于到达第n-1阶然后在走一阶加上到达n-2阶的走法然后再走两步。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(n&lt;<span class="number">2</span>)&#123;</span><br><span class="line">          <span class="keyword">return</span> n;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//dp[3]=dp[2]+dp[1]</span></span><br><span class="line">      <span class="keyword">int</span> pre1=<span class="number">2</span>; <span class="comment">//dp[2]</span></span><br><span class="line">      <span class="keyword">int</span> pre2=<span class="number">1</span>; <span class="comment">//dp[1]</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;i++)&#123;</span><br><span class="line">          <span class="keyword">int</span> cur=pre1+pre2;</span><br><span class="line">          pre2=pre1;</span><br><span class="line">          pre1=cur;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> pre1;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3><span id="198-打家劫舍">198. 打家劫舍</span></h3><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,1]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。</span><br><span class="line">     偷窃到的最高金额 = 1 + 3 = 4 。</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,7,9,3,1]</span><br><span class="line">输出: 12</span><br><span class="line">解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。</span><br><span class="line">     偷窃到的最高金额 = 2 + 9 + 1 = 12 。</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/house-robber/" target="_blank" rel="noopener">leetcode原题地址</a></p><h4><span id="解法">解法</span></h4><p>$$<br>dp[n]=max(dp[n-2]+nums[n],dp[n-1])<br>$$</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//dp[n]=max(dp[n-2]+nums[n],dp[n-1])</span></span><br><span class="line">       <span class="comment">//这种写法比直接利用dp数组更节省空间</span></span><br><span class="line">       <span class="keyword">int</span> pre2=<span class="number">0</span>;<span class="comment">//dp[n-2]</span></span><br><span class="line">       <span class="keyword">int</span> pre1=<span class="number">0</span>;<span class="comment">//dp[n-1]</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">           <span class="keyword">int</span> cur=Math.max(pre2+nums[i],pre1);</span><br><span class="line">           pre2=pre1;</span><br><span class="line">           pre1=cur;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> pre1;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3><span id="213-打家劫舍">213. 打家劫舍</span></h3><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,3,2]</span><br><span class="line">输出: 3</span><br><span class="line">解释: 你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,1]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。</span><br><span class="line">     偷窃到的最高金额 = 1 + 3 = 4 。</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/house-robber-ii/" target="_blank" rel="noopener">leetcode原题地址</a></p><h4><span id="解法">解法</span></h4><p>这道题的原理和上一题类似，但是因为是环形的，所以第一家和最后一家只能选择一个偷。所以我们将这两个方案都计算一下，比较得到最佳方案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span>(nums==<span class="keyword">null</span>||nums.length==<span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(nums.length==<span class="number">1</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> Math.max(rob(nums,<span class="number">0</span>,nums.length-<span class="number">2</span>),rob(nums,<span class="number">1</span>,nums.length-<span class="number">1</span>));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">       <span class="comment">//dp[n]=max(dp[n-1],dp[n-2]+nums[n]);</span></span><br><span class="line">       <span class="keyword">int</span> pre1=<span class="number">0</span>; <span class="comment">//dp[n-1]</span></span><br><span class="line">       <span class="keyword">int</span> pre2=<span class="number">0</span>; <span class="comment">//dp[n-2]</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;=end;i++)&#123;</span><br><span class="line">           <span class="keyword">int</span> cur=Math.max(pre1,pre2+nums[i]);</span><br><span class="line">           pre2=pre1;</span><br><span class="line">           pre1=cur;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> pre1;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3><span id="64-最小路径和">64. 最小路径和</span></h3><p>给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p><p>说明：每次只能向下或者向右移动一步。</p><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  [1,3,1],</span><br><span class="line">  [1,5,1],</span><br><span class="line">  [4,2,1]</span><br><span class="line">]</span><br><span class="line">输出: 7</span><br><span class="line">解释: 因为路径 1→3→1→1→1 的总和最小。</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/minimum-path-sum/" target="_blank" rel="noopener">leetcode原题地址</a></p><h4><span id="解法">解法</span></h4><p>$$<br>dp[i,j]=grid[i,j]+min(dp[i+1,j],dp[i,j+1])<br>$$</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[grid[<span class="number">0</span>].length];</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = grid.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> j = grid[<span class="number">0</span>].length - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">              <span class="keyword">if</span>(i == grid.length - <span class="number">1</span> &amp;&amp; j != grid[<span class="number">0</span>].length - <span class="number">1</span>)</span><br><span class="line">                  dp[j] = grid[i][j] +  dp[j + <span class="number">1</span>];</span><br><span class="line">              <span class="keyword">else</span> <span class="keyword">if</span>(j == grid[<span class="number">0</span>].length - <span class="number">1</span> &amp;&amp; i != grid.length - <span class="number">1</span>)</span><br><span class="line">                  dp[j] = grid[i][j] + dp[j];</span><br><span class="line">              <span class="keyword">else</span> <span class="keyword">if</span>(j != grid[<span class="number">0</span>].length - <span class="number">1</span> &amp;&amp; i != grid.length - <span class="number">1</span>)</span><br><span class="line">                  dp[j] = grid[i][j] + Math.min(dp[j], dp[j + <span class="number">1</span>]);</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                  dp[j] = grid[i][j];</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3><span id="62-不同路径">62. 不同路径</span></h3><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角。</p><p>问总共有多少条不同的路径？</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: m = 3, n = 2</span><br><span class="line">输出: 3</span><br><span class="line">解释:</span><br><span class="line">从左上角开始，总共有 3 条路径可以到达右下角。</span><br><span class="line"></span><br><span class="line">1. 向右 -&gt; 向右 -&gt; 向下</span><br><span class="line">2. 向右 -&gt; 向下 -&gt; 向右</span><br><span class="line">3. 向下 -&gt; 向右 -&gt; 向右</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: m = 7, n = 3</span><br><span class="line">输出: 28</span><br></pre></td></tr></table></figure><p>提示：</p><pre><code>1 &lt;= m, n &lt;= 100题目数据保证答案小于等于 2 * 10 ^ 9</code></pre><p><a href="https://leetcode-cn.com/problems/unique-paths/" target="_blank" rel="noopener">leetcode原题地址</a></p><h4><span id="解法">解法</span></h4><p>$$<br>dp[i,j]=dp[i-1,j]+dp[i,j-1]<br>$$</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span>[][] dp=<span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">           dp[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">           dp[<span class="number">0</span>][j]=<span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">               dp[i][j]=dp[i-<span class="number">1</span>][j]+dp[i][j-<span class="number">1</span>];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3><span id="303-区域和检索-数组不可变">303. 区域和检索-数组不可变</span></h3><p>给定一个整数数组  nums，求出数组从索引 i 到 j  (i ≤ j) 范围内元素的总和，包含 i,  j 两点。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给定 nums = [-2, 0, 3, -5, 2, -1]，求和函数为 sumRange()</span><br><span class="line"></span><br><span class="line">sumRange(0, 2) -&gt; 1</span><br><span class="line">sumRange(2, 5) -&gt; -1</span><br><span class="line">sumRange(0, 5) -&gt; -3</span><br></pre></td></tr></table></figure><p>说明:</p><pre><code>你可以假设数组不可变。会多次调用 sumRange 方法。</code></pre><p><a href="https://leetcode-cn.com/problems/range-sum-query-immutable/" target="_blank" rel="noopener">leetcode原题地址</a></p><h4><span id="解法">解法</span></h4><p>求区间i-j的和，可以转换为sum[j+1]-sum[j]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] sums;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">NumArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       sums=<span class="keyword">new</span> <span class="keyword">int</span>[nums.length+<span class="number">1</span>];</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=nums.length;i++)&#123;</span><br><span class="line"></span><br><span class="line">           sums[i]=sums[i-<span class="number">1</span>]+nums[i-<span class="number">1</span>];</span><br><span class="line">          </span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> sums[j+<span class="number">1</span>]-sums[i];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3><span id="343-整数拆分">343. 整数拆分</span></h3><p>给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 2</span><br><span class="line">输出: 1</span><br><span class="line">解释: 2 = 1 + 1, 1 × 1 = 1。</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: 10</span><br><span class="line">输出: 36</span><br><span class="line">解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。</span><br><span class="line"></span><br><span class="line">说明: 你可以假设 n 不小于 2 且不大于 58。</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/integer-break/" target="_blank" rel="noopener">leetcode原题地址</a></p><h4><span id="解法">解法</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">integerBreak</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//dp[i]=max(dp[i],max(j*dp[i-j],j*(i-j)))</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">      dp[<span class="number">1</span>]=dp[<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=n;i++)&#123;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">              dp[i]=Math.max(dp[i],Math.max(j*dp[i-j],j*(i-j)));</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> dp[n];</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3><span id="300-最长上升子序列">300. 最长上升子序列</span></h3><p>给定一个无序的整数数组，找到其中最长上升子序列的长度。</p><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [10,9,2,5,3,7,101,18]</span><br><span class="line">输出: 4 </span><br><span class="line">解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。</span><br></pre></td></tr></table></figure><p>说明:</p><pre><code>可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。你算法的时间复杂度应该为 O(n2) 。</code></pre><p>进阶: 你能将算法的时间复杂度降低到 O(n log n) 吗?</p><p><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">leetcode原题地址</a></p><h4><span id="解法">解法</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">         <span class="keyword">int</span> max=<span class="number">1</span>;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;nums.length;j++)&#123;</span><br><span class="line">             <span class="keyword">if</span>(nums[i]&gt;nums[j])&#123;</span><br><span class="line">                 dp[i]=Math.max(max,dp[j]+<span class="number">1</span>);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         dp[i]=max;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> ret=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;dp.length;i++)&#123;</span><br><span class="line">     </span><br><span class="line">           <span class="keyword">if</span>(dp[i]&gt;ret)&#123;</span><br><span class="line">               ret =dp[i];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> ret;</span><br><span class="line">       </span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;动态规划&quot;&gt;&lt;a href=&quot;#动态规划&quot; class=&quot;headerlink&quot; title=&quot;动态规划&quot;&gt;&lt;/a&gt;动态规划&lt;/h2&gt;&lt;p&gt;动态规划和递归都是见原问题拆成多个子问题然后求解，它们之间最本质的区别是，动态规划保存了子问题的解，避免重复计算。&lt;/p&gt;
&lt;h3 id=&quot;70-爬楼梯&quot;&gt;&lt;a href=&quot;#70-爬楼梯&quot; class=&quot;headerlink&quot; title=&quot;70. 爬楼梯&quot;&gt;&lt;/a&gt;70. 爬楼梯&lt;/h3&gt;&lt;p&gt;假设你正在爬楼梯。需要 n 阶你才能到达楼顶。&lt;/p&gt;
&lt;p&gt;每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？&lt;/p&gt;
&lt;p&gt;注意：给定 n 是一个正整数。&lt;/p&gt;
&lt;p&gt;示例 1：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入： 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出： 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释： 有两种方法可以爬到楼顶。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1.  1 阶 + 1 阶&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2.  2 阶&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;示例 2：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入： 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出： 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释： 有三种方法可以爬到楼顶。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1.  1 阶 + 1 阶 + 1 阶&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2.  1 阶 + 2 阶&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3.  2 阶 + 1 阶&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/climbing-stairs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;leetcode原题地址&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法之排序</title>
    <link href="http://yoursite.com/2020/03/30/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2020/03/30/算法之排序/</id>
    <published>2020-03-30T01:44:00.000Z</published>
    <updated>2020-03-30T07:39:32.815Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="排序">排序</span></h2><h3><span id="215数组中的第k个最大元素">215.数组中的第k个最大元素</span></h3><p>在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,2,1,5,6,4] 和 k = 2</span><br><span class="line">输出: 5</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,2,3,1,2,4,5,5,6] 和 k = 4</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><p>说明:</p><p>你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。</p><p><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/" target="_blank" rel="noopener">leetcode原题地址</a></p><a id="more"></a><h4><span id="解法">解法</span></h4><ol><li>是用堆排序</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//小顶堆</span></span><br><span class="line">       PriorityQueue&lt;Integer&gt; pq=<span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">           pq.add(num);</span><br><span class="line">           <span class="keyword">if</span>(pq.size()&gt;k)&#123;</span><br><span class="line">               pq.poll();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> pq.poll();</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(NlogK)，空间复杂度为O(K)</p><ol start="2"><li>使用快排</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">       sort(nums);</span><br><span class="line">       <span class="keyword">return</span> nums[k-<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">       doSort(arr,<span class="number">0</span>,arr.length-<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSort</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line">           <span class="keyword">int</span> pivot = partition(arr, left, right);</span><br><span class="line">           doSort(arr,left,pivot-<span class="number">1</span>);</span><br><span class="line">           doSort(arr,pivot,right);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//寻找枢轴</span></span><br><span class="line">       <span class="keyword">int</span> mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">       <span class="keyword">int</span> pivot=arr[mid];</span><br><span class="line">       <span class="keyword">while</span> (left&lt;=right)&#123;</span><br><span class="line">           <span class="keyword">while</span> (right&gt;=<span class="number">0</span>&amp;&amp;arr[right]&lt;pivot)&#123;</span><br><span class="line">               right--;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">while</span> (left&lt;arr.length&amp;&amp;arr[left]&gt;pivot)&#123;</span><br><span class="line">               left++;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(left&lt;=right)&#123;</span><br><span class="line">               swap(arr, left, right);</span><br><span class="line">               left++;</span><br><span class="line">               right--;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> left;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> tmp=arr[a];</span><br><span class="line">       arr[a]=arr[b];</span><br><span class="line">       arr[b]=tmp;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>快速选择</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> l=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> r=nums.length-<span class="number">1</span>;</span><br><span class="line">       k=nums.length-k;</span><br><span class="line">       <span class="keyword">while</span> (l&lt;r)&#123;</span><br><span class="line">           <span class="keyword">int</span> p = partition(nums, l, r);</span><br><span class="line">           <span class="keyword">if</span>(p==k)&#123;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span>(p&gt;k)&#123;</span><br><span class="line">               r=p-<span class="number">1</span>;</span><br><span class="line">           &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">               l=p+<span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> nums[k];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> l, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = l, j = h + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (a[++i] &lt; a[l] &amp;&amp; i &lt; h) &#123;&#125;;</span><br><span class="line">            <span class="keyword">while</span> (a[--j] &gt; a[l] &amp;&amp; j &gt; l) &#123;&#125;;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= j) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(a, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">        swap(a, l, j);</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp=arr[a];</span><br><span class="line">        arr[a]=arr[b];</span><br><span class="line">        arr[b]=tmp;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3><span id="347-前k个高频元素">347. 前k个高频元素</span></h3><p>给定一个非空的整数数组，返回其中出现频率前 k 高的元素。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,1,1,2,2,3], k = 2</span><br><span class="line">输出: [1,2]</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1], k = 1</span><br><span class="line">输出: [1]</span><br></pre></td></tr></table></figure><p>说明：</p><pre><code>你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。你的算法的时间复杂度必须优于 O(n log n) , n 是数组的大小。</code></pre><p><a href="https://leetcode-cn.com/problems/top-k-frequent-elements/" target="_blank" rel="noopener">leetcode原题地址</a></p><h4><span id="解法">解法</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">topKFrequent</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用hashmap统计频率</span></span><br><span class="line">        HashMap&lt;Integer, Integer&gt; count = <span class="keyword">new</span> HashMap();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n: nums) &#123;</span><br><span class="line">            count.put(n, count.getOrDefault(n, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        PriorityQueue&lt;Integer&gt; heap =</span><br><span class="line">                <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;((n1, n2) -&gt; count.get(n1) - count.get(n2));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//建立堆</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n: count.keySet()) &#123;</span><br><span class="line">            heap.add(n);</span><br><span class="line">            <span class="keyword">if</span> (heap.size() &gt; k)&#123;</span><br><span class="line">                heap.poll();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; top_k = <span class="keyword">new</span> LinkedList();</span><br><span class="line">        <span class="keyword">while</span> (!heap.isEmpty()) &#123;</span><br><span class="line">            top_k.add(heap.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(top_k);</span><br><span class="line">        <span class="keyword">return</span> top_k;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3><span id="75-颜色分类">75. 颜色分类</span></h3><p>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p><p>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p><p>注意:<br>不能使用代码库中的排序函数来解决这道题。</p><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,0,2,1,1,0]</span><br><span class="line">输出: [0,0,1,1,2,2]</span><br></pre></td></tr></table></figure><p>进阶：</p><pre><code>一个直观的解决方案是使用计数排序的两趟扫描算法。首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。你能想出一个仅使用常数空间的一趟扫描算法吗？</code></pre><p><a href="https://leetcode-cn.com/problems/sort-colors/" target="_blank" rel="noopener">leetcode原题地址</a></p><h4><span id="解法">解法</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> zero = -<span class="number">1</span>, one = <span class="number">0</span>, two = nums.length;</span><br><span class="line">        <span class="keyword">while</span> (one &lt; two) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[one] == <span class="number">0</span>) &#123;</span><br><span class="line">                swap(nums, ++zero, one++);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[one] == <span class="number">2</span>) &#123;</span><br><span class="line">                swap(nums, --two, one);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ++one;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp=arr[a];</span><br><span class="line">    arr[a]=arr[b];</span><br><span class="line">    arr[b]=tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;排序&quot;&gt;&lt;a href=&quot;#排序&quot; class=&quot;headerlink&quot; title=&quot;排序&quot;&gt;&lt;/a&gt;排序&lt;/h2&gt;&lt;h3 id=&quot;215-数组中的第k个最大元素&quot;&gt;&lt;a href=&quot;#215-数组中的第k个最大元素&quot; class=&quot;headerlink&quot; title=&quot;215.数组中的第k个最大元素&quot;&gt;&lt;/a&gt;215.数组中的第k个最大元素&lt;/h3&gt;&lt;p&gt;在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。&lt;/p&gt;
&lt;p&gt;示例 1:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: [3,2,1,5,6,4] 和 k = 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;示例 2:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: [3,2,3,1,2,4,5,5,6] 和 k = 4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;说明:&lt;/p&gt;
&lt;p&gt;你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/kth-largest-element-in-an-array/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;leetcode原题地址&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法之双指针</title>
    <link href="http://yoursite.com/2020/03/29/%E7%AE%97%E6%B3%95%E4%B9%8B%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    <id>http://yoursite.com/2020/03/29/算法之双指针/</id>
    <published>2020-03-29T08:53:00.000Z</published>
    <updated>2020-03-29T08:53:22.594Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="双指针">双指针</span></h2><p>双指针主要用于遍历数组，两个指针指向不同的元素，从而协同完成任务。</p><a id="more"></a><h3><span id="167-两数之和-ii-输入有序数组">167. 两数之和 II - 输入有序数组</span></h3><p>给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。</p><p>函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。</p><p>说明:</p><pre><code>返回的下标值（index1 和 index2）不是从零开始的。你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。</code></pre><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: numbers = [2, 7, 11, 15], target = 9</span><br><span class="line">输出: [1,2]</span><br><span class="line">解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/" target="_blank" rel="noopener">leetcode原题地址</a></p><h4><span id="解答">解答</span></h4><p>我们使用两个指针，一个指针从数组的左边开始，一个指针从数组的右边开始。</p><p>如果两个指针所指数据等于target，那么就直接返回；如果小于target，那么左指针右移动；</p><p>如果大于target，则右指针左移。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line">       <span class="keyword">int</span> minIndex=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> maxIndex=numbers.length-<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">int</span>[] result=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">       <span class="keyword">while</span> (minIndex&lt;maxIndex)&#123;</span><br><span class="line">           <span class="keyword">int</span> sum=numbers[minIndex]+numbers[maxIndex];</span><br><span class="line">           <span class="keyword">if</span>(sum==target)&#123;</span><br><span class="line">               <span class="comment">//返回结果的下标不是从零开始的</span></span><br><span class="line">               result[<span class="number">0</span>]=++minIndex;</span><br><span class="line">               result[<span class="number">1</span>]=++maxIndex;</span><br><span class="line">               <span class="keyword">return</span> result;</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum&gt;target)&#123;</span><br><span class="line">               maxIndex--;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               minIndex++;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3><span id="633平方数之和">633.平方数之和</span></h3><p>给定一个非负整数 c ，你要判断是否存在两个整数 a 和 b，使得 a2 + b2 = c。</p><p>示例1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 5</span><br><span class="line">输出: True</span><br><span class="line">解释: 1 * 1 + 2 * 2 = 5</span><br></pre></td></tr></table></figure><p>示例2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 3</span><br><span class="line">输出: False</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/sum-of-square-numbers/" target="_blank" rel="noopener">leetcode原题地址</a></p><h4><span id="解答">解答</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">judgeSquareSum</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> b=(<span class="keyword">int</span>) Math.sqrt(c);</span><br><span class="line">        <span class="keyword">while</span> (a&lt;=b)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp=a*a+b*b;</span><br><span class="line">            <span class="keyword">if</span>(tmp==c)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(tmp&lt;c)&#123;</span><br><span class="line">                a++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                b--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3><span id="345-反转字符串中的元音字母">345. 反转字符串中的元音字母</span></h3><p>编写一个函数，以字符串作为输入，反转该字符串中的元音字母。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;hello&quot;</span><br><span class="line">输出: &quot;holle&quot;</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;leetcode&quot;</span><br><span class="line">输出: &quot;leotcede&quot;</span><br></pre></td></tr></table></figure><p>说明:<br>元音字母不包含字母”y”。</p><p><a href="https://leetcode-cn.com/problems/reverse-vowels-of-a-string/" target="_blank" rel="noopener">leetcode原题地址</a></p><h4><span id="解法">解法</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> HashSet&lt;Character&gt; set=<span class="keyword">new</span> HashSet&lt;&gt;(</span><br><span class="line">            Arrays.asList(<span class="string">'a'</span>,<span class="string">'e'</span>,<span class="string">'i'</span>,<span class="string">'o'</span>,<span class="string">'u'</span>,<span class="string">'A'</span>,<span class="string">'E'</span>,<span class="string">'I'</span>,<span class="string">'O'</span>,<span class="string">'U'</span>));</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseVowels</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right=chars.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left&lt;right)&#123;</span><br><span class="line">            <span class="keyword">while</span> (right&gt;=<span class="number">0</span>&amp;&amp;!set.contains(chars[right]))&#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (left&lt;chars.length&amp;&amp;!set.contains(chars[left]))&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line">                swap(chars,left,right);</span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(chars);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span>[] chars,<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> tmp=chars[a];</span><br><span class="line">        chars[a]=chars[b];</span><br><span class="line">        chars[b]=tmp;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3><span id="680-验证回文字符串ii">680 验证回文字符串Ⅱ</span></h3><p>给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;aba&quot;</span><br><span class="line">输出: True</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;abca&quot;</span><br><span class="line">输出: True</span><br><span class="line">解释: 你可以删除c字符。</span><br></pre></td></tr></table></figure><p>注意:</p><pre><code>字符串只包含从 a-z 的小写字母。字符串的最大长度是50000。</code></pre><p><a href="https://leetcode.com/problems/valid-palindrome-ii/description/" target="_blank" rel="noopener">leetcode原题地址</a></p><h4><span id="解法">解法</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end=s.length()-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (start&lt;end)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(start)!=s.charAt(end))&#123;</span><br><span class="line">               <span class="keyword">return</span> isPalinerome(s,start,end-<span class="number">1</span>)||isPalinerome(s,start+<span class="number">1</span>,end);</span><br><span class="line">            &#125;</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPalinerome</span><span class="params">(String str,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (start&lt;end)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str.charAt(start)!=str.charAt(end))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="141-环形链表">141. 环形链表</span></h3><p>给定一个链表，判断链表中是否有环。</p><p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [3,2,0,-4], pos = 1</span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2], pos = 0</span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1], pos = -1</span><br><span class="line">输出：false</span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure><p>进阶：</p><p>你能用 O(1)（即，常量）内存解决此问题吗？</p><p><a href="https://leetcode-cn.com/problems/linked-list-cycle/" target="_blank" rel="noopener">leetcode原题地址</a></p><h4><span id="解法">解法</span></h4><p>快慢指针法，一个指针一次只走一步，另一个指针一次走2步。如果链表中有环，那么它们一定会相遇。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode slow=head;</span><br><span class="line">        ListNode fast=head;</span><br><span class="line">        <span class="keyword">while</span> (fast!=<span class="keyword">null</span>&amp;&amp;fast.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            slow=slow.next;</span><br><span class="line">            fast=fast.next.next;</span><br><span class="line">            <span class="keyword">if</span>(fast==slow)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3><span id="524通过删除字母匹配到字典中最长单词">524.通过删除字母匹配到字典中最长单词</span></h3><p>给定一个字符串和一个字符串字典，找到字典里面最长的字符串，该字符串可以通过删除给定字符串的某些字符来得到。如果答案不止一个，返回长度最长且字典顺序最小的字符串。如果答案不存在，则返回空字符串。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;abpcplea&quot;, d = [&quot;ale&quot;,&quot;apple&quot;,&quot;monkey&quot;,&quot;plea&quot;]</span><br><span class="line"></span><br><span class="line">输出: </span><br><span class="line">&quot;apple&quot;</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;abpcplea&quot;, d = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</span><br><span class="line"></span><br><span class="line">输出: </span><br><span class="line">&quot;a&quot;</span><br></pre></td></tr></table></figure><p>说明:</p><pre><code>所有输入的字符串只包含小写字母。字典的大小不会超过 1000。所有输入的字符串长度不会超过 1000。</code></pre><p><a href="https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting/" target="_blank" rel="noopener">leetcode原题地址</a></p><h4><span id="解法">解法</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">findLongestWord</span><span class="params">(String s, List&lt;String&gt; d)</span> </span>&#123;</span><br><span class="line">    String longestWord = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">for</span> (String target : d) &#123;</span><br><span class="line">        <span class="keyword">int</span> l1 = longestWord.length(), l2 = target.length();</span><br><span class="line">        <span class="keyword">if</span> (l1 &gt; l2 || (l1 == l2 &amp;&amp; longestWord.compareTo(target) &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span> (isValid(s, target)) &#123;</span><br><span class="line">            longestWord = target;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> longestWord;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s,String target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; s.length() &amp;&amp; j &lt; target.length()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i) == target.charAt(j)) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> j == target.length();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;双指针&quot;&gt;&lt;a href=&quot;#双指针&quot; class=&quot;headerlink&quot; title=&quot;双指针&quot;&gt;&lt;/a&gt;双指针&lt;/h2&gt;&lt;p&gt;双指针主要用于遍历数组，两个指针指向不同的元素，从而协同完成任务。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法:矩形覆盖</title>
    <link href="http://yoursite.com/2020/03/29/%E7%AE%97%E6%B3%95%EF%BC%9A%E7%9F%A9%E5%BD%A2%E8%A6%86%E7%9B%96/"/>
    <id>http://yoursite.com/2020/03/29/算法：矩形覆盖/</id>
    <published>2020-03-29T03:08:00.000Z</published>
    <updated>2020-03-29T03:08:59.150Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="题目描述">题目描述</span></h2><p>我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？ </p><p><a href="https://www.nowcoder.com/practice/72a5a919508a4251859fb2cfb987a0e6?tpId=13&amp;tqId=11163&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">牛客网在线测试</a></p><a id="more"></a><h2><span id="解题思路">解题思路</span></h2><p>当n为1时，只有一种覆盖方法；当n为2 时，有两种覆盖方法；可以先覆盖 2*1 的矩形，再覆盖 2*(n-1) 的矩形；或者先覆盖 2*2 的矩形，再覆盖 2*(n-2)<br>的矩形。而覆盖 2*(n-1) 和 2*(n-2) 的矩形可以看成子问题。</p><p><img src="https://s1.ax1x.com/2020/03/29/GE4hUs.png" alt="GE4hUs.png"></p><h2><span id="解题代码">解题代码</span></h2><ol><li>递归写法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">RectCover</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target&lt;=<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> target;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> RectCover(target-<span class="number">1</span>)+RectCover(target-<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>非递归写法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">RectCover</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> pre2 = <span class="number">1</span>, pre1 = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            result = pre2 + pre1;</span><br><span class="line">            pre2 = pre1;</span><br><span class="line">            pre1 = result;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？ &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.nowcoder.com/practice/72a5a919508a4251859fb2cfb987a0e6?tpId=13&amp;amp;tqId=11163&amp;amp;tPage=1&amp;amp;rp=1&amp;amp;ru=/ta/coding-interviews&amp;amp;qru=/ta/coding-interviews/question-ranking&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;牛客网在线测试&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法:用两个栈实现队列</title>
    <link href="http://yoursite.com/2020/03/29/%E7%AE%97%E6%B3%95%EF%BC%9A%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
    <id>http://yoursite.com/2020/03/29/算法：用两个栈实现队列/</id>
    <published>2020-03-29T02:21:00.000Z</published>
    <updated>2020-03-29T02:22:00.576Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="题目描述">题目描述</span></h2><p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p><p><a href="https://www.nowcoder.com/practice/54275ddae22f475981afa2244dd448c6?tpId=13&amp;tqId=11158&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">牛客网在线测试</a></p><a id="more"></a><h2><span id="解题思路">解题思路</span></h2><p>我们使用两个栈，in栈用来处理入栈操作，out栈用来处理出栈操作。一个元素进入in栈之后，出栈的顺序被反转，当元素需要出栈的时候，需要先进入out栈，此时元素出栈顺序再次反转，这样就和队列出栈的顺序一致了。</p><h2><span id="解题代码">解题代码</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;Integer&gt; in = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">   Stack&lt;Integer&gt; out = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       in.push(node);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(out.isEmpty())&#123;</span><br><span class="line">           <span class="keyword">while</span> (!in.isEmpty())&#123;</span><br><span class="line">               <span class="comment">//将in栈中的数据，加入到out栈，此时out栈的顺序就是出队列顺序</span></span><br><span class="line">               out.push(in.pop());</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(out.isEmpty())&#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"队列空"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> out.pop();</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.nowcoder.com/practice/54275ddae22f475981afa2244dd448c6?tpId=13&amp;amp;tqId=11158&amp;amp;tPage=1&amp;amp;rp=1&amp;amp;ru=/ta/coding-interviews&amp;amp;qru=/ta/coding-interviews/question-ranking&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;牛客网在线测试&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法:重建二叉树</title>
    <link href="http://yoursite.com/2020/03/28/%E7%AE%97%E6%B3%95%EF%BC%9A%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://yoursite.com/2020/03/28/算法：重建二叉树/</id>
    <published>2020-03-28T03:57:00.000Z</published>
    <updated>2020-03-28T03:57:08.364Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="题目描述">题目描述</span></h2><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p><p><a href="https://www.nowcoder.com/practice/8a19cbe657394eeaac2f6ea9b0f6fcf6?tpId=13&amp;tqId=11157&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">牛客网在线测试</a></p><a id="more"></a><h2><span id="解题思路">解题思路</span></h2><p>解决这个题的关键是要清楚前序遍历序列和中序遍历序列的特点。</p><p>前序遍历序列的结构是这个样子的<code>(根节点，左子树的节点...,右子树的节点...)</code></p><p>而中序遍历序列的结构是这个样子的<code>(左子树的节点...,根节点,右子树的节点...)</code></p><p>根据遍历序列的特点，我们可以通过先序遍历序列找到根节点的值，然后根据根节点的值，再利用中序遍历的值，可以拿到左右子树的节点值。</p><h2><span id="解题代码">解题代码</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//记录中序遍历序列每个值所对应的下标</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;Integer,Integer&gt; indexOfInOrders=<span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span> [] pre,<span class="keyword">int</span> [] in)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;in.length;i++)&#123;</span><br><span class="line">            indexOfInOrders.put(in[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> reConstructBinaryTree(pre,<span class="number">0</span>,pre.length-<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span>[] pre,<span class="keyword">int</span> preL,<span class="keyword">int</span> preR,<span class="keyword">int</span> inL)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preL&gt;preR)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//先序遍历序列的第一个节点就是根节点</span></span><br><span class="line">        TreeNode root=<span class="keyword">new</span> TreeNode(pre[preL]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> inIndex = indexOfInOrders.get(root.val);</span><br><span class="line">        <span class="keyword">int</span> leftTreeSize=inIndex-inL;</span><br><span class="line">        root.left=reConstructBinaryTree(pre,preL+<span class="number">1</span>,preL+leftTreeSize,inL);</span><br><span class="line">        root.right=reConstructBinaryTree(pre,preL+leftTreeSize+<span class="number">1</span>,preR,inL+leftTreeSize+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.nowcoder.com/practice/8a19cbe657394eeaac2f6ea9b0f6fcf6?tpId=13&amp;amp;tqId=11157&amp;amp;tPage=1&amp;amp;rp=1&amp;amp;ru=/ta/coding-interviews&amp;amp;qru=/ta/coding-interviews/question-ranking&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;牛客网在线测试&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法:二叉树的下一个结点</title>
    <link href="http://yoursite.com/2020/03/28/%E7%AE%97%E6%B3%95%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E7%BB%93%E7%82%B9/"/>
    <id>http://yoursite.com/2020/03/28/算法：二叉树的下一个结点/</id>
    <published>2020-03-28T03:57:00.000Z</published>
    <updated>2020-03-29T02:01:12.973Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="题目描述">题目描述</span></h2><p>给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</p><p><a href="https://www.nowcoder.com/practice/9023a0c988684a53960365b889ceaf5e?tpId=13&amp;tqId=11210&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">牛客网在线测试</a></p><a id="more"></a><h2><span id="解题思路">解题思路</span></h2><ol><li>如果一个节点的右子树不为空，那么该节点的下一个节点是右子树的最左节点</li><li>如果一个节点的右子树为空，那么该节点的下一个节点是向上找第一个左链接指向的树包含该节点的祖先节点</li></ol><h2><span id="解题代码">解题代码</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeLinkNode <span class="title">GetNext</span><span class="params">(TreeLinkNode pNode)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(pNode.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">          TreeLinkNode right = pNode.right;</span><br><span class="line">          <span class="keyword">while</span> (right.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">              right=right.left;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> right;</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">while</span> (pNode.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">              TreeLinkNode parent = pNode.next;</span><br><span class="line">              <span class="keyword">if</span> (parent.left == pNode) &#123;</span><br><span class="line">                  <span class="keyword">return</span> parent;</span><br><span class="line">              &#125;</span><br><span class="line">              pNode = pNode.next;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.nowcoder.com/practice/9023a0c988684a53960365b889ceaf5e?tpId=13&amp;amp;tqId=11210&amp;amp;tPage=1&amp;amp;rp=1&amp;amp;ru=/ta/coding-interviews&amp;amp;qru=/ta/coding-interviews/question-ranking&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;牛客网在线测试&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法：从头到尾打印链表</title>
    <link href="http://yoursite.com/2020/03/28/%E7%AE%97%E6%B3%95%EF%BC%9A%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2020/03/28/算法：从尾到头打印链表/</id>
    <published>2020-03-28T02:50:00.000Z</published>
    <updated>2020-03-28T02:50:58.174Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="题目描述">题目描述</span></h2><p>从尾到头打印链表</p><p><a href="https://www.nowcoder.com/practice/d0267f7f55b3412ba93bd35cfa8e8035?tpId=13&amp;tqId=11156&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">牛客网在线测试</a></p><h2><span id="解题思路">解题思路</span></h2><h3><span id="使用递归">使用递归</span></h3><p>要逆序打印链表<code>1-&gt;2-&gt;3</code>，可以先打印链表<code>2-&gt;3</code>再打印节点1。而打印俩表<code>2-&gt;3</code>可以看作一个新的链表，可以再次调用求解函数对其进行逆序输出。</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">       ArrayList&lt;Integer&gt; list=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">       <span class="keyword">if</span>(listNode!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           list.addAll(printListFromTailToHead(listNode.next));</span><br><span class="line">           list.add(listNode.val);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> list;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3><span id="使用头插法">使用头插法</span></h3><p>使用头插法可以得到一个逆序的链表。然后遍历输出这个逆序链表即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//临时的空节点作为头节点</span></span><br><span class="line">       ListNode head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">       <span class="comment">//使用头插法</span></span><br><span class="line">       <span class="keyword">while</span> (listNode!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           ListNode tmp=listNode.next;</span><br><span class="line">           listNode.next=head.next;</span><br><span class="line">           head.next=listNode;</span><br><span class="line">           listNode=tmp;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       ArrayList&lt;Integer&gt; result=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       ListNode cur=head.next;</span><br><span class="line">       <span class="keyword">while</span> (cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           result.add(cur.val);</span><br><span class="line">           cur=cur.next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3><span id="使用栈">使用栈</span></h3><p>栈具有后进先出的特点，在遍历链表时间将值按顺序放入栈，最后出栈即尾逆序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">       Stack&lt;Integer&gt; stack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">       ListNode cur=listNode;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span> (cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           stack.push(cur.val);</span><br><span class="line">           cur=cur.next;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       ArrayList&lt;Integer&gt; result=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">           result.add(stack.pop());</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">       </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;从尾到头打印链表&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.nowcoder.com/practice/d0267f7f55b3412ba93bd35cfa8e8035?tpId=13&amp;amp;tqId=11156&amp;amp;tPage=1&amp;amp;rp=1&amp;amp;ru=/ta/coding-interviews&amp;amp;qru=/ta/coding-interviews/question-ranking&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;牛客网在线测试&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;解题思路&quot;&gt;&lt;a href=&quot;#解题思路&quot; class=&quot;headerlink&quot; title=&quot;解题思路&quot;&gt;&lt;/a&gt;解题思路&lt;/h2&gt;&lt;h3 id=&quot;使用递归&quot;&gt;&lt;a href=&quot;#使用递归&quot; class=&quot;headerlink&quot; title=&quot;使用递归&quot;&gt;&lt;/a&gt;使用递归&lt;/h3&gt;&lt;p&gt;要逆序打印链表&lt;code&gt;1-&amp;gt;2-&amp;gt;3&lt;/code&gt;，可以先打印链表&lt;code&gt;2-&amp;gt;3&lt;/code&gt;再打印节点1。而打印俩表&lt;code&gt;2-&amp;gt;3&lt;/code&gt;可以看作一个新的链表，可以再次调用求解函数对其进行逆序输出。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法：二维数组中的查找</title>
    <link href="http://yoursite.com/2020/03/28/%E7%AE%97%E6%B3%95%EF%BC%9A%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/"/>
    <id>http://yoursite.com/2020/03/28/算法：二维数组中的查找/</id>
    <published>2020-03-28T02:10:00.000Z</published>
    <updated>2020-03-28T02:10:20.666Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="题目描述">题目描述</span></h2><p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Consider the following matrix:</span><br><span class="line">[</span><br><span class="line">[1, 4, 7, 11, 15],</span><br><span class="line">[2, 5, 8, 12, 19],</span><br><span class="line">[3, 6, 9, 16, 22],</span><br><span class="line">[10, 13, 14, 17, 24],</span><br><span class="line">[18, 21, 23, 26, 30]</span><br><span class="line">] </span><br><span class="line">Given target = 5, return true.</span><br><span class="line">Given target = 20, return false.</span><br></pre></td></tr></table></figure><a id="more"></a><p><a href="https://www.nowcoder.com/practice/abc3fe2ce8e146608e868a70efebf62e?tpId=13&amp;tqId=11154&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">牛客在线测试</a></p><h2><span id="解题思路">解题思路</span></h2><p>通过观察二维数组，我们可以发现二维数组中的一个数，小于它的数一定在其左边，大于它的数一定在其下边。我们利用这个规律，从右上角开始查找。通过target与当前元素的大小关系来缩小查找区间。</p><h2><span id="解题代码">解题代码</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> [][] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array==<span class="keyword">null</span>||array.length==<span class="number">0</span>||array[<span class="number">0</span>].length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> row=array.length;</span><br><span class="line">        <span class="keyword">int</span> col=array[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> r=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> c=col-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (r&lt;row&amp;&amp;c&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(target==array[r][c])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target&lt;array[r][c])&#123;</span><br><span class="line">                c--;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                r++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Consider the following matrix:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[1, 4, 7, 11, 15],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[2, 5, 8, 12, 19],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[3, 6, 9, 16, 22],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[10, 13, 14, 17, 24],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[18, 21, 23, 26, 30]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;] &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Given target = 5, return true.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Given target = 20, return false.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法：数组中重复的数字</title>
    <link href="http://yoursite.com/2020/03/28/%E7%AE%97%E6%B3%95%EF%BC%9A%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>http://yoursite.com/2020/03/28/算法：数组中重复的数字/</id>
    <published>2020-03-28T01:12:00.000Z</published>
    <updated>2020-03-28T01:12:55.014Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="题目描述">题目描述</span></h2><p>在一个长度为 n 的数组里的所有数字都在 0 到 n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字是重<br>复的，也不知道每个数字重复几次。请找出数组中任意一个重复的数字。</p><a id="more"></a><h2><span id="解题思路">解题思路</span></h2><p>这道题我在第一次做的时候，首先想到的就是利用hashset来直接寻找重复的数字。但是这肯定不是最好的方法。</p><p>题目中有一个关键的信息，<strong>所有数字都在 0 到 n-1 的范围内</strong>而数组的下标的取值访问也是0到n-1，那么我们就可以直接将所有数字映射到原数组中。在映射的过程中，判断是否有重复的即可。</p><p>以数组<code>(2, 3, 1, 0, 2, 5)</code>为例，当我们遍历到index=4处，该位置上的数为2，应该放到数组下标为2的位置上去，但是该位置已经有一个2了，那么我们就可以断定2就是重复的。</p><h2><span id="解题代码">解题代码</span></h2><p>下面就是利用第二种解法，它的时间复杂度为O(N)，空间复杂度为O(1).</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> numbers</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> length</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> duplication 在duplication[0]存放重复的数字</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 存在重复的数字返回true，否则反之</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[],<span class="keyword">int</span> length,<span class="keyword">int</span> [] duplication)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(numbers==<span class="keyword">null</span>||length&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numbers.length;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span> (numbers[i]!=i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(numbers[i]==numbers[numbers[i]])&#123;</span><br><span class="line">                duplication[<span class="number">0</span>]=numbers[i];</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//把numbers[i]移动到下标为numbers[i]的位置上</span></span><br><span class="line">            swap(numbers,i,numbers[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp=arr[a];</span><br><span class="line">    arr[a]=arr[b];</span><br><span class="line">    arr[b]=tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;在一个长度为 n 的数组里的所有数字都在 0 到 n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字是重&lt;br&gt;复的，也不知道每个数字重复几次。请找出数组中任意一个重复的数字。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>公平锁与非公平锁</title>
    <link href="http://yoursite.com/2020/03/18/%E5%85%AC%E5%B9%B3%E9%94%81%E5%92%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81/"/>
    <id>http://yoursite.com/2020/03/18/公平锁和非公平锁/</id>
    <published>2020-03-18T13:50:00.000Z</published>
    <updated>2020-03-18T13:51:16.830Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="什么是公平锁什么是非公平锁">什么是公平锁？什么是非公平锁？</span></h2><p>公平锁：多个线程按照申请锁的先后顺序去获得锁，线程会直接进入队列去排队，永远都是队列的第一位才能获得锁。</p><p>非公平锁：多个线程去获得锁的时候，会直接去尝试获取，获取不到，再去进入等待队列，如果能获取到，就直接获取到锁。</p><h2><span id="优缺点比较">优缺点比较</span></h2><h3><span id="公平锁">公平锁</span></h3><p>优点：所有的线程都能够得到资源，不会饿死在队列中。</p><p>缺点：吞吐量会下降很多，队列里面除了第一个线程，其它线程都会阻塞，CPU唤醒阻塞线程的开销会很大。</p><h3><span id="非公平锁">非公平锁</span></h3><p>优点：可以减少CPU唤醒线程的开销，整体的吞吐率提高。</p><p>缺点：可能导致队列中的线程一直获取不到锁或者长时间获取不到锁，导致饿死。</p><h2><span id="源码体现">源码体现</span></h2><p>在<code>ReentrantLock</code>中就提供了公平锁和非公平锁两种模式(<strong>默认是非公平实现</strong>)。</p><h3><span id="公平锁实现">公平锁实现</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">           <span class="keyword">int</span> c = getState();</span><br><span class="line">           <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                   compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                   <span class="comment">//只有当队列为空或自己是队列头的时候，才会尝试CAS修改state</span></span><br><span class="line">                   <span class="comment">//修改state成功后，才算获取到了锁，否则加入到队列中等待</span></span><br><span class="line">                   setExclusiveOwnerThread(current);</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">               <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">               <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">               setState(nextc);</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">判断当前队列是否为空或者自己是否是在同步队列的首位，</span></span><br><span class="line"><span class="comment">如果是，则返回true</span></span><br><span class="line"><span class="comment">否则返回false</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        Node h = head;</span><br><span class="line">        Node s;</span><br><span class="line">        <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">            ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>公平锁只有在队列为空，或者自己为队头的时候才会尝试去修改state，当修改成功后则直接拿到了锁，否则进入排队。</p><h3><span id="非公平锁实现">非公平锁实现</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//state==0，通过CAS尝试修改state，而不是直接去排队</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">                <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">                <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">                setState(nextc);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>非公平锁当state==0，就会立即去尝试CAS修改state，修改成功了则直接拿到了锁，否则加入阻塞队列。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;&lt;span id=&quot;什么是公平锁什么是非公平锁&quot;&gt;什么是公平锁？什么是非公平锁？&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;公平锁：多个线程按照申请锁的先后顺序去获得锁，线程会直接进入队列去排队，永远都是队列的第一位才能获得锁。&lt;/p&gt;
&lt;p&gt;非公平锁：多个线程去获得锁的时候，会直接去
      
    
    </summary>
    
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>select、poll、epoll的原理与区别</title>
    <link href="http://yoursite.com/2020/03/15/select%E3%80%81poll%E3%80%81epoll%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2020/03/15/select、poll、epoll的原理与区别/</id>
    <published>2020-03-15T09:06:00.000Z</published>
    <updated>2020-03-15T13:59:50.795Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="io复用">IO复用</span></h2><p>select、poll、epoll都是IO复用的基本实现，select出现的最后，之后是poll，再是epoll。</p><h3><span id="select">Select</span></h3><p>我们使用select就可以实现同时处理多个网络连接的IO请求，基本原理就是程序调用select，然后整个程序就进入阻塞状态，这个时候，kernel内核就会轮询检查所有select负责的文件描述符fd，当找到其中哪个数据准备好了文件描述符，会返回给select，select通知系统调用，将数据从内核复制到进程的缓存区。</p><a id="more"></a><p>原理图如下：</p><p><img src="https://s1.ax1x.com/2020/03/15/836qER.png" alt="836qER.png"></p><p>时间复杂度未O(n)</p><p>缺点：</p><ol><li>进程可以打开的fd有限制，（32位机1024个，64位2048个）（原因是存储fd是一个固定大小的数组）</li><li>对socket进行扫描是线性扫描，即采用轮询的方法，效率较低。</li><li>用户空间和内核空间之间复制数据非常的消耗资源</li></ol><h3><span id="poll">poll</span></h3><p>poll的基本原理和select非常的类似，但是采用的是<strong>链表</strong>来存储fd，且poll相比select不会修改描述符。poll相对于select提供了更多的事件类型，并且对描述符的重复利用比select高。</p><p><strong>select和poll的返回结果没有声明哪些描述符已经准备好了，如果返回值大于0.，应用进程就需要使用轮询的方式找到IO完成的描述符。这也是影响效率的一大因素</strong></p><h3><span id="epoll">epoll</span></h3><p>epoll提供了三个函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  建立一個 epoll 对象，并传回它的id</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br><span class="line">  </span><br><span class="line"><span class="comment">//事件注册函数，将需要监听的事件和需要监听的fd交给epoll对象</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//等待注册的事件被触发或者timeout发生</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event *events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><p>epoll主要解决了这些问题：</p><ol><li>对fd的数量没有限制，所以最大数量与能打开的fd数量有关。</li><li>epoll不再需要每次调用都从用户空间将fd_set复制到内核</li><li>select和poll都是主动去轮询，需要遍历每个fd。而epoll采用的是被动触发的方式，给fd注册了相应的事件的时候，为每个fd指定了一个回调函数，当数据准备好后，就会把就绪的fd加入到就绪队列中，epoll_wait的工作方式实际上就是再这个就绪队列中查看有没有就绪的fd，如果有，就唤醒就绪队列上的等待者，然后调用回调函数。</li><li>就是select和poll只能通知有fd已经就绪了，但不能知道究竟是哪个fd就绪，所以select和poll就要去主动轮询一遍找到就绪的fd。而epoll则是不但可以知道有fd可以就绪，而且还具体可以知道就绪fd的编号，所以直接找到就可以，不用轮询。这也是主动式和被动式的区别。</li></ol><p>epoll有两种触发方式：LT（水平触发），ET（边缘触发）</p><ol><li>LT模式：当epoll_wait()检查到描述符事件到达时，将此事件通知进行，进程可以不立即处理该事件，下次调用epoll_wait()会再次通知进程。是默认的一种模式，并且同时支持Blocking和No-Blocking。</li><li>ET模型：和LT模式不同的是，通知之后进程必须立即处理事件，下次再调用epoll_wait()时不会再得到事件到达的通知。ET模式很大程度上减少了epoll事件被重复触发的次数，因此效率比LT模式要高。只支持No-Blocking，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</li></ol><p><img src="https://s1.ax1x.com/2020/03/15/881oqg.png" alt="881oqg.png"></p><h2><span id="应用场景">应用场景</span></h2><h3><span id="select应用场景">select应用场景</span></h3><p>select的timeout参数精度为1nm，比poll和epoll的1ms精度更高，因此select适合实时性要求比较高的场景。select的可移植性非常的好。</p><h3><span id="poll应用场景">poll应用场景</span></h3><p>poll没有最大描述符数量的限制，如果平台支持并且对实时性要求不高，应该使用poll而不是select</p><h3><span id="epoll应用场景">epoll应用场景</span></h3><p>只需要运行在linux平台下，有大量的描述符需要同时轮询，并且这些连接最好时长连接。在监听少量的描述符的适合，体现不出epoll的优势。</p><p>在需要监控的描述符状态变化多，而且都是非常短暂的，也没有必要使用epoll。因为epoll中的所有描述符都存储在内核中，造成了每次需要对描述符的状态改变都需要通过epoll_ctl()进行系统调用，频繁的系统调用降低了效率。并且因为epoll的描述符存储在内核中，不容易调试。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;IO复用&quot;&gt;&lt;a href=&quot;#IO复用&quot; class=&quot;headerlink&quot; title=&quot;IO复用&quot;&gt;&lt;/a&gt;IO复用&lt;/h2&gt;&lt;p&gt;select、poll、epoll都是IO复用的基本实现，select出现的最后，之后是poll，再是epoll。&lt;/p&gt;
&lt;h3 id=&quot;Select&quot;&gt;&lt;a href=&quot;#Select&quot; class=&quot;headerlink&quot; title=&quot;Select&quot;&gt;&lt;/a&gt;Select&lt;/h3&gt;&lt;p&gt;我们使用select就可以实现同时处理多个网络连接的IO请求，基本原理就是程序调用select，然后整个程序就进入阻塞状态，这个时候，kernel内核就会轮询检查所有select负责的文件描述符fd，当找到其中哪个数据准备好了文件描述符，会返回给select，select通知系统调用，将数据从内核复制到进程的缓存区。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>再读Sping源码一</title>
    <link href="http://yoursite.com/2020/03/14/%E5%86%8D%E8%AF%BBSpring%E6%BA%90%E7%A0%81%E4%B8%80/"/>
    <id>http://yoursite.com/2020/03/14/再读Spring源码一/</id>
    <published>2020-03-14T09:06:00.000Z</published>
    <updated>2020-03-22T13:49:36.160Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="applicationcontext的创建过程">ApplicationContext的创建过程</span></h2><p>在之前，我已经写过一篇关于BeanFactory的文章。但是在实际开发中，直接使用BeanFactory的场景还是比较少的，更多的时候是使用ApplicationContext。</p><p>那么下面我们就从<code>ApplicationContext context=new ClassPathXmlApplicationContext(&quot;beanFactoryTest.xml&quot;);</code>来探究ApplicationContext是如何启动的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(String configLocation)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="keyword">this</span>(<span class="keyword">new</span> String[] &#123;configLocation&#125;, <span class="keyword">true</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">String[] configLocations, <span class="keyword">boolean</span> refresh, @Nullable ApplicationContext parent)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">super</span>(parent);</span><br><span class="line">setConfigLocations(configLocations);</span><br><span class="line"><span class="keyword">if</span> (refresh) &#123;</span><br><span class="line">refresh();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>实例化ApplicatoinContext的关键就在于这个<code>refresh()</code>方法。我们来看一下具体实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line"><span class="comment">// 准备工作，初始化Spring的状态，使Spring进入运行状态</span></span><br><span class="line">prepareRefresh();</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化BeanFactory</span></span><br><span class="line">ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 准备bean工厂以供在此上下文中使用。</span></span><br><span class="line">prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//没有具体实现，谁要使用谁就实现，作用就是BeanFactory准备工作完成后做一些定制化的处理</span></span><br><span class="line">postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用工厂后处理器 </span></span><br><span class="line">invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册Bean后处理器</span></span><br><span class="line">registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化消息源：初始化容器的国际化信息资源</span></span><br><span class="line">initMessageSource();</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化应用上下文事件广播器</span></span><br><span class="line">initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化其它特殊的bean</span></span><br><span class="line">onRefresh();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册事件监听器</span></span><br><span class="line">registerListeners();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化所有的单例bean</span></span><br><span class="line">finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">//发布上下文刷新事件</span></span><br><span class="line">finishRefresh();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">logger.warn(<span class="string">"Exception encountered during context initialization - "</span> +</span><br><span class="line"><span class="string">"cancelling refresh attempt: "</span> + ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">destroyBeans();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reset 'active' flag.</span></span><br><span class="line">cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Propagate exception to caller.</span></span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">// Reset common introspection caches in Spring's core, since we</span></span><br><span class="line"><span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">resetCommonCaches();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>refresh()</code>方法中调用了许多其它的方法。下面我们就依次进入这些方法的实现中去探究一下，它们完成了什么工作。</p><h3><span id="准备工作preparerefresh">准备工作prepareRefresh()</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.startupDate = System.currentTimeMillis();</span><br><span class="line"><span class="comment">//设置context关闭状态，激活标志</span></span><br><span class="line">    <span class="keyword">this</span>.closed.set(<span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">this</span>.active.set(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 这个方法没有做任何事情，它的实现是空的。</span></span><br><span class="line"><span class="comment">设计这个方法是为了在启动之前替换一些属性占位符</span></span><br><span class="line"><span class="comment">这个地方是为了方便我们后期拓展</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">initPropertySources();</span><br><span class="line"><span class="comment">/*验证必须的属性是否正确</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">getEnvironment().validateRequiredProperties();</span><br><span class="line">    </span><br><span class="line"><span class="keyword">this</span>.earlyApplicationEvents = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="初始化beanfactory">初始化BeanFactory</span></h3><p>初始化BeanFactory的工作由下面这行代码完成：</p><p><code>ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title">obtainFreshBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">//初始化BeanFactory的工作实际由这个方法完成</span></span><br><span class="line">refreshBeanFactory();</span><br><span class="line"><span class="keyword">return</span> getBeanFactory();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (hasBeanFactory()) &#123;</span><br><span class="line">           <span class="comment">/*如果之前已经由BeanFactory了那么就销毁单例池中的bean</span></span><br><span class="line"><span class="comment">           关闭BeanFactory</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">destroyBeans();</span><br><span class="line">closeBeanFactory();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//创建容器对象</span></span><br><span class="line">DefaultListableBeanFactory beanFactory = createBeanFactory();</span><br><span class="line">           <span class="comment">//设置SerializationId</span></span><br><span class="line">beanFactory.setSerializationId(getId());</span><br><span class="line">           </span><br><span class="line">           <span class="comment">/*</span></span><br><span class="line"><span class="comment">           这个方法是一个钩子方法，</span></span><br><span class="line"><span class="comment">           子类可以覆盖它对当前上下文管理的BeanFactory进行自定义操作</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">customizeBeanFactory(beanFactory);</span><br><span class="line">           <span class="comment">/*装载配置文件，并传入相关联的BeanFacory对象</span></span><br><span class="line"><span class="comment">           作为BeanDefinition的容器</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">loadBeanDefinitions(beanFactory);</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanFactoryMonitor) &#123;</span><br><span class="line"><span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">"I/O error parsing bean definition source for "</span> + getDisplayName(), ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源代码我们可以看出，初始化BeanFactory的工作实际上是由<code>refreshBeanFactory()</code>完成的。它工作流程是这样的：</p><ol><li><p>首先判断BeanFactory是否已经存在了，如果已经存在，就销毁单例池和BeanFactory。否则继续执行BeanFactory的初始化工作</p></li><li><p>创建容器对象<code>DefaultListableBeanFactory</code>,这个对象非常的关键，它就是我们常说的IOC容器，稍后我们会探究创建容器对象的过程。</p></li><li><p>设置SerializationId</p></li><li><p>执行子类的钩子方法，可以对BeanFacotry进行自定义</p></li><li><p>装载配置文件，得到BeanDefinition，传入BeanFactory作为BeanDefintion的容器</p></li><li><p>完成BeanFactory的初始化工作</p></li></ol><p>整个工作流程中，比较关键的第五步。下面我们来仔细分析一下这一步背后的逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException, IOException </span>&#123;</span><br><span class="line"><span class="comment">// Create a new XmlBeanDefinitionReader for the given BeanFactory.</span></span><br><span class="line">XmlBeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Configure the bean definition reader with this context's</span></span><br><span class="line"><span class="comment">// resource loading environment.</span></span><br><span class="line">beanDefinitionReader.setEnvironment(<span class="keyword">this</span>.getEnvironment());</span><br><span class="line">beanDefinitionReader.setResourceLoader(<span class="keyword">this</span>);</span><br><span class="line">beanDefinitionReader.setEntityResolver(<span class="keyword">new</span> ResourceEntityResolver(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">initBeanDefinitionReader(beanDefinitionReader);</span><br><span class="line">loadBeanDefinitions(beanDefinitionReader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的背后涉及了许多解析配置文件的细节，这里我们就不深究了。总之这段代码的作用就是解析配置文件，得到BeanDefinition，然后将所有的BeanDefintioin存入<code>DefaultListableBeanFactory</code>类中的<code>Map&lt;String, BeanDefinition&gt; beanDefinitionMap</code>中，到此，我们已经拥有了创建Bean的描述信息BeanDefinition和BeanFactory。</p><h3><span id="准备beanfactory">准备BeanFactory</span></h3><p>准备BeanFactory的工作是由<code>prepareBeanFactory(beanFactory);</code>完成的。我们看一下它的具体实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 设置类加载器，存在则直接设置/不存在则新建一个默认类加载器</span></span><br><span class="line">beanFactory.setBeanClassLoader(getClassLoader());</span><br><span class="line">        <span class="comment">//设置EL表达式解析器，bean出书画完成后完成属性填充式可能会用到</span></span><br><span class="line">beanFactory.setBeanExpressionResolver(<span class="keyword">new</span> StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));</span><br><span class="line">        <span class="comment">//设置属性注册解析器PropertyEditor</span></span><br><span class="line">beanFactory.addPropertyEditorRegistrar(<span class="keyword">new</span> ResourceEditorRegistrar(<span class="keyword">this</span>, getEnvironment()));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用上下文回调配置bean工厂</span></span><br><span class="line">beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationContextAwareProcessor(<span class="keyword">this</span>));</span><br><span class="line"><span class="comment">//设置忽略自动装配的接口</span></span><br><span class="line">  beanFactory.ignoreDependencyInterface(EnvironmentAware.class);</span><br><span class="line">beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);</span><br><span class="line">beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);</span><br><span class="line">beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);</span><br><span class="line">beanFactory.ignoreDependencyInterface(MessageSourceAware.class);</span><br><span class="line">beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册可以解析的自动装配</span></span><br><span class="line">beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);</span><br><span class="line">beanFactory.registerResolvableDependency(ResourceLoader.class, <span class="keyword">this</span>);</span><br><span class="line">beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, <span class="keyword">this</span>);</span><br><span class="line">beanFactory.registerResolvableDependency(ApplicationContext.class, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将早期用于检测内部bean的后处理器注册为applicationlistener。</span></span><br><span class="line">beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationListenerDetector(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检测LoadTimeWeaver并准备编织(如果找到)。</span></span><br><span class="line"><span class="keyword">if</span> (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">beanFactory.addBeanPostProcessor(<span class="keyword">new</span> LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line"><span class="comment">// 为类型匹配设置一个临时类加载器。</span></span><br><span class="line">beanFactory.setTempClassLoader(<span class="keyword">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册缺省环境bean。</span></span><br><span class="line"><span class="keyword">if</span> (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) &#123;</span><br><span class="line">beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>准备BeanFactory主要做了这些事情：</p><ol><li>设置类加载器</li><li>设置EL表达式解析器</li><li>利用BeanPostProcessor的特性给各种Aware接口的实现类注入ApplicationContext中对应的属性</li><li>设置各种Aware接口的实现类为忽略自动装配</li><li>设置自动装配的类(BeanFactory，ResourceLoader，ApplicationEventPublisher，ApplicationContext)</li><li>如果BeanFactory中存在loadTimeWeaver的bean，那么需要添加动态织入功能。</li><li>注册各种可用组件（environment，systemProperties，systemEnvironment）</li></ol><h3><span id="允许用户在beanfactory准备工作完成之后做一些定制化处理">允许用户在BeanFactory准备工作完成之后做一些定制化处理</span></h3><p><code>postProcessBeanFactory(beanFactory);</code>这个方法Spring中并没有具体实现的，它允许用户对BeanFactory进行一些定制化的处理。</p><h3><span id="调用工厂后处理器">调用工厂后处理器</span></h3><p><code>invokeBeanFactoryPostProcessors(beanFactory);</code></p><p>根据反射机制从BeanDefintionRegistry中找出所有的BeanFactoryProcessor类型的Bean，并调用其postProcessBeanFactory()方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">invokeBeanFactoryPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*getBeanFactoryPostProcessors()拿到当前应用上下文beanFactoryPostProcessors变量中的值</span></span><br><span class="line"><span class="comment">invokeBeanFactoryPostProcessors实例化并调用所有已注册的BeanFactoryPostProcessors</span></span><br><span class="line"><span class="comment">*/</span>       </span><br><span class="line">       PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime</span></span><br><span class="line"><span class="comment">// (e.g. through an @Bean method registered by ConfigurationClassPostProcessor)</span></span><br><span class="line"><span class="keyword">if</span> (beanFactory.getTempClassLoader() == <span class="keyword">null</span> &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">beanFactory.addBeanPostProcessor(<span class="keyword">new</span> LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line">beanFactory.setTempClassLoader(<span class="keyword">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="注册bean后处理器">注册Bean后处理器</span></h3><p><code>registerBeanPostProcessors(beanFactory);</code></p><p>根据反射机制从BeanDefintionRegistry中找出所有BeanPostProcessor类型的bean，并将它们注册到容器Bean后处理器的注册表中。</p><h3><span id="初始化消息源初始化容器的国际化信息资源">初始化消息源：初始化容器的国际化信息资源</span></h3><p><code>initMessageSource();</code></p><h3><span id="初始化应用上下文事件广播器">初始化应用上下文事件广播器</span></h3><p><code>initApplicationEventMulticaster();</code></p><p>AbstractApplciationContext拥有一个applicationEventMulticaster 成员变量，applicationEventMulticaster 提供了容器监听器的注册表，成其为事件广播器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initApplicationEventMulticaster</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line">    <span class="comment">//首先看配置文件中有无配置该类型的类</span></span><br><span class="line"><span class="keyword">if</span> (beanFactory.containsLocalBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME)) &#123;</span><br><span class="line"><span class="keyword">this</span>.applicationEventMulticaster =</span><br><span class="line">beanFactory.getBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster.class);</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">"Using ApplicationEventMulticaster ["</span> + <span class="keyword">this</span>.applicationEventMulticaster + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果没有，则应用Spring框架提供的事件广播器实例</span></span><br><span class="line"><span class="keyword">this</span>.applicationEventMulticaster = <span class="keyword">new</span> SimpleApplicationEventMulticaster(beanFactory);</span><br><span class="line">beanFactory.registerSingleton(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, <span class="keyword">this</span>.applicationEventMulticaster);</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">"No '"</span> + APPLICATION_EVENT_MULTICASTER_BEAN_NAME + <span class="string">"' bean, using "</span> +</span><br><span class="line"><span class="string">"["</span> + <span class="keyword">this</span>.applicationEventMulticaster.getClass().getSimpleName() + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring初始化事件广播器，用户可以在配置文件中为容器定义一个自定义的事件广播器(Bean的名称必须是applicationEventMulticaster)，只要实现了ApplicationEventMulticaster即可，Spring会从beanFactory中自动获取，如果没有找到外部配置的事件广播器，Spring将使用其内置的SimpleApplicationEventMulticasterSimpleApplicationEventMulticaster</p><h3><span id="初始化其它特殊的bean">初始化其它特殊的bean</span></h3><p><code>onRefresh();</code></p><p>这个方法是一个钩爪方法。子类可以借助这个钩子方法执行一些特殊的操作。</p><p>比如<code>AbstractRefreshableWebApplicationContext</code>就通过这个方法完成了初始化ThemeSource的操作。</p><h3><span id="初始化事件监听器">初始化事件监听器</span></h3><p><code>registerListeners();</code></p><p>Spring从BeanDefinitionRegistry中找出所有实现ApplicationListener的bean，将BeanDefinition对象生成bean，注册为容器的事件监听器，实际的操作就是将器添加到事件广播器提供的监听器注册表中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerListeners</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// Register statically specified listeners first.</span></span><br><span class="line"><span class="keyword">for</span> (ApplicationListener&lt;?&gt; listener : getApplicationListeners()) &#123;</span><br><span class="line">getApplicationEventMulticaster().addApplicationListener(listener);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span></span><br><span class="line"><span class="comment">// uninitialized to let post-processors apply to them!</span></span><br><span class="line">String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">for</span> (String listenerBeanName : listenerBeanNames) &#123;</span><br><span class="line">getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Publish early application events now that we finally have a multicaster...</span></span><br><span class="line">Set&lt;ApplicationEvent&gt; earlyEventsToProcess = <span class="keyword">this</span>.earlyApplicationEvents;</span><br><span class="line"><span class="keyword">this</span>.earlyApplicationEvents = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (earlyEventsToProcess != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (ApplicationEvent earlyEvent : earlyEventsToProcess) &#123;</span><br><span class="line">getApplicationEventMulticaster().multicastEvent(earlyEvent);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="初始化所有的单例bean">初始化所有的单例bean</span></h3><p>实例化所有单例的bean，并将它们放入到Spring容器的缓存中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishBeanFactoryInitialization</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line"><span class="comment">// Initialize conversion service for this context.</span></span><br><span class="line"><span class="keyword">if</span> (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;</span><br><span class="line">beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) &#123;</span><br><span class="line">beanFactory.setConversionService(</span><br><span class="line">beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register a default embedded value resolver if no bean post-processor</span></span><br><span class="line"><span class="comment">// (such as a PropertyPlaceholderConfigurer bean) registered any before:</span></span><br><span class="line"><span class="comment">// at this point, primarily for resolution in annotation attribute values.</span></span><br><span class="line"><span class="keyword">if</span> (!beanFactory.hasEmbeddedValueResolver()) &#123;</span><br><span class="line">beanFactory.addEmbeddedValueResolver(strVal -&gt; getEnvironment().resolvePlaceholders(strVal));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early.</span></span><br><span class="line">String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">for</span> (String weaverAwareName : weaverAwareNames) &#123;</span><br><span class="line">getBean(weaverAwareName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Stop using the temporary ClassLoader for type matching.</span></span><br><span class="line">beanFactory.setTempClassLoader(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allow for caching all bean definition metadata, not expecting further changes.</span></span><br><span class="line">beanFactory.freezeConfiguration();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">beanFactory.preInstantiateSingletons();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="发布上下文刷新事件">发布上下文刷新事件</span></h3><p><code>finishRefresh();</code></p><p>创建上下文刷新事件，事件广播其负责将这些事件广播道每个注册事件监听器中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// Clear context-level resource caches (such as ASM metadata from scanning).</span></span><br><span class="line">clearResourceCaches();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize lifecycle processor for this context.</span></span><br><span class="line">initLifecycleProcessor();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Propagate refresh to lifecycle processor first.</span></span><br><span class="line">getLifecycleProcessor().onRefresh();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Publish the final event.</span></span><br><span class="line">publishEvent(<span class="keyword">new</span> ContextRefreshedEvent(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Participate in LiveBeansView MBean, if active.</span></span><br><span class="line">LiveBeansView.registerApplicationContext(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="getbean的过程">getBean的过程</span></h2><p>下面我将仔细分析这段代码的底层实现。</p><p><code>final MyTestBean bean = (MyTestBean) context.getBean(&quot;myTestBean&quot;);</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">       <span class="comment">//这个方法是空方法</span></span><br><span class="line">assertBeanFactoryActive();</span><br><span class="line"><span class="keyword">return</span> getBeanFactory().getBean(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="keyword">return</span> doGetBean(name, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最关键的就是这个方法了，下面我们分析一下它背后的逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doGetBean</span><span class="params">(<span class="keyword">final</span> String name, @Nullable <span class="keyword">final</span> Class&lt;T&gt; requiredType,</span></span></span><br><span class="line"><span class="function"><span class="params">@Nullable <span class="keyword">final</span> Object[] args, <span class="keyword">boolean</span> typeCheckOnly)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//拿到beanname</span></span><br><span class="line"><span class="keyword">final</span> String beanName = transformedBeanName(name);</span><br><span class="line">Object bean;</span><br><span class="line"></span><br><span class="line"><span class="comment">//检测单例池中手动注册的单例对象</span></span><br><span class="line">Object sharedInstance = getSingleton(beanName);</span><br><span class="line"><span class="keyword">if</span> (sharedInstance != <span class="keyword">null</span> &amp;&amp; args == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line"><span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">logger.trace(<span class="string">"Returning eagerly cached instance of singleton bean '"</span> + beanName +</span><br><span class="line"><span class="string">"' that is not fully initialized yet - a consequence of a circular reference"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">logger.trace(<span class="string">"Returning cached instance of singleton bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">           </span><br><span class="line">           </span><br><span class="line">           <span class="comment">/*</span></span><br><span class="line"><span class="comment">           如果shareInstance是普通的单例bean则直接返回；</span></span><br><span class="line"><span class="comment">           如果shareInstance是FactoryBean类型，则需要调用getObject工厂方法获取真正的bean实例；</span></span><br><span class="line"><span class="comment">           如果用户想要获取FactoryBean则不做特殊处理</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/*Spring只能解决单例对象的setter注入的循环依赖，不能解决构造注入，</span></span><br><span class="line"><span class="comment">也不能解决多例的循环依赖*/</span></span><br><span class="line"><span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检测是否有父工厂</span></span><br><span class="line">BeanFactory parentBeanFactory = getParentBeanFactory();</span><br><span class="line">           </span><br><span class="line">           <span class="comment">//如果存在父工厂且当前bean工厂不存在当前bean的定义，那么bean定义存在父工厂中</span></span><br><span class="line"><span class="keyword">if</span> (parentBeanFactory != <span class="keyword">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line"><span class="comment">// 获取bean的原始名称</span></span><br><span class="line">String nameToLookup = originalBeanName(name);</span><br><span class="line">               <span class="comment">//若为AbstractBeanFactory类型，委托父类处理</span></span><br><span class="line"><span class="keyword">if</span> (parentBeanFactory <span class="keyword">instanceof</span> AbstractBeanFactory) &#123;</span><br><span class="line"><span class="keyword">return</span> ((AbstractBeanFactory) parentBeanFactory).doGetBean(</span><br><span class="line">nameToLookup, requiredType, args, typeCheckOnly);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 委托到构造函数getBean处理</span></span><br><span class="line"><span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (requiredType != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="comment">//委托给标准getBean处理</span></span><br><span class="line"><span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">           </span><br><span class="line">           <span class="comment">/*</span></span><br><span class="line"><span class="comment">           typeCheckOnly是用来判断调用getBean仅仅进行类型检查获取bean对象</span></span><br><span class="line"><span class="comment">           如果不是仅仅只做类型检查，而是创建bean对象，则需要调用markBeanAsCreated</span></span><br><span class="line"><span class="comment">           进行记录</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line"><span class="keyword">if</span> (!typeCheckOnly) &#123;</span><br><span class="line">markBeanAsCreated(beanName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">               </span><br><span class="line">               <span class="comment">/*从容器中或取beanName对应的GenericBeanDefinition对象，并将其转化为RootBeanDefinition对象</span></span><br><span class="line"><span class="comment">               */</span></span><br><span class="line">               </span><br><span class="line"><span class="keyword">final</span> RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">               <span class="comment">//检查当前创建的bean定义是不是抽象的bean定义</span></span><br><span class="line">checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理dependsOn依赖</span></span><br><span class="line">               <span class="comment">//获取所依赖的bean的名称</span></span><br><span class="line">String[] dependsOn = mbd.getDependsOn();</span><br><span class="line"><span class="keyword">if</span> (dependsOn != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (String dep : dependsOn) &#123;</span><br><span class="line"><span class="keyword">if</span> (isDependent(beanName, dep)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">"Circular depends-on relationship between '"</span> + beanName + <span class="string">"' and '"</span> + dep + <span class="string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line">                       <span class="comment">//保存bean直接的依赖关系</span></span><br><span class="line">registerDependentBean(dep, beanName);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">                           <span class="comment">//获取依赖的bean（如果依赖的bean没有被创建，那么这个时候就被创建了）</span></span><br><span class="line">getBean(dep);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">"'"</span> + beanName + <span class="string">"' depends on missing bean '"</span> + dep + <span class="string">"'"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//是单例，则创建单例bean</span></span><br><span class="line"><span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">                           <span class="comment">//创建bean</span></span><br><span class="line"><span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line"><span class="comment">//创建bean的过程中发生异常，需要销毁关于当前bean的所有信息</span></span><br><span class="line">destroySingleton(beanName);</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">                   </span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">           如果shareInstance是普通的单例bean则直接返回；</span></span><br><span class="line"><span class="comment">           如果shareInstance是FactoryBean类型，则需要调用getObject工厂方法获取真正的bean实例；</span></span><br><span class="line"><span class="comment">           如果用户想要获取FactoryBean则不做特殊处理</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">               <span class="comment">//如果是多例模式</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line"><span class="comment">// It's a prototype -&gt; create a new instance.</span></span><br><span class="line">Object prototypeInstance = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">beforePrototypeCreation(beanName);</span><br><span class="line">prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">afterPrototypeCreation(beanName);</span><br><span class="line">&#125;</span><br><span class="line">bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">String scopeName = mbd.getScope();</span><br><span class="line"><span class="keyword">final</span> Scope scope = <span class="keyword">this</span>.scopes.get(scopeName);</span><br><span class="line"><span class="keyword">if</span> (scope == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No Scope registered for scope name '"</span> + scopeName + <span class="string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Object scopedInstance = scope.get(beanName, () -&gt; &#123;</span><br><span class="line">beforePrototypeCreation(beanName);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">afterPrototypeCreation(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName,</span><br><span class="line"><span class="string">"Scope '"</span> + scopeName + <span class="string">"' is not active for the current thread; consider "</span> +</span><br><span class="line"><span class="string">"defining a scoped proxy for this bean if you intend to refer to it from a singleton"</span>,</span><br><span class="line">ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">cleanupAfterBeanCreationFailure(beanName);</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check if required type matches the type of the actual bean instance.</span></span><br><span class="line"><span class="keyword">if</span> (requiredType != <span class="keyword">null</span> &amp;&amp; !requiredType.isInstance(bean)) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType);</span><br><span class="line"><span class="keyword">if</span> (convertedBean == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> convertedBean;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (TypeMismatchException ex) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">"Failed to convert bean '"</span> + name + <span class="string">"' to required type '"</span> +</span><br><span class="line">ClassUtils.getQualifiedName(requiredType) + <span class="string">"'"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (T) bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="拿到beanname">拿到BeanName</span></h3><p><code>final String beanName = transformedBeanName(name);</code></p><h3><span id="尝试从缓存中获取对象">尝试从缓存中获取对象</span></h3><p><code>Object sharedInstance = getSingleton(beanName);</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, <span class="keyword">boolean</span> allowEarlyReference)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//从单例池中获取单例对象</span></span><br><span class="line">Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">           <span class="comment">//单例池中没有该单例对象，且该单例正在创建过程中</span></span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">               <span class="comment">//从提前暴露单例池中获取实例化的单例对象</span></span><br><span class="line">singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">                   <span class="comment">//依然未获取到，就去获取单例工厂</span></span><br><span class="line">ObjectFactory&lt;?&gt; singletonFactory = <span class="keyword">this</span>.singletonFactories.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">                       <span class="comment">//使用工厂方法获取单例对象，这个时候单例对象仅仅实例化</span></span><br><span class="line">                       <span class="comment">//在这个过程中还会调用getEarlyBeanReference()进行后置处理</span></span><br><span class="line">singletonObject = singletonFactory.getObject();</span><br><span class="line">                       <span class="comment">//加入提前暴露单例池</span></span><br><span class="line"><span class="keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">                       <span class="comment">//从单例工厂Map中删除该单例工厂</span></span><br><span class="line"><span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> singletonObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法的整个流程是这个样子的：</p><ol><li>首先尝试直接从单例池中获取，如果获取到了就直接返回。</li><li>从单例池中没有获取到且该bean正在创建过程中，就尝试从提前暴露单例池中获取，获取到了直接返回。</li><li>如果提前暴露单例池中也没有，且允许提前暴露，就去获取该bean对应的bean工厂。</li><li>拿到bean工厂后通过bean工厂实例化bean，并加入提前暴露单例池，并从工厂池中删除该工厂。</li></ol><p><strong>这个方法中涉及到了Spring中非常重要的三级缓存机制，它用来解决循环依赖问题。首先尝试从一级缓存（单例池singletonObjects）中获取，如果获取不到就取二级缓存（提前暴露单例池earlySingletonObjects）中获取，二级缓存中的对象只是一个早期对象，这些对象都是刚刚实例化的对象，还没进行属性赋值等工作。如果二级缓存中依赖没有找到，那么就从三级缓存（singletonFactories）中获取，在getBean过程中调用构造方式实例化的适合，会把早期对象包裹成一个ObjectFactory暴露到三级缓存中</strong></p><p><em>通过分析代码流程，我们可以看处这个方法是会返回空的，并且这个时候但会的bean并不完整，还未进行属性注入等工作</em></p><h3><span id="从头开始合并bean定义">从头开始，合并Bean定义</span></h3><p>但调用<code>getSingleton</code>方法并没有拿到bean的时候，就需要从头开始。创建一个bean的第一步就是拿到描述bean的信息即BeanDefinition。因为继承的存在，所以完整的Bean定义信息有一部分还在父类中，因此需要合并父类定义信息。</p><p><code>final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</code></p><p>它的具体实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> RootBeanDefinition <span class="title">getMergedLocalBeanDefinition</span><span class="params">(String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="comment">//首先尝试从缓存中获取</span></span><br><span class="line">RootBeanDefinition mbd = <span class="keyword">this</span>.mergedBeanDefinitions.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (mbd != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> mbd;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> getMergedBeanDefinition(beanName, getBeanDefinition(beanName));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先尝试从缓存中获取合并后的Bean定义信息，如果缓存中没有，最终调用了这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> RootBeanDefinition <span class="title">getMergedBeanDefinition</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">String beanName, BeanDefinition bd, @Nullable BeanDefinition containingBd)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.mergedBeanDefinitions) &#123;</span><br><span class="line">RootBeanDefinition mbd = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check with full lock now in order to enforce the same merged instance.</span></span><br><span class="line"><span class="keyword">if</span> (containingBd == <span class="keyword">null</span>) &#123;</span><br><span class="line">mbd = <span class="keyword">this</span>.mergedBeanDefinitions.get(beanName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mbd == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//如果没有父类配置</span></span><br><span class="line"><span class="keyword">if</span> (bd.getParentName() == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// Use copy of given root bean definition.</span></span><br><span class="line"><span class="keyword">if</span> (bd <span class="keyword">instanceof</span> RootBeanDefinition) &#123;</span><br><span class="line">                        <span class="comment">//直接将原来的Bean定义升级为RootBeanDefinition，完成合并</span></span><br><span class="line">mbd = ((RootBeanDefinition) bd).cloneBeanDefinition();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//包裹为RootBeanDefinition</span></span><br><span class="line">mbd = <span class="keyword">new</span> RootBeanDefinition(bd);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//有父类定义</span></span><br><span class="line">BeanDefinition pbd;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//获取父类bean的名称</span></span><br><span class="line">String parentBeanName = transformedBeanName(bd.getParentName());</span><br><span class="line">                        <span class="comment">/*</span></span><br><span class="line"><span class="comment">                        如果父类beanName与子类beanName名称相同，</span></span><br><span class="line"><span class="comment">                        则父类bean一定在父容器中</span></span><br><span class="line"><span class="comment">                        */</span></span><br><span class="line"><span class="keyword">if</span> (!beanName.equals(parentBeanName)) &#123;</span><br><span class="line">pbd = getMergedBeanDefinition(parentBeanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                             * 这里再次调用getMergedBeanDefinition，只不过参数值变为了</span></span><br><span class="line"><span class="comment">                             * parentBeanName，用于合并父BeanDefinition 和爷爷辈的</span></span><br><span class="line"><span class="comment">                             * BeanDefinition。如果爷爷辈的BeanDefinition仍有父</span></span><br><span class="line"><span class="comment">                             * BeanDefinition，则继续合并</span></span><br><span class="line"><span class="comment">                             */</span></span><br><span class="line">BeanFactory parent = getParentBeanFactory();</span><br><span class="line"><span class="keyword">if</span> (parent <span class="keyword">instanceof</span> ConfigurableBeanFactory) &#123;</span><br><span class="line">pbd = ((ConfigurableBeanFactory) parent).getMergedBeanDefinition(parentBeanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> NoSuchBeanDefinitionException(parentBeanName,</span><br><span class="line"><span class="string">"Parent name '"</span> + parentBeanName + <span class="string">"' is equal to bean name '"</span> + beanName +</span><br><span class="line"><span class="string">"': cannot be resolved without an AbstractBeanFactory parent"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(bd.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">"Could not resolve parent bean definition '"</span> + bd.getParentName() + <span class="string">"'"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 以父类BeanDefintion的配置信息为基本创建RootBeanDefinition</span></span><br><span class="line">mbd = <span class="keyword">new</span> RootBeanDefinition(pbd);</span><br><span class="line">                    <span class="comment">//用子类的BeanDefintion中的属性覆盖父BeanDefintion中的属性</span></span><br><span class="line">mbd.overrideFrom(bd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//如果用户未配置scope，则设置未singleton</span></span><br><span class="line"><span class="keyword">if</span> (!StringUtils.hasLength(mbd.getScope())) &#123;</span><br><span class="line">mbd.setScope(RootBeanDefinition.SCOPE_SINGLETON);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (containingBd != <span class="keyword">null</span> &amp;&amp; !containingBd.isSingleton() &amp;&amp; mbd.isSingleton()) &#123;</span><br><span class="line">mbd.setScope(containingBd.getScope());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (containingBd == <span class="keyword">null</span> &amp;&amp; isCacheBeanMetadata()) </span><br><span class="line">                    <span class="comment">//缓存合并后的BeanDefintion</span></span><br><span class="line"><span class="keyword">this</span>.mergedBeanDefinitions.put(beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> mbd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="处理dependson依赖">处理DependsOn依赖</span></h3><p>DependsOn依赖是bean创建前后的依赖。</p><p>整个DependsOn依赖的处理主要是<code>doGetBean</code>方法中的这段代码完成的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">String[] dependsOn = mbd.getDependsOn();</span><br><span class="line"><span class="keyword">if</span> (dependsOn != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (String dep : dependsOn) &#123;</span><br><span class="line"><span class="keyword">if</span> (isDependent(beanName, dep)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">"Circular depends-on relationship between '"</span> + beanName + <span class="string">"' and '"</span> + dep + <span class="string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line">registerDependentBean(dep, beanName);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">getBean(dep);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">"'"</span> + beanName + <span class="string">"' depends on missing bean '"</span> + dep + <span class="string">"'"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从BeanDefintion中获取到DependsOn依赖的bean信息后。依次遍历调用<code>isDependent</code>方法。它的实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isDependent</span><span class="params">(String beanName, String dependentBeanName)</span> </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.dependentBeanMap) &#123;</span><br><span class="line"><span class="keyword">return</span> isDependent(beanName, dependentBeanName, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isDependent</span><span class="params">(String beanName, String dependentBeanName, @Nullable Set&lt;String&gt; alreadySeen)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//alreadySeen中存放的是已经检查的依赖bean</span></span><br><span class="line"><span class="keyword">if</span> (alreadySeen != <span class="keyword">null</span> &amp;&amp; alreadySeen.contains(beanName)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//获取原始beanName</span></span><br><span class="line">String canonicalName = canonicalName(beanName);</span><br><span class="line">    <span class="comment">//获取当前bean所依赖的bean的名称的集合</span></span><br><span class="line">Set&lt;String&gt; dependentBeans = <span class="keyword">this</span>.dependentBeanMap.get(canonicalName);</span><br><span class="line"><span class="keyword">if</span> (dependentBeans == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//不依赖任何的前置bean，则直接返回</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (dependentBeans.contains(dependentBeanName)) &#123;</span><br><span class="line">            <span class="comment">//说明已经存在已经注册的bean</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//递归检查依赖</span></span><br><span class="line"><span class="keyword">for</span> (String transitiveDependency : dependentBeans) &#123;</span><br><span class="line"><span class="keyword">if</span> (alreadySeen == <span class="keyword">null</span>) &#123;</span><br><span class="line">alreadySeen = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line">            <span class="comment">//添加到areadySeen</span></span><br><span class="line">alreadySeen.add(beanName);</span><br><span class="line">            <span class="comment">//递归检查依赖</span></span><br><span class="line"><span class="keyword">if</span> (isDependent(transitiveDependency, dependentBeanName, alreadySeen)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用<code>registerDependentBean</code>保存bean直接的依赖关系。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerDependentBean</span><span class="params">(String beanName, String dependentBeanName)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取原始的beanName</span></span><br><span class="line">String canonicalName = canonicalName(beanName);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加 &lt;canonicalName, dependentBeanName&gt; 到 dependentBeanMap 中</span></span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.dependentBeanMap) &#123;</span><br><span class="line">Set&lt;String&gt; dependentBeans =</span><br><span class="line"><span class="keyword">this</span>.dependentBeanMap.computeIfAbsent(canonicalName, k -&gt; <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="number">8</span>));</span><br><span class="line"><span class="keyword">if</span> (!dependentBeans.add(dependentBeanName)) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加 &lt;dependentBeanName, canonicalName&gt; 到 dependenciesForBeanMap 中</span></span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.dependenciesForBeanMap) &#123;</span><br><span class="line">Set&lt;String&gt; dependenciesForBean =</span><br><span class="line"><span class="keyword">this</span>.dependenciesForBeanMap.computeIfAbsent(dependentBeanName, k -&gt; <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="number">8</span>));</span><br><span class="line">dependenciesForBean.add(canonicalName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后调用<code>getBean</code>方法，获取所依赖的Bean（若该bean没创建，就创建）。</p><h3><span id="处理单例bean">处理单例Bean</span></h3><p>处理单实例的bean主要是由这段代码完成的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">destroySingleton(beanName);</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>从这段代码我们可以看出关键在于<code>getSingleton</code>方法.下面我们来看它的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> </span>&#123;</span><br><span class="line">Assert.notNull(beanName, <span class="string">"Bean name must not be null"</span>);</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">            <span class="comment">//尝试从单例池(一级缓存)中获取</span></span><br><span class="line">Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//单例池中没有</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.singletonsCurrentlyInDestruction) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationNotAllowedException(beanName,</span><br><span class="line"><span class="string">"Singleton bean creation not allowed while singletons of this factory are in destruction "</span> +</span><br><span class="line"><span class="string">"(Do not request a bean from a BeanFactory in a destroy method implementation!)"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Creating shared instance of singleton bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line">                <span class="comment">//标记当前bean正在创建</span></span><br><span class="line">beforeSingletonCreation(beanName);</span><br><span class="line"><span class="keyword">boolean</span> newSingleton = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">boolean</span> recordSuppressedExceptions = (<span class="keyword">this</span>.suppressedExceptions == <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line"><span class="keyword">this</span>.suppressedExceptions = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//创建bean</span></span><br><span class="line">singletonObject = singletonFactory.getObject();</span><br><span class="line">newSingleton = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line"><span class="comment">//回调singletonObjects的get方法</span></span><br><span class="line">singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeanCreationException ex) &#123;</span><br><span class="line"><span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line"><span class="keyword">for</span> (Exception suppressedException : <span class="keyword">this</span>.suppressedExceptions) &#123;</span><br><span class="line">ex.addRelatedCause(suppressedException);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line"><span class="keyword">this</span>.suppressedExceptions = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">                    <span class="comment">//后置处理，将当前bean从正在创建集合中移除</span></span><br><span class="line">afterSingletonCreation(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (newSingleton) &#123;</span><br><span class="line">                    <span class="comment">//加入单例池</span></span><br><span class="line">addSingleton(beanName, singletonObject);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> singletonObject;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个过程中，比较关键的在于<code>singletonFactory.getObject();</code></p><p>这个<code>getObject</code>实际上是调用了<code>createBean</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">"Creating instance of bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line">RootBeanDefinition mbdToUse = mbd;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Make sure bean class is actually resolved at this point, and</span></span><br><span class="line"><span class="comment">// clone the bean definition in case of a dynamically resolved Class</span></span><br><span class="line"><span class="comment">// which cannot be stored in the shared merged bean definition.</span></span><br><span class="line">Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);</span><br><span class="line"><span class="keyword">if</span> (resolvedClass != <span class="keyword">null</span> &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != <span class="keyword">null</span>) &#123;</span><br><span class="line">mbdToUse = <span class="keyword">new</span> RootBeanDefinition(mbd);</span><br><span class="line">mbdToUse.setBeanClass(resolvedClass);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Prepare method overrides.</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">mbdToUse.prepareMethodOverrides();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(mbdToUse.getResourceDescription(),</span><br><span class="line">beanName, <span class="string">"Validation of method overrides failed"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.</span></span><br><span class="line">Object bean = resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line"><span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbdToUse.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">"BeanPostProcessor before instantiation of bean failed"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Object beanInstance = doCreateBean(beanName, mbdToUse, args);</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">"Finished creating instance of bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> beanInstance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeanCreationException | ImplicitlyAppearedSingletonException ex) &#123;</span><br><span class="line"><span class="comment">// A previously detected exception with proper bean creation context already,</span></span><br><span class="line"><span class="comment">// or illegal singleton state to be communicated up to DefaultSingletonBeanRegistry.</span></span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">mbdToUse.getResourceDescription(), beanName, <span class="string">"Unexpected exception during bean creation"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>真正完成bean创建的是<code>doCreateBean</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> @Nullable Object[] args)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BeanWrapper是bean包装器，包装bean对象和属性描述器</span></span><br><span class="line">BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">            <span class="comment">//从没有完成的FactoryBean中移除</span></span><br><span class="line">instanceWrapper = <span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//使用合适的实例化策略进行实例化</span></span><br><span class="line">instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//拿到刚刚实例化的早期bean</span></span><br><span class="line"><span class="keyword">final</span> Object bean = instanceWrapper.getWrappedInstance();</span><br><span class="line">Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();</span><br><span class="line"><span class="keyword">if</span> (beanType != NullBean.class) &#123;</span><br><span class="line">mbd.resolvedTargetType = beanType;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allow post-processors to modify the merged bean definition.</span></span><br><span class="line"><span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;</span><br><span class="line"><span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//进行后置处理@AutoWired的注解的预解析</span></span><br><span class="line">applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">"Post-processing of merged bean definition failed"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">mbd.postProcessed = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断该对象是否可以早期暴露</span></span><br><span class="line"><span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">isSingletonCurrentlyInCreation(beanName));</span><br><span class="line"><span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">"Eagerly caching bean '"</span> + beanName +</span><br><span class="line"><span class="string">"' to allow for resolving potential circular references"</span>);</span><br><span class="line">&#125;</span><br><span class="line">            <span class="comment">//将早期暴露对象包装未一个SingletonFactory，存放到三级缓存中</span></span><br><span class="line">addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize the bean instance.</span></span><br><span class="line">Object exposedObject = bean;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//进行属性赋值（调用set方法进行赋值）</span></span><br><span class="line">populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">            <span class="comment">//进行bean的初始化，这里可能生成代理对象</span></span><br><span class="line">exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;</span><br><span class="line"><span class="keyword">throw</span> (BeanCreationException) ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">mbd.getResourceDescription(), beanName, <span class="string">"Initialization of bean failed"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果允许早期引用</span></span><br><span class="line"><span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 去缓存中获取到我们的对象 由于传递的allowEarlyReference 是false 要求只能在一级二级缓存中去获取</span></span><br><span class="line"><span class="comment">             * 正常普通的bean(不存在循环依赖的bean) 创建的过程中，压根不会把三级缓存提升到二级缓存中</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">Object earlySingletonReference = getSingleton(beanName, <span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">//能够获取到</span></span><br><span class="line"><span class="keyword">if</span> (earlySingletonReference != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//经过后置处理的bean和早期bean引用还相等的话，表示当前bean没有被代理过</span></span><br><span class="line"><span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">exposedObject = earlySingletonReference;</span><br><span class="line">&#125;</span><br><span class="line">                <span class="comment">//处理依赖bean</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br><span class="line">String[] dependentBeans = getDependentBeans(beanName);</span><br><span class="line">Set&lt;String&gt; actualDependentBeans = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(dependentBeans.length);</span><br><span class="line"><span class="keyword">for</span> (String dependentBean : dependentBeans) &#123;</span><br><span class="line"><span class="keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">actualDependentBeans.add(dependentBean);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName,</span><br><span class="line"><span class="string">"Bean with name '"</span> + beanName + <span class="string">"' has been injected into other beans ["</span> +</span><br><span class="line">StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +</span><br><span class="line"><span class="string">"] in its raw version as part of a circular reference, but has eventually been "</span> +</span><br><span class="line"><span class="string">"wrapped. This means that said other beans do not use the final version of the "</span> +</span><br><span class="line"><span class="string">"bean. This is often the result of over-eager type matching - consider using "</span> +</span><br><span class="line"><span class="string">"'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example."</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="根据shareinstance获取真正bean">根据ShareInstance获取真正bean</span></h3><p>在<code>doGetBean</code>方法中我们多次看到<code>bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</code></p><p>之所以要不是直接返回<code>ShareInstance</code>，是因为可能拿到的bean是一个FactoryBean的bean，需要调用getBean方法，才能拿到真正的bean。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getObjectForBeanInstance</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">Object beanInstance, String name, String beanName, @Nullable RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果name以&amp;开头，但beanInstance却不是FactoryBean，则认为有问题</span></span><br><span class="line"><span class="keyword">if</span> (BeanFactoryUtils.isFactoryDereference(name)) &#123;</span><br><span class="line"><span class="keyword">if</span> (beanInstance <span class="keyword">instanceof</span> NullBean) &#123;</span><br><span class="line"><span class="keyword">return</span> beanInstance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!(beanInstance <span class="keyword">instanceof</span> FactoryBean)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanIsNotAFactoryException(transformedBeanName(name), beanInstance.getClass());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如果上面的判断通过了，则表明beanInstance可能是一个普通的bean，页可能是一个FactoryBean，</span></span><br><span class="line"><span class="comment">如果是一个不同bean，这里直接返回即可</span></span><br><span class="line"><span class="comment">如果是FactoryBean，则要调用工厂方法生成一个bean</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span> (!(beanInstance <span class="keyword">instanceof</span> FactoryBean) || BeanFactoryUtils.isFactoryDereference(name)) &#123;</span><br><span class="line"><span class="keyword">return</span> beanInstance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object object = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (mbd == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            如果mbd未空，则从缓存中加载bean，FactoryBean生成的单例bean会被缓存</span></span><br><span class="line"><span class="comment">            在factoryBeanObjectCache集合中，不会每次都创建</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">object = getCachedObjectForFactoryBean(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (object == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//经过前面的判断，这里可以断定beanInstance是FactoryBean类型的</span></span><br><span class="line">FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) beanInstance;</span><br><span class="line"><span class="comment">//如果mbd为空，则判断是否存在名字beanName的BeanDefiniton</span></span><br><span class="line"><span class="keyword">if</span> (mbd == <span class="keyword">null</span> &amp;&amp; containsBeanDefinition(beanName)) &#123;</span><br><span class="line">mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">&#125;</span><br><span class="line">            </span><br><span class="line"><span class="keyword">boolean</span> synthetic = (mbd != <span class="keyword">null</span> &amp;&amp; mbd.isSynthetic());</span><br><span class="line">            <span class="comment">//调用getObjectFromFactoryBean方法继续和获取实例</span></span><br><span class="line">object = getObjectFromFactoryBean(factory, beanName, !synthetic);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后调用<code>getObjectFromFactoryBean(factory, beanName, !synthetic);</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getObjectFromFactoryBean</span><span class="params">(FactoryBean&lt;?&gt; factory, String beanName, <span class="keyword">boolean</span> shouldPostProcess)</span> </span>&#123;</span><br><span class="line">           <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * FactoryBean 也有单例和非单例之分，针对不同类型的 FactoryBean，这里有两种处理方式：</span></span><br><span class="line"><span class="comment">             *   1. 单例 FactoryBean 生成的 bean 实例也认为是单例类型。需放入缓存中，供后续重复使用</span></span><br><span class="line"><span class="comment">             *   2. 非单例 FactoryBean 生成的 bean 实例则不会被放入缓存中，每次都会创建新的实例</span></span><br><span class="line"><span class="comment">             **/</span></span><br><span class="line">        <span class="keyword">if</span> (factory.isSingleton() &amp;&amp; containsSingleton(beanName)) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (getSingletonMutex()) &#123;</span><br><span class="line">                <span class="comment">//从缓存中取bean实例，避免多次创建bean实例</span></span><br><span class="line">                Object object = <span class="keyword">this</span>.factoryBeanObjectCache.get(beanName);</span><br><span class="line">                <span class="keyword">if</span> (object == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//使用工厂对象中创建实例</span></span><br><span class="line">                    object = doGetObjectFromFactoryBean(factory, beanName);</span><br><span class="line">                    <span class="comment">// Only post-process and store if not put there already during getObject() call above</span></span><br><span class="line">                    <span class="comment">// (e.g. because of circular reference processing triggered by custom getBean calls)</span></span><br><span class="line">                    Object alreadyThere = <span class="keyword">this</span>.factoryBeanObjectCache.get(beanName);</span><br><span class="line">                    <span class="keyword">if</span> (alreadyThere != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        object = alreadyThere;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (shouldPostProcess) &#123;</span><br><span class="line">                            <span class="comment">//判断当地的bean是否正在创建</span></span><br><span class="line">                            <span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">                                <span class="comment">// Temporarily return non-post-processed object, not storing it yet..</span></span><br><span class="line">                                <span class="keyword">return</span> object;</span><br><span class="line">                            &#125;</span><br><span class="line">                            beforeSingletonCreation(beanName);</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                object = postProcessObjectFromFactoryBean(object, beanName);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                                <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName,</span><br><span class="line">                                        <span class="string">"Post-processing of FactoryBean's singleton object failed"</span>, ex);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">finally</span> &#123;</span><br><span class="line">                                afterSingletonCreation(beanName);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 这里的beanName对应于FactoryBean的实现类，FactoryBean的实现类也会被实例化，并被缓存在singletonObjects中</span></span><br><span class="line">                        <span class="keyword">if</span> (containsSingleton(beanName)) &#123;</span><br><span class="line">                            <span class="comment">// 这里的beanName对应于FactoryBean的实现类，FactoryBean的实现类也会被实例化，并被缓存在singletonObjects中</span></span><br><span class="line">                            <span class="keyword">this</span>.factoryBeanObjectCache.put(beanName, object);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> object;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Object object = doGetObjectFromFactoryBean(factory, beanName);</span><br><span class="line">            <span class="keyword">if</span> (shouldPostProcess) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    object = postProcessObjectFromFactoryBean(object, beanName);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName, <span class="string">"Post-processing of FactoryBean's object failed"</span>, ex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> object;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>使用工厂对象创建实例<code>object=doGetObjectFromFactoryBean(factory,beanName)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">doGetObjectFromFactoryBean</span><span class="params">(<span class="keyword">final</span> FactoryBean&lt;?&gt; factory, <span class="keyword">final</span> String beanName)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Object object;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                AccessControlContext acc = getAccessControlContext();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    object = AccessController.doPrivileged((PrivilegedExceptionAction&lt;Object&gt;) factory::getObject, acc);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (PrivilegedActionException pae) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> pae.getException();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//真正的调用工厂bean的getObject()方法</span></span><br><span class="line">                object = factory.getObject();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (FactoryBeanNotInitializedException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName, ex.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName, <span class="string">"FactoryBean threw exception on object creation"</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Do not accept a null value for a FactoryBean that's not fully</span></span><br><span class="line">        <span class="comment">// initialized yet: Many FactoryBeans just return null then.</span></span><br><span class="line">        <span class="keyword">if</span> (object == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(</span><br><span class="line">                        beanName, <span class="string">"FactoryBean which is currently in creation returned null from getObject"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            object = <span class="keyword">new</span> NullBean();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3><span id="流程图">流程图</span></h3><p><img src="https://s1.ax1x.com/2020/03/14/8QHPCd.png" alt="8QHPCd.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;ApplicationContext的创建过程&quot;&gt;&lt;a href=&quot;#ApplicationContext的创建过程&quot; class=&quot;headerlink&quot; title=&quot;ApplicationContext的创建过程&quot;&gt;&lt;/a&gt;ApplicationContext的创建过程&lt;/h2&gt;&lt;p&gt;在之前，我已经写过一篇关于BeanFactory的文章。但是在实际开发中，直接使用BeanFactory的场景还是比较少的，更多的时候是使用ApplicationContext。&lt;/p&gt;
&lt;p&gt;那么下面我们就从&lt;code&gt;ApplicationContext context=new ClassPathXmlApplicationContext(&amp;quot;beanFactoryTest.xml&amp;quot;);&lt;/code&gt;来探究ApplicationContext是如何启动的。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ClassPathXmlApplicationContext&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String configLocation)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; BeansException &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; String[] &amp;#123;configLocation&amp;#125;, &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ClassPathXmlApplicationContext&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;		String[] configLocations, &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; refresh, @Nullable ApplicationContext parent)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; BeansException &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt;(parent);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	setConfigLocations(configLocations);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (refresh) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		refresh();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>JDK8新特性详解</title>
    <link href="http://yoursite.com/2020/03/09/JDK8%E6%96%B0%E7%89%B9%E6%80%A7%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2020/03/09/JDK8新特性详解/</id>
    <published>2020-03-09T13:37:00.000Z</published>
    <updated>2020-03-09T13:37:35.281Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="jdk8新特性详解">JDK8新特性详解</span></h2><p>JDK8主要引入了这些新特性：</p><ol><li>接口的默认实现</li><li>Lambda表达式</li><li>函数式接口</li><li>方法与构造函数引用</li><li>内置了许多函数式接口</li><li>Stream流</li></ol><a id="more"></a><h3><span id="接口的默认实现">接口的默认实现</span></h3><p>jdk8允许我们给接口添加一个非抽象的方法实现，只需要使用default关键字接口，这个特性又叫做拓展方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Formula</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">double</span> <span class="title">sqrt</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.sqrt(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个接口同时定义了两个方法<code>calculate</code>和<code>sqrt</code>.只不过<code>sqrt</code>方法拥有自己的默认实现。</p><h3><span id="lambda表达式">Lambda表达式</span></h3><p>在老版本中我们对一个list进行排序，我们一般需要这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; names = Arrays.asList(<span class="string">"peter"</span>, <span class="string">"anna"</span>, <span class="string">"mike"</span>, <span class="string">"xenia"</span>);</span><br><span class="line"></span><br><span class="line">Collections.sort(names, <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b.compareTo(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>通过JDK8之后提供的Lambda表达式，可以避免使用匿名对象，可以这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(names, (String a, String b) -&gt; b.compareTo(a));</span><br><span class="line"><span class="comment">//编译器可以自动推导参数类型，所以我们甚至不需要写参数类型</span></span><br><span class="line">Collections.sort(names, (a, b) -&gt; b.compareTo(a));</span><br></pre></td></tr></table></figure><p>Lambda的访问外层作用域与匿名对象类类似。可以直接访问标记了final的外层局部变量或者实例的字段以及静态变量。</p><h3><span id="函数式接口">函数式接口</span></h3><p>所谓的函数式接口是指有且仅有一个抽象方法的接口。</p><p>函数式接口的写法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyFunctionalInterface</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myMethod</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数式接口的典型使用场景就是作为方法的参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FunctionalInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数式接口作为方法参数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(MyFunctionalInterface inter)</span> </span>&#123;</span><br><span class="line">inter.myMethod(); <span class="comment">// 调用自定义的函数式接口方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//调用使用函数式接口的方法</span></span><br><span class="line">doSomething(() ‐&gt; System.out.println(<span class="string">"Lambda执行啦！"</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="方法与构造函数引用">方法与构造函数引用</span></h3><p>假如我们又这样一个函数式接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IConvert</span>&lt;<span class="title">F</span>,<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将F类型转换成T类型</span></span><br><span class="line"><span class="function">T <span class="title">convert</span><span class="params">(F from)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以这样使用这个新特性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IConvert&lt;String, Integer&gt; convertor = (from) -&gt; ( Integer.parseInt(from));</span><br><span class="line"><span class="comment">//简化写法</span></span><br><span class="line">IConvert&lt;String, Integer&gt; convertor = Integer::parseInt;</span><br></pre></td></tr></table></figure><p>还可以引用对象的方法；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyObject obj=<span class="keyword">new</span> MyObject();</span><br><span class="line">IConvert&lt;String,String&gt; convertor=something::startWith;</span><br></pre></td></tr></table></figure><p>还可以引用构造函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">PersonFactory</span>&lt;<span class="title">P</span> <span class="keyword">extends</span> <span class="title">Person</span>&gt;</span>&#123;</span><br><span class="line"><span class="function">P <span class="title">create</span><span class="params">(String firstName, String lastName)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以通过引用构造函数实现工厂类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PersonFactory&lt;Person&gt; factory = Person::<span class="keyword">new</span>;</span><br><span class="line">Person p = factory.create(<span class="string">"zhuge"</span>, <span class="string">"xx"</span>);</span><br></pre></td></tr></table></figure><h3><span id="内置函数式接口">内置函数式接口</span></h3><p>JDK8中内置了许多函数式接口，包括Comparator和Runnable等，它们被添加了@FunctionalNterface注解，以用来支持Lambda表示式。</p><h3><span id="stream流">Stream流</span></h3><p>Stream流提供了一种对集合Collection的方便的操作。</p><h4><span id="filter过滤">Filter过滤</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">"hello"</span>,<span class="string">"world"</span>,<span class="string">"apple"</span>,<span class="string">"people"</span>,<span class="string">"sea"</span>,</span><br><span class="line">                                  <span class="string">"watch"</span>,<span class="string">"table"</span>,<span class="string">"book"</span>,<span class="string">"school"</span>,<span class="string">"help"</span>);</span><br><span class="line">list</span><br><span class="line">    .stream() <span class="comment">//获取stream</span></span><br><span class="line">    .filter(s -&gt; s.startsWith(<span class="string">"s"</span>))  <span class="comment">//设置filter。中间操作</span></span><br><span class="line">    .forEach(System.out::println);   <span class="comment">//打印出流中的元素。终端操作</span></span><br></pre></td></tr></table></figure><h4><span id="sorted排序">Sorted排序</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list</span><br><span class="line">    .stream()</span><br><span class="line">    .sorted((a,b) -&gt; b.compareTo(a))</span><br><span class="line">    .forEach(System.out::println);</span><br></pre></td></tr></table></figure><h4><span id="map">Map</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">"10"</span>,<span class="string">"100"</span>,<span class="string">"1000"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"---- test map ----"</span>);</span><br><span class="line">list</span><br><span class="line">    .stream()</span><br><span class="line">    .map(Integer::valueOf)  <span class="comment">//转换为整数</span></span><br><span class="line">    .map(a -&gt; a + <span class="number">1</span>)        <span class="comment">//执行加一操作</span></span><br><span class="line">    .forEach(System.out::println);</span><br></pre></td></tr></table></figure><h4><span id="match匹配">Match匹配</span></h4><p>这是一种终端操作，姐u共不是stream对象，而是boolean值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">anyMatch</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">allMatch</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">noneMatch</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate)</span></span>;</span><br></pre></td></tr></table></figure><h4><span id="count计数">Count计数</span></h4><p>这是一种终端操作，用来统计stream中元素的个数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> count = </span><br><span class="line">    list</span><br><span class="line">        .stream() <span class="comment">//获取stream</span></span><br><span class="line">        .filter(s -&gt; s.startsWith(<span class="string">"s"</span>))  <span class="comment">//设置filter。中间操作</span></span><br><span class="line">        .count();</span><br></pre></td></tr></table></figure><h4><span id="reduce">Reduce</span></h4><p>list[0]和list[1]执行操作，得到的结果为result。result再和list[2]执行操作，得到的结果result。依次进行，对所有元素执行一遍.根据上述描述也可以看出，这里的“操作”必须满足两个入参、返回值是同一类型的</p><p>比如求和：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"---- test reduce ----"</span>);</span><br><span class="line">Optional&lt;Integer&gt; sum = </span><br><span class="line">    list</span><br><span class="line">        .stream()</span><br><span class="line">        .reduce((a,b) -&gt; a + b);</span><br><span class="line"></span><br><span class="line">sum.ifPresent(System.out::println);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;JDK8新特性详解&quot;&gt;&lt;a href=&quot;#JDK8新特性详解&quot; class=&quot;headerlink&quot; title=&quot;JDK8新特性详解&quot;&gt;&lt;/a&gt;JDK8新特性详解&lt;/h2&gt;&lt;p&gt;JDK8主要引入了这些新特性：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;接口的默认实现&lt;/li&gt;
&lt;li&gt;Lambda表达式&lt;/li&gt;
&lt;li&gt;函数式接口&lt;/li&gt;
&lt;li&gt;方法与构造函数引用&lt;/li&gt;
&lt;li&gt;内置了许多函数式接口&lt;/li&gt;
&lt;li&gt;Stream流&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
</feed>
