<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>个人博客</title>
  
  <subtitle>博观而约取 厚积而薄发</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zofun.github.io/"/>
  <updated>2020-05-28T09:38:00.288Z</updated>
  <id>https://zofun.github.io/</id>
  
  <author>
    <name>zofun</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Netty启动原理</title>
    <link href="https://zofun.github.io/2020/05/28/Netty%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86/"/>
    <id>https://zofun.github.io/2020/05/28/Netty启动原理/</id>
    <published>2020-05-28T09:37:00.000Z</published>
    <updated>2020-05-28T09:38:00.288Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="典型的netty服务端启动代码">典型的Netty服务端启动代码：</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            serverBootstrap.group(bossGroup,workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line"></span><br><span class="line">                            <span class="comment">//入站编码处理器</span></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> MyByteToLongDecoder());</span><br><span class="line">                            <span class="comment">//出站的handler进行编码</span></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> MyLongToByteEncoder());</span><br><span class="line">                            <span class="comment">//自定义的handler 处理业务逻辑</span></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> MyServerHandler());</span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">            ChannelFuture channelFuture = serverBootstrap.bind(<span class="number">7000</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h2><span id="启动流程分析">启动流程分析</span></h2><h3><span id="nioeventloopgroup的创建">NioEventLoopGroup的创建</span></h3><p>在启动Netty服务器之前创建了两个<code>NioEventLoopGroup</code></p><p>那么我们首先来分析它们的创建过程：</p><p><code>NioEventLoopGroup</code>的实例化最终调用了它的父类的构造器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">MultithreadEventExecutorGroup</span><span class="params">(<span class="keyword">int</span> nThreads, Executor executor,</span></span></span><br><span class="line"><span class="function"><span class="params">                                           EventExecutorChooserFactory chooserFactory, Object... args)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (nThreads &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">//参数合法性检测</span></span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(<span class="string">"nThreads: %d (expected: &gt; 0)"</span>, nThreads));</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (executor == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">//如果线程池为空，则创建一个线程池，</span></span><br><span class="line">           <span class="comment">//这个线程池非常的特殊，他为每个任务都单独创建一个任务</span></span><br><span class="line">           executor = <span class="keyword">new</span> ThreadPerTaskExecutor(newDefaultThreadFactory());</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个children实际上是一个NioEventLoop数组</span></span><br><span class="line">       children = <span class="keyword">new</span> EventExecutor[nThreads];</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nThreads; i ++) &#123;</span><br><span class="line">           <span class="keyword">boolean</span> success = <span class="keyword">false</span>; <span class="comment">//用于标记是否创建成功</span></span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">//这里的newChild实际是子类NioEventLoopGroup实现的</span></span><br><span class="line">               children[i] = newChild(executor, args);</span><br><span class="line">               success = <span class="keyword">true</span>;</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">               <span class="comment">// <span class="doctag">TODO:</span> Think about if this is a good exception type</span></span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"failed to create a child event loop"</span>, e);</span><br><span class="line">           &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">               <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">                   <span class="comment">//如果在创建的NioEventLoop数组数组中途出现了异常</span></span><br><span class="line">                   <span class="comment">//那么就将成功创建的NioEventLoop关闭掉</span></span><br><span class="line">                   <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j ++) &#123;</span><br><span class="line">                       children[j].shutdownGracefully();</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j ++) &#123;</span><br><span class="line">                       EventExecutor e = children[j];</span><br><span class="line">                       <span class="keyword">try</span> &#123;</span><br><span class="line">                           <span class="keyword">while</span> (!e.isTerminated()) &#123;</span><br><span class="line">                               e.awaitTermination(Integer.MAX_VALUE, TimeUnit.SECONDS);</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125; <span class="keyword">catch</span> (InterruptedException interrupted) &#123;</span><br><span class="line">                           <span class="comment">// Let the caller handle the interruption.</span></span><br><span class="line">                           Thread.currentThread().interrupt();</span><br><span class="line">                           <span class="keyword">break</span>;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//chooser实际上是每次进行相关操作时线程的选择的实现，默认使用的是轮询策略</span></span><br><span class="line">       chooser = chooserFactory.newChooser(children);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">final</span> FutureListener&lt;Object&gt; terminationListener = <span class="keyword">new</span> FutureListener&lt;Object&gt;() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(Future&lt;Object&gt; future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">               <span class="keyword">if</span> (terminatedChildren.incrementAndGet() == children.length) &#123;</span><br><span class="line">                   terminationFuture.setSuccess(<span class="keyword">null</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (EventExecutor e: children) &#123;</span><br><span class="line">           e.terminationFuture().addListener(terminationListener);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       Set&lt;EventExecutor&gt; childrenSet = <span class="keyword">new</span> LinkedHashSet&lt;EventExecutor&gt;(children.length);</span><br><span class="line">       Collections.addAll(childrenSet, children);</span><br><span class="line">       readonlyChildren = Collections.unmodifiableSet(childrenSet);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><code>newChild</code>的实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">protected</span> EventLoop <span class="title">newChild</span><span class="params">(Executor executor, Object... args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       EventLoopTaskQueueFactory queueFactory = args.length == <span class="number">4</span> ? (EventLoopTaskQueueFactory) args[<span class="number">3</span>] : <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> NioEventLoop(<span class="keyword">this</span>, executor, (SelectorProvider) args[<span class="number">0</span>],</span><br><span class="line">           ((SelectStrategyFactory) args[<span class="number">1</span>]).newSelectStrategy(), (RejectedExecutionHandler) args[<span class="number">2</span>], queueFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是<code>NioEventLoopGroup</code>的实现，在启动Netty服务端的时候，创建了两个<code>NioEventLoopGroup</code>,分别是<code>boosGroup</code>和<code>workerGroup</code>,它们本质上是一样的，只是作用不同。</p><h3><span id="serverbootstrap与nioeventloopgroup的绑定">ServerBootstrap与NioEventLoopGroup的绑定</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ServerBootstrap <span class="title">group</span><span class="params">(EventLoopGroup parentGroup, EventLoopGroup childGroup)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.group(parentGroup);</span><br><span class="line">    ObjectUtil.checkNotNull(childGroup, <span class="string">"childGroup"</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.childGroup != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"childGroup set already"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.childGroup = childGroup;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这里开始两个<code>NioEventLoopGroup</code>的作用开始不同了。</p><h3><span id="serverbootstrap的bind处理">ServerBootstrap的bind处理</span></h3><p>通过层层调用最终来到了<code>doBind</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ChannelFuture <span class="title">doBind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//对Channel进行初始化和注册操作</span></span><br><span class="line">       <span class="keyword">final</span> ChannelFuture regFuture = initAndRegister();</span><br><span class="line">       <span class="keyword">final</span> Channel channel = regFuture.channel();</span><br><span class="line">       <span class="keyword">if</span> (regFuture.cause() != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> regFuture;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (regFuture.isDone()) &#123;</span><br><span class="line">           <span class="comment">// At this point we know that the registration was complete and successful.</span></span><br><span class="line">           ChannelPromise promise = channel.newPromise();</span><br><span class="line">           doBind0(regFuture, channel, localAddress, promise);</span><br><span class="line">           <span class="keyword">return</span> promise;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">// Registration future is almost always fulfilled already, but just in case it's not.</span></span><br><span class="line">           <span class="keyword">final</span> PendingRegistrationPromise promise = <span class="keyword">new</span> PendingRegistrationPromise(channel);</span><br><span class="line">           regFuture.addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">               <span class="meta">@Override</span></span><br><span class="line">               <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                   Throwable cause = future.cause();</span><br><span class="line">                   <span class="keyword">if</span> (cause != <span class="keyword">null</span>) &#123;</span><br><span class="line">                       <span class="comment">// Registration on the EventLoop failed so fail the ChannelPromise directly to not cause an</span></span><br><span class="line">                       <span class="comment">// IllegalStateException once we try to access the EventLoop of the Channel.</span></span><br><span class="line">                       promise.setFailure(cause);</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       <span class="comment">// Registration was successful, so set the correct executor to use.</span></span><br><span class="line">                       <span class="comment">// See https://github.com/netty/netty/issues/2586</span></span><br><span class="line">                       promise.registered();</span><br><span class="line"></span><br><span class="line">                       doBind0(regFuture, channel, localAddress, promise);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;);</span><br><span class="line">           <span class="keyword">return</span> promise;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>在进行<code>doBind</code>最开始就进行了<code>Channel</code>的绑定和初始化工作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> ChannelFuture <span class="title">initAndRegister</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Channel channel = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//利用Channel工厂创建一个Channel，实际上是通过反射实例化的</span></span><br><span class="line">        channel = channelFactory.newChannel();</span><br><span class="line">        init(channel);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="keyword">if</span> (channel != <span class="keyword">null</span>) &#123;</span><br><span class="line">            channel.unsafe().closeForcibly();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> DefaultChannelPromise(channel, GlobalEventExecutor.INSTANCE).setFailure(t);</span><br><span class="line">        &#125;</span><br><span class="line">   </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DefaultChannelPromise(<span class="keyword">new</span> FailedChannel(), GlobalEventExecutor.INSTANCE).setFailure(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ChannelFuture regFuture = config().group().register(channel);</span><br><span class="line">    <span class="keyword">if</span> (regFuture.cause() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (channel.isRegistered()) &#123;</span><br><span class="line">            channel.close();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            channel.unsafe().closeForcibly();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> regFuture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">       setChannelOptions(channel, options0().entrySet().toArray(newOptionArray(<span class="number">0</span>)), logger);</span><br><span class="line">       setAttributes(channel, attrs0().entrySet().toArray(newAttrArray(<span class="number">0</span>)));</span><br><span class="line"></span><br><span class="line">       ChannelPipeline p = channel.pipeline();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">final</span> EventLoopGroup currentChildGroup = childGroup;</span><br><span class="line">       <span class="keyword">final</span> ChannelHandler currentChildHandler = childHandler;</span><br><span class="line">       <span class="keyword">final</span> Entry&lt;ChannelOption&lt;?&gt;, Object&gt;[] currentChildOptions =</span><br><span class="line">               childOptions.entrySet().toArray(newOptionArray(<span class="number">0</span>));</span><br><span class="line">       <span class="keyword">final</span> Entry&lt;AttributeKey&lt;?&gt;, Object&gt;[] currentChildAttrs = childAttrs.entrySet().toArray(newAttrArray(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">       p.addLast(<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(<span class="keyword">final</span> Channel ch)</span> </span>&#123;</span><br><span class="line">               <span class="keyword">final</span> ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">               ChannelHandler handler = config.handler();</span><br><span class="line">               <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   pipeline.addLast(handler);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               ch.eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                   <span class="meta">@Override</span></span><br><span class="line">                   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                       pipeline.addLast(<span class="keyword">new</span> ServerBootstrapAcceptor(</span><br><span class="line">                               ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>该方法主要做<code>Channel</code>的初始化工作，如果我们在启动前设置了参数，这里也会传递过去。</p><p>完成<code>Channel</code>的初始化工作之后就需要对<code>Channel</code>进行注册：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(EventLoop eventLoop, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    ObjectUtil.checkNotNull(eventLoop, <span class="string">"eventLoop"</span>);</span><br><span class="line">    <span class="keyword">if</span> (isRegistered()) &#123;</span><br><span class="line">        promise.setFailure(<span class="keyword">new</span> IllegalStateException(<span class="string">"registered to an event loop already"</span>));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!isCompatible(eventLoop)) &#123;</span><br><span class="line">        promise.setFailure(</span><br><span class="line">                <span class="keyword">new</span> IllegalStateException(<span class="string">"incompatible event loop type: "</span> + eventLoop.getClass().getName()));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AbstractChannel.<span class="keyword">this</span>.eventLoop = eventLoop;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (eventLoop.inEventLoop()) &#123;</span><br><span class="line">        register0(promise);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            eventLoop.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    register0(promise);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            logger.warn(</span><br><span class="line">                    <span class="string">"Force-closing a channel whose registration task was not accepted by an event loop: &#123;&#125;"</span>,</span><br><span class="line">                    AbstractChannel.<span class="keyword">this</span>, t);</span><br><span class="line">            closeForcibly();</span><br><span class="line">            closeFuture.setClosed();</span><br><span class="line">            safeSetFailure(promise, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">register0</span><span class="params">(ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!promise.setUncancellable() || !ensureOpen(promise)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> firstRegistration = neverRegistered;</span><br><span class="line">        doRegister();</span><br><span class="line">        neverRegistered = <span class="keyword">false</span>;</span><br><span class="line">        registered = <span class="keyword">true</span>;</span><br><span class="line">        pipeline.invokeHandlerAddedIfNeeded();</span><br><span class="line">        safeSetSuccess(promise);</span><br><span class="line">        pipeline.fireChannelRegistered();</span><br><span class="line">        <span class="keyword">if</span> (isActive()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (firstRegistration) &#123;</span><br><span class="line">                pipeline.fireChannelActive();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (config().isAutoRead()) &#123;</span><br><span class="line">                beginRead();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        closeForcibly();</span><br><span class="line">        closeFuture.setClosed();</span><br><span class="line">        safeSetFailure(promise, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而<code>doRegister</code>方法完成了最终的注册工作<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegister</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> selected = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), <span class="number">0</span>, <span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CancelledKeyException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!selected) &#123;</span><br><span class="line">                eventLoop().selectNow();</span><br><span class="line">                selected = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样就把<code>Channle</code>注册到了boss线程的<code>selector</code>多路复用器上，完成了<code>channel</code>的初始化和注册。<br>那么Server端是何时启动监听呢，其实通过上述代码会发现，每个Channel（不管server还是client）在运行期间，全局绑定一个唯一的线程不变（NioEventLoop),Netty所有的I/O操作都是和这个channel对应NioEventLoop进行操作，也就是很多步骤都会有一个eventLoop.inEventLoop()的判断，判断是否在这个channel对应的线程中，如果不在，则会执行eventLoop.execute(new Runnable() {}这步操作时，会判断IO线程是否启动，如果没有启动，会启动IO线程：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task, <span class="keyword">boolean</span> immediate)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> inEventLoop = inEventLoop();</span><br><span class="line">    addTask(task);</span><br><span class="line">    <span class="keyword">if</span> (!inEventLoop) &#123;</span><br><span class="line">        startThread();</span><br><span class="line">        <span class="keyword">if</span> (isShutdown()) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> reject = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (removeTask(task)) &#123;</span><br><span class="line">                    reject = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (UnsupportedOperationException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (reject) &#123;</span><br><span class="line">                reject();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!addTaskWakesUp &amp;&amp; immediate) &#123;</span><br><span class="line">        wakeup(inEventLoop);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最终会调用<code>NioEventLoop</code>的run方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> selectCnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> strategy;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                strategy = selectStrategy.calculateStrategy(selectNowSupplier, hasTasks());</span><br><span class="line">                <span class="keyword">switch</span> (strategy) &#123;</span><br><span class="line">                <span class="keyword">case</span> SelectStrategy.CONTINUE:</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">case</span> SelectStrategy.BUSY_WAIT:</span><br><span class="line">                <span class="keyword">case</span> SelectStrategy.SELECT:</span><br><span class="line">                    <span class="keyword">long</span> curDeadlineNanos = nextScheduledTaskDeadlineNanos();</span><br><span class="line">                    <span class="keyword">if</span> (curDeadlineNanos == -<span class="number">1L</span>) &#123;</span><br><span class="line">                        curDeadlineNanos = NONE; <span class="comment">// nothing on the calendar</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    nextWakeupNanos.set(curDeadlineNanos);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!hasTasks()) &#123;</span><br><span class="line">                            strategy = select(curDeadlineNanos);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        nextWakeupNanos.lazySet(AWAKE);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// fall through</span></span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                rebuildSelector0();</span><br><span class="line">                selectCnt = <span class="number">0</span>;</span><br><span class="line">                handleLoopException(e);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            selectCnt++;</span><br><span class="line">            cancelledKeys = <span class="number">0</span>;</span><br><span class="line">            needsToSelectAgain = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> ioRatio = <span class="keyword">this</span>.ioRatio;</span><br><span class="line">            <span class="keyword">boolean</span> ranTasks;</span><br><span class="line">            <span class="keyword">if</span> (ioRatio == <span class="number">100</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (strategy &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        processSelectedKeys();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// Ensure we always run tasks.</span></span><br><span class="line">                    ranTasks = runAllTasks();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strategy &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">long</span> ioStartTime = System.nanoTime();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    processSelectedKeys();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">long</span> ioTime = System.nanoTime() - ioStartTime;</span><br><span class="line">                    ranTasks = runAllTasks(ioTime * (<span class="number">100</span> - ioRatio) / ioRatio);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ranTasks = runAllTasks(<span class="number">0</span>); <span class="comment">// This will run the minimum number of tasks</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ranTasks || strategy &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (selectCnt &gt; MIN_PREMATURE_SELECTOR_RETURNS &amp;&amp; logger.isDebugEnabled()) &#123;</span><br><span class="line">                    logger.debug(<span class="string">"Selector.select() returned prematurely &#123;&#125; times in a row for Selector &#123;&#125;."</span>,</span><br><span class="line">                            selectCnt - <span class="number">1</span>, selector);</span><br><span class="line">                &#125;</span><br><span class="line">                selectCnt = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (unexpectedSelectorWakeup(selectCnt)) &#123; <span class="comment">// Unexpected wakeup (unusual case)</span></span><br><span class="line">                selectCnt = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CancelledKeyException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(CancelledKeyException.class.getSimpleName() + <span class="string">" raised by a Selector &#123;&#125; - JDK bug?"</span>,</span><br><span class="line">                        selector, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            handleLoopException(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (isShuttingDown()) &#123;</span><br><span class="line">                closeAll();</span><br><span class="line">                <span class="keyword">if</span> (confirmShutdown()) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            handleLoopException(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>到此整个Netty服务端就启动了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;典型的Netty服务端启动代码：&quot;&gt;&lt;a href=&quot;#典型的Netty服务端启动代码：&quot; class=&quot;headerlink&quot; title=&quot;典型的Netty服务端启动代码：&quot;&gt;&lt;/a&gt;典型的Netty服务端启动代码：&lt;/h2&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MyServer&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; Exception&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        EventLoopGroup bossGroup = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; NioEventLoopGroup(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        EventLoopGroup workerGroup = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; NioEventLoopGroup();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            ServerBootstrap serverBootstrap = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ServerBootstrap();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            serverBootstrap.group(bossGroup,workerGroup)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    .channel(NioServerSocketChannel.class)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    .childHandler(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ChannelInitializer&amp;lt;SocketChannel&amp;gt;() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;initChannel&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(SocketChannel ch)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; Exception &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                            ChannelPipeline pipeline = ch.pipeline();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                            &lt;span class=&quot;comment&quot;&gt;//入站编码处理器&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                            pipeline.addLast(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; MyByteToLongDecoder());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                            &lt;span class=&quot;comment&quot;&gt;//出站的handler进行编码&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                            pipeline.addLast(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; MyLongToByteEncoder());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                            &lt;span class=&quot;comment&quot;&gt;//自定义的handler 处理业务逻辑&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                            pipeline.addLast(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; MyServerHandler());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            ChannelFuture channelFuture = serverBootstrap.bind(&lt;span class=&quot;number&quot;&gt;7000&lt;/span&gt;).sync();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            channelFuture.channel().closeFuture().sync();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;span class=&quot;keyword&quot;&gt;finally&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            bossGroup.shutdownGracefully();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            workerGroup.shutdownGracefully();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="https://zofun.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Netty" scheme="https://zofun.github.io/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>web安全基础知识一</title>
    <link href="https://zofun.github.io/2020/05/22/web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%80/"/>
    <id>https://zofun.github.io/2020/05/22/web安全基础知识一/</id>
    <published>2020-05-22T08:53:00.000Z</published>
    <updated>2020-05-22T08:55:11.214Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="常见网站应用攻击方式">常见网站应用攻击方式</span></h2><h3><span id="xss攻击">XSS攻击</span></h3><p>XSS攻击即跨站点脚本攻击（cross site script），指黑客通过篡改网页，注入恶意HTML脚本，在用户浏览网页时，控制用户浏览器进行恶意操作的一种攻击方式。<br>常见的XSS攻击的类型有两种：</p><ul><li>反射型：攻击者诱使用户点击一个嵌入恶意脚本的连接，达到攻击的目的。</li><li>持久型：黑客提交包含恶意脚本的请求，保存在被攻击的web站点的数据库中，用户浏览网页时，恶意脚本就被包含在正常页面中，达到攻击的目的。</li></ul><a id="more"></a><h4><span id="防范手段">防范手段</span></h4><p><strong>消毒</strong><br>XSS攻击者一般都是通过在请求中嵌入恶意脚本达到攻击的目的，这些脚本一般用户输入中不使用的，如果进行过滤和消毒处理，即对某些html危险字符转义，如”&gt;””&lt;”等，就可以防范大部分攻击。<br><strong>HttpOnly</strong><br>即浏览器禁止页面JavaScript访问带有HttpOnly属性的Cookie。该方法可以防止XSS攻击者窃取Cookie，对于存放敏感信息的Cookie，如用户认证信息等，可通过对该Cookie添加HttpOnly属性，避免被攻击脚本窃取。</p><h3><span id="注入攻击">注入攻击</span></h3><p>注入攻击主要有两种形式，SQL注入攻击和OS注入攻击。<br>SQL注入攻击的原理就是攻击者在HTTP请求中注入恶意SQL命令，服务器用请求参数构造数据库SQL命令时，恶意SQL被一起构造，并在数据库中执行。SQL注入攻击需要用户对数据库得结构有所了解才能进行，攻击者获取数据库表结构的手段有：网站开源的代码，错误回显，盲注。</p><h4><span id="sql注入的防范方法">SQL注入的防范方法</span></h4><p><strong>消毒</strong><br>和防止XSS攻击一样，请求参数消毒是一种比较简单粗暴又有效的手段。通过正则匹配，过滤请求数据中可能注入的SQL。<br><strong>参数绑定</strong><br>使用预编译手段，绑定参数是最好的防SQL注入方法。目前很多数据层很多框架都提供SQL预编译和参数绑定。</p><h3><span id="csrf攻击">CSRF攻击</span></h3><p>CSRF（cross site request frogery，跨站点请求伪造），攻击者通过跨站请求，以合法用户的身份进行非常操作，如转账交易、发表评论等。CSRF的主要手段是利用跨站请求，在用户不支持的情况下，以用户的身份伪造请求。核心是利用了浏览器Cookie或服务器Session策略，盗取用户身份。<br><img src="https://s1.ax1x.com/2020/05/22/YOW7CT.png" alt="YOW7CT.png"></p><h4><span id="csrf的防御手段">CSRF的防御手段</span></h4><p>CSRF的防范手段主要是识别请求者身份。<br><strong>表单Token</strong><br>CSRF是一个伪造用户请求的操作，所以需要构造用户请求的所有参数才可以。表单Token通过在请求参数中增加随机数的办法来阻止攻击者获得所有请求参数。服务器检查请求参数中Token的值是否存在并且正确请求提交者是否合法。<br><strong>验证码</strong><br>在请求提交时，需要用户输入验证码，以避免在用户不知情的情况下被攻击者伪造请求。<br><strong>Referer check</strong><br>HTTP请求头的Referer域中记录着请求来源，可通过检查请求来源，验证其是否合法。</p><h3><span id="其它攻击和漏洞">其它攻击和漏洞</span></h3><h4><span id="error-code">Error Code</span></h4><p>错误回显，许多web服务器默认是打开异常信息输出的，即服务器端未处理的异常堆栈信息回直接输出到客户端浏览器，这种方式虽然对程序调试和错误报告有好处，但同时也给黑客造成可乘之机。</p><h4><span id="html注释">HTML注释</span></h4><p>未调式程序或其它不恰当的原因，有时程序开发人员会在PHP，JSP等服务器页面程序中使用HTML注释语法进行程序注释，这些HTML注释信息会显示在客户端浏览器给黑客攻击便利。</p><h4><span id="文件上传">文件上传</span></h4><p>一般网站都会有文件上传功能，设置头像、分享视频、上传附件等。如果上传的是可执行的程序，并通过该程序获得服务器端命令执行能力，那么攻击者几乎可以在服务器上为所欲为。最有效的防范手段是设置上传文件白名单，只允许上传可靠的文件类型。此外还可以修改文件名、使用专门的存储手段等，保护服务器避免受上传文件攻击。</p><h4><span id="路径遍历">路径遍历</span></h4><p>攻击者在请求的URL中使用相对路径，遍历系统未开放的目录和文件。防御防范主要是讲JS、CSS等资源文件部署在独立的服务器，使用独立域名，其它文件不使用静态URL范围，到你太参数不包含文件路径信息。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;常见网站应用攻击方式&quot;&gt;&lt;a href=&quot;#常见网站应用攻击方式&quot; class=&quot;headerlink&quot; title=&quot;常见网站应用攻击方式&quot;&gt;&lt;/a&gt;常见网站应用攻击方式&lt;/h2&gt;&lt;h3 id=&quot;XSS攻击&quot;&gt;&lt;a href=&quot;#XSS攻击&quot; class=&quot;headerlink&quot; title=&quot;XSS攻击&quot;&gt;&lt;/a&gt;XSS攻击&lt;/h3&gt;&lt;p&gt;XSS攻击即跨站点脚本攻击（cross site script），指黑客通过篡改网页，注入恶意HTML脚本，在用户浏览网页时，控制用户浏览器进行恶意操作的一种攻击方式。&lt;br&gt;常见的XSS攻击的类型有两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;反射型：攻击者诱使用户点击一个嵌入恶意脚本的连接，达到攻击的目的。&lt;/li&gt;
&lt;li&gt;持久型：黑客提交包含恶意脚本的请求，保存在被攻击的web站点的数据库中，用户浏览网页时，恶意脚本就被包含在正常页面中，达到攻击的目的。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="https://zofun.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="web安全" scheme="https://zofun.github.io/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot自动配置原理</title>
    <link href="https://zofun.github.io/2020/05/21/SpringBoot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/"/>
    <id>https://zofun.github.io/2020/05/21/SpringBoot自动配置原理/</id>
    <published>2020-05-21T06:45:00.000Z</published>
    <updated>2020-05-21T06:46:05.730Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="简介">简介</span></h2><p>SpringBoot相较于Spring的一大进步就是它简化了配置。SpringBoot遵循”约定优于配置”的原则，使用注解对一些常规的配置项做默认配置，减少或不使用xml配置。Springboot还提供了大量的starter，只需引入一个starter，就可以直接使用框架。</p><h2><span id="几个重要的注解">几个重要的注解</span></h2><p>在<code>SpringBoot</code>启动类上添加的<code>SpringBootApplication</code>注解。这个注解实际上是一个复合注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(excludeFilters = &#123; <span class="meta">@Filter</span>(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span><br><span class="line"><span class="meta">@Filter</span>(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</span><br></pre></td></tr></table></figure><p>我们主要关注<code>@SpringBootConfiguration</code>,<code>@EnableAutoConfiguration</code>,<code>@ComponeScan</code>.<br><code>@SpringBootConfiguration</code>注解的底层是<code>@Configuration</code>注解，即支持JavaConfig的方式来进行配置。</p><p><code>@EnableAutoConfiguration</code>注解的作用就是开启自动配置功能。</p><p><code>@ComponentScan</code>注解的作用就是烧苗当前类所属的<code>package</code>，<code>将@Controller</code>、<code>@Service</code>、<code>@Component</code>、<code>@Repository</code>等注解所表示的类加载到IOC容器中。</p><p>通过对这几个注解的分析，我们可以知道自动配置工作主要是由<code>EnableAutoConfiguration</code>注解来实现的。</p><h2><span id="自动配置的关键enableautoconfiguration注解">自动配置的关键：@EnableAutoConfiguration注解</span></h2><p>该注解的定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import</span>(AutoConfigurationImportSelector.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br></pre></td></tr></table></figure><p>该注解使用<code>@Import</code>向IOC容器中注入了<code>AutoConfigurationImportSelector</code>类。<br>该类中提供了获取所有候选的配置的方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;String&gt; <span class="title">getCandidateConfigurations</span><span class="params">(AnnotationMetadata metadata, AnnotationAttributes attributes)</span> </span>&#123;</span><br><span class="line">List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(),</span><br><span class="line">getBeanClassLoader());</span><br><span class="line">Assert.notEmpty(configurations, <span class="string">"No auto configuration classes found in META-INF/spring.factories. If you "</span></span><br><span class="line">+ <span class="string">"are using a custom packaging, make sure that file is correct."</span>);</span><br><span class="line"><span class="keyword">return</span> configurations;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过<code>loadFactoryNames</code>方法拿到了一个<code>List</code>，这个方法中传入了一个<code>getSpringFactoriesLoaderFactoryClass()</code>,这个方法，实际上就是获取了标记了<code>@EnableAutoConfiguratioin</code>注解的类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; getSpringFactoriesLoaderFactoryClass() &#123;</span><br><span class="line">    <span class="keyword">return</span> EnableAutoConfiguration.class;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当我们的SpringBoot项目启动的时候，会先导入AutoConfigurationImportSelector，这个类会帮我们选择所有候选的配置，我们需要导入的配置都是SpringBoot帮我们写好的一个一个的配置类，那么这些配置类的位置，存在与META-INF/spring.factories文件中，通过这个文件，Spring可以找到这些配置类的位置，于是去加载其中的配置。<br><img src="https://s1.ax1x.com/2020/05/21/YbmZhq.png" alt="YbmZhq.png"></p><h2><span id="总结">总结</span></h2><ul><li>SpringBoot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值</li><li>将这些值作为自动配置类导入容器 ， 自动配置类就生效 ， 帮我们进行自动配置工作；</li><li>它将所有需要导入的组件以全类名的方式返回 ， 这些组件就会被添加到容器中 ；</li><li>它会给容器中导入非常多的自动配置类 （xxxAutoConfiguration）, 就是给容器中导入这个场景需要的所有组件 ， 并配置好这些组件 ；</li><li>有了自动配置类 ， 免去了我们手动编写配置注入功能组件等的工作；</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;&lt;span id=&quot;简介&quot;&gt;简介&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;SpringBoot相较于Spring的一大进步就是它简化了配置。SpringBoot遵循”约定优于配置”的原则，使用注解对一些常规的配置项做默认配置，减少或不使用xml配置。Springboot还提供了大量的
      
    
    </summary>
    
    
    
      <category term="技术" scheme="https://zofun.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="SpringBoot" scheme="https://zofun.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>跟踪SpringMVC请求过程</title>
    <link href="https://zofun.github.io/2020/05/20/%E8%B7%9F%E8%B8%AASpringMVC%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B/"/>
    <id>https://zofun.github.io/2020/05/20/跟踪SpringMVC请求过程/</id>
    <published>2020-05-20T09:45:00.000Z</published>
    <updated>2020-05-20T09:45:18.835Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="整体流程">整体流程</span></h2><ol><li>所有的请求都被拦截到<code>DispatcherServlet</code>,它也是一个<code>Servlet</code>,执行<code>doService</code></li><li>快照请求中的所有的参数，将框架中的一些对象设置到<code>request</code>对象中。</li><li>调用<code>doDispatch(request,response)</code>方法</li><li>调用<code>getHandler</code>方法获取对应的<code>Handler</code></li><li>调用<code>getHandlerAdapter</code>拿到对应的<code>HandlerAdapter</code></li><li>应用拦截器的<code>PreHandler</code>,如果拦截器的<code>PreHandeler</code>返回false，则直接返回</li><li>调用<code>HandlerAdapter</code>对象的<code>handler</code>得到<code>ModelAndView</code>对象</li><li>应用拦截器的<code>postHandle</code>方法</li><li>调用<code>processDispatchResult</code>对结果进行处理，其内部调用了拦截器的<code>afterCompletion</code>方法</li></ol><a id="more"></a><h2><span id="源码细节">源码细节</span></h2><h3><span id="如何拿到对应的handler">如何拿到对应的Handler？</span></h3><p>获取<code>Handler</code>是通过<code>getHandler</code>方法来获取的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> HandlerExecutionChain <span class="title">getHandler</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (HandlerMapping hm : <span class="keyword">this</span>.handlerMappings) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(</span><br><span class="line"><span class="string">"Testing handler map ["</span> + hm + <span class="string">"] in DispatcherServlet with name '"</span> + getServletName() + <span class="string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line">HandlerExecutionChain handler = hm.getHandler(request);</span><br><span class="line"><span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> handler;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这段代码看起来非常的简单，遍历<code>handlerMappings</code>,从<code>HandlerMapping</code>从获取<code>HandlerExecutionChain</code>即我们的<code>handler</code>.</p><p>这个<code>HandlerExecutionChain</code>中包含了<code>handler</code>和<code>HandlerInterceptor</code>数组。也就是我们拿到<code>handler</code>实际上是一个处理链。</p><h3><span id="为什么需要handleradapter它的如何获取到的">为什么需要HandlerAdapter，它的如何获取到的？</span></h3><p>SpringMVC的<code>handler</code>的实现方式比较的多，比如通过继承<code>Controller</code>的，基于注解控制器方式，<code>HttpRequestHandler</code>的方式。因为<code>handler</code>的实现方式不同，因此调用的方式也就不确定了。因此引入了<code>HandlerAdapter</code>来进行适配。<br><code>HandlerAdapter</code>接口有三个方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断当前的HandlerAdapter是否支持HandlerMethod</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Object handler)</span></span>;</span><br><span class="line"><span class="function">ModelAndView <span class="title">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">getLastModified</span><span class="params">(HttpServletRequest request, Object handler)</span></span>;</span><br></pre></td></tr></table></figure></p><p>获取<code>HandlerAdapter</code>是通过<code>getHandlerAdapter</code>方法来获取的。通过对<code>HandlerAdapter</code>使用原因的分析，我们可以直到所谓获取对应的<code>HandlerAdapter</code>实际上从<code>HandlerAdapter</code>列表中找出一个支持当前<code>handler</code>的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> HandlerAdapter <span class="title">getHandlerAdapter</span><span class="params">(Object handler)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (HandlerAdapter ha : <span class="keyword">this</span>.handlerAdapters) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">"Testing handler adapter ["</span> + ha + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ha.supports(handler)) &#123;</span><br><span class="line"><span class="keyword">return</span> ha;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ServletException(<span class="string">"No adapter for handler ["</span> + handler +</span><br><span class="line"><span class="string">"]: The DispatcherServlet configuration needs to include a HandlerAdapter that supports this handler"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法就是简单的遍历<code>HandlerAdapter</code>列表，从中找出一个支持当前<code>handler</code>的，并返回。</p><h3><span id="handler方法的执行过程">handler方法的执行过程</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最终拿到了我们的Controller类</span></span><br><span class="line">Class&lt;?&gt; clazz = ClassUtils.getUserClass(handler);</span><br><span class="line"><span class="comment">//判断是否使用了@SessionAttributes</span></span><br><span class="line">Boolean annotatedWithSessionAttributes = <span class="keyword">this</span>.sessionAnnotatedClassesCache.get(clazz);</span><br><span class="line"><span class="keyword">if</span> (annotatedWithSessionAttributes == <span class="keyword">null</span>) &#123;</span><br><span class="line">annotatedWithSessionAttributes = (AnnotationUtils.findAnnotation(clazz, SessionAttributes.class) != <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">this</span>.sessionAnnotatedClassesCache.put(clazz, annotatedWithSessionAttributes);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (annotatedWithSessionAttributes) &#123;</span><br><span class="line"><span class="comment">// Always prevent caching in case of session attribute management.</span></span><br><span class="line">checkAndPrepare(request, response, <span class="keyword">this</span>.cacheSecondsForSessionAttributeHandlers, <span class="keyword">true</span>);</span><br><span class="line"><span class="comment">// Prepare cached set of session attributes names.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 禁用缓存</span></span><br><span class="line">checkAndPrepare(request, response, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Execute invokeHandlerMethod in synchronized block if required.</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.synchronizeOnSession) &#123;</span><br><span class="line">HttpSession session = request.getSession(<span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">if</span> (session != <span class="keyword">null</span>) &#123;</span><br><span class="line">Object mutex = WebUtils.getSessionMutex(session);</span><br><span class="line"><span class="keyword">synchronized</span> (mutex) &#123;</span><br><span class="line"><span class="keyword">return</span> invokeHandlerMethod(request, response, handler);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> invokeHandlerMethod(request, response, handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终来到了<code>invokerhandlerMethod</code>方法了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ModelAndView <span class="title">invokeHandlerMethod</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">ServletHandlerMethodResolver methodResolver = getMethodResolver(handler);</span><br><span class="line"><span class="comment">//获取处理请求的方法</span></span><br><span class="line">Method handlerMethod = methodResolver.resolveHandlerMethod(request);</span><br><span class="line"><span class="comment">//创建各种组件</span></span><br><span class="line">ServletHandlerMethodInvoker methodInvoker = <span class="keyword">new</span> ServletHandlerMethodInvoker(methodResolver);</span><br><span class="line">ServletWebRequest webRequest = <span class="keyword">new</span> ServletWebRequest(request, response);</span><br><span class="line">ExtendedModelMap implicitModel = <span class="keyword">new</span> BindingAwareModelMap();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用方法拿到结果</span></span><br><span class="line">Object result = methodInvoker.invokeHandlerMethod(handlerMethod, handler, webRequest, implicitModel);</span><br><span class="line"><span class="comment">//获取ModelAndView</span></span><br><span class="line">ModelAndView mav =</span><br><span class="line">methodInvoker.getModelAndView(handlerMethod, handler.getClass(), result, implicitModel, webRequest);</span><br><span class="line"><span class="comment">//更新view中的属性</span></span><br><span class="line">methodInvoker.updateModelAttributes(handler, (mav != <span class="keyword">null</span> ? mav.getModel() : <span class="keyword">null</span>), implicitModel, webRequest);</span><br><span class="line"><span class="keyword">return</span> mav;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后调用<code>mappedHandler.applyPostHandle(processedRequest, response, mv);</code>进行后处理。后处理的过程就是调用所有的后置拦截器进行处理。</p><h2><span id="filter与interceptor">Filter与Interceptor</span></h2><h3><span id="filter的实现方式">Filter的实现方式</span></h3><ol><li><p>实现<code>Filter</code>接口</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebFilter</span>(filterName = <span class="string">"filterOne"</span>, urlPatterns = &#123;<span class="string">"/*"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterOne</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"init"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"===========before doFilter"</span>);</span><br><span class="line">        filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">        System.out.println(<span class="string">"===========after doFilter"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"destroy"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3><span id="interceptor的实现方式">Interceptor的实现方式</span></h3><ol><li><p>实现<code>HandlerInterceptor</code>接口</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Controller调用之前的拦截器。。。"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该方法controller调用之后，页面渲染之前执行，要preHandler返回ture才会执行该方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> modelAndView</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"controller调用之后，页面渲染之前执行"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**请求完成之后执行的拦截器，要preHandler返回ture才会执行该方法</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ex</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"请求完成之后执行的拦截器"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在<code>springmvc</code>的配置文件中进行配置</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!-- 使用bean定义一个Interceptor，直接定义在mvc:interceptors根下面的Interceptor将拦截所有的请求 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.host.app.web.interceptor.AllInterceptor"</span>/&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">"/test/number.do"</span>/&gt;</span>  </span><br><span class="line">        <span class="comment">&lt;!-- 定义在mvc:interceptor下面的表示是对特定的请求才进行拦截的 --&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.host.app.web.interceptor.LoginInterceptor"</span>/&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h3><span id="相同点">相同点</span></h3><ul><li>都可以拦截请求，过滤请求</li><li>都是应用了过滤器（责任链）设计模式</li></ul><h3><span id="区别">区别</span></h3><ul><li><code>Filter</code>过滤器访问较大，配置在<code>web.xml</code></li><li><code>Interceptor</code>范围比较小，配置在<code>springmvc</code></li><li>在进入<code>springmvc</code>处理之前，首先要处理<code>web.xml</code></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;整体流程&quot;&gt;&lt;a href=&quot;#整体流程&quot; class=&quot;headerlink&quot; title=&quot;整体流程&quot;&gt;&lt;/a&gt;整体流程&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;所有的请求都被拦截到&lt;code&gt;DispatcherServlet&lt;/code&gt;,它也是一个&lt;code&gt;Servlet&lt;/code&gt;,执行&lt;code&gt;doService&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;快照请求中的所有的参数，将框架中的一些对象设置到&lt;code&gt;request&lt;/code&gt;对象中。&lt;/li&gt;
&lt;li&gt;调用&lt;code&gt;doDispatch(request,response)&lt;/code&gt;方法&lt;/li&gt;
&lt;li&gt;调用&lt;code&gt;getHandler&lt;/code&gt;方法获取对应的&lt;code&gt;Handler&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;调用&lt;code&gt;getHandlerAdapter&lt;/code&gt;拿到对应的&lt;code&gt;HandlerAdapter&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;应用拦截器的&lt;code&gt;PreHandler&lt;/code&gt;,如果拦截器的&lt;code&gt;PreHandeler&lt;/code&gt;返回false，则直接返回&lt;/li&gt;
&lt;li&gt;调用&lt;code&gt;HandlerAdapter&lt;/code&gt;对象的&lt;code&gt;handler&lt;/code&gt;得到&lt;code&gt;ModelAndView&lt;/code&gt;对象&lt;/li&gt;
&lt;li&gt;应用拦截器的&lt;code&gt;postHandle&lt;/code&gt;方法&lt;/li&gt;
&lt;li&gt;调用&lt;code&gt;processDispatchResult&lt;/code&gt;对结果进行处理，其内部调用了拦截器的&lt;code&gt;afterCompletion&lt;/code&gt;方法&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="https://zofun.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="SpringMVC" scheme="https://zofun.github.io/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>Netty之ChannelHandler</title>
    <link href="https://zofun.github.io/2020/05/17/Netty%E4%B9%8BChannelHandler/"/>
    <id>https://zofun.github.io/2020/05/17/Netty之ChannelHandler/</id>
    <published>2020-05-17T14:21:00.000Z</published>
    <updated>2020-05-18T09:55:56.753Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="channel的生命周期">Channel的生命周期</span></h2><p><code>Channel</code>包含4个状态：</p><table><thead><tr><th>ChannelUnregistered</th><th>Channel已经被创建，但还未注册到EventLoop</th></tr></thead><tbody><tr><td>ChannelRegistered</td><td>Channel已经被注册到EventLoop</td></tr><tr><td>ChannelActive</td><td>Channel处于活动状态，它现在可以接受和发送数据了</td></tr><tr><td>ChannelInactive</td><td>Channel没有连接到远程节点</td></tr></tbody></table><a id="more"></a><h2><span id="channelhandler的生命周期">ChannelHandler的生命周期</span></h2><p><code>ChannelHandler</code>接口定义了一系列生命周期操作：</p><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>handlerAdded</td><td>当把ChannelHandler添加到ChannelPipeline中时要调用</td></tr><tr><td>handlerRemoved</td><td>当从ChannelPipeline中移除ChannelHandler时被调用</td></tr><tr><td>exceptionCaught</td><td>当处理过程中在ChannelPipeline中有错误产生时调用</td></tr></tbody></table><h2><span id="channelinboundhandler接口">ChannelInboundHandler接口</span></h2><p><img src="https://s1.ax1x.com/2020/05/17/YRSkl9.png" alt="YRSkl9.png"></p><h2><span id="channeloutboundhandler接口">ChannelOutboundHandler接口</span></h2><p><img src="https://s1.ax1x.com/2020/05/17/YRSew6.png" alt="YRSew6.png"></p><h2><span id="channelhandler适配器">ChannelHandler适配器</span></h2><p><img src="https://s1.ax1x.com/2020/05/17/YRSJmt.png" alt="YRSJmt.png"></p><h2><span id="资源管理">资源管理</span></h2><p>每当调用<code>ChannelInboundHandler.channelRead()</code>或者<code>ChannelOutboundHandler.write()</code>方法来处理数据时，都需要确保没有任何的资源泄漏。Netty使用引用计数来处理池化的<code>ByteBuf</code>.所以在完全使用某个<code>ByteBuf</code>之后，调整其引用计数是很重要的。<br>Netty提供了<code>class ResourceLeakDetector</code>，它可以对应用程序缓冲区分配做大约1%的采样率进行内存泄漏检测。相关的开销是非常的小的。</p><table><thead><tr><th>级别</th><th>描述</th></tr></thead><tbody><tr><td>DISABLED</td><td>禁止内存泄漏检测</td></tr><tr><td>SIMPLE</td><td>使用1%的默认采样率检测并报告任何发现的泄漏。（默认）</td></tr><tr><td>ADVANCED</td><td>使用默认的采样率，报告所发现的任何的泄漏以及对应的消息被访问的位置。</td></tr><tr><td>PARANOID</td><td>类是于ADVANCED，但是其间会对每次访问都进行采样。这会对性能有较大的影响。</td></tr></tbody></table><p>泄漏检测级别可以通过JVM启动选项来设置：<br><code>java -Dio.netty.leakDetectionLevel=ADVANCED</code></p><h2><span id="channelpipeline接口">ChannelPipeline接口</span></h2><p><code>ChannelPipeline</code>是一个拦截流经<code>Channel</code>的入站和出站事件的<code>ChannelHandler</code>实例链。每一个新创建的Channel都会被分配给一个新的ChannelPipeline，这项关联式永久性的，Channel既不能附加另外一个ChannelPipeline，也不能分离其当前的。<br>根据事件的起源事件将会被分为<code>ChannelInboundHandler</code>或者<code>ChannelOutboundHandler</code>处理。<br><img src="https://s1.ax1x.com/2020/05/17/YRNLan.png" alt="YRNLan.png"></p><h3><span id="修改channelpipeline">修改ChannelPipeline</span></h3><p><code>ChannelPipeline</code>可以通过添加、删除或者替换其它的<code>ChannelHandler</code>来实时地修改<code>ChannelPipeline</code>的布局。<br><img src="https://s1.ax1x.com/2020/05/17/YRUIF1.png" alt="YRUIF1.png"><br><code>ChannelPipeline</code>还提供了访问<code>ChannelHandler</code>的操作：<br><img src="https://s1.ax1x.com/2020/05/17/YRdAgK.png" alt="YRdAgK.png"></p><h3><span id="触发事件">触发事件</span></h3><p><code>ChannelPipeline</code>的API公开了用于调用入站和出站操作的附加方法。<br><img src="https://s1.ax1x.com/2020/05/17/YRd18P.png" alt="YRd18P.png"><br><img src="https://s1.ax1x.com/2020/05/17/YRdB80.png" alt="YRdB80.png"></p><h2><span id="channelhandlercontext接口">ChannelHandlerContext接口</span></h2><p><code>ChannelHandlerContext</code>代表了<code>ChannelHandler</code>和<code>ChannelPipeline</code>之间的关联。每当有<code>ChannelHandler</code>添加到<code>ChannelPipeline</code>中时，都会创建<code>ChannelHandlerContext</code>。<code>ChannelHandlerContext</code>的主要功能就是管理它所关联的<code>ChannelHandler</code>和在同一<code>ChannelPipeline</code>中的其它<code>ChannelHandler</code>之间的交互。</p><h2><span id="异常处理">异常处理</span></h2><p>Netty提供了几种方式来处理入站和出站过程中出现的异常。</p><h3><span id="入站异常">入站异常</span></h3><p>如果需要处理入站异常，需要在对应的<code>ChannelInboundHandler</code>中重写<code>exceptionCaught</code>方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InboundExceptionHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span></span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">Throwable cause)</span> </span>&#123;</span><br><span class="line">cause.printStackTrace();</span><br><span class="line">ctx.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>一般将异常处理的<code>ChannelHandler</code>放到<code>ChannelPipeline</code>的最后一个位置。这样在整个处理路链中无论哪个环节出了异常都可以得到处理。因为<code>exceptionCaught()</code>的默认实现是将异常转发给下一个<code>HandlerHandler</code>.</p><h3><span id="处理出站异常">处理出站异常</span></h3><p>处理出站异常基于以下的机制：</p><ul><li>每个出站操作都会返回一个<code>ChannelFuture</code>，注册到<code>ChannelFuture</code>的<code>ChannelFutureListener</code>将在操作完成时痛殴之该操作时注册成功还是出错了</li><li>几乎所有的<code>ChannelOutboundHandler</code>上的方法都会传入一个<code>ChannelPromise</code>的实例，作为<code>ChannelFuture</code>的子类，<code>ChannelPromise</code>也可以被分配用于异步通知的监听器。但是，<code>ChannelPromise</code>还具有提供立即通知的可写方法。</li></ul><p>处理方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ChannelFuture future = channel.write(someMessage);</span><br><span class="line">future.addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture f)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!f.isSuccess()) &#123;</span><br><span class="line">f.cause().printStackTrace();</span><br><span class="line">f.channel().close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>另一种方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OutboundExceptionHandler</span> <span class="keyword">extends</span>    <span class="title">ChannelOutboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ChannelHandlerContext ctx, Object msg,</span></span></span><br><span class="line"><span class="function"><span class="params">ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">promise.addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture f)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!f.isSuccess()) &#123;</span><br><span class="line">f.cause().printStackTrace();</span><br><span class="line">f.channel().close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Channel的生命周期&quot;&gt;&lt;a href=&quot;#Channel的生命周期&quot; class=&quot;headerlink&quot; title=&quot;Channel的生命周期&quot;&gt;&lt;/a&gt;Channel的生命周期&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Channel&lt;/code&gt;包含4个状态：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;ChannelUnregistered&lt;/th&gt;
&lt;th&gt;Channel已经被创建，但还未注册到EventLoop&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;ChannelRegistered&lt;/td&gt;
&lt;td&gt;Channel已经被注册到EventLoop&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ChannelActive&lt;/td&gt;
&lt;td&gt;Channel处于活动状态，它现在可以接受和发送数据了&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ChannelInactive&lt;/td&gt;
&lt;td&gt;Channel没有连接到远程节点&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="https://zofun.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Netty" scheme="https://zofun.github.io/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>负载均衡的实现方式与算法</title>
    <link href="https://zofun.github.io/2020/05/17/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    <id>https://zofun.github.io/2020/05/17/负载均衡的实现方式与算法/</id>
    <published>2020-05-17T09:47:00.000Z</published>
    <updated>2020-05-18T09:47:15.900Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="负载均衡的实现方式">负载均衡的实现方式</span></h2><h3><span id="http重定向负载均衡">HTTP重定向负载均衡</span></h3><p><img src="https://s1.ax1x.com/2020/05/18/YflQIK.png" alt="YflQIK.png"></p><p>HTTP重定向负载均衡需要一台重定向服务器。它的功能就是根据用户的HTTP请求根据负载均衡算法选择一个真实的服务器地址，并将服务器地址信息写入到重定向响应中返回给用户浏览器。用户浏览器再获取到响应之后，根据返回的信息，重新发送一个请求到真实的服务器上。</p><a id="more"></a><p>优点：</p><ul><li><p>实现比较简单<br>缺点：</p></li><li><p>浏览器需要请求两次服务器才能完成一次访问，性能较差。</p></li><li>重定向服务器本身容易成为性能的瓶颈，使得整个集群的伸缩性有限。</li><li>另外HTTP返回码302重定向，可能会使搜索引擎判断未SEO作弊，降低搜索排名。</li></ul><h3><span id="dns域名解析负载均衡">DNS域名解析负载均衡</span></h3><p><img src="https://s1.ax1x.com/2020/05/18/Yf1Ttf.png" alt="Yf1Ttf.png"><br>DNS域名解析负载均衡是在进行域名解析的时候分局负载均衡算法选择一个合适的I{P地址返回，这样来实现负载均衡。<strong>大型网站一般将DNS域名解析负载均衡作为第一级负载均衡的手段</strong><br>优点：</p><ul><li>将负载均衡的工作交由DNS，省去了管理完整负载均衡服务器的麻烦</li><li>技术实现比较灵活、方便、简单易行，成本低，适用于大多数TCP/IP应用</li><li>对于部署的服务而言，无需任何的修改</li><li>服务器可以位于互联网的任意位置</li><li>一些DNS还支持地址位置的域名解析，即域名解析成距离用户地址位置最近的一个服务器地址，这样可以加快用户的访问速度。</li></ul><p>缺点；</p><ul><li>因为DNS是多级解析的，因此当集群结构改变后，需要很长时间才能使缓冲的DNS信息刷新。</li><li>不能按照服务器的处理能力来分配负载。DNS负载均衡采用的是简单的轮询算法，不能区分服务器之间的差异，不能反映服务器的运行状态。</li><li>可能会造成额外的网络问题，为了使本DNS服务器和其它DNS服务器能够即时的交互，保证DNS数据及时更新，使地址能够随机分配，一般都要将DNS的刷新时间设置的较小，但太小将会使DNS流量大增造成额外的网络问题。</li></ul><h3><span id="反向代理负载均衡">反向代理负载均衡</span></h3><p><img src="https://s1.ax1x.com/2020/05/18/Yf5GEd.png" alt="Yf5GEd.png"><br>通过反向代理服务器来选择合适的服务器作为目的服务器进行请求的转发。来实现负载均衡</p><h3><span id="ip负载均衡">IP负载均衡</span></h3><p>IP负载均衡又称为网络层负载均衡，它和原理就是通过内核驱动更改IP的目的地址来完成数据负载均衡。<br><img src="https://s1.ax1x.com/2020/05/18/YfRWi6.png" alt="YfRWi6.png"><br>原理图：<br><img src="https://s1.ax1x.com/2020/05/18/YfRTLd.png" alt="YfRTLd.png"><br>IP负载均衡在内核进程完成数据分发，处理性能得到了很好的提高。但是由于所有请求和响应都要经过负载均衡服务器，集群的最大响应数据吞吐量将受到负载均衡服务器网卡带宽的限制。</p><h3><span id="数据链路负载均衡">数据链路负载均衡</span></h3><p>数据链路层负载均衡通过修改通信协议数据包的mac地址进行负载均衡。<br><img src="https://s1.ax1x.com/2020/05/18/Yf4bjS.png" alt="Yf4bjS.png"><br>这种三角传输模式的链路层负载均衡是目前大型网站使用比较广泛的负载均衡手段。在Linux平台下最好的链路层负载均衡开源产品时LVS（Linux Virtual Server）。</p><h2><span id="基本的负载均衡算法">基本的负载均衡算法</span></h2><h3><span id="轮询法">轮询法</span></h3><p>将请求按照顺序轮流的分配到后端服务器上，它均衡地对待后端的每一台服务器，而不关心服务器实际的连接数和当前的系统负载。</p><h3><span id="随机法">随机法</span></h3><p>通过随机算法，根据后端服务器的列表大小指来随机的选择其中的一台服务器进行访问。</p><h3><span id="源地址哈希法">源地址哈希法</span></h3><p>源地址哈希的思想是根据获取客户端的IP，通过hash函数计算得到的一个数值，用改数值对服务器列表的大小进行取模运算，得到的结果便是客服端要访问的服务器的序列。采用源地址哈希法进行负载均衡，同一IP地址的客户端，当后端服务器列表不变时，它每次都会映射到同一台后端服务器进行访问。</p><h3><span id="加权轮询法">加权轮询法</span></h3><p>不同的后端服务器可能机器的配置和当前系统的负载并不相同，因此它们的抗压能力也不相同。给配置高、负载低的机器配置更高的权重，让其处理更多的请；而配置低、负载高的机器，给其分配较低的权重，降低其系统负载，加权轮询能很好地处理这一问题，并将请求顺序且按照权重分配到后端。</p><h3><span id="加权随机法">加权随机法</span></h3><p>与加权轮询法一样，加权随机法也根据后端机器的配置，系统的负载分配不同的权重。不同的是，它是按照权重随机请求后端服务器，而非顺序。</p><h3><span id="最小连接数法">最小连接数法</span></h3><p>最小连接数算法比较灵活和智能，由于后端服务器的配置不尽相同，对于请求的处理有快有慢，它是根据后端服务器当前的连接情况，动态地选取其中当前积压连接数最少的一台服务器来处理当前的请求，尽可能地提高后端服务的利用效率，将负责合理地分流到每一台服务器。</p><h2><span id="nginx提供的负载均衡算法">Nginx提供的负载均衡算法</span></h2><ul><li>轮询</li><li>加权轮询</li><li>IP_hash</li><li>fair<br>  根据后端服务器的响应时间来进行分配，响应时间段的优先分配。</li><li><p>url_hash</p><h2><span id="dubbo提供的负载均衡算法">Dubbo提供的负载均衡算法</span></h2></li><li><p>加权随机</p></li><li>加权轮询</li><li>最小活跃调用</li><li><p>一致性hash算法</p><p>  <img src="https://s1.ax1x.com/2020/05/18/Yh984P.png" alt="Yh984P.png"></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;负载均衡的实现方式&quot;&gt;&lt;a href=&quot;#负载均衡的实现方式&quot; class=&quot;headerlink&quot; title=&quot;负载均衡的实现方式&quot;&gt;&lt;/a&gt;负载均衡的实现方式&lt;/h2&gt;&lt;h3 id=&quot;HTTP重定向负载均衡&quot;&gt;&lt;a href=&quot;#HTTP重定向负载均衡&quot; class=&quot;headerlink&quot; title=&quot;HTTP重定向负载均衡&quot;&gt;&lt;/a&gt;HTTP重定向负载均衡&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/05/18/YflQIK.png&quot; alt=&quot;YflQIK.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;HTTP重定向负载均衡需要一台重定向服务器。它的功能就是根据用户的HTTP请求根据负载均衡算法选择一个真实的服务器地址，并将服务器地址信息写入到重定向响应中返回给用户浏览器。用户浏览器再获取到响应之后，根据返回的信息，重新发送一个请求到真实的服务器上。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="https://zofun.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="分布式" scheme="https://zofun.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Netty之ByteBuf</title>
    <link href="https://zofun.github.io/2020/05/17/Netty%E4%B9%8BByteBuf/"/>
    <id>https://zofun.github.io/2020/05/17/Netty之ByteBuf/</id>
    <published>2020-05-17T08:24:00.000Z</published>
    <updated>2020-05-17T08:23:21.104Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="简介">简介</span></h2><p><code>ByteBuf</code>是Netty的数据容器，它解决了JDK API的局限性，能为网络应用程序的开发者提供更好的API支持。<br><code>ByteBuf</code>API的优点如下：</p><ul><li>它可以被用户自定义的缓冲区类型拓展</li><li>通过内置的复合缓冲区类型实现了透明的零拷贝。</li><li>容量可以按需增长</li><li>在读和写这两种模式下切换不需要调用<code>BuyteBuffer</code>的<code>flip()</code>方法</li><li>读和写使用了不同的索引</li><li>方式支持链式调用</li><li>支持引用计数</li><li>支持池化</li></ul><a id="more"></a><h2><span id="工作原理">工作原理</span></h2><p><code>ByteBuf</code>内部维护了两个不同的索引，一个用于读取，一个用于写入。<br><img src="https://s1.ax1x.com/2020/05/17/Y2JhY8.png" alt="Y2JhY8.png"></p><h2><span id="使用模式">使用模式</span></h2><h3><span id="堆缓冲区">堆缓冲区</span></h3><p>最常见的<code>ByteBuf</code>模式，是将数据存储到JVM的堆空间中。这种模式被称为支持数组。它能够在没有使用池化的情况下，提供较为快速的分配和释放。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ByteBuf heapBuf = ...;</span><br><span class="line"><span class="comment">//检查是否是数组支撑</span></span><br><span class="line"><span class="keyword">if</span> (heapBuf.hasArray()) &#123;</span><br><span class="line"><span class="keyword">byte</span>[] array = heapBuf.array();</span><br><span class="line"><span class="keyword">int</span> offset = heapBuf.arrayOffset() + heapBuf.readerIndex();</span><br><span class="line"><span class="keyword">int</span> length = heapBuf.readableBytes();</span><br><span class="line">handleArray(array, offset, length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3><span id="直接缓冲区">直接缓冲区</span></h3><p>直接缓冲区是指内存空间是通过本地调用分配而来的。因此直接缓冲区的内容将驻留在堆外。<br>通过使用直接缓冲区，避免了依次将JVM堆中的缓冲区复制到直接缓冲区的国产，因此效率更高。但是直接缓冲区的创建和释放的成本比较高。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ByteBuf directBuf = ...;</span><br><span class="line"><span class="keyword">if</span> (!directBuf.hasArray()) &#123;</span><br><span class="line">    <span class="comment">//如果不是数组支撑，那么就是一个直接缓冲区</span></span><br><span class="line"><span class="keyword">int</span> length = directBuf.readableBytes();</span><br><span class="line"><span class="keyword">byte</span>[] array = <span class="keyword">new</span> <span class="keyword">byte</span>[length];</span><br><span class="line">    <span class="comment">//从直接缓冲区中读取数据到array中</span></span><br><span class="line">directBuf.getBytes(directBuf.readerIndex(), array);</span><br><span class="line">handleArray(array, <span class="number">0</span>, length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3><span id="复合缓冲区">复合缓冲区</span></h3><p>复合缓冲区可以为多个<code>ByteBuf</code>提供一个聚合视图。我们可以根据需要添加或删除<code>ByteBuf</code>实例。Netty通过<code>ByteBuf</code>的一个子类<code>CompositeByteBuf</code>来实现复合缓冲区。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">byteBufComposite</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 复合缓冲区，只是提供一个视图</span></span><br><span class="line">    CompositeByteBuf messageBuf = Unpooled.compositeBuffer();</span><br><span class="line">    ByteBuf headerBuf = Unpooled.buffer(); <span class="comment">// can be backing or direct</span></span><br><span class="line">    ByteBuf bodyBuf = Unpooled.directBuffer();   <span class="comment">// can be backing or direct</span></span><br><span class="line">    messageBuf.addComponents(headerBuf, bodyBuf);</span><br><span class="line">    messageBuf.removeComponent(<span class="number">0</span>); <span class="comment">// remove the header</span></span><br><span class="line">    <span class="keyword">for</span> (ByteBuf buf : messageBuf) &#123;</span><br><span class="line">        System.out.println(buf.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="字节级操作">字节级操作</span></h2><h3><span id="随机访问索引">随机访问索引</span></h3><p>和普通的Java数组一样，<code>ByteBuf</code>的索引也是从零开始的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ByteBuf buffer = ...;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; buffer.capacity(); i++) &#123;</span><br><span class="line"><span class="keyword">byte</span> b = buffer.getByte(i);</span><br><span class="line">System.out.println((<span class="keyword">char</span>)b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3><span id="顺序访问索引">顺序访问索引</span></h3><p><code>ByteBuf</code>同时具有读索引和写索引，因此两个索引把<code>ByteBuf</code>分为了三个部分。分贝是可丢弃字节区，可读字节区，可写字节区。<br><img src="https://s1.ax1x.com/2020/05/17/Y2yPnf.png" alt="Y2yPnf.png"></p><h3><span id="查找操作">查找操作</span></h3><p>查找<code>ByteBuf</code>指定的指。可以利用<code>indexOf()</code>来直接查询，也可以利用<code>ByteProcessor</code>作为参数来查找某个指定的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">byteProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ByteBuf buffer = Unpooled.buffer(); <span class="comment">//get reference form somewhere</span></span><br><span class="line">    <span class="comment">// 使用indexOf()方法来查找</span></span><br><span class="line">    buffer.indexOf(buffer.readerIndex(), buffer.writerIndex(), (<span class="keyword">byte</span>)<span class="number">8</span>);</span><br><span class="line">    <span class="comment">// 使用ByteProcessor查找给定的值</span></span><br><span class="line">    <span class="keyword">int</span> index = buffer.forEachByte(ByteProcessor.FIND_CR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="派生缓冲区">派生缓冲区</span></h3><p>派生缓冲区为<code>ByteBuf</code>提供了以专门的方式来呈现其内容的视图，这类视图是通过以下方法被创建的:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">duplicate();</span><br><span class="line">slice();</span><br><span class="line">slice(<span class="keyword">int</span>,<span class="keyword">int</span>);</span><br><span class="line">Upooled.ummodifiableBuffer(...);</span><br><span class="line">order(ByteOrder);</span><br><span class="line">readSlice(<span class="keyword">int</span>);</span><br></pre></td></tr></table></figure><h2><span id="bytebufholder接口">ByteBufHolder接口</span></h2><p><code>ByteBufHolder</code>是<code>ByteBuf</code>的容器，可以通过子类实现<code>ByteBufHolder</code>接口，根据自身需要添加自己需要的数据字段。可以用于自定义缓冲区类型扩展字段。<br><code>ByteBufHolder</code>接口提供了几种用于访问底层数据和引用计数的方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">content();<span class="comment">//返回持有的所有的ByteBuf</span></span><br><span class="line">copy();<span class="comment">//返回一个深拷贝</span></span><br><span class="line">duplicate();<span class="comment">//返回一个浅拷贝</span></span><br></pre></td></tr></table></figure></p><h2><span id="bytebuf分配">ByteBuf分配</span></h2><h3><span id="按需分配bytebufallocator接口">按需分配ByteBufAllocator接口</span></h3><p>为了降低分配和释放内存的开销，Netty通过<code>ByteBufAllocator</code>实现<code>ByteBuf</code>池化。<br><img src="https://s1.ax1x.com/2020/05/17/Y22ixs.png" alt="Y22ixs.png"><br>如何获取<code>ByteBufAllocator</code>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Channel channel = ...;</span><br><span class="line"><span class="comment">//从Channel中获取</span></span><br><span class="line">ByteBufAllocator allocator = channel.alloc();</span><br><span class="line"></span><br><span class="line"><span class="comment">//从ChannelHandlerContext中获取</span></span><br><span class="line">ChannelHandlerContext ctx = ...;</span><br><span class="line">ByteBufAllocator allocator2 = ctx.alloc();</span><br></pre></td></tr></table></figure><h3><span id="unpooled缓冲区">Unpooled缓冲区</span></h3><p>在不能获取到<code>ByteBufAllocator</code>中情况下，可以使用<code>Unpooled</code>获取缓冲区。<br><img src="https://s1.ax1x.com/2020/05/17/Y22wzd.png" alt="Y22wzd.png"></p><h2><span id="引用计数">引用计数</span></h2><p>引用计数是一种通过在某个对象所持有的资源不再被其它对象引用时释放该对象所持有的资源来优化内存使用和性能的计数。</p><p>一个<code>ReferencceCounted</code>实现的实例通常以活动的引用计数为1作为开始。只要引用计数大于0，旧能保证对象不会被释放。当活动引用的数量减少到0时，该实例就会被释放。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ByteBuf buffer = ...</span><br><span class="line">  <span class="comment">// 引用计数加1</span></span><br><span class="line">  buffer.retain();</span><br><span class="line">  <span class="comment">// 输出引用计数</span></span><br><span class="line">  buffer.refCnt();</span><br><span class="line">  <span class="comment">// 引用计数减1</span></span><br><span class="line">  buffer.release();</span><br></pre></td></tr></table></figure><h2><span id="零拷贝">零拷贝</span></h2><p>零拷贝是指在操作数据的时候，不需要将数据buffer从一个内存区域拷贝到另一个内存区域，因为少了一次内存的拷贝，因此CPU的效率就得到了较大的提升。</p><h3><span id="os层面的零拷贝">OS层面的零拷贝</span></h3><p>OS层面的零拷贝通常是指避免在用户态与内核态之间来回进行数据拷贝。比如Linux提供了<code>mmap</code>系统调用，它可以将用户内存空间映射到内核空间。这样用户对这段内存空间的操作就可以直接反映到内核。</p><h3><span id="netty层面的零拷贝">Netty层面的零拷贝</span></h3><p>Netty层面的零拷贝主要体现在这几个方法：</p><ul><li>提供了<code>CompositeByteBuf</code>,它可以将多个<code>ByteBuf</code>合并为一个逻辑上的<code>ByteBif</code>,避免了<code>ByteBuf</code>之间的拷贝。</li><li><p>通过<code>wrap</code>操作，我们可以将<code>byte[]</code>数组,<code>ByteBuf</code>、<code>ByteBuffer</code>包装为一个<code>ByteBuf</code>对象，进而避免了拷贝操作。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] bytes = ...</span><br><span class="line">ByteBuf byteBuf = Unpooled.wrappedBuffer(bytes);</span><br></pre></td></tr></table></figure></li><li><p><code>ByteBuf</code> 支持 <code>slice</code>操作, 因此可以将 <code>ByteBuf</code> 分解为多个<strong>共享同一个存储区域</strong>的 <code>ByteBuf</code>, 避免了内存的拷贝.</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ByteBuf byteBuf = ...</span><br><span class="line">ByteBuf header = byteBuf.slice(<span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line">ByteBuf body = byteBuf.slice(<span class="number">5</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure></li><li><p>通过 <code>FileRegion</code> 包装的<code>FileChannel.tranferTo</code> 实现文件传输, 可以直接将文件缓冲区的数据发送到目标 <code>Channel</code>, 避免了传统通过循环 write 方式导致的内存拷贝问题.</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile srcFile = <span class="keyword">new</span> RandomAccessFile(srcFileName, <span class="string">"r"</span>);</span><br><span class="line">   FileChannel srcFileChannel = srcFile.getChannel();</span><br><span class="line"></span><br><span class="line">   RandomAccessFile destFile = <span class="keyword">new</span> RandomAccessFile(destFileName, <span class="string">"rw"</span>);</span><br><span class="line">   FileChannel destFileChannel = destFile.getChannel();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">long</span> position = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">long</span> count = srcFileChannel.size();</span><br><span class="line"><span class="comment">//直接传输，而不是通过while进行循环的</span></span><br><span class="line">   srcFileChannel.transferTo(position, count, destFileChannel);</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;&lt;code&gt;ByteBuf&lt;/code&gt;是Netty的数据容器，它解决了JDK API的局限性，能为网络应用程序的开发者提供更好的API支持。&lt;br&gt;&lt;code&gt;ByteBuf&lt;/code&gt;API的优点如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;它可以被用户自定义的缓冲区类型拓展&lt;/li&gt;
&lt;li&gt;通过内置的复合缓冲区类型实现了透明的零拷贝。&lt;/li&gt;
&lt;li&gt;容量可以按需增长&lt;/li&gt;
&lt;li&gt;在读和写这两种模式下切换不需要调用&lt;code&gt;BuyteBuffer&lt;/code&gt;的&lt;code&gt;flip()&lt;/code&gt;方法&lt;/li&gt;
&lt;li&gt;读和写使用了不同的索引&lt;/li&gt;
&lt;li&gt;方式支持链式调用&lt;/li&gt;
&lt;li&gt;支持引用计数&lt;/li&gt;
&lt;li&gt;支持池化&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="https://zofun.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Netty" scheme="https://zofun.github.io/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>Netty线程模型</title>
    <link href="https://zofun.github.io/2020/05/16/Netty%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/"/>
    <id>https://zofun.github.io/2020/05/16/Netty线程模型/</id>
    <published>2020-05-16T14:04:00.000Z</published>
    <updated>2020-05-16T14:06:28.513Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="reactor线程模型">Reactor线程模型</span></h2><p>Netty的线程模型实际上就是Reactor模型的一种实现。</p><p>Reactor模型是基于事件驱动开发的，核心组成部分是一个Reactor和一个线程池，其中Reactor负责监听和分配事件，线程池负责处理事件。根据Reactor的数量有线程池的数量，又可以将Reactor分为三种模型：</p><ul><li>单线程模型（单Reactor，单线程）</li><li>多线程模型（单Reactor，多线程）</li><li>主从多线程模型（多Reactor，多线程）</li></ul><a id="more"></a><h3><span id="单线程模型">单线程模型</span></h3><p><img src="https://s1.ax1x.com/2020/05/16/YcVCsH.png" alt="YcVCsH.png"></p><ul><li>Reactor内部通过<code>selector</code>轮询连接，收到事件后，通过<code>dispatch</code>进行分发。</li><li>如果是连接事件，则分发给<code>Acceptor</code>处理，<code>Accepter</code>通过<code>accept</code>接受连接，并创建一个<code>Headler</code>来处理连接后的各种事件。</li><li>如果是读写事件，那么直接交由对应的<code>Headelr</code>进行处理。</li></ul><h3><span id="多线程模型">多线程模型</span></h3><p><img src="https://s1.ax1x.com/2020/05/16/YcZNNt.png" alt="YcZNNt.png"></p><ul><li>主线程中，Reactor对象通过<code>selector</code>监控连接事件，收到事件后通过<code>dispatch</code>进行分发。</li><li>如果是建立连接的事件，则<code>Accepter</code>负责处理，它会通过<code>accept</code>接受请求，并创建一个<code>Headler</code>来处理后序事件，<strong>而<code>Headler</code>只负责相应事件，不进行业务操作，也就是只进行<code>read</code>读取数据和<code>write</code>写出数据，业务处理是交给线程池进行处理</strong>。</li><li>线程池分配一个线程来进行业务的处理，处理结果交由对应的<code>Handler</code>进行转发。</li></ul><h3><span id="主从多线程模型">主从多线程模型</span></h3><p><img src="https://s1.ax1x.com/2020/05/16/YcZgNq.png" alt="YcZgNq.png"></p><ul><li>存在多个<code>Reactor</code>，每个<code>Reactor</code>都有自己的<code>selector</code>选择器，线程和<code>dispatch</code></li><li>主线程中的<code>mainReactor</code>通过自己的<code>selector</code>监控连接建立事件，收到事件后通过<code>Accepter</code>接受，将任务分配给某个子线程。</li><li>子线程中的<code>subReactor</code>将<code>mainReactor</code>分配的连接加入连接队列中通过自己的<code>selector</code>进行监听，并创建一个<code>Handler</code>用于处理后序事件。</li><li><code>Handler</code>完成<code>read</code>-&gt;业务处理-&gt;<code>send</code>的完整业务流程。</li></ul><h2><span id="netty中的线程模型与reactor的联系">Netty中的线程模型与Reactor的联系</span></h2><p>在Netty中主要是通过<code>NioEventLoopGroup</code>线程池来实现具体的线程模型的。</p><h3><span id="单线程模型">单线程模型</span></h3><p>单线程模型就是指定一个线程执行客户端连接和读写操作，也就是在一个<code>Reactor</code>中完成。对应的实现方式就是将<code>NioEventLoopGroup</code>线程数设置为1.</p><p>Netty中是这样构造单线程模型的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NioEventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">       ServerBootstrap bootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">       bootstrap.group(group)</span><br><span class="line">               .channel(NioServerSocketChannel.class)</span><br><span class="line">               .channel(NioServerSocketChannel.class)</span><br><span class="line">               .option(ChannelOption.TCP_NODELAY, <span class="keyword">true</span>)</span><br><span class="line">               .option(ChannelOption.SO_BACKLOG, <span class="number">1024</span>)</span><br><span class="line">               .childHandler(<span class="keyword">new</span> ServerHandlerInitializer());</span><br></pre></td></tr></table></figure><h3><span id="多线程模型">多线程模型</span></h3><p>多线程模型就是当<code>Reactor</code>进行客户端的连接处理，然后业务处理交由线程池来执行。</p><p>Netty中是这样构造多线程模型的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NioEventLoopGroup eventGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">ServerBootstrap bootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">bootstrap.group(eventGroup)</span><br><span class="line">        .channel(NioServerSocketChannel.class)</span><br><span class="line">        .option(ChannelOption.TCP_NODELAY, <span class="keyword">true</span>)</span><br><span class="line">        .option(ChannelOption.SO_BACKLOG, <span class="number">1024</span>)</span><br><span class="line">        .childHandler(<span class="keyword">new</span> ServerHandlerInitializer());</span><br></pre></td></tr></table></figure><h3><span id="主从多线程模型最常使用">主从多线程模型（最常使用）</span></h3><p>主从多线程模型是有多个<code>Reactor</code>,也就是有多个<code>selector</code>,所以我们定义一个<code>bossGroup</code>和一个<code>workGroup</code></p><p>在Netty中是这样构建主从多线程模型的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NioEventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">NioEventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">ServerBootstrap bootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">bootstrap.group(bossGroup,workerGroup)</span><br><span class="line">        .channel(NioServerSocketChannel.class)</span><br><span class="line">        .option(ChannelOption.TCP_NODELAY, <span class="keyword">true</span>)</span><br><span class="line">        .option(ChannelOption.SO_BACKLOG, <span class="number">1024</span>)</span><br><span class="line">        .childHandler(<span class="keyword">new</span> ServerHandlerInitializer());</span><br></pre></td></tr></table></figure><p>相较于多线程模型，主从多线程模型不会遇到处理连接的瓶颈问题。在多线程模型下，因为只有一个NIO的<code>Acceptor</code>来处理连接请求，所以会出现性能瓶颈。</p><h2><span id="nioeventloop源码分析">NioEventLoop源码分析</span></h2><p>在Netty线程模型中，<code>NioEventLoop</code>是比较关键的类。下面我们对它的实现进行分析。</p><p><img src="https://s1.ax1x.com/2020/05/16/Yc7gje.png" alt="Yc7gje.png"></p><p>它的继承关系图如下：</p><p><img src="https://s1.ax1x.com/2020/05/16/YcoFud.png" alt="YcoFud.png"></p><p><code>NioEventLoop</code>需要处理网络IO请求，因此有一个多路复用器<code>Selector</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Selector selector;</span><br><span class="line"><span class="keyword">private</span> Selector unwrappedSelector;</span><br><span class="line"><span class="keyword">private</span> SelectedSelectionKeySet selectedKeys;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> SelectorProvider provider;</span><br></pre></td></tr></table></figure><p>并且在构造方法中完成了初始化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">NioEventLoop(NioEventLoopGroup parent, Executor executor, SelectorProvider selectorProvider,</span><br><span class="line">             SelectStrategy strategy, RejectedExecutionHandler rejectedExecutionHandler,</span><br><span class="line">             EventLoopTaskQueueFactory queueFactory) &#123;</span><br><span class="line">    <span class="keyword">super</span>(parent, executor, <span class="keyword">false</span>, newTaskQueue(queueFactory), newTaskQueue(queueFactory),</span><br><span class="line">            rejectedExecutionHandler);</span><br><span class="line">    <span class="keyword">if</span> (selectorProvider == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"selectorProvider"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (strategy == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"selectStrategy"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    provider = selectorProvider;</span><br><span class="line">    <span class="keyword">final</span> SelectorTuple selectorTuple = openSelector();</span><br><span class="line">    selector = selectorTuple.selector;</span><br><span class="line">    unwrappedSelector = selectorTuple.unwrappedSelector;</span><br><span class="line">    selectStrategy = strategy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>NioEventLoop</code>中<code>run()</code>方法比较的关键：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   <span class="comment">//通过hasTasks方法判断队列中是否还有未处理的方法</span></span><br><span class="line">                   <span class="keyword">switch</span> (selectStrategy.calculateStrategy(selectNowSupplier, hasTasks())) &#123;</span><br><span class="line">                   <span class="keyword">case</span> SelectStrategy.CONTINUE:</span><br><span class="line">                       <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">case</span> SelectStrategy.BUSY_WAIT:</span><br><span class="line">                       <span class="comment">// fall-through to SELECT since the busy-wait is not supported with NIO</span></span><br><span class="line"><span class="comment">//没有任务则执行，select()执行网络IO</span></span><br><span class="line">                   <span class="keyword">case</span> SelectStrategy.SELECT:</span><br><span class="line">                       select(wakenUp.getAndSet(<span class="keyword">false</span>));</span><br><span class="line">                       <span class="keyword">if</span> (wakenUp.get()) &#123;</span><br><span class="line">                           selector.wakeup();</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="comment">// fall through</span></span><br><span class="line">                   <span class="keyword">default</span>:</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                   <span class="comment">//如果本轮Selector的轮询结果为null，那么可能触发了jdk epoll的bug</span></span><br><span class="line">                   <span class="comment">//该bug会导致IO线程处于100%的状态，需要重建Selector来解决</span></span><br><span class="line">                   rebuildSelector0();</span><br><span class="line">                   handleLoopException(e);</span><br><span class="line">                   <span class="keyword">continue</span>;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               cancelledKeys = <span class="number">0</span>;</span><br><span class="line">               needsToSelectAgain = <span class="keyword">false</span>;</span><br><span class="line">               <span class="comment">//处理IO事件所需的事件和花费在处理task的时间的比例，默认为50%</span></span><br><span class="line">               <span class="keyword">final</span> <span class="keyword">int</span> ioRatio = <span class="keyword">this</span>.ioRatio;</span><br><span class="line">               <span class="keyword">if</span> (ioRatio == <span class="number">100</span>) &#123;</span><br><span class="line">                   <span class="keyword">try</span> &#123;</span><br><span class="line">                       <span class="comment">//如果比例为100.则表示每次处理完IO后，才开始处理task</span></span><br><span class="line">                       processSelectedKeys();</span><br><span class="line">                   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                       </span><br><span class="line">                       <span class="comment">// 执行task任务</span></span><br><span class="line">                       runAllTasks();</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="comment">//记录处理IO的开始时间</span></span><br><span class="line">                   <span class="keyword">final</span> <span class="keyword">long</span> ioStartTime = System.nanoTime();</span><br><span class="line">                   <span class="keyword">try</span> &#123;</span><br><span class="line">                       <span class="comment">//处理IO请求</span></span><br><span class="line">                       processSelectedKeys();</span><br><span class="line">                   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                       <span class="comment">//计算IO请求的耗时</span></span><br><span class="line">                       <span class="keyword">final</span> <span class="keyword">long</span> ioTime = System.nanoTime() - ioStartTime;</span><br><span class="line">                       <span class="comment">//执行task。判断执行task任务时间是否超过配置的比例，如果超过则停止执行task</span></span><br><span class="line">                       runAllTasks(ioTime * (<span class="number">100</span> - ioRatio) / ioRatio);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">               handleLoopException(t);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// Always handle shutdown even if the loop processing threw an exception.</span></span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="keyword">if</span> (isShuttingDown()) &#123;</span><br><span class="line">                   closeAll();</span><br><span class="line">                   <span class="keyword">if</span> (confirmShutdown()) &#123;</span><br><span class="line">                       <span class="keyword">return</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">               handleLoopException(t);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>重建<code>Selector</code>的方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rebuildSelector0</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">final</span> Selector oldSelector = selector;</span><br><span class="line">      <span class="keyword">final</span> SelectorTuple newSelectorTuple;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (oldSelector == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//创建一个新的Selector</span></span><br><span class="line">          newSelectorTuple = openSelector();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          logger.warn(<span class="string">"Failed to create a new Selector."</span>, e);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Register all channels to the new Selector.</span></span><br><span class="line">      <span class="keyword">int</span> nChannels = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">      <span class="keyword">for</span> (SelectionKey key: oldSelector.keys()) &#123;</span><br><span class="line">          <span class="comment">//将原Selector上注册的所有SelectionKey转移到新的Selector</span></span><br><span class="line">          Object a = key.attachment();</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">if</span> (!key.isValid() || key.channel().keyFor(newSelectorTuple.unwrappedSelector) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                  <span class="keyword">continue</span>;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">int</span> interestOps = key.interestOps();</span><br><span class="line">              key.cancel();</span><br><span class="line">              SelectionKey newKey = key.channel().register(newSelectorTuple.unwrappedSelector, interestOps, a);</span><br><span class="line">              <span class="keyword">if</span> (a <span class="keyword">instanceof</span> AbstractNioChannel) &#123;</span><br><span class="line">                  <span class="comment">// Update SelectionKey</span></span><br><span class="line">                  ((AbstractNioChannel) a).selectionKey = newKey;</span><br><span class="line">              &#125;</span><br><span class="line">              nChannels ++;</span><br><span class="line">          &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">              logger.warn(<span class="string">"Failed to re-register a Channel to the new Selector."</span>, e);</span><br><span class="line">              <span class="keyword">if</span> (a <span class="keyword">instanceof</span> AbstractNioChannel) &#123;</span><br><span class="line">                  AbstractNioChannel ch = (AbstractNioChannel) a;</span><br><span class="line">                  ch.unsafe().close(ch.unsafe().voidPromise());</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                  NioTask&lt;SelectableChannel&gt; task = (NioTask&lt;SelectableChannel&gt;) a;</span><br><span class="line">                  invokeChannelUnregistered(task, key, e);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用新的Selector替换旧的</span></span><br><span class="line">      selector = newSelectorTuple.selector;</span><br><span class="line">      unwrappedSelector = newSelectorTuple.unwrappedSelector;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// time to close the old selector as everything else is registered to the new one</span></span><br><span class="line">          <span class="comment">//关闭旧的Selector</span></span><br><span class="line">          oldSelector.close();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">          <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">              logger.warn(<span class="string">"Failed to close the old Selector."</span>, t);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">          logger.info(<span class="string">"Migrated "</span> + nChannels + <span class="string">" channel(s) to the new Selector."</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>处理IO请求的是由<code>processSelectedKey</code>完成的，它的实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processSelectedKey</span><span class="params">(SelectionKey k, AbstractNioChannel ch)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> AbstractNioChannel.NioUnsafe unsafe = ch.unsafe();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略代码 ......</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> readyOps = k.readyOps();</span><br><span class="line">        <span class="comment">// We first need to call finishConnect() before try to trigger a read(...) or write(...) as otherwise</span></span><br><span class="line">        <span class="comment">// the NIO JDK channel implementation may throw a NotYetConnectedException.</span></span><br><span class="line">        <span class="keyword">if</span> ((readyOps &amp; SelectionKey.OP_CONNECT) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// remove OP_CONNECT as otherwise Selector.select(..) will always return without blocking</span></span><br><span class="line">            <span class="comment">// See https://github.com/netty/netty/issues/924</span></span><br><span class="line">            <span class="keyword">int</span> ops = k.interestOps();</span><br><span class="line">            ops &amp;= ~SelectionKey.OP_CONNECT;</span><br><span class="line">            k.interestOps(ops);</span><br><span class="line"></span><br><span class="line">            unsafe.finishConnect();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((readyOps &amp; SelectionKey.OP_WRITE) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// Call forceFlush which will also take care of clear the OP_WRITE once there is nothing left to write</span></span><br><span class="line">            ch.unsafe().forceFlush();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != <span class="number">0</span> || readyOps == <span class="number">0</span>) &#123;</span><br><span class="line">            unsafe.read();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CancelledKeyException ignored) &#123;</span><br><span class="line">        unsafe.close(unsafe.voidPromise());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>首先获取 Channel 的 NioUnsafe，所有的读写等操作都在 Channel 的 unsafe 类中操作。</li><li>获取 SelectionKey 就绪事件，如果是 OP_CONNECT，则说明已经连接成功，并把注册的 OP_CONNECT 事件取消。</li><li>如果是 OP_WRITE 事件，说明可以继续向 Channel 中写入数据，当写完数据后用户自己吧 OP_WRITE 事件取消掉。</li><li>如果是 OP_READ 或 OP_ACCEPT 事件，则调用 unsafe.read() 进行读取数据。unsafe.read() 中会调用到 ChannelPipeline 进行读取数据。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NioMessageUnsafe</span> <span class="keyword">extends</span> <span class="title">AbstractNioUnsafe</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 省略代码 ......</span></span><br><span class="line">            <span class="comment">// 获取 Channel 对应的 ChannelPipeline</span></span><br><span class="line">            <span class="keyword">final</span> ChannelPipeline pipeline = pipeline();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> closed = <span class="keyword">false</span>;</span><br><span class="line">            Throwable exception = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 省略代码 ......</span></span><br><span class="line">                <span class="keyword">int</span> size = readBuf.size();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i ++) &#123;</span><br><span class="line">                    readPending = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="comment">// 委托给 pipeline 中的 Handler 进行读取数据</span></span><br><span class="line">                    pipeline.fireChannelRead(readBuf.get(i));</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure><p>当 NioEventLoop 读取数据的时候会委托给 Channel 中的 unsafe 对象进行读取数据。<br> Unsafe中真正读取数据是交由 ChannelPipeline 来处理。<br> ChannelPipeline 中是注册的我们自定义的 Handler，然后由 ChannelPipeline中的 Handler 一个接一个的处理请求的数据。</p><p>作者：jijs<br>链接：<a href="https://www.jianshu.com/p/9e5e45a23309" target="_blank" rel="noopener">https://www.jianshu.com/p/9e5e45a23309</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Reactor线程模型&quot;&gt;&lt;a href=&quot;#Reactor线程模型&quot; class=&quot;headerlink&quot; title=&quot;Reactor线程模型&quot;&gt;&lt;/a&gt;Reactor线程模型&lt;/h2&gt;&lt;p&gt;Netty的线程模型实际上就是Reactor模型的一种实现。&lt;/p&gt;
&lt;p&gt;Reactor模型是基于事件驱动开发的，核心组成部分是一个Reactor和一个线程池，其中Reactor负责监听和分配事件，线程池负责处理事件。根据Reactor的数量有线程池的数量，又可以将Reactor分为三种模型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单线程模型（单Reactor，单线程）&lt;/li&gt;
&lt;li&gt;多线程模型（单Reactor，多线程）&lt;/li&gt;
&lt;li&gt;主从多线程模型（多Reactor，多线程）&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="https://zofun.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Netty" scheme="https://zofun.github.io/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>段页式内存管理</title>
    <link href="https://zofun.github.io/2020/05/15/%E6%AE%B5%E9%A1%B5%E5%BC%8F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>https://zofun.github.io/2020/05/15/段页式内存管理/</id>
    <published>2020-05-15T09:48:00.000Z</published>
    <updated>2020-05-15T09:48:19.962Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="内存管理需要解决的问题">内存管理需要解决的问题</span></h2><p>内存管理无非就是解决三个问题：</p><ul><li>如何使进程的地址空间隔离</li><li>如果提高内存的使用效率</li><li>如何解决程序运行时的重定位问题</li></ul><p>现在的内存管理方案就是引入虚拟内存这一中间层。虚拟内存位于程序和物理内存之间，程序只能看见虚拟内存，不能直接访问物理内存。每个程序都有自己独立的虚拟地址空间，这样就做到了<strong>进程地址空间的隔离</strong>。</p><p>引入了虚拟地址技术后，我们需要解决如何将虚拟地址映射到物理地址。这主要有分段和分页两种技术。</p><a id="more"></a><h2><span id="分段机制">分段机制</span></h2><p>这种方法的基本思路是将程序所需要的内存地址空间大小的虚拟空间映射到某个物理地址空间。</p><p><img src="https://s1.ax1x.com/2020/05/15/YsDYaq.png" alt="YsDYaq.png"></p><p>分段机制使得每个进程具有独立的进程地址空间，保证了地址空间的隔离性。同时它也解决了程序重定位的问题，因为程序始终是在虚拟地址空间下运行的。</p><p>分段机制同样也存在许多的问题，因为它映射的粒度太大，是以程序为单位的，如果内存不足，那么只能换出整个程序。这样内存的使用效率就很低。</p><h2><span id="分页机制">分页机制</span></h2><p>分页机制就是将内存地址空间分为若干各很小的固定大小的页，每一页的大小由内存来决定。这样映射的粒度更小了，根据局部性原理，我们只需要在内存中保存少部分的页，大部分的页都可以换到磁盘中去。</p><p><img src="https://s1.ax1x.com/2020/05/15/YssggO.png" alt="YssggO.png"></p><p><strong>页式存储管理能够有效的提高内存利用率，而分段存储管理能反映程序的逻辑结构并有利于段的共享</strong></p><h2><span id="段页式管理">段页式管理</span></h2><p>段页式管理就是将程序分为多个逻辑段，在每个段里面又进行分页，即将分段和分页组合起来使用。</p><p><img src="https://s1.ax1x.com/2020/05/15/Ys6kfP.png" alt="Ys6kfP.png"></p><p>在段页式系统中，作业的逻辑地址分为三部分：段号、页号和页内偏移量。</p><p><img src="https://s1.ax1x.com/2020/05/15/Ys6R7d.png" alt="Ys6R7d.png"></p><p>为了实现地址变化，系统为每个进程维护了一个段表，每个分段又有一个页表。段表中包含段号、页表长度和页表的起始地址。页表中包含页号和块号。系统还有一个段表寄存器，存储段表的起始地址和段表长度。</p><p>在进行地址变化式，通过段表查到页表的起始地址，然后再通过页表查到物理块的地址。</p><p><img src="https://s1.ax1x.com/2020/05/15/Ysco5R.png" alt="Ysco5R.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;内存管理需要解决的问题&quot;&gt;&lt;a href=&quot;#内存管理需要解决的问题&quot; class=&quot;headerlink&quot; title=&quot;内存管理需要解决的问题&quot;&gt;&lt;/a&gt;内存管理需要解决的问题&lt;/h2&gt;&lt;p&gt;内存管理无非就是解决三个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如何使进程的地址空间隔离&lt;/li&gt;
&lt;li&gt;如果提高内存的使用效率&lt;/li&gt;
&lt;li&gt;如何解决程序运行时的重定位问题&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;现在的内存管理方案就是引入虚拟内存这一中间层。虚拟内存位于程序和物理内存之间，程序只能看见虚拟内存，不能直接访问物理内存。每个程序都有自己独立的虚拟地址空间，这样就做到了&lt;strong&gt;进程地址空间的隔离&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;引入了虚拟地址技术后，我们需要解决如何将虚拟地址映射到物理地址。这主要有分段和分页两种技术。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="https://zofun.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Linux" scheme="https://zofun.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>fork()与写时复制</title>
    <link href="https://zofun.github.io/2020/05/15/fork()%E4%B8%8E%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6/"/>
    <id>https://zofun.github.io/2020/05/15/fork()与写时复制/</id>
    <published>2020-05-15T08:51:00.000Z</published>
    <updated>2020-05-15T08:51:55.988Z</updated>
    
    <content type="html"><![CDATA[<h3><span id="没有写时复制时的问题">没有写时复制时的问题</span></h3><p>最初在Unit系统中，在使用<code>fork()</code>系统调用创建子进程的时候，会复制父进程的整个地址空间并把复制的那一份分配给子进程。这种情况比较耗时。因为它需要：</p><ul><li>为子进程的页表分配空间</li><li>为子进程的页分配页面</li><li>初始子进程的页表</li><li>把父进程的页复制到子进程相应的页中。</li></ul><p>创建一个地址空间的这种方法涉及许多内存访问，消耗许多CPU周期，并且完全破环了高速缓存中的内容。在大多数情况下，这种做法常常时毫无意义的，因为许多子进程通过装入一个新的程序开始它们的执行，这样就完全丢弃了所继承的地址空间。</p><a id="more"></a><h3><span id="linux的fork使用写时复制">Linux的fork()使用写时复制</span></h3><p>写时复制技术时一种可以推迟甚至避免拷贝数据的技术。内核不需要复制整个地址空间，而是让父子进程共享同一个地址空间，只用在需要写入的时候才会复制地址空间，从而使各个进程拥有自己的地址空间。</p><p><strong>写时复制</strong></p><p>内核只为新生成的子进程创建虚拟空间结构，它们复制于父进程的虚拟空间结构，但是不为这些段分配物理内存，它们共享父进程的空间，当父进程中有更改相应段的行为发生时，再为子进程相应的段分配物理空间。</p><p><img src="https://s1.ax1x.com/2020/05/15/YsJAk4.png" alt="YsJAk4.png"></p><p><strong>vfork()</strong></p><p>这个方案直接利用父进程的虚拟地址空间，<code>vfork()</code>并不会把父进程的地址空间完全复制给子进程，因为子进程会立即调用<code>exec</code>或<code>exit</code>，也就不会访问该地址空间了。在子进程调用<code>exec</code>之前，它在父进程空间中运行。<strong><code>vfork()</code>保证子进程先运行，在子进程调用<code>exec</code>或<code>exit</code>之后父进程才能调度运行</strong>。</p><p><img src="https://s1.ax1x.com/2020/05/15/YstpZT.png" alt="YstpZT.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;没有写时复制时的问题&quot;&gt;&lt;a href=&quot;#没有写时复制时的问题&quot; class=&quot;headerlink&quot; title=&quot;没有写时复制时的问题&quot;&gt;&lt;/a&gt;没有写时复制时的问题&lt;/h3&gt;&lt;p&gt;最初在Unit系统中，在使用&lt;code&gt;fork()&lt;/code&gt;系统调用创建子进程的时候，会复制父进程的整个地址空间并把复制的那一份分配给子进程。这种情况比较耗时。因为它需要：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为子进程的页表分配空间&lt;/li&gt;
&lt;li&gt;为子进程的页分配页面&lt;/li&gt;
&lt;li&gt;初始子进程的页表&lt;/li&gt;
&lt;li&gt;把父进程的页复制到子进程相应的页中。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;创建一个地址空间的这种方法涉及许多内存访问，消耗许多CPU周期，并且完全破环了高速缓存中的内容。在大多数情况下，这种做法常常时毫无意义的，因为许多子进程通过装入一个新的程序开始它们的执行，这样就完全丢弃了所继承的地址空间。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="https://zofun.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Linux" scheme="https://zofun.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux内核设计与实现读书笔记一</title>
    <link href="https://zofun.github.io/2020/05/15/Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%80/"/>
    <id>https://zofun.github.io/2020/05/15/Linux内核设计与实现读书笔记一/</id>
    <published>2020-05-14T16:51:00.000Z</published>
    <updated>2020-05-14T13:51:37.111Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="进程管理">进程管理</span></h2><h3><span id="进程">进程</span></h3><h4><span id="相关概念">相关概念</span></h4><p>进程就是处于执行期的程序。进程是处于执行期的程序以及相关资源的总称。<br>线程是进程中的活动对象，每个线程都拥有一个独立的程序计数器、进程栈和一组进程寄存器。<br>内核调度的对象是线程而不是进程。</p><h4><span id="进程描述符及任务结构">进程描述符及任务结构</span></h4><p>内核吧进程的列表存放在叫做任务队列的双向循环列表中。链表中每一项的类型都是<code>task_struct</code>、被称为进程描述符。该结构包含了内核管理一个进程所需的所有信息。</p><a id="more"></a><h4><span id="分配进程描述符">分配进程描述符</span></h4><p>Linux通过slab分配器分配task_struct结构，这样能够达到对象复用和缓存着色的目的。</p><p>在2.6之前为了减少对寄存器的使用，<code>task_struct</code>存储在内核栈的尾端，而在2.6之后使用slab分配器动态生成<code>task_stuct</code>，所以只需要在栈第或栈顶创建一个<code>thread_info</code>，它的内部包含了<code>task_struct</code>等信息。</p><p><img src="https://s1.ax1x.com/2020/05/13/YwEt4s.png" alt="YwEt4s.png"></p><p>每个任务的<code>thread_info</code>结构在它的内核栈的尾端分配。结构中<code>task</code>域中存放的是指向该任务实际<code>task_struct</code>的指针。</p><h4><span id="进程描述符的存放">进程描述符的存放</span></h4><p>内核通过一个唯一的进程标识符或PID来标识每个进程。</p><p>在内核中，任务访问通常需要获得指向其<code>task_struct</code>的指针。内核使用<code>current</code>宏可以计算出当前进程<code>task_struct</code>的指针。</p><h4><span id="进程管理">进程管理</span></h4><p>进程描述符中state域描述了进程的当前状态。系统中每个进程都必然处于五种状态中的一种。</p><ul><li>TASK_RUNNING（运行）：进程是可执行的，它或者正在执行，或者在运行队列中等待执行。</li><li>TASK_INTERRUPTIBLE（可中断）：进程正在随眠，等待某些条件达成。一旦这些条件达成，内核就会把进程状态设置为运行。</li><li>TASK_UNINTERRUPTIBLE（不可中断）：除了就算接收到信号也不会被唤醒或准备投入运行外，这个状态与可打断状态相同。</li><li>_TASK_TRACED：被其它进程跟踪的进程，例如通过<code>ptrace</code>对调试程序进行跟踪。</li><li>_TASK_STOOPED：进程停止运行。</li></ul><p><img src="https://s1.ax1x.com/2020/05/13/Ywut5F.png" alt="Ywut5F.png"></p><h4><span id="进程上下文">进程上下文</span></h4><p>一般的程序是在用户空间执行，当程序进行了系统调用或触发了某一异常，那么它就会陷入到内核空间。此时，我们称内核“代表进程执行”并处于进程上下文中。在此上下问中current宏是有效的。</p><h4><span id="进程创建">进程创建</span></h4><p>在Unix操作系统中进程的创建分为两步完成，第一步是调用<code>fork()</code>方法拷贝当前进程创建一个子进程（父子进程的唯一区别就是PID），然后调用<code>exec()</code>方法载入可执行文件并开始执行。</p><p>而Linux对整个进程的创建做出了优化：</p><p><strong>写时拷贝</strong></p><p>写时拷贝时一种可以推迟甚至免除拷贝数据的技术，在创建进程的时候，内核并不需要再一开始就复制整个进程地址空间，而是让父子进程共享一个拷贝。只有再需要写入的时候，数据才会被复制，从而使各个进程拥有各自的拷贝。也就是所，资源的复制只有在需要写入的时候才进行，在此之前，只是以只读的方式共享，这种技术使得地址空间上的页的拷贝被推迟到实际发生写入的时候才进行，在页根本不会被写入的情况下（比如fork后立即调用exec）它们就无需复制了。</p><p><strong>也就是只有进程空间的各段的内容要发生变化时，才将父进程的内容复制一份给子进程。</strong></p><p><strong>fork()</strong></p><p>Linux通过<code>clone()</code>系统调用来实现<code>fork()</code>。然后<code>clone()</code>去调用<code>do_fork()</code>。<code>do_fork()</code>完成了创建中的大部分工作，该函数调用了<code>copy_process()</code>函数，然后让进程开始运行。<code>copy_process()</code>函数完成的工作如下：</p><ol><li>调用<code>dup_task_struct()</code>为新建成创建一个内核栈，<code>thread_info</code>结构和<code>task_struct</code>,这些只与当前进程的只相同。此时，子进程和父进程的描述符使完全相同的。</li><li>检测创建了这个子进程之后，当前用户所拥有的进程数目有没有超出给它分配资源的限制。</li><li>子进程着手使自己与父进程区别开来。将进程描述符内的许多成员清零或设置为初始值。</li><li>将子进程的状态设置为<code>TASK_UNINTERRUPTIBLE</code>，以保证它不会投入运行。</li><li><code>copy_process()</code>调用<code>copy_flags()</code>以更新<code>task_struct</code>的flag成员。</li><li>调用<code>alloc_pid()</code>为新进程分配一个有效的PID。</li><li>根据传递给<code>clone()</code>的参数标志，决定拷贝或共享打开的资源。</li><li>最后<code>copy_process</code>做扫尾工作并返回一个指向子进程的指针。</li></ol><p><strong>vfork()</strong></p><p>除了不拷贝父进程的页表项外，<code>vfork()</code>系统调用和<code>fork()</code>的功能相同。子进程作为父进程的一个单独的线程在他的地址空间里运行，父进程被阻塞，直到子进程退出或执行<code>exec()</code>.</p><p><code>vfork()</code>系统调用的实现是通过项<code>clone()</code>系统调用实现的：</p><ol><li>在调用<code>copy_process()</code>时，<code>task_struct</code>的<code>vfor_done</code>成员被设置为NULL。</li><li>在执行<code>do_fork()</code>时，如果给定特别标志，则<code>vfork_done</code>会指向特定地址。</li><li>子进程先开始指向后，父进程不是马上恢复执行，而是一直等待，直到父进程通过<code>vfork_done</code>指针向它发送信号。</li><li>在调用<code>mm_release()</code>时，该函数用于进程退出内存地址空间，并且检查<code>vfork_done</code>是否为空，如果不为空，则会向父进程发送信号。</li><li>回到<code>do_fork()，</code>父进程醒来并返回。</li></ol><h3><span id="线程在linux中的实现">线程在Linux中的实现</span></h3><p>线程机制时现代编程技术中常用的一种抽象概念，该机制提供了在同一程序内共享内存地址空间运行的一组线程。这些线程还可以共享打开的文件或其它资源，线程机制支持并发程序设计技术，在多处理器系统上，它也能保证真正的并行处理。</p><p>在Linux中的内核实现中，它不严格区分线程和进程，线程仅仅被视为一个与其它进程共享某些资源的进程。</p><h4><span id="创建线程">创建线程</span></h4><p>线程的创建于普通进程的创建类似，只不过在调用<code>clone()</code>的时候徐娅传递一些参数标志来指明需要共享的资源。</p><h4><span id="内核线程">内核线程</span></h4><p>内核进程需要在后台执行一些操作，这些操作由内核线程来完成。</p><p>内核线程和普通的进程的区别在于内核线程没有独立的地址空间。它们只在内核空间运行，从来不切换到用户空间去。内核进程和普通进程一样，可以被调度，也可以被抢占。内核线程也只能由其它内核线程创建。</p><h3><span id="进程终结">进程终结</span></h3><p>当一个进程终结时，内核必须要释放它所占有的资源并通知其父进程。</p><p>进程终结时，最终大多都是通过<code>do_exit()</code>来完成的。它主要完成了以下工作：</p><ol><li>将<code>task_struct</code>中的标志成员设置为<code>PF_EXITING</code></li><li>调用<code>del_timer_sync()</code>删除任一内核定时器，根据返回的结果，保证没有定时器在排队，也没有定时器处理程序在运行。</li><li>如果BSD的进程计帐功能时开启的，那么会调用<code>acct_update_integerals()</code>来输出记账信息。</li><li>调用<code>exit_mm()</code>函数释放进程占用<code>mm_struct</code>，如果没有别的进程使用它，就释放。</li><li>接下来调用<code>sem_exit()</code>函数，如果进程排队等候IPC信号，它则离开队列。</li><li>调用<code>exit_files()</code>和<code>exit_fs()</code>，以分别递减文件描述符，文件系统数据的引用计数。如果引用计数降为0，那么它代表没有进程使用相应的资源，此时就可以释放。</li><li>接着把存放在<code>task_struct</code>的<code>exit_code</code>成员中的任务退出代码置为由<code>exit()</code>提供的退出代码。</li><li>调用<code>exit_notify()</code>向父进程发送行信号，给子进程重新找养父，养父为线程组中的其它进程或者init进程，并把进程状态设置为<code>EXIT_ZOMBIE</code>.</li><li><code>do_exit()</code>调用<code>schedule()</code>切换到新的进程，因为处于<code>EXIT_ZOMBIE</code>状态的进程不会再调度，所以这是进程所执行的最后一段代码。<code>do_exit()</code>永不返回。</li></ol><h4><span id="删除进程描述符">删除进程描述符</span></h4><p>调用<code>do_exit()</code>之后，尽管线程已经僵死不能再运行了，但是系统还是保留了它们的进程描述符。这样做的好处就是有办法再进程终结后仍然能够获得它的信息。</p><p>当需要释放进程描述符的时候，会调用<code>release_task()</code>.</p><h4><span id="处理孤儿进程">处理孤儿进程</span></h4><p>如果父进程在子进程之前退出，必须有机制来保证子进程能找到一个新的父进程，否则这些成为孤儿的进程就会在退出时永远处于僵死状态，白白的消耗内存。</p><p>处理孤儿进程的方案是，首先会尝试在当前线程组内找一个线程作为父进程，如果不行，就让<code>init</code>做它们的父进程。</p><h2><span id="进程调度">进程调度</span></h2><h3><span id="多任务">多任务</span></h3><p>多任务操作系统就是能够同时并发地交互执行多个进程地操作系统。</p><p>多任务系统可以划分为两类：非抢占式多任务和抢占式多任务。Linux提供了抢占式多任务模式。</p><p>在此模式下，由调度程序来决定什么时候停止一个进程的运行，以便其它进程能够得到执行的机会。这个强制挂起的动作叫做抢占。进程在被抢占之前能够运行的时间式预先分配号的，叫做进程的时间篇。</p><p>在非抢占式多任务模式下，除非进程自己主动停止运行，否则它会一直执行。进程主动挂起自己的操作称为让步。</p><h3><span id="linux的进程调度">Linux的进程调度</span></h3><p>Linux2.5之后采用了一种叫做<code>O(1)</code>的调度程序。</p><h3><span id="调度策略">调度策略</span></h3><h4><span id="io消耗型和处理器消耗型的进程">IO消耗型和处理器消耗型的进程</span></h4><p>进程可以分为IO消耗型和处理器消耗性。前者指进程的大部分时间用来提交IO请求或是等待IO请求。因此，这样的进程进程处于可运行的状态，但通常都是运行短短的一会，因为它在等待更多的IO请求时最后总会阻塞。</p><p>而处理器消耗型进程把时间大多用在执行代码上，除非被抢占，否则它门通常都一直不停的运行，因为它们没有太多的IO需求。</p><p>调递策略通常要在两个矛盾的目标中间寻找平衡：进程响应迅速（响应时间短）和最大系统利用率（高吞吐率）。</p><h4><span id="进程优先级">进程优先级</span></h4><p>调度算法中最基本的一类就是基于优先级的调度。这是一种根据进程的价值和对处理器时间的需求来对进程分级的想法。</p><p>Linux采用了两种不同的优先级范围，第一种是用nice值，它的范围是从<code>-20到+19</code>，nice值越小，优先级越高。第二种范围是实时范围，其值是可配置的，默认情况下它的变化范围是从0到99，值越大，优先级越大。</p><p>实时优先级和nice优先级处于互不相交的两个范畴。</p><h4><span id="时间片">时间片</span></h4><p>时间片是一个数值，它表示进程在被抢占前所能持续运行的时间。调度策略必须规定一个默认的时间片。</p><p>一个处于就绪状态的进程能够进入运行态的完全是由进程优先级和是否有时间片决定的。</p><h3><span id="linux调度算法">Linux调度算法</span></h3><p>Linux中提供了一种CFS调度算法，即完全公平调度算法。CFS的实现思路就是根据进程的权重分配运行时间。这里的权重其实是和进程的nice值之间有一一对应的关系，可以通过全局数组<code>prio_to_weight</code>来转换。<br>$$<br>分配给进程的运行时间=调度周期*进程权重/所有进程权重之和<br>$$</p><h4><span id="cfs调度算法实现">CFS调度算法实现</span></h4><p><strong>调度器实体结构</strong></p><p>CFS不再有时间片的概念，但是它也必须维护每个进程运行的时间记账，因为它需要确保每个进程只在分配给它的时间片内运行。CFS使用调度器实体结构来最终进程运行记账。</p><p><img src="https://s1.ax1x.com/2020/05/14/YDtIfA.png" alt="YDtIfA.png"></p><p><strong>虚拟实时</strong></p><p><code>vruntime</code>变量存放进程的虚拟运行时间，该运行时间的计算是经过了所有可运行进程总数的标准化。</p><p><strong>进程选择</strong></p><p>当CFS需要选择下一个运行进程是，它会挑一个具有最小<code>vruntime</code>的进程。CFS使用红黑树来组织可运行进程队列，并利用其迅速找到<code>vruntime</code>值最小的进程。</p><h4><span id="休眠和唤醒">休眠和唤醒</span></h4><p><strong>等待队列</strong></p><p>休眠通过等待队列进行处理。等待队列是由等待某些事件发生的进程组成的简单链表。</p><p><strong>唤醒</strong></p><p>唤醒操作通过函数<code>wake_up()</code>进行，它会唤醒指定的等待队列上的所有进程。它调用函数<code>wake_up()</code>进行，它会唤醒指定的等待队列上的所有进程。</p><h4><span id="抢占">抢占</span></h4><p><strong>用户抢占</strong></p><p>用户抢占在以下情况下产生：</p><ul><li>从系统调用返回用户空间时</li><li>从中断处理程序返回用户空间时</li></ul><p><strong>内核抢占</strong></p><p>内核抢占会发生在：</p><ul><li>中断处理程序正在执行，且返回内核空间之前。</li><li>内核代码再一次具有可抢占性的时候。</li><li>如果内核中的任务显示地调用<code>schedule()</code></li><li>如果内核中的任务阻塞。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;进程管理&quot;&gt;&lt;a href=&quot;#进程管理&quot; class=&quot;headerlink&quot; title=&quot;进程管理&quot;&gt;&lt;/a&gt;进程管理&lt;/h2&gt;&lt;h3 id=&quot;进程&quot;&gt;&lt;a href=&quot;#进程&quot; class=&quot;headerlink&quot; title=&quot;进程&quot;&gt;&lt;/a&gt;进程&lt;/h3&gt;&lt;h4 id=&quot;相关概念&quot;&gt;&lt;a href=&quot;#相关概念&quot; class=&quot;headerlink&quot; title=&quot;相关概念&quot;&gt;&lt;/a&gt;相关概念&lt;/h4&gt;&lt;p&gt;进程就是处于执行期的程序。进程是处于执行期的程序以及相关资源的总称。&lt;br&gt;线程是进程中的活动对象，每个线程都拥有一个独立的程序计数器、进程栈和一组进程寄存器。&lt;br&gt;内核调度的对象是线程而不是进程。&lt;/p&gt;
&lt;h4 id=&quot;进程描述符及任务结构&quot;&gt;&lt;a href=&quot;#进程描述符及任务结构&quot; class=&quot;headerlink&quot; title=&quot;进程描述符及任务结构&quot;&gt;&lt;/a&gt;进程描述符及任务结构&lt;/h4&gt;&lt;p&gt;内核吧进程的列表存放在叫做任务队列的双向循环列表中。链表中每一项的类型都是&lt;code&gt;task_struct&lt;/code&gt;、被称为进程描述符。该结构包含了内核管理一个进程所需的所有信息。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="https://zofun.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Linux" scheme="https://zofun.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo小知识点总结</title>
    <link href="https://zofun.github.io/2020/05/12/Dubbo%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <id>https://zofun.github.io/2020/05/12/Dubbo小知识点总结/</id>
    <published>2020-05-12T12:49:00.000Z</published>
    <updated>2020-05-12T12:49:18.096Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="dubbo的几种集群容错方案">Dubbo的几种集群容错方案</span></h2><table><thead><tr><th>集群容错方案</th><th>解释</th></tr></thead><tbody><tr><td>Failover（默认）</td><td>快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。</td></tr><tr><td>Failsafe</td><td>安全失败，出现异常时，直接忽略，通常用于写入日志</td></tr><tr><td>Failback</td><td>失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知等。</td></tr><tr><td>Forking</td><td>并行调用多个服务器，只要有一个成功即放hi。通常用于对实时性要求较高的读操作。</td></tr><tr><td>Broadcast</td><td>广播所有的调用者，逐个调用，任意一台报错即报错。通常用于通知所有的提供者更新缓存本地资源信息。</td></tr></tbody></table><p>它的配置方式是这样的：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">cluster</span>=<span class="string">"failsafe"</span> /&gt;</span></span><br></pre></td></tr></table></figure><h2><span id="dubbo的负载均衡算法有哪些">Dubbo的负载均衡算法有哪些</span></h2><p>Dubbo内部提供了4种负载均衡算法。</p><ol><li>基于权重随机算法的RandomLoadBalance(默认)</li><li>基于最少活跃调用数算法的LeastActiveBalance</li><li>基于一致性hash算法的ConsistentHashLoadBalance</li><li>基于加权轮询算法的RoundRobinLoadBalance<br> 基于加权的轮询算法会根据每台服务器的性能为服务器设置一个权值，加权后，每台服务器能够得到的请求数比例，接近或等于他们的权重比。比如服务器 A、B、C 权重比为 5:2:1。那么在8次请求中，服务器 A 将收到其中的5次请求，服务器 B 会收到其中的2次请求，服务器 C 则收到其中的1次请求。</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">"com.alibaba.hello.api.WorldService"</span> <span class="attr">version</span>=<span class="string">"1.0.0"</span> <span class="attr">ref</span>=<span class="string">"helloService"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">timeout</span>=<span class="string">"300"</span> <span class="attr">retries</span>=<span class="string">"2"</span> <span class="attr">loadbalance</span>=<span class="string">"random"</span> <span class="attr">actives</span>=<span class="string">"0"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:method</span> <span class="attr">name</span>=<span class="string">"findAllPerson"</span> <span class="attr">timeout</span>=<span class="string">"10000"</span> <span class="attr">retries</span>=<span class="string">"9"</span> <span class="attr">loadbalance</span>=<span class="string">"leastactive"</span> <span class="attr">actives</span>=<span class="string">"5"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span>/&gt;</span></span><br></pre></td></tr></table></figure><h2><span id="服务化推荐用法">服务化推荐用法</span></h2><h3><span id="分包">分包</span></h3><p>将服务接口、服务模型、服务异常均放在API包中，因为服务模型和异常也是API的一部分，这样做服务分包原则：重用发布等价原则（REP），共同重用原则(CRP)</p><h3><span id="粒度">粒度</span></h3><p>服务接口应该尽可能大粒度，每个服务方法应代表一个功能，而不是某功能的一个步骤，否则将面临分布式事务问题，而Dubbo并未提供分布式事务解决方案。</p><h3><span id="版本">版本</span></h3><p>每个接口都应该定义版本号，为后序不兼容升级提供可能。</p><h3><span id="兼容性">兼容性</span></h3><p>服务接口增加方法，或服务模型增加字段，可向后兼容，删除方法或删除字段，将不兼容，枚举类型新增字段也不兼容，需要通过变更版本号升级。</p><h3><span id="枚举值">枚举值</span></h3><p>如果是完备集，可以使用<code>Enum</code><br>如果后期可能会有变更，建议使用<code>String</code>代替。</p><h3><span id="序列化">序列化</span></h3><p>服务参数和返回值建议使用POJO对象。</p><h3><span id="异常">异常</span></h3><p>建议使用异常汇报错误，而不是返回错误码，异常信息能够携带更多信息，并且语义更加友好。</p><h3><span id="调用">调用</span></h3><p>不要只是因为是 Dubbo 调用，而把调用 <code>try...catch</code> 起来。<code>try...catch</code> 应该加上合适的回滚边界上。<br>Provider 端需要对输入参数进行校验。如有性能上的考虑，服务实现者可以考虑在 API 包上加上服务 Stub 类来完成检验。</p><h2><span id="dubbo推荐用法">Dubbo推荐用法</span></h2><h3><span id="在provider端尽可能多配置consumer端属性">在Provider端尽可能多配置consumer端属性</span></h3><p>因为作为服务的提供方，比服务消费方更清楚服务的性能。在服务提供端配置后，消费端不配置则会使用服务提供端的配置。如果在消费端进行配置，那么对服务端来讲就是不可控的。</p><p>一个配置示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">"com.alibaba.hello.api.HelloService"</span> <span class="attr">version</span>=<span class="string">"1.0.0"</span> <span class="attr">ref</span>=<span class="string">"helloService"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">timeout</span>=<span class="string">"300"</span> <span class="attr">retries</span>=<span class="string">"2"</span> <span class="attr">loadbalance</span>=<span class="string">"random"</span> <span class="attr">actives</span>=<span class="string">"0"</span> /&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">"com.alibaba.hello.api.WorldService"</span> <span class="attr">version</span>=<span class="string">"1.0.0"</span> <span class="attr">ref</span>=<span class="string">"helloService"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">timeout</span>=<span class="string">"300"</span> <span class="attr">retries</span>=<span class="string">"2"</span> <span class="attr">loadbalance</span>=<span class="string">"random"</span> <span class="attr">actives</span>=<span class="string">"0"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:method</span> <span class="attr">name</span>=<span class="string">"findAllPerson"</span> <span class="attr">timeout</span>=<span class="string">"10000"</span> <span class="attr">retries</span>=<span class="string">"9"</span> <span class="attr">loadbalance</span>=<span class="string">"leastactive"</span> <span class="attr">actives</span>=<span class="string">"5"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>建议在服务提供端配置的消费端属性有：<br><code>timeout</code>、<code>retries</code>  、 <code>loadbalance</code> <code>actives</code></p><h3><span id="在服务提供端配置合理的提供端属性">在服务提供端配置合理的提供端属性</span></h3><p>比如这样：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">threads</span>=<span class="string">"200"</span> /&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">"com.alibaba.hello.api.HelloService"</span> <span class="attr">version</span>=<span class="string">"1.0.0"</span> <span class="attr">ref</span>=<span class="string">"helloService"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">executes</span>=<span class="string">"200"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:method</span> <span class="attr">name</span>=<span class="string">"findAllPerson"</span> <span class="attr">executes</span>=<span class="string">"50"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dubbo:service</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>建议在服务提供端配置的提供端属性有：<br><code>threads</code> (服务线程池的大小)、<code>executes</code>（一个服务提供者并行执行请求的上限）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;&lt;span id=&quot;dubbo的几种集群容错方案&quot;&gt;Dubbo的几种集群容错方案&lt;/span&gt;&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;集群容错方案&lt;/th&gt;
&lt;th&gt;解释&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Fai
      
    
    </summary>
    
    
    
      <category term="技术" scheme="https://zofun.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Dubbo" scheme="https://zofun.github.io/tags/Dubbo/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis的使用回顾</title>
    <link href="https://zofun.github.io/2020/05/12/MyBatis%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9B%9E%E9%A1%BE/"/>
    <id>https://zofun.github.io/2020/05/12/MyBatis的使用回顾/</id>
    <published>2020-05-12T08:13:00.000Z</published>
    <updated>2020-05-12T08:13:59.626Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="mapper文件的编写">Mapper文件的编写</span></h2><h3><span id="select">select</span></h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span> = <span class="string">“</span> <span class="attr">selectPerson</span>” <span class="attr">parameterType</span> = <span class="string">“</span> <span class="attr">int</span>” <span class="attr">resultType</span> = <span class="string">“</span> <span class="attr">hashmap</span>” &gt;</span>   </span><br><span class="line">  SELECT * FROM PERSON WHERE ID =＃&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/ <span class="attr">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里有两点需要注意的，一是区分<code>#</code>和<code>$</code>的区别.<code>#</code>的底层是基于预编译语句来实现了，这样可以避免SQL注入的风险。而<code>$</code>在底层是通过字符串的直接拼接来实现了，因此有SQL注入的风险。</p><a id="more"></a><p>上面是常见的<code>select</code>的用法，实际上它还有许多其它的属性供我们选用。</p><p>比如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span></span></span><br><span class="line"><span class="tag">  <span class="attr">id</span>=<span class="string">"selectPerson"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">parameterType</span>=<span class="string">"int"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">parameterMap</span>=<span class="string">"deprecated"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">resultType</span>=<span class="string">"hashmap"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">resultMap</span>=<span class="string">"personResultMap"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">flushCache</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">useCache</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">timeout</span>=<span class="string">"10"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">fetchSize</span>=<span class="string">"256"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">statementType</span>=<span class="string">"PREPARED"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">resultSetType</span>=<span class="string">"FORWARD_ONLY"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>下面列举了一些相对比较常用的属性：</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>id</td><td></td></tr><tr><td>parameterType</td><td>将传递到该语句中的参数的标准类名或别名</td></tr><tr><td>resultType</td><td>从该语句返回的结果预期的标准类名或别名</td></tr><tr><td>resultMap</td><td>对外部resultMap的引用，用于结果集映射</td></tr><tr><td>flushCache</td><td>若将该属性设置为true，那么调用此语句时会刷新本地和二级缓存</td></tr><tr><td>useCache</td><td>将此属性设置为true，这该语句的结果会被缓存到二级缓存中。默认值为true</td></tr><tr><td>timeout</td><td>超时时间</td></tr><tr><td>fetchSize</td><td>设置成批的返回的行数</td></tr><tr><td>statementType</td><td>设置statement的类型，有<code>STATEMENT</code>,<code>PREPARED</code>或<code>CALLABLE</code>.默认是第二种，即<code>PreparedStatement</code></td></tr></tbody></table><h3><span id="insertupdate-and-delete">insert，update and delete</span></h3><p>这三个标签常见的用法如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span></span></span><br><span class="line"><span class="tag">  <span class="attr">id</span>=<span class="string">"insertAuthor"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">parameterType</span>=<span class="string">"domain.blog.Author"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">flushCache</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">statementType</span>=<span class="string">"PREPARED"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">keyProperty</span>=<span class="string">""</span></span></span><br><span class="line"><span class="tag">  <span class="attr">keyColumn</span>=<span class="string">""</span></span></span><br><span class="line"><span class="tag">  <span class="attr">useGeneratedKeys</span>=<span class="string">""</span></span></span><br><span class="line"><span class="tag">  <span class="attr">timeout</span>=<span class="string">"20"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">update</span></span></span><br><span class="line"><span class="tag">  <span class="attr">id</span>=<span class="string">"updateAuthor"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">parameterType</span>=<span class="string">"domain.blog.Author"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">flushCache</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">statementType</span>=<span class="string">"PREPARED"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">timeout</span>=<span class="string">"20"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span></span></span><br><span class="line"><span class="tag">  <span class="attr">id</span>=<span class="string">"deleteAuthor"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">parameterType</span>=<span class="string">"domain.blog.Author"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">flushCache</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">statementType</span>=<span class="string">"PREPARED"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">timeout</span>=<span class="string">"20"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>一些属性的用法补充：</p><table><thead><tr><th>属性</th><th>解释</th></tr></thead><tbody><tr><td>useGeneratedKeys</td><td>当设置为true的时候，使用数据库内部生成的主键。默认为false</td></tr><tr><td>keyProperty</td><td>该属性一般与<code>useGeneratedKeys</code>结合使用，它标识的是Java对象的属性名。配置了该属性之后，会将数据库中自动生成的主键存到对应的java属性中。</td></tr><tr><td>keyColumn</td><td>这几个属性一般是结合使用的,keyColumn指定数据库主键字段名。</td></tr></tbody></table><h3><span id="sql片段">sql片段</span></h3><p>sql片段是mybatis动态sql的基础。它的使用方法如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">"userColumns"</span>&gt;</span> $&#123;alias&#125;.id,$&#123;alias&#125;.username,$&#123;alias&#125;.password <span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectUsers"</span> <span class="attr">resultType</span>=<span class="string">"map"</span>&gt;</span></span><br><span class="line">  select</span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">"userColumns"</span>&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"alias"</span> <span class="attr">value</span>=<span class="string">"t1"</span>/&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span>,</span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">"userColumns"</span>&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"alias"</span> <span class="attr">value</span>=<span class="string">"t2"</span>/&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">  from some_table t1</span><br><span class="line">    cross join some_table t2</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里通过属性，为sql片段传递数据，使用起来非常的灵活：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">"sometable"</span>&gt;</span></span><br><span class="line">  $&#123;prefix&#125;Table</span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">"someinclude"</span>&gt;</span></span><br><span class="line">  from</span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">"$&#123;include_target&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"select"</span> <span class="attr">resultType</span>=<span class="string">"map"</span>&gt;</span></span><br><span class="line">  select</span><br><span class="line">    field1, field2, field3</span><br><span class="line">  <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">"someinclude"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"Some"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"include_target"</span> <span class="attr">value</span>=<span class="string">"sometable"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3><span id="resultmap">resultMap</span></h3><p>结果集映射是mybatis非常重要的特性</p><p>它的简单的使用方法如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"userResultMap"</span> <span class="attr">type</span>=<span class="string">"User"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"user_id"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"username"</span> <span class="attr">column</span>=<span class="string">"user_name"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"password"</span> <span class="attr">column</span>=<span class="string">"hashed_password"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在<code>&lt;resultMap&gt;</code>还可以使用<code>&lt;constructor&gt;</code>标签，通过构造器完成结果集Java对象的映射。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">constructor</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">idArg</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">javaType</span>=<span class="string">"int"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">arg</span> <span class="attr">column</span>=<span class="string">"username"</span> <span class="attr">javaType</span>=<span class="string">"String"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">arg</span> <span class="attr">column</span>=<span class="string">"age"</span> <span class="attr">javaType</span>=<span class="string">"_int"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">constructor</span>&gt;</span></span><br></pre></td></tr></table></figure><p>用于一对一关联查询结果映射的<code>&lt;assocation&gt;</code>标签的使用方式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"blogResult"</span> <span class="attr">type</span>=<span class="string">"Blog"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"author"</span> <span class="attr">column</span>=<span class="string">"author_id"</span> <span class="attr">javaType</span>=<span class="string">"Author"</span> <span class="attr">select</span>=<span class="string">"selectAuthor"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectBlog"</span> <span class="attr">resultMap</span>=<span class="string">"blogResult"</span>&gt;</span></span><br><span class="line">  SELECT * FROM BLOG WHERE ID = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectAuthor"</span> <span class="attr">resultType</span>=<span class="string">"Author"</span>&gt;</span></span><br><span class="line">  SELECT * FROM AUTHOR WHERE ID = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>另一个例子：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"blogResult"</span> <span class="attr">type</span>=<span class="string">"Blog"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"blog_id"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"title"</span> <span class="attr">column</span>=<span class="string">"blog_title"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"author"</span> <span class="attr">javaType</span>=<span class="string">"Author"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"author_id"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"username"</span> <span class="attr">column</span>=<span class="string">"author_username"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"password"</span> <span class="attr">column</span>=<span class="string">"author_password"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"email"</span> <span class="attr">column</span>=<span class="string">"author_email"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"bio"</span> <span class="attr">column</span>=<span class="string">"author_bio"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><p>一对多的关系映射的标签<code>&lt;collection&gt;</code>标签的使用方式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"posts"</span> <span class="attr">ofType</span>=<span class="string">"domain.blog.Post"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"post_id"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"subject"</span> <span class="attr">column</span>=<span class="string">"post_subject"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"body"</span> <span class="attr">column</span>=<span class="string">"post_body"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;Post&gt; posts;</span><br></pre></td></tr></table></figure><p>另一个例子是这样的：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"blogResult"</span> <span class="attr">type</span>=<span class="string">"Blog"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"blog_id"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"title"</span> <span class="attr">column</span>=<span class="string">"blog_title"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"posts"</span> <span class="attr">ofType</span>=<span class="string">"Post"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"post_id"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"subject"</span> <span class="attr">column</span>=<span class="string">"post_subject"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"body"</span> <span class="attr">column</span>=<span class="string">"post_body"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><p>鉴别器<code>&lt;discriminator&gt;</code>,它可以根据</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"vehicleResult"</span> <span class="attr">type</span>=<span class="string">"Vehicle"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"id"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"vin"</span> <span class="attr">column</span>=<span class="string">"vin"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"year"</span> <span class="attr">column</span>=<span class="string">"year"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"make"</span> <span class="attr">column</span>=<span class="string">"make"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"model"</span> <span class="attr">column</span>=<span class="string">"model"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"color"</span> <span class="attr">column</span>=<span class="string">"color"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">discriminator</span> <span class="attr">javaType</span>=<span class="string">"int"</span> <span class="attr">column</span>=<span class="string">"vehicle_type"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">case</span> <span class="attr">value</span>=<span class="string">"1"</span> <span class="attr">resultMap</span>=<span class="string">"carResult"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">case</span> <span class="attr">value</span>=<span class="string">"2"</span> <span class="attr">resultMap</span>=<span class="string">"truckResult"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">case</span> <span class="attr">value</span>=<span class="string">"3"</span> <span class="attr">resultMap</span>=<span class="string">"vanResult"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">case</span> <span class="attr">value</span>=<span class="string">"4"</span> <span class="attr">resultMap</span>=<span class="string">"suvResult"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">discriminator</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><h3><span id="动态sql">动态SQL</span></h3><h4><span id="if">if</span></h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findActiveBlogWithTitleLike"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">resultType</span>=<span class="string">"Blog"</span>&gt;</span></span><br><span class="line">  SELECT * FROM BLOG</span><br><span class="line">  WHERE state = ‘ACTIVE’</span><br><span class="line">  <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"title != null"</span>&gt;</span></span><br><span class="line">    AND title like #&#123;title&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h4><span id="choose-when-otherwise">choose, when, otherwise</span></h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findActiveBlogLike"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">resultType</span>=<span class="string">"Blog"</span>&gt;</span></span><br><span class="line">  SELECT * FROM BLOG WHERE state = ‘ACTIVE’</span><br><span class="line">  <span class="tag">&lt;<span class="name">choose</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">"title != null"</span>&gt;</span></span><br><span class="line">      AND title like #&#123;title&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">"author != null and author.name != null"</span>&gt;</span></span><br><span class="line">      AND author_name like #&#123;author.name&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">otherwise</span>&gt;</span></span><br><span class="line">      AND featured = 1</span><br><span class="line">    <span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h4><span id="trim-where-set">trim, where, set</span></h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">"WHERE"</span> <span class="attr">prefixOverrides</span>=<span class="string">"AND |OR "</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findActiveBlogLike"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">resultType</span>=<span class="string">"Blog"</span>&gt;</span></span><br><span class="line">  SELECT * FROM BLOG</span><br><span class="line">  <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"state != null"</span>&gt;</span></span><br><span class="line">         state = #&#123;state&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"title != null"</span>&gt;</span></span><br><span class="line">        AND title like #&#123;title&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"author != null and author.name != null"</span>&gt;</span></span><br><span class="line">        AND author_name like #&#123;author.name&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"updateAuthorIfNecessary"</span>&gt;</span></span><br><span class="line">  update Author</span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"username != null"</span>&gt;</span>username=#&#123;username&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"password != null"</span>&gt;</span>password=#&#123;password&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"email != null"</span>&gt;</span>email=#&#123;email&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"bio != null"</span>&gt;</span>bio=#&#123;bio&#125;<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">  where id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><h4><span id="foreach">foreach</span></h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectPostIn"</span> <span class="attr">resultType</span>=<span class="string">"domain.blog.Post"</span>&gt;</span></span><br><span class="line">  SELECT *</span><br><span class="line">  FROM POST P</span><br><span class="line">  WHERE ID in</span><br><span class="line">  <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">item</span>=<span class="string">"item"</span> <span class="attr">index</span>=<span class="string">"index"</span> <span class="attr">collection</span>=<span class="string">"list"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">open</span>=<span class="string">"("</span> <span class="attr">separator</span>=<span class="string">","</span> <span class="attr">close</span>=<span class="string">")"</span>&gt;</span></span><br><span class="line">        #&#123;item&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Mapper文件的编写&quot;&gt;&lt;a href=&quot;#Mapper文件的编写&quot; class=&quot;headerlink&quot; title=&quot;Mapper文件的编写&quot;&gt;&lt;/a&gt;Mapper文件的编写&lt;/h2&gt;&lt;h3 id=&quot;select&quot;&gt;&lt;a href=&quot;#select&quot; class=&quot;headerlink&quot; title=&quot;select&quot;&gt;&lt;/a&gt;select&lt;/h3&gt;&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;id&lt;/span&gt; = &lt;span class=&quot;string&quot;&gt;“&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;selectPerson&lt;/span&gt;” &lt;span class=&quot;attr&quot;&gt;parameterType&lt;/span&gt; = &lt;span class=&quot;string&quot;&gt;“&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;int&lt;/span&gt;” &lt;span class=&quot;attr&quot;&gt;resultType&lt;/span&gt; = &lt;span class=&quot;string&quot;&gt;“&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;hashmap&lt;/span&gt;” &amp;gt;&lt;/span&gt;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  SELECT * FROM PERSON WHERE ID =＃&amp;#123;id&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/ &lt;span class=&quot;attr&quot;&gt;select&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这里有两点需要注意的，一是区分&lt;code&gt;#&lt;/code&gt;和&lt;code&gt;$&lt;/code&gt;的区别.&lt;code&gt;#&lt;/code&gt;的底层是基于预编译语句来实现了，这样可以避免SQL注入的风险。而&lt;code&gt;$&lt;/code&gt;在底层是通过字符串的直接拼接来实现了，因此有SQL注入的风险。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="https://zofun.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="MyBatis" scheme="https://zofun.github.io/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo集群容错</title>
    <link href="https://zofun.github.io/2020/05/11/Dubbo%E9%9B%86%E7%BE%A4%E5%AE%B9%E9%94%99/"/>
    <id>https://zofun.github.io/2020/05/11/Dubbo集群容错/</id>
    <published>2020-05-11T09:36:00.000Z</published>
    <updated>2020-05-11T09:36:19.458Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="简介">简介</span></h2><p>Dubbo集群容错方面的源码包括四个部分，分别式服务目录Directory、服务路由Router、集群Cluster和负载均衡LoadBalance。</p><p>它们之间的关系是这样的：</p><p><img src="https://s1.ax1x.com/2020/05/11/YJAi1H.png" alt="YJAi1H.png"></p><a id="more"></a><h2><span id="服务目录">服务目录</span></h2><h2><span id="简介">简介</span></h2><p>服务目录中存储了服务提供者有关的信息，通过服务目录，服务消费者可以获取到服务提供者的信息，比如IP、端口、服务协议等。通过这些信息，服务消费者就可以进行远程服务调用了。服务提供者的信息是有变动的，因此服务目录中的信息也有要做相应的变更。</p><p>而服务目录中的信息，其实又是从注册中心中获取的，然后根据从注册中心中获取的信息为每条配置信息生成一个<code>Invoker</code>对象。</p><p>因此简单来讲服务目录就是一个会根据注册中心的有关信息进行相应调整的<code>Invoker</code>集合。</p><p>Dubbo中服务目录的继承体系如图：</p><p><img src="https://s1.ax1x.com/2020/05/11/YGIuMn.png" alt="YGIuMn.png"></p><h3><span id="源码分析">源码分析</span></h3><p>针对服务目录，我们主要分析一个<code>AbstractDirectory</code>和它的两个子类。</p><p>下面我们来看<code>AbstractDirectory</code>的具体实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Invoker&lt;T&gt;&gt; list(Invocation invocation) <span class="keyword">throws</span> RpcException &#123;</span><br><span class="line">    <span class="keyword">if</span> (destroyed) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Directory already destroyed..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用 doList 方法列举 Invoker，doList 是模板方法，由子类实现</span></span><br><span class="line">    List&lt;Invoker&lt;T&gt;&gt; invokers = doList(invocation);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取路由 Router 列表</span></span><br><span class="line">    List&lt;Router&gt; localRouters = <span class="keyword">this</span>.routers;</span><br><span class="line">    <span class="keyword">if</span> (localRouters != <span class="keyword">null</span> &amp;&amp; !localRouters.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Router router : localRouters) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 获取 runtime 参数，并根据参数决定是否进行路由</span></span><br><span class="line">                <span class="keyword">if</span> (router.getUrl() == <span class="keyword">null</span> || router.getUrl().getParameter(Constants.RUNTIME_KEY, <span class="keyword">false</span>)) &#123;</span><br><span class="line">                    <span class="comment">// 进行服务路由</span></span><br><span class="line">                    invokers = router.route(invokers, getConsumerUrl(), invocation);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                logger.error(<span class="string">"Failed to execute router: ..."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> invokers;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板方法，由子类实现</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">abstract</span> List&lt;Invoker&lt;T&gt;&gt; doList(Invocation invocation) <span class="keyword">throws</span> RpcException;</span><br></pre></td></tr></table></figure><p><code>AbstractDirectory</code>的<code>list</code>方法，主要完成两件事情：</p><ol><li>通过<code>doList</code>获取<code>Invoker</code>列表</li><li>根据<code>Router</code>的<code>getUrl</code>返回值为空与否，以及runtime参数决定是否进行服务路由。</li></ol><p>这里的<code>doList</code>方法其实是一个模板方法，由它的子类来负责具体的实现。</p><p>那么下面我们就来看一看它的两个子类是如何实现这个方法的。</p><h4><span id="staticdirectory">StaticDirectory</span></h4><p><code>StaticDirectory</code>即静态服务目录，它内部存放的<code>Invoker</code>集合是不会变动的。它的源码实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticDirectory</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractDirectory</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Invoker 列表</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Invoker&lt;T&gt;&gt; invokers;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略构造方法</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Class&lt;T&gt; <span class="title">getInterface</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取接口类</span></span><br><span class="line">        <span class="keyword">return</span> invokers.get(<span class="number">0</span>).getInterface();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检测服务目录是否可用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAvailable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isDestroyed()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Invoker&lt;T&gt; invoker : invokers) &#123;</span><br><span class="line">            <span class="keyword">if</span> (invoker.isAvailable()) &#123;</span><br><span class="line">                <span class="comment">// 只要有一个 Invoker 是可用的，就认为当前目录是可用的</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isDestroyed()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 调用父类销毁逻辑</span></span><br><span class="line">        <span class="keyword">super</span>.destroy();</span><br><span class="line">        <span class="comment">// 遍历 Invoker 列表，并执行相应的销毁逻辑</span></span><br><span class="line">        <span class="keyword">for</span> (Invoker&lt;T&gt; invoker : invokers) &#123;</span><br><span class="line">            invoker.destroy();</span><br><span class="line">        &#125;</span><br><span class="line">        invokers.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> List&lt;Invoker&lt;T&gt;&gt; doList(Invocation invocation) <span class="keyword">throws</span> RpcException &#123;</span><br><span class="line">        <span class="comment">// 列举 Inovker，也就是直接返回 invokers 成员变量</span></span><br><span class="line">        <span class="keyword">return</span> invokers;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的实现非常的简单。</p><h4><span id="registrydirctory">RegistryDirctory</span></h4><p><code>RegistryDirectory</code>是一种动态服务目录，它会根据注册中心中服务配置的变化而动态的变化。因此<code>RegistryDirectory</code>中比较关键的点就在于，它是如何进行<code>Invoker</code>列举的？它是如何接收服务配置信息变更的？它是如何刷新<code>Invoker</code>列表的。</p><h5><span id="列举invoker">列举Invoker</span></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Invoker&lt;T&gt;&gt; doList(Invocation invocation) &#123;</span><br><span class="line">    <span class="keyword">if</span> (forbidden) &#123;</span><br><span class="line">        <span class="comment">// 服务提供者关闭或禁用了服务，此时抛出 No provider 异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcException.FORBIDDEN_EXCEPTION,</span><br><span class="line">            <span class="string">"No provider available from registry ..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Invoker&lt;T&gt;&gt; invokers = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 获取 Invoker 本地缓存</span></span><br><span class="line">    Map&lt;String, List&lt;Invoker&lt;T&gt;&gt;&gt; localMethodInvokerMap = <span class="keyword">this</span>.methodInvokerMap;</span><br><span class="line">    <span class="keyword">if</span> (localMethodInvokerMap != <span class="keyword">null</span> &amp;&amp; localMethodInvokerMap.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取方法名和参数列表</span></span><br><span class="line">        String methodName = RpcUtils.getMethodName(invocation);</span><br><span class="line">        Object[] args = RpcUtils.getArguments(invocation);</span><br><span class="line">        <span class="comment">// 检测参数列表的第一个参数是否为 String 或 enum 类型</span></span><br><span class="line">        <span class="keyword">if</span> (args != <span class="keyword">null</span> &amp;&amp; args.length &gt; <span class="number">0</span> &amp;&amp; args[<span class="number">0</span>] != <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; (args[<span class="number">0</span>] <span class="keyword">instanceof</span> String || args[<span class="number">0</span>].getClass().isEnum())) &#123;</span><br><span class="line">            <span class="comment">// 通过 方法名 + 第一个参数名称 查询 Invoker 列表，具体的使用场景暂时没想到</span></span><br><span class="line">            invokers = localMethodInvokerMap.get(methodName + <span class="string">"."</span> + args[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (invokers == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 通过方法名获取 Invoker 列表</span></span><br><span class="line">            invokers = localMethodInvokerMap.get(methodName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (invokers == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 通过星号 * 获取 Invoker 列表</span></span><br><span class="line">            invokers = localMethodInvokerMap.get(Constants.ANY_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 冗余逻辑，pull request #2861 移除了下面的 if 分支代码</span></span><br><span class="line">        <span class="keyword">if</span> (invokers == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Iterator&lt;List&lt;Invoker&lt;T&gt;&gt;&gt; iterator = localMethodInvokerMap.values().iterator();</span><br><span class="line">            <span class="keyword">if</span> (iterator.hasNext()) &#123;</span><br><span class="line">                invokers = iterator.next();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回 Invoker 列表</span></span><br><span class="line">    <span class="keyword">return</span> invokers == <span class="keyword">null</span> ? <span class="keyword">new</span> ArrayList&lt;Invoker&lt;T&gt;&gt;(<span class="number">0</span>) : invokers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Invoker</code>的列举逻辑还是比较简单的，主要就是从<code>localMethodInvokerMap</code>中获取对应的<code>Invoker</code></p><h5><span id="接收服务变更通知">接收服务变更通知</span></h5><p><code>RegistryDirectory</code>是一个动态服务目录，会随注册中心配置的变化而进行动态调整，因此<code>RegistryDirectory</code>实现了<code>NotifyListener</code>接口，通过这个接口获取注册中心变更通知。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(List&lt;URL&gt; urls)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义三个集合，分别用于存放服务提供者 url，路由 url，配置器 url</span></span><br><span class="line">    List&lt;URL&gt; invokerUrls = <span class="keyword">new</span> ArrayList&lt;URL&gt;();</span><br><span class="line">    List&lt;URL&gt; routerUrls = <span class="keyword">new</span> ArrayList&lt;URL&gt;();</span><br><span class="line">    List&lt;URL&gt; configuratorUrls = <span class="keyword">new</span> ArrayList&lt;URL&gt;();</span><br><span class="line">    <span class="keyword">for</span> (URL url : urls) &#123;</span><br><span class="line">        String protocol = url.getProtocol();</span><br><span class="line">        <span class="comment">// 获取 category 参数</span></span><br><span class="line">        String category = url.getParameter(Constants.CATEGORY_KEY, Constants.DEFAULT_CATEGORY);</span><br><span class="line">        <span class="comment">// 根据 category 参数将 url 分别放到不同的列表中</span></span><br><span class="line">        <span class="keyword">if</span> (Constants.ROUTERS_CATEGORY.equals(category)</span><br><span class="line">                || Constants.ROUTE_PROTOCOL.equals(protocol)) &#123;</span><br><span class="line">            <span class="comment">// 添加路由器 url</span></span><br><span class="line">            routerUrls.add(url);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Constants.CONFIGURATORS_CATEGORY.equals(category)</span><br><span class="line">                || Constants.OVERRIDE_PROTOCOL.equals(protocol)) &#123;</span><br><span class="line">            <span class="comment">// 添加配置器 url</span></span><br><span class="line">            configuratorUrls.add(url);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Constants.PROVIDERS_CATEGORY.equals(category)) &#123;</span><br><span class="line">            <span class="comment">// 添加服务提供者 url</span></span><br><span class="line">            invokerUrls.add(url);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 忽略不支持的 category</span></span><br><span class="line">            logger.warn(<span class="string">"Unsupported category ..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (configuratorUrls != <span class="keyword">null</span> &amp;&amp; !configuratorUrls.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 将 url 转成 Configurator</span></span><br><span class="line">        <span class="keyword">this</span>.configurators = toConfigurators(configuratorUrls);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (routerUrls != <span class="keyword">null</span> &amp;&amp; !routerUrls.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 将 url 转成 Router</span></span><br><span class="line">        List&lt;Router&gt; routers = toRouters(routerUrls);</span><br><span class="line">        <span class="keyword">if</span> (routers != <span class="keyword">null</span>) &#123;</span><br><span class="line">            setRouters(routers);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Configurator&gt; localConfigurators = <span class="keyword">this</span>.configurators;</span><br><span class="line">    <span class="keyword">this</span>.overrideDirectoryUrl = directoryUrl;</span><br><span class="line">    <span class="keyword">if</span> (localConfigurators != <span class="keyword">null</span> &amp;&amp; !localConfigurators.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Configurator configurator : localConfigurators) &#123;</span><br><span class="line">            <span class="comment">// 配置 overrideDirectoryUrl</span></span><br><span class="line">            <span class="keyword">this</span>.overrideDirectoryUrl = configurator.configure(overrideDirectoryUrl);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 刷新 Invoker 列表</span></span><br><span class="line">    refreshInvoker(invokerUrls);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>notify</code> 方法首先是根据 <code>url</code> 的 <code>category</code> 参数对 <code>url</code> 进行分门别类存储，然后通过 <code>toRouters</code> 和 <code>toConfigurators</code> 将<code>url</code> 列表转成 <code>Router</code> 和<code>Configurator</code> 列表。最后调用 <code>refreshInvoker</code> 方法刷新 <code>Invoker</code> 列表。</p><h5><span id="刷新invoker列表">刷新Invoker列表</span></h5><p>refreshInvoker 方法是保证 RegistryDirectory 随注册中心变化而变化的关键所在。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">refreshInvoker</span><span class="params">(List&lt;URL&gt; invokerUrls)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// invokerUrls 仅有一个元素，且 url 协议头为 empty，此时表示禁用所有服务</span></span><br><span class="line">    <span class="keyword">if</span> (invokerUrls != <span class="keyword">null</span> &amp;&amp; invokerUrls.size() == <span class="number">1</span> &amp;&amp; invokerUrls.get(<span class="number">0</span>) != <span class="keyword">null</span></span><br><span class="line">            &amp;&amp; Constants.EMPTY_PROTOCOL.equals(invokerUrls.get(<span class="number">0</span>).getProtocol())) &#123;</span><br><span class="line">        <span class="comment">// 设置 forbidden 为 true</span></span><br><span class="line">        <span class="keyword">this</span>.forbidden = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">this</span>.methodInvokerMap = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 销毁所有 Invoker</span></span><br><span class="line">        destroyAllInvokers();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.forbidden = <span class="keyword">false</span>;</span><br><span class="line">        Map&lt;String, Invoker&lt;T&gt;&gt; oldUrlInvokerMap = <span class="keyword">this</span>.urlInvokerMap;</span><br><span class="line">        <span class="keyword">if</span> (invokerUrls.isEmpty() &amp;&amp; <span class="keyword">this</span>.cachedInvokerUrls != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 添加缓存 url 到 invokerUrls 中</span></span><br><span class="line">            invokerUrls.addAll(<span class="keyword">this</span>.cachedInvokerUrls);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.cachedInvokerUrls = <span class="keyword">new</span> HashSet&lt;URL&gt;();</span><br><span class="line">            <span class="comment">// 缓存 invokerUrls</span></span><br><span class="line">            <span class="keyword">this</span>.cachedInvokerUrls.addAll(invokerUrls);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (invokerUrls.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将 url 转成 Invoker</span></span><br><span class="line">        Map&lt;String, Invoker&lt;T&gt;&gt; newUrlInvokerMap = toInvokers(invokerUrls);</span><br><span class="line">        <span class="comment">// 将 newUrlInvokerMap 转成方法名到 Invoker 列表的映射</span></span><br><span class="line">        Map&lt;String, List&lt;Invoker&lt;T&gt;&gt;&gt; newMethodInvokerMap = toMethodInvokers(newUrlInvokerMap);</span><br><span class="line">        <span class="comment">// 转换出错，直接打印异常，并返回</span></span><br><span class="line">        <span class="keyword">if</span> (newUrlInvokerMap == <span class="keyword">null</span> || newUrlInvokerMap.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            logger.error(<span class="keyword">new</span> IllegalStateException(<span class="string">"urls to invokers error ..."</span>));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 合并多个组的 Invoker</span></span><br><span class="line">        <span class="keyword">this</span>.methodInvokerMap = multiGroup ? toMergeMethodInvokerMap(newMethodInvokerMap) : newMethodInvokerMap;</span><br><span class="line">        <span class="keyword">this</span>.urlInvokerMap = newUrlInvokerMap;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 销毁无用 Invoker</span></span><br><span class="line">            destroyUnusedInvokers(oldUrlInvokerMap, newUrlInvokerMap);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.warn(<span class="string">"destroyUnusedInvokers error. "</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>refreshInvoker</code> 方法首先会根据入参 <code>invokerUrls</code> 的数量和协议头判断是否禁用所有的服务，如果禁用，则将  <code>forbidden</code>设为 <code>true</code>，并销毁所有的 <code>Invoker</code>。若不禁用，则将 <code>url</code> 转成 <code>Invoker</code>，得到 <code>&lt;url,  Invoker&gt;</code> 的映射关系。然后进一步进行转换，得到 <code>&lt;methodName, Invoker 列表&gt;</code>映射关系。之后进行多组 <code>Invoker</code>合并操作，并将合并结果赋值给 <code>methodInvokerMap</code>。<code>methodInvokerMap</code> 变量在 <code>doList</code> 方法中会被用到，<code>doList</code> 会对该变量进行读操作，在这里是写操作。当新的 <code>Invoker</code>  列表生成后，还要一个重要的工作要做，就是销毁无用的 <code>Invoker</code>，避免服务消费者调用已下线的服务的服务。</p><p>到此就实现了<code>Invoker</code>的刷新。</p><h2><span id="服务路由">服务路由</span></h2><h3><span id="简介">简介</span></h3><p>服务路由就是包含一条路由规则，路由规则决定了服务消费者的调用目标，即规定了服务消费者可调用可调用哪些服务提供者。Dubbo目前提供了三种服务路由实现，分别是条件路<code>ConditionRouter</code>、脚本路由<code>ScriptRounter</code>和标签路路由<code>TagRounter</code>。其中条件路由是我们最常用的。</p><h2><span id="源码分析">源码分析</span></h2><p>下面我们就以条件路由为例进行源码分析。</p><p>条件路由规则有两个条件组成，分别用于对服务消费者和提供者进行匹配。比如有这样一条规则：</p><p><code>host=10.20.153.10 =&gt; host=12.20.153.11</code></p><p>这条规则表明IP<code>10.20.153.10</code>的服务消费者只能调用IP为10.20.153.11机器上的服务，不可调用其它机器上的服务。条件路由规则的格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[服务消费者匹配条件] =&gt; [服务提供者匹配条件]</span><br></pre></td></tr></table></figure><h4><span id="表达式解析">表达式解析</span></h4><p>路由规则是一条字符串表达式，在进行路由之前会先进行条件表达式解析，具体的解析过程这里就不看源码了。</p><p>只需要知道通过解之后，得到一个<code>Map&lt;String, MatchPair&gt; condition</code>.解析后的信息，以这样的格式进行表示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"host"</span>: &#123;</span><br><span class="line">        <span class="string">"matches"</span>: [<span class="string">"2.2.2.2"</span>],</span><br><span class="line">        <span class="string">"mismatches"</span>: [<span class="string">"1.1.1.1"</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"method"</span>: &#123;</span><br><span class="line">        <span class="string">"matches"</span>: [<span class="string">"hello"</span>],</span><br><span class="line">        <span class="string">"mismatches"</span>: []</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="路由服务">路由服务</span></h4><p>服务路由的入口方法是<code>ConditionRouter</code>的<code>route</code>方法，该方法定义在<code>Router</code>接口中，实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; List&lt;Invoker&lt;T&gt;&gt; route(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation) <span class="keyword">throws</span> RpcException &#123;</span><br><span class="line">    <span class="keyword">if</span> (invokers == <span class="keyword">null</span> || invokers.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> invokers;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 先对服务消费者条件进行匹配，如果匹配失败，表明服务消费者 url 不符合匹配规则，</span></span><br><span class="line">        <span class="comment">// 无需进行后续匹配，直接返回 Invoker 列表即可。比如下面的规则：</span></span><br><span class="line">        <span class="comment">//     host = 10.20.153.10 =&gt; host = 10.0.0.10</span></span><br><span class="line">        <span class="comment">// 这条路由规则希望 IP 为 10.20.153.10 的服务消费者调用 IP 为 10.0.0.10 机器上的服务。</span></span><br><span class="line">        <span class="comment">// 当消费者 ip 为 10.20.153.11 时，matchWhen 返回 false，表明当前这条路由规则不适用于</span></span><br><span class="line">        <span class="comment">// 当前的服务消费者，此时无需再进行后续匹配，直接返回即可。</span></span><br><span class="line">        <span class="keyword">if</span> (!matchWhen(url, invocation)) &#123;</span><br><span class="line">            <span class="keyword">return</span> invokers;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Invoker&lt;T&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;Invoker&lt;T&gt;&gt;();</span><br><span class="line">        <span class="comment">// 服务提供者匹配条件未配置，表明对指定的服务消费者禁用服务，也就是服务消费者在黑名单中</span></span><br><span class="line">        <span class="keyword">if</span> (thenCondition == <span class="keyword">null</span>) &#123;</span><br><span class="line">            logger.warn(<span class="string">"The current consumer in the service blacklist..."</span>);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里可以简单的把 Invoker 理解为服务提供者，现在使用服务提供者匹配规则对 </span></span><br><span class="line">        <span class="comment">// Invoker 列表进行匹配</span></span><br><span class="line">        <span class="keyword">for</span> (Invoker&lt;T&gt; invoker : invokers) &#123;</span><br><span class="line">            <span class="comment">// 若匹配成功，表明当前 Invoker 符合服务提供者匹配规则。</span></span><br><span class="line">            <span class="comment">// 此时将 Invoker 添加到 result 列表中</span></span><br><span class="line">            <span class="keyword">if</span> (matchThen(invoker.getUrl(), url)) &#123;</span><br><span class="line">                result.add(invoker);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 返回匹配结果，如果 result 为空列表，且 force = true，表示强制返回空列表，</span></span><br><span class="line">        <span class="comment">// 否则路由结果为空的路由规则将自动失效</span></span><br><span class="line">        <span class="keyword">if</span> (!result.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (force) &#123;</span><br><span class="line">            logger.warn(<span class="string">"The route result is empty and force execute ..."</span>);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        logger.error(<span class="string">"Failed to execute condition router rule: ..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 原样返回，此时 force = false，表示该条路由规则失效</span></span><br><span class="line">    <span class="keyword">return</span> invokers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>route</code> 方法先是调用 <code>matchWhen</code> 对服务消费者进行匹配，如果匹配失败，直接返回 <code>Invoker</code> 列表。如果匹配成功，再对服务提供者进行匹配，匹配逻辑封装在了 <code>matchThen</code> 方法中。</p><h2><span id="集群">集群</span></h2><h3><span id="简介">简介</span></h3><p>为了避免单点故障，现在应用通常至少会部署在两台服务器上。对于一些负载比较高的服务，会部署更多的服务器。对于服务消费者来说，同一环境下出现了多个服务提供者。这时会出现一个问题，服务消费者需要决定选择哪个服务提供者进行调用。另外服务调用失败时的处理措施也是需要考虑的。为了处理这些问题，Dubbo定义了集群接口<code>Cluster</code>以及<code>Cluster Invoker</code>.集群<code>Cluster</code> 用途是将多个服务提供者合并为一个 <code>Cluster Invoker</code>，并将这个 <code>Invoker</code>  暴露给服务消费者。这样一来，服务消费者只需通过这个 <code>Invoker</code>  进行远程调用即可，至于具体调用哪个服务提供者，以及调用失败后如何处理等问题，现在都交给集群模块去处理。集群模块是服务提供者和服务消费者的中间层，为服务消费者屏蔽了服务提供者的情况，这样服务消费者就可以专心处理远程调用相关事宜。</p><p><img src="https://s1.ax1x.com/2020/05/11/YJAi1H.png" alt="YJAi1H.png"></p><p>集群工作过程可分为两个阶段，第一个阶段是在服务消费者初始化期间，集群 <code>Cluster</code> 实现类为服务消费者创建 <code>Cluster Invoker</code> 实例，即上图中的<code>merge</code> 操作。</p><p>第二个阶段是在服务消费者进行远程调用时。以 <code>FailoverClusterInvoker</code> 为例，该类型  <code>Cluster Invoker</code> 首先会调用<code>Directory</code> 的<code>list</code> 方法列举 <code>Invoker</code> 列表（可将 <code>Invoker</code>  简单理解为服务提供者）。<code>Directory</code>的用途是保存 <code>Invoker</code>，可简单类比为 <code>List&lt;Invoker&gt;</code>。其实现类 <code>RegistryDirectory</code> 是一个动态服务目录，可感知注册中心配置的变化，它所持有的 <code>Invoker</code>  列表会随着注册中心内容的变化而变化。每次变化后，<code>RegistryDirectory</code> 会动态增删 <code>Invoker</code>，并调用 <code>Router</code> 的 <code>route</code>方法进行路由，过滤掉不符合路由规则的 <code>Invoker</code>。当 <code>FailoverClusterInvoker</code> 拿到<code>Directory</code>  返回的 <code>Invoker</code> 列表后，它会通过<code>LoadBalance</code>从 <code>Invoker</code> 列表中选择一个 <code>Invoker</code>。最后  <code>FailoverClusterInvoker</code> 会将参数传给 <code>LoadBalance</code> 选择出的 <code>Invoker</code> 实例的 <code>invoke</code>  方法，进行真正的远程调用。</p><p>Dubbo集群提供了以下几种容错机制：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Failover Cluster - 失败自动切换</span><br><span class="line">Failfast Cluster - 快速失败</span><br><span class="line">Failsafe Cluster - 失败安全</span><br><span class="line">Failback Cluster - 失败自动恢复</span><br><span class="line">Forking Cluster - 并行调用多个服务提供者</span><br></pre></td></tr></table></figure><h3><span id="源码分析">源码分析</span></h3><h4><span id="cluster实现类分析">Cluster实现类分析</span></h4><p><code>Cluster</code>的实现类负责生成<code>Cluster Invoker</code>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FailoverCluster</span> <span class="keyword">implements</span> <span class="title">Cluster</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String NAME = <span class="string">"failover"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">join</span><span class="params">(Directory&lt;T&gt; directory)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建并返回 FailoverClusterInvoker 对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FailoverClusterInvoker&lt;T&gt;(directory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的实现类的逻辑比较简单.</p><h4><span id="cluster-invoker分析">Cluster Invoker分析</span></h4><p>我们首先从各种 <code>Cluster Invoker</code>的父类 <code>AbstractClusterInvoker</code> 源码开始说起。前面说过，集群工作过程可分为两个阶段，第一个阶段是在服务消费者初始化期间，即服务引出。第二个阶段是在服务消费者进行远程调用时，此时<code>AbstractClusterInvoker</code>的 <code>invoke</code> 方法会被调用。列举 <code>Invoker</code>，负载均衡等操作均会在此阶段被执行。因此下面先来看一下 <code>invoke</code>方法的逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(<span class="keyword">final</span> Invocation invocation)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">    checkWhetherDestroyed();</span><br><span class="line">    LoadBalance loadbalance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定 attachments 到 invocation 中.</span></span><br><span class="line">    Map&lt;String, String&gt; contextAttachments = RpcContext.getContext().getAttachments();</span><br><span class="line">    <span class="keyword">if</span> (contextAttachments != <span class="keyword">null</span> &amp;&amp; contextAttachments.size() != <span class="number">0</span>) &#123;</span><br><span class="line">        ((RpcInvocation) invocation).addAttachments(contextAttachments);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 列举 Invoker</span></span><br><span class="line">    List&lt;Invoker&lt;T&gt;&gt; invokers = list(invocation);</span><br><span class="line">    <span class="keyword">if</span> (invokers != <span class="keyword">null</span> &amp;&amp; !invokers.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 加载 LoadBalance</span></span><br><span class="line">        loadbalance = ExtensionLoader.getExtensionLoader(LoadBalance.class).getExtension(invokers.get(<span class="number">0</span>).getUrl()</span><br><span class="line">                .getMethodParameter(RpcUtils.getMethodName(invocation), Constants.LOADBALANCE_KEY, Constants.DEFAULT_LOADBALANCE));</span><br><span class="line">    &#125;</span><br><span class="line">    RpcUtils.attachInvocationIdIfAsync(getUrl(), invocation);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用 doInvoke 进行后续操作</span></span><br><span class="line">    <span class="keyword">return</span> doInvoke(invocation, invokers, loadbalance);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象方法，由子类实现</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Result <span class="title">doInvoke</span><span class="params">(Invocation invocation, List&lt;Invoker&lt;T&gt;&gt; invokers,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       LoadBalance loadbalance)</span> <span class="keyword">throws</span> RpcException</span>;</span><br></pre></td></tr></table></figure><p><code>AbstractClusterInvoker</code> 的 <code>invoke</code> 方法主要用于列举<code>Invoker</code>，以及加载<code>LoadBalance</code>，最后在调用模板方法<code>doInvoke</code>进行后序操作。</p><p>下面我们来看<code>FailoverClusterInvoker</code>是如何实现<code>doInvoke</code>的，它在调用失败后，会自动切换<code>Invoke</code>进行重试。它是缺省的<code>Cluster Invoker</code>实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FailoverClusterInvoker</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractClusterInvoker</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略部分代码</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">doInvoke</span><span class="params">(Invocation invocation, <span class="keyword">final</span> List&lt;Invoker&lt;T&gt;&gt; invokers, LoadBalance loadbalance)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        List&lt;Invoker&lt;T&gt;&gt; copyinvokers = invokers;</span><br><span class="line">        checkInvokers(copyinvokers, invocation);</span><br><span class="line">        <span class="comment">// 获取重试次数</span></span><br><span class="line">        <span class="keyword">int</span> len = getUrl().getMethodParameter(invocation.getMethodName(), Constants.RETRIES_KEY, Constants.DEFAULT_RETRIES) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            len = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        RpcException le = <span class="keyword">null</span>;</span><br><span class="line">        List&lt;Invoker&lt;T&gt;&gt; invoked = <span class="keyword">new</span> ArrayList&lt;Invoker&lt;T&gt;&gt;(copyinvokers.size());</span><br><span class="line">        Set&lt;String&gt; providers = <span class="keyword">new</span> HashSet&lt;String&gt;(len);</span><br><span class="line">        <span class="comment">// 循环调用，失败重试</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                checkWhetherDestroyed();</span><br><span class="line">                <span class="comment">// 在进行重试前重新列举 Invoker，这样做的好处是，如果某个服务挂了，</span></span><br><span class="line">                <span class="comment">// 通过调用 list 可得到最新可用的 Invoker 列表</span></span><br><span class="line">                copyinvokers = list(invocation);</span><br><span class="line">                <span class="comment">// 对 copyinvokers 进行判空检查</span></span><br><span class="line">                checkInvokers(copyinvokers, invocation);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 通过负载均衡选择 Invoker</span></span><br><span class="line">            Invoker&lt;T&gt; invoker = select(loadbalance, invocation, copyinvokers, invoked);</span><br><span class="line">            <span class="comment">// 添加到 invoker 到 invoked 列表中</span></span><br><span class="line">            invoked.add(invoker);</span><br><span class="line">            <span class="comment">// 设置 invoked 到 RPC 上下文中</span></span><br><span class="line">            RpcContext.getContext().setInvokers((List) invoked);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 调用目标 Invoker 的 invoke 方法</span></span><br><span class="line">                Result result = invoker.invoke(invocation);</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RpcException e) &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.isBiz()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> e;</span><br><span class="line">                &#125;</span><br><span class="line">                le = e;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                le = <span class="keyword">new</span> RpcException(e.getMessage(), e);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                providers.add(invoker.getUrl().getAddress());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 若重试失败，则抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(..., <span class="string">"Failed to invoke the method ..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>FailoverClusterInvoker</code> 的 <code>doInvoke</code> 方法首先是获取重试次数，然后根据重试次数进行循环调用，失败后进行重试。在  for 循环内，首先是通过负载均衡组件选择一个 <code>Invoker</code>，然后再通过这个 <code>Invoker</code> 的 <code>invoke</code>方法进行远程调用。如果失败了，记录下异常，并进行重试。重试时会再次调用父类的<code>list</code> 方法列举 <code>Invoker</code>。</p><p>在选择<code>Invoker</code>的时候，使用了<code>select</code>方法主要就是对<strong>粘滞连接特性</strong>的处理。它的实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Invoker&lt;T&gt; <span class="title">select</span><span class="params">(LoadBalance loadbalance, Invocation invocation, List&lt;Invoker&lt;T&gt;&gt; invokers, List&lt;Invoker&lt;T&gt;&gt; selected)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (invokers == <span class="keyword">null</span> || invokers.isEmpty())</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 获取调用方法名</span></span><br><span class="line">    String methodName = invocation == <span class="keyword">null</span> ? <span class="string">""</span> : invocation.getMethodName();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 sticky 配置，sticky 表示粘滞连接。所谓粘滞连接是指让服务消费者尽可能的</span></span><br><span class="line">    <span class="comment">// 调用同一个服务提供者，除非该提供者挂了再进行切换</span></span><br><span class="line">    <span class="keyword">boolean</span> sticky = invokers.get(<span class="number">0</span>).getUrl().getMethodParameter(methodName, Constants.CLUSTER_STICKY_KEY, Constants.DEFAULT_CLUSTER_STICKY);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 检测 invokers 列表是否包含 stickyInvoker，如果不包含，</span></span><br><span class="line">        <span class="comment">// 说明 stickyInvoker 代表的服务提供者挂了，此时需要将其置空</span></span><br><span class="line">        <span class="keyword">if</span> (stickyInvoker != <span class="keyword">null</span> &amp;&amp; !invokers.contains(stickyInvoker)) &#123;</span><br><span class="line">            stickyInvoker = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 在 sticky 为 true，且 stickyInvoker != null 的情况下。如果 selected 包含 </span></span><br><span class="line">        <span class="comment">// stickyInvoker，表明 stickyInvoker 对应的服务提供者可能因网络原因未能成功提供服务。</span></span><br><span class="line">        <span class="comment">// 但是该提供者并没挂，此时 invokers 列表中仍存在该服务提供者对应的 Invoker。</span></span><br><span class="line">        <span class="keyword">if</span> (sticky &amp;&amp; stickyInvoker != <span class="keyword">null</span> &amp;&amp; (selected == <span class="keyword">null</span> || !selected.contains(stickyInvoker))) &#123;</span><br><span class="line">            <span class="comment">// availablecheck 表示是否开启了可用性检查，如果开启了，则调用 stickyInvoker 的 </span></span><br><span class="line">            <span class="comment">// isAvailable 方法进行检查，如果检查通过，则直接返回 stickyInvoker。</span></span><br><span class="line">            <span class="keyword">if</span> (availablecheck &amp;&amp; stickyInvoker.isAvailable()) &#123;</span><br><span class="line">                <span class="keyword">return</span> stickyInvoker;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果线程走到当前代码处，说明前面的 stickyInvoker 为空，或者不可用。</span></span><br><span class="line">    <span class="comment">// 此时继续调用 doSelect 选择 Invoker</span></span><br><span class="line">    Invoker&lt;T&gt; invoker = doSelect(loadbalance, invocation, invokers, selected);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 sticky 为 true，则将负载均衡组件选出的 Invoker 赋值给 stickyInvoker</span></span><br><span class="line">    <span class="keyword">if</span> (sticky) &#123;</span><br><span class="line">        stickyInvoker = invoker;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> invoker;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这段代码我们也可以轻松的明白什么是粘滞连接。</p><p>在这个方法中又调用了<code>doSelect</code>方法，这个方法的作用就是根据负载均衡策略选择合适的<code>Invoker</code>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Invoker&lt;T&gt; <span class="title">doSelect</span><span class="params">(LoadBalance loadbalance, Invocation invocation, List&lt;Invoker&lt;T&gt;&gt; invokers, List&lt;Invoker&lt;T&gt;&gt; selected)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (invokers == <span class="keyword">null</span> || invokers.isEmpty())</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (invokers.size() == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> invokers.get(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (loadbalance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果 loadbalance 为空，这里通过 SPI 加载 Loadbalance，默认为 RandomLoadBalance</span></span><br><span class="line">        loadbalance = ExtensionLoader.getExtensionLoader(LoadBalance.class).getExtension(Constants.DEFAULT_LOADBALANCE);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通过负载均衡组件选择 Invoker</span></span><br><span class="line">    Invoker&lt;T&gt; invoker = loadbalance.select(invokers, getUrl(), invocation);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果 selected 包含负载均衡选择出的 Invoker，或者该 Invoker 无法经过可用性检查，此时进行重选</span></span><br><span class="line">    <span class="keyword">if</span> ((selected != <span class="keyword">null</span> &amp;&amp; selected.contains(invoker))</span><br><span class="line">            || (!invoker.isAvailable() &amp;&amp; getUrl() != <span class="keyword">null</span> &amp;&amp; availablecheck)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 进行重选</span></span><br><span class="line">            Invoker&lt;T&gt; rinvoker = reselect(loadbalance, invocation, invokers, selected, availablecheck);</span><br><span class="line">            <span class="keyword">if</span> (rinvoker != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果 rinvoker 不为空，则将其赋值给 invoker</span></span><br><span class="line">                invoker = rinvoker;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// rinvoker 为空，定位 invoker 在 invokers 中的位置</span></span><br><span class="line">                <span class="keyword">int</span> index = invokers.indexOf(invoker);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 获取 index + 1 位置处的 Invoker，以下代码等价于：</span></span><br><span class="line">                    <span class="comment">//     invoker = invokers.get((index + 1) % invokers.size());</span></span><br><span class="line">                    invoker = index &lt; invokers.size() - <span class="number">1</span> ? invokers.get(index + <span class="number">1</span>) : invokers.get(<span class="number">0</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    logger.warn(<span class="string">"... may because invokers list dynamic change, ignore."</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            logger.error(<span class="string">"cluster reselect fail reason is : ..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> invoker;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>doSelect</code> 主要做了两件事，第一是通过负载均衡组件选择 <code>Invoker</code>。第二是，如果选出来的 <code>Invoker</code>  不稳定，或不可用，此时需要调用 <code>reselect</code> 方法进行重选。若 <code>reselect</code> 选出来的 <code>Invoker</code>为空，此时定位 <code>invoker</code> 在<code>invokers</code> 列表中的位置 <code>index</code>，然后获取<code>index + 1</code> 处的 invoker，这也可以看做是重选逻辑的一部分。</p><p>负责重选的<code>reselect</code>方法的实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Invoker&lt;T&gt; <span class="title">reselect</span><span class="params">(LoadBalance loadbalance, Invocation invocation,</span></span></span><br><span class="line"><span class="function"><span class="params">    List&lt;Invoker&lt;T&gt;&gt; invokers, List&lt;Invoker&lt;T&gt;&gt; selected, <span class="keyword">boolean</span> availablecheck)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line"></span><br><span class="line">    List&lt;Invoker&lt;T&gt;&gt; reselectInvokers = <span class="keyword">new</span> ArrayList&lt;Invoker&lt;T&gt;&gt;(invokers.size() &gt; <span class="number">1</span> ? (invokers.size() - <span class="number">1</span>) : invokers.size());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面的 if-else 分支逻辑有些冗余，pull request #2826 对这段代码进行了简化，可以参考一下</span></span><br><span class="line">    <span class="comment">// 根据 availablecheck 进行不同的处理</span></span><br><span class="line">    <span class="keyword">if</span> (availablecheck) &#123;</span><br><span class="line">        <span class="comment">// 遍历 invokers 列表</span></span><br><span class="line">        <span class="keyword">for</span> (Invoker&lt;T&gt; invoker : invokers) &#123;</span><br><span class="line">            <span class="comment">// 检测可用性</span></span><br><span class="line">            <span class="keyword">if</span> (invoker.isAvailable()) &#123;</span><br><span class="line">                <span class="comment">// 如果 selected 列表不包含当前 invoker，则将其添加到 reselectInvokers 中</span></span><br><span class="line">                <span class="keyword">if</span> (selected == <span class="keyword">null</span> || !selected.contains(invoker)) &#123;</span><br><span class="line">                    reselectInvokers.add(invoker);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// reselectInvokers 不为空，此时通过负载均衡组件进行选择</span></span><br><span class="line">        <span class="keyword">if</span> (!reselectInvokers.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> loadbalance.select(reselectInvokers, getUrl(), invocation);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不检查 Invoker 可用性</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Invoker&lt;T&gt; invoker : invokers) &#123;</span><br><span class="line">            <span class="comment">// 如果 selected 列表不包含当前 invoker，则将其添加到 reselectInvokers 中</span></span><br><span class="line">            <span class="keyword">if</span> (selected == <span class="keyword">null</span> || !selected.contains(invoker)) &#123;</span><br><span class="line">                reselectInvokers.add(invoker);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!reselectInvokers.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 通过负载均衡组件进行选择</span></span><br><span class="line">            <span class="keyword">return</span> loadbalance.select(reselectInvokers, getUrl(), invocation);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 若线程走到此处，说明 reselectInvokers 集合为空，此时不会调用负载均衡组件进行筛选。</span></span><br><span class="line">        <span class="comment">// 这里从 selected 列表中查找可用的 Invoker，并将其添加到 reselectInvokers 集合中</span></span><br><span class="line">        <span class="keyword">if</span> (selected != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Invoker&lt;T&gt; invoker : selected) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((invoker.isAvailable())</span><br><span class="line">                        &amp;&amp; !reselectInvokers.contains(invoker)) &#123;</span><br><span class="line">                    reselectInvokers.add(invoker);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!reselectInvokers.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 再次进行选择，并返回选择结果</span></span><br><span class="line">            <span class="keyword">return</span> loadbalance.select(reselectInvokers, getUrl(), invocation);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>reselect</code> 方法总结下来其实只做了两件事情，第一是查找可用的 <code>Invoker</code>，并将其添加到 <code>reselectInvokers</code> 集合中。第二，如果 <code>reselectInvokers</code> 不为空，则通过负载均衡组件再次进行选择.</p><p>还有一些容错处理的实现类，这里就不分析了。</p><h2><span id="负载均衡">负载均衡</span></h2><h3><span id="简介">简介</span></h3><p><code>LoadBalance</code> 中文意思为负载均衡，它的职责是将网络请求，或者其他形式的负载“均摊”到不同的机器上。避免集群中部分服务器压力过大，而另一些服务器比较空闲的情况。通过负载均衡，可以让每台服务器获取到适合自己处理能力的负载。</p><p>Dubbo提供了4种负载均衡的实现：</p><ul><li><code>RandomLoadBalance</code>:基于权重随机算法</li><li><code>LeastActiveLoadBalance</code>：基于最少活跃连接数算法</li><li><code>ConsistentHashLoadBalance</code>：基于一致性hash算法</li><li><code>RoundRobinLoadBalance</code>：基于加权轮询算法</li></ul><h3><span id="源码分析">源码分析</span></h3><p>在Dubbo种所有的负载均衡策略均是<code>AbstractLoadBalance</code>的子类，该类实现了<code>LoadBalance</code>接口，并封装了一些公共逻辑。</p><p>下面我们来分析一下<code>AbstractLoadBalance</code>中的公共逻辑。</p><p>整个负载均衡的入口方法<code>select</code>的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">select</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (invokers == <span class="keyword">null</span> || invokers.isEmpty())</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 如果 invokers 列表中仅有一个 Invoker，直接返回即可，无需进行负载均衡</span></span><br><span class="line">    <span class="keyword">if</span> (invokers.size() == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> invokers.get(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用 doSelect 方法进行负载均衡，该方法为抽象方法，由子类实现</span></span><br><span class="line">    <span class="keyword">return</span> doSelect(invokers, url, invocation);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">abstract</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">doSelect</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span></span>;</span><br></pre></td></tr></table></figure><p>它还提供了计算服务提供者权重的计算方法<code>getWeight</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getWeight</span><span class="params">(Invoker&lt;?&gt; invoker, Invocation invocation)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从 url 中获取权重 weight 配置值</span></span><br><span class="line">    <span class="keyword">int</span> weight = invoker.getUrl().getMethodParameter(invocation.getMethodName(), Constants.WEIGHT_KEY, Constants.DEFAULT_WEIGHT);</span><br><span class="line">    <span class="keyword">if</span> (weight &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取服务提供者启动时间戳</span></span><br><span class="line">        <span class="keyword">long</span> timestamp = invoker.getUrl().getParameter(Constants.REMOTE_TIMESTAMP_KEY, <span class="number">0L</span>);</span><br><span class="line">        <span class="keyword">if</span> (timestamp &gt; <span class="number">0L</span>) &#123;</span><br><span class="line">            <span class="comment">// 计算服务提供者运行时长</span></span><br><span class="line">            <span class="keyword">int</span> uptime = (<span class="keyword">int</span>) (System.currentTimeMillis() - timestamp);</span><br><span class="line">            <span class="comment">// 获取服务预热时间，默认为10分钟</span></span><br><span class="line">            <span class="keyword">int</span> warmup = invoker.getUrl().getParameter(Constants.WARMUP_KEY, Constants.DEFAULT_WARMUP);</span><br><span class="line">            <span class="comment">// 如果服务运行时间小于预热时间，则重新计算服务权重，即降权</span></span><br><span class="line">            <span class="keyword">if</span> (uptime &gt; <span class="number">0</span> &amp;&amp; uptime &lt; warmup) &#123;</span><br><span class="line">                <span class="comment">// 重新计算服务权重</span></span><br><span class="line">                weight = calculateWarmupWeight(uptime, warmup, weight);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> weight;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateWarmupWeight</span><span class="params">(<span class="keyword">int</span> uptime, <span class="keyword">int</span> warmup, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 计算权重，下面代码逻辑上形似于 (uptime / warmup) * weight。</span></span><br><span class="line">    <span class="comment">// 随着服务运行时间 uptime 增大，权重计算值 ww 会慢慢接近配置值 weight</span></span><br><span class="line">    <span class="keyword">int</span> ww = (<span class="keyword">int</span>) ((<span class="keyword">float</span>) uptime / ((<span class="keyword">float</span>) warmup / (<span class="keyword">float</span>) weight));</span><br><span class="line">    <span class="keyword">return</span> ww &lt; <span class="number">1</span> ? <span class="number">1</span> : (ww &gt; weight ? weight : ww);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是权重的计算过程，该过程主要用于保证当服务运行时长小于服务预热时间时，对服务进行降权，避免让服务在启动之初就处于高负载状态。服务预热是一个优化手段，与此类似的还有 JVM 预热。主要目的是让服务启动后“低功率”运行一段时间，使其效率慢慢提升至最佳状态。</p><p>下面我们就以Dubbo的默认负载均衡策略<code>RandomLoadBalance</code>的实现为例来分析这些负载均衡策略是如何实现的。</p><p><code>RandomLoadBalance</code>是加权随机算法的具体实现，它的算法思想很简单。假设我们有一组服务器 <code>servers = [A, B,  C]</code>，他们对应的权重为 <code>weights = [5, 3, 2]</code>，权重总和为10。现在把这些权重值平铺在一维坐标值上，<code>[0, 5)</code>区间属于服务器 <code>A</code>，<code>[5, 8)</code>区间属于服务器 <code>B</code>，<code>[8, 10)</code> 区间属于服务器 <code>C</code>。接下来通过随机数生成器生成一个范围在<code>[0, 10)</code> 之间的随机数，然后计算这个随机数会落到哪个区间上.基于这个思路，它的代码实现也是非常简单的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomLoadBalance</span> <span class="keyword">extends</span> <span class="title">AbstractLoadBalance</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NAME = <span class="string">"random"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Random random = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">doSelect</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = invokers.size();</span><br><span class="line">        <span class="keyword">int</span> totalWeight = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> sameWeight = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 下面这个循环有两个作用，第一是计算总权重 totalWeight，</span></span><br><span class="line">        <span class="comment">// 第二是检测每个服务提供者的权重是否相同</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> weight = getWeight(invokers.get(i), invocation);</span><br><span class="line">            <span class="comment">// 累加权重</span></span><br><span class="line">            totalWeight += weight;</span><br><span class="line">            <span class="comment">// 检测当前服务提供者的权重与上一个服务提供者的权重是否相同，</span></span><br><span class="line">            <span class="comment">// 不相同的话，则将 sameWeight 置为 false。</span></span><br><span class="line">            <span class="keyword">if</span> (sameWeight &amp;&amp; i &gt; <span class="number">0</span></span><br><span class="line">                    &amp;&amp; weight != getWeight(invokers.get(i - <span class="number">1</span>), invocation)) &#123;</span><br><span class="line">                sameWeight = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 下面的 if 分支主要用于获取随机数，并计算随机数落在哪个区间上</span></span><br><span class="line">        <span class="keyword">if</span> (totalWeight &gt; <span class="number">0</span> &amp;&amp; !sameWeight) &#123;</span><br><span class="line">            <span class="comment">// 随机获取一个 [0, totalWeight) 区间内的数字</span></span><br><span class="line">            <span class="keyword">int</span> offset = random.nextInt(totalWeight);</span><br><span class="line">            <span class="comment">// 循环让 offset 数减去服务提供者权重值，当 offset 小于0时，返回相应的 Invoker。</span></span><br><span class="line">            <span class="comment">// 举例说明一下，我们有 servers = [A, B, C]，weights = [5, 3, 2]，offset = 7。</span></span><br><span class="line">            <span class="comment">// 第一次循环，offset - 5 = 2 &gt; 0，即 offset &gt; 5，</span></span><br><span class="line">            <span class="comment">// 表明其不会落在服务器 A 对应的区间上。</span></span><br><span class="line">            <span class="comment">// 第二次循环，offset - 3 = -1 &lt; 0，即 5 &lt; offset &lt; 8，</span></span><br><span class="line">            <span class="comment">// 表明其会落在服务器 B 对应的区间上</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">                <span class="comment">// 让随机值 offset 减去权重值</span></span><br><span class="line">                offset -= getWeight(invokers.get(i), invocation);</span><br><span class="line">                <span class="keyword">if</span> (offset &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 返回相应的 Invoker</span></span><br><span class="line">                    <span class="keyword">return</span> invokers.get(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果所有服务提供者权重值相同，此时直接随机返回一个即可</span></span><br><span class="line">        <span class="keyword">return</span> invokers.get(random.nextInt(length));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此这个Dubbo集群的源码就分析完毕了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Dubbo集群容错方面的源码包括四个部分，分别式服务目录Directory、服务路由Router、集群Cluster和负载均衡LoadBalance。&lt;/p&gt;
&lt;p&gt;它们之间的关系是这样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/05/11/YJAi1H.png&quot; alt=&quot;YJAi1H.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="https://zofun.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Dubbo" scheme="https://zofun.github.io/tags/Dubbo/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo服务调用过程</title>
    <link href="https://zofun.github.io/2020/05/10/Dubbo%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B/"/>
    <id>https://zofun.github.io/2020/05/10/Dubbo服务调用过程/</id>
    <published>2020-05-10T13:44:00.000Z</published>
    <updated>2020-05-10T13:44:44.948Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="简介">简介</span></h2><p>Dubbo服务调用的基本过程如图：</p><p><img src="https://s1.ax1x.com/2020/05/10/Y33nc8.png" alt="Y33nc8.png"></p><p>首先服务消费者通过代理对象Proxy发起远程调用，接着通过网络客户端将编码后的请求发送给服务提供方的网络层上。Server收到请求之后，首先要做的就是对数据包进行解码。然后将解码后的请求发送至分发器，再由分发器将请求发送到指定的线程池上，最后由线程池调用具体的服务。这就是一个远程调用请求的发送过程。</p><a id="more"></a><h2><span id="服务调用过程源码分析">服务调用过程源码分析</span></h2><h3><span id="服务消费端进行服务调用过程">服务消费端进行服务调用过程</span></h3><p>我们知道服务消费端是通过为接口生成的代理对象进行服务调用的，他的代理对象的实现如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">proxy0</span> <span class="keyword">implements</span> <span class="title">ClassGenerator</span>.<span class="title">DC</span>, <span class="title">EchoService</span>, <span class="title">DemoService</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 方法数组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Method[] methods;</span><br><span class="line">    <span class="keyword">private</span> InvocationHandler handler;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">proxy0</span><span class="params">(InvocationHandler invocationHandler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.handler = invocationHandler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">proxy0</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String string)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将参数存储到 Object 数组中</span></span><br><span class="line">        Object[] arrobject = <span class="keyword">new</span> Object[]&#123;string&#125;;</span><br><span class="line">        <span class="comment">// 调用 InvocationHandler 实现类的 invoke 方法得到调用结果</span></span><br><span class="line">        Object object = <span class="keyword">this</span>.handler.invoke(<span class="keyword">this</span>, methods[<span class="number">0</span>], arrobject);</span><br><span class="line">        <span class="comment">// 返回调用结果</span></span><br><span class="line">        <span class="keyword">return</span> (String)object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 回声测试方法 */</span></span><br><span class="line">    <span class="keyword">public</span> Object $echo(Object object) &#123;</span><br><span class="line">        Object[] arrobject = <span class="keyword">new</span> Object[]&#123;object&#125;;</span><br><span class="line">        Object object2 = <span class="keyword">this</span>.handler.invoke(<span class="keyword">this</span>, methods[<span class="number">1</span>], arrobject);</span><br><span class="line">        <span class="keyword">return</span> object2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个代理类的实现逻辑比较简单，首先将参数存储到数组中，然后调用<code>InvocationHandler</code>的实现类的<code>invoke</code>方法，然后得到一个调用结果，最后将这个结果返回给调用端。</p><p>也就是说这个代理类只做了三件事情：</p><ol><li>将参数进行封装</li><li>调用<code>invoke</code>方法，进行服务调用</li><li>返回结果</li></ol><p>下面我们来分析这个<code>InvocationHandler</code>的实现类的代码实现；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InvokerInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Invoker&lt;?&gt; invoker;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InvokerInvocationHandler</span><span class="params">(Invoker&lt;?&gt; handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.invoker = handler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        String methodName = method.getName();</span><br><span class="line">        Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 拦截定义在 Object 类中的方法（未被子类重写），比如 wait/notify</span></span><br><span class="line">        <span class="keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">            <span class="keyword">return</span> method.invoke(invoker, args);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果 toString、hashCode 和 equals 等方法被子类重写了，这里也直接调用</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"toString"</span>.equals(methodName) &amp;&amp; parameterTypes.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> invoker.toString();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"hashCode"</span>.equals(methodName) &amp;&amp; parameterTypes.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> invoker.hashCode();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"equals"</span>.equals(methodName) &amp;&amp; parameterTypes.length == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> invoker.equals(args[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将 method 和 args 封装到 RpcInvocation 中，并执行后续的调用</span></span><br><span class="line">        <span class="keyword">return</span> invoker.invoke(<span class="keyword">new</span> RpcInvocation(method, args)).recreate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类的<code>invoke</code>的实现逻辑非常的简单，如果调用的是Object中的一些方法，那么直接进行处理即可（这些方法根本不需要远程调用），否则通过<code>Invoker</code>接口的实现类的<code>invoke</code>方法进行远程调用。</p><p>这里的<code>Invoker</code>的实现类其实是<code>MockClusterInvoker</code>,它的内部封装了服务降级的逻辑，下面我们来看它的具体实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MockClusterInvoker</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Invoker</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Invoker&lt;T&gt; invoker;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        Result result = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 mock 配置值</span></span><br><span class="line">        String value = directory.getUrl().getMethodParameter(invocation.getMethodName(), Constants.MOCK_KEY, Boolean.FALSE.toString()).trim();</span><br><span class="line">        <span class="keyword">if</span> (value.length() == <span class="number">0</span> || value.equalsIgnoreCase(<span class="string">"false"</span>)) &#123;</span><br><span class="line">            <span class="comment">// 无 mock 逻辑，直接调用其他 Invoker 对象的 invoke 方法，</span></span><br><span class="line">            <span class="comment">// 比如 FailoverClusterInvoker</span></span><br><span class="line">            result = <span class="keyword">this</span>.invoker.invoke(invocation);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value.startsWith(<span class="string">"force"</span>)) &#123;</span><br><span class="line">            <span class="comment">// force:xxx 直接执行 mock 逻辑，不发起远程调用</span></span><br><span class="line">            result = doMockInvoke(invocation, <span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// fail:xxx 表示消费方对调用服务失败后，再执行 mock 逻辑，不抛出异常</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 调用其他 Invoker 对象的 invoke 方法</span></span><br><span class="line">                result = <span class="keyword">this</span>.invoker.invoke(invocation);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RpcException e) &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.isBiz()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> e;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 调用失败，执行 mock 逻辑</span></span><br><span class="line">                    result = doMockInvoke(invocation, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略其他方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里主要是对服务降级的处理，如果没有配置服务降级的逻辑，那么直接进行远程调用；如果服务降级信息配置为<code>force</code>那么直接降级，不发起远程调用；如果服务降级信息配置为<code>fail</code>，那么会尝试进行远程调用，如果失败那么就进行服务降级逻辑。</p><p>在这里我们就不深究这个服务降级的实现了，主要来看一看远程调用。在这个类中进行远程调用使用的是实现了<code>Invoker</code>接口的<code>AbstractInvoker</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractInvoker</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Invoker</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(Invocation inv)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (destroyed.get()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Rpc invoker for service ..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        RpcInvocation invocation = (RpcInvocation) inv;</span><br><span class="line">        <span class="comment">// 设置 Invoker</span></span><br><span class="line">        invocation.setInvoker(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (attachment != <span class="keyword">null</span> &amp;&amp; attachment.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 设置 attachment</span></span><br><span class="line">            invocation.addAttachmentsIfAbsent(attachment);</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;String, String&gt; contextAttachments = RpcContext.getContext().getAttachments();</span><br><span class="line">        <span class="keyword">if</span> (contextAttachments != <span class="keyword">null</span> &amp;&amp; contextAttachments.size() != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 添加 contextAttachments 到 RpcInvocation#attachment 变量中</span></span><br><span class="line">            invocation.addAttachments(contextAttachments);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (getUrl().getMethodParameter(invocation.getMethodName(), Constants.ASYNC_KEY, <span class="keyword">false</span>)) &#123;</span><br><span class="line">            <span class="comment">// 设置异步信息到 RpcInvocation#attachment 中</span></span><br><span class="line">            invocation.setAttachment(Constants.ASYNC_KEY, Boolean.TRUE.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        RpcUtils.attachInvocationIdIfAsync(getUrl(), invocation);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 抽象方法，由子类实现</span></span><br><span class="line">            <span class="keyword">return</span> doInvoke(invocation);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (RpcException e) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> RpcResult(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Result <span class="title">doInvoke</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略其他方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码的主要逻辑就是将信息添加到<code>RpcInvocation#attachment</code>,然后调用<code>doInvoke</code>执行后序逻辑。<code>doInvoke</code>是一个抽象方法，由子类<code>DubboInvoker</code>实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboInvoker</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractInvoker</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExchangeClient[] clients;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Result <span class="title">doInvoke</span><span class="params">(<span class="keyword">final</span> Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        RpcInvocation inv = (RpcInvocation) invocation;</span><br><span class="line">        <span class="keyword">final</span> String methodName = RpcUtils.getMethodName(invocation);</span><br><span class="line">        <span class="comment">// 设置 path 和 version 到 attachment 中</span></span><br><span class="line">        inv.setAttachment(Constants.PATH_KEY, getUrl().getPath());</span><br><span class="line">        inv.setAttachment(Constants.VERSION_KEY, version);</span><br><span class="line"></span><br><span class="line">        ExchangeClient currentClient;</span><br><span class="line">        <span class="keyword">if</span> (clients.length == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 从 clients 数组中获取 ExchangeClient</span></span><br><span class="line">            currentClient = clients[<span class="number">0</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            currentClient = clients[index.getAndIncrement() % clients.length];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取异步配置</span></span><br><span class="line">            <span class="keyword">boolean</span> isAsync = RpcUtils.isAsync(getUrl(), invocation);</span><br><span class="line">            <span class="comment">// isOneway 为 true，表示“单向”通信</span></span><br><span class="line">            <span class="keyword">boolean</span> isOneway = RpcUtils.isOneway(getUrl(), invocation);</span><br><span class="line">            <span class="keyword">int</span> timeout = getUrl().getMethodParameter(methodName, Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 异步无返回值</span></span><br><span class="line">            <span class="keyword">if</span> (isOneway) &#123;</span><br><span class="line">                <span class="keyword">boolean</span> isSent = getUrl().getMethodParameter(methodName, Constants.SENT_KEY, <span class="keyword">false</span>);</span><br><span class="line">                <span class="comment">// 发送请求</span></span><br><span class="line">                currentClient.send(inv, isSent);</span><br><span class="line">                <span class="comment">// 设置上下文中的 future 字段为 null</span></span><br><span class="line">                RpcContext.getContext().setFuture(<span class="keyword">null</span>);</span><br><span class="line">                <span class="comment">// 返回一个空的 RpcResult</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> RpcResult();</span><br><span class="line">            &#125; </span><br><span class="line"></span><br><span class="line">            <span class="comment">// 异步有返回值</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (isAsync) &#123;</span><br><span class="line">                <span class="comment">// 发送请求，并得到一个 ResponseFuture 实例</span></span><br><span class="line">                ResponseFuture future = currentClient.request(inv, timeout);</span><br><span class="line">                <span class="comment">// 设置 future 到上下文中</span></span><br><span class="line">                RpcContext.getContext().setFuture(<span class="keyword">new</span> FutureAdapter&lt;Object&gt;(future));</span><br><span class="line">                <span class="comment">// 暂时返回一个空结果</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> RpcResult();</span><br><span class="line">            &#125; </span><br><span class="line"></span><br><span class="line">            <span class="comment">// 同步调用</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                RpcContext.getContext().setFuture(<span class="keyword">null</span>);</span><br><span class="line">                <span class="comment">// 发送请求，得到一个 ResponseFuture 实例，并调用该实例的 get 方法进行等待</span></span><br><span class="line">                <span class="keyword">return</span> (Result) currentClient.request(inv, timeout).get();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(..., <span class="string">"Invoke remote method timeout...."</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemotingException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(..., <span class="string">"Failed to invoke remote method: ..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略其他方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码包含了Dubbo对同步调用和一步调用的处理逻辑。Dubbo实现同步调用和异步调用比较关键的点是由谁负责调用<code>ResponseFuture</code> 的<code>get</code>方法，同步调用模式下是由框架来调用<code>get</code>方法的，而异步调用是由用户来调用<code>get</code>方法的。</p><p>这个方法主要完成的就是利用<code>client</code>进行远程调用，并处理同步调用和异步调用的细节。</p><p>下面我们来看一看<code>ResponseFuture</code>的一个默认实现<code>DefaultFuture</code>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultFuture</span> <span class="keyword">implements</span> <span class="title">ResponseFuture</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Long, Channel&gt; CHANNELS = </span><br><span class="line">        <span class="keyword">new</span> ConcurrentHashMap&lt;Long, Channel&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Long, DefaultFuture&gt; FUTURES = </span><br><span class="line">        <span class="keyword">new</span> ConcurrentHashMap&lt;Long, DefaultFuture&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Channel channel;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Request request;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> timeout;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition done = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Response response;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultFuture</span><span class="params">(Channel channel, Request request, <span class="keyword">int</span> timeout)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.channel = channel;</span><br><span class="line">        <span class="keyword">this</span>.request = request;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取请求 id，这个 id 很重要，后面还会见到</span></span><br><span class="line">        <span class="keyword">this</span>.id = request.getId();</span><br><span class="line">        <span class="keyword">this</span>.timeout = timeout &gt; <span class="number">0</span> ? timeout : channel.getUrl().getPositiveParameter(Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT);</span><br><span class="line">        <span class="comment">// 存储 &lt;requestId, DefaultFuture&gt; 映射关系到 FUTURES 中</span></span><br><span class="line">        FUTURES.put(id, <span class="keyword">this</span>);</span><br><span class="line">        CHANNELS.put(id, channel);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> get(timeout);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(<span class="keyword">int</span> timeout)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (timeout &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            timeout = Constants.DEFAULT_TIMEOUT;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 检测服务提供方是否成功返回了调用结果</span></span><br><span class="line">        <span class="keyword">if</span> (!isDone()) &#123;</span><br><span class="line">            <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 循环检测服务提供方是否成功返回了调用结果</span></span><br><span class="line">                <span class="keyword">while</span> (!isDone()) &#123;</span><br><span class="line">                    <span class="comment">// 如果调用结果尚未返回，这里等待一段时间</span></span><br><span class="line">                    done.await(timeout, TimeUnit.MILLISECONDS);</span><br><span class="line">                    <span class="comment">// 如果调用结果成功返回，或等待超时，此时跳出 while 循环，执行后续的逻辑</span></span><br><span class="line">                    <span class="keyword">if</span> (isDone() || System.currentTimeMillis() - start &gt; timeout) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果调用结果仍未返回，则抛出超时异常</span></span><br><span class="line">            <span class="keyword">if</span> (!isDone()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException(sent &gt; <span class="number">0</span>, channel, getTimeoutMessage(<span class="keyword">false</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 返回调用结果</span></span><br><span class="line">        <span class="keyword">return</span> returnFromResponse();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 通过检测 response 字段为空与否，判断是否收到了调用结果</span></span><br><span class="line">        <span class="keyword">return</span> response != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">returnFromResponse</span><span class="params">()</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        Response res = response;</span><br><span class="line">        <span class="keyword">if</span> (res == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"response cannot be null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果调用结果的状态为 Response.OK，则表示调用过程正常，服务提供方成功返回了调用结果</span></span><br><span class="line">        <span class="keyword">if</span> (res.getStatus() == Response.OK) &#123;</span><br><span class="line">            <span class="keyword">return</span> res.getResult();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (res.getStatus() == Response.CLIENT_TIMEOUT || res.getStatus() == Response.SERVER_TIMEOUT) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException(res.getStatus() == Response.SERVER_TIMEOUT, channel, res.getErrorMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RemotingException(channel, res.getErrorMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略其他方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实这段代码非常逻辑非常的简单，如果服务消费者还没有收到结果时，那么调用<code>get</code>方法，就会被阻塞。同步调用模式下，是由框架来执行<code>get</code>方法的，它会阻塞直至收到结果。而异步模式下将该对象封装到<code>FutureAdapter</code>对象中，然后设置到<code>RpcContext</code>中，供用户使用。这个适配器的主要作用就是将<code>Dubbo</code>的<code>ResponseFuture</code>和<code>JDK</code>中的<code>Future</code>进行适配，这样用户可以调用<code>Future</code>的<code>get</code>方法的时候经过了<code>FutureAdapter</code>的适配，最终调用<code>ResponseFuture</code>的<code>get</code>方法。</p><p>到此，整个执行的流程如下：</p><p><img src="https://s1.ax1x.com/2020/05/10/Y3yed1.png" alt="Y3yed1.png"></p><h3><span id="服务消费端发送请求">服务消费端发送请求</span></h3><p>通过之前的源码分析，我们可以看出服务调用是通过<code>client</code>发送请求完成的，下面我们就来分析，这个请求发送的具体流程。</p><p>在之前提到的<code>client</code>其实就是实现<code>ExchangeClient</code>接口的<code>ReferenceCountExchangeClient</code>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceCountExchangeClient</span> <span class="keyword">implements</span> <span class="title">ExchangeClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> URL url;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger referenceCount = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReferenceCountExchangeClient</span><span class="params">(ExchangeClient client, ConcurrentMap&lt;String, LazyConnectExchangeClient&gt; ghostClientMap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.client = client;</span><br><span class="line">        <span class="comment">// 引用计数自增</span></span><br><span class="line">        referenceCount.incrementAndGet();</span><br><span class="line">        <span class="keyword">this</span>.url = client.getUrl();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseFuture <span class="title">request</span><span class="params">(Object request)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="comment">// 直接调用被装饰对象的同签名方法</span></span><br><span class="line">        <span class="keyword">return</span> client.request(request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseFuture <span class="title">request</span><span class="params">(Object request, <span class="keyword">int</span> timeout)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="comment">// 直接调用被装饰对象的同签名方法</span></span><br><span class="line">        <span class="keyword">return</span> client.request(request, timeout);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 引用计数自增，该方法由外部调用 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">incrementAndGetCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// referenceCount 自增</span></span><br><span class="line">        referenceCount.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> timeout)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// referenceCount 自减</span></span><br><span class="line">        <span class="keyword">if</span> (referenceCount.decrementAndGet() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (timeout == <span class="number">0</span>) &#123;</span><br><span class="line">                client.close();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                client.close(timeout);</span><br><span class="line">            &#125;</span><br><span class="line">            client = replaceWithLazyClient();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略部分方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ReferenceCountExchangeClient</code>内部主要进行的是引用计数的处理，其它均调用的是被装饰对象的相关方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeaderExchangeClient</span> <span class="keyword">implements</span> <span class="title">ExchangeClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ScheduledThreadPoolExecutor scheduled = <span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">2</span>, <span class="keyword">new</span> NamedThreadFactory(<span class="string">"dubbo-remoting-client-heartbeat"</span>, <span class="keyword">true</span>));</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Client client;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExchangeChannel channel;</span><br><span class="line">    <span class="keyword">private</span> ScheduledFuture&lt;?&gt; heartbeatTimer;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> heartbeat;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> heartbeatTimeout;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeaderExchangeClient</span><span class="params">(Client client, <span class="keyword">boolean</span> needHeartbeat)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (client == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"client == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.client = client;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建 HeaderExchangeChannel 对象</span></span><br><span class="line">        <span class="keyword">this</span>.channel = <span class="keyword">new</span> HeaderExchangeChannel(client);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 以下代码均与心跳检测逻辑有关</span></span><br><span class="line">        String dubbo = client.getUrl().getParameter(Constants.DUBBO_VERSION_KEY);</span><br><span class="line">        <span class="keyword">this</span>.heartbeat = client.getUrl().getParameter(Constants.HEARTBEAT_KEY, dubbo != <span class="keyword">null</span> &amp;&amp; dubbo.startsWith(<span class="string">"1.0."</span>) ? Constants.DEFAULT_HEARTBEAT : <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">this</span>.heartbeatTimeout = client.getUrl().getParameter(Constants.HEARTBEAT_TIMEOUT_KEY, heartbeat * <span class="number">3</span>);</span><br><span class="line">        <span class="keyword">if</span> (heartbeatTimeout &lt; heartbeat * <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"heartbeatTimeout &lt; heartbeatInterval * 2"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (needHeartbeat) &#123;</span><br><span class="line">            <span class="comment">// 开启心跳检测定时器</span></span><br><span class="line">            startHeartbeatTimer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseFuture <span class="title">request</span><span class="params">(Object request)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="comment">// 直接 HeaderExchangeChannel 对象的同签名方法</span></span><br><span class="line">        <span class="keyword">return</span> channel.request(request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseFuture <span class="title">request</span><span class="params">(Object request, <span class="keyword">int</span> timeout)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="comment">// 直接 HeaderExchangeChannel 对象的同签名方法</span></span><br><span class="line">        <span class="keyword">return</span> channel.request(request, timeout);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        doClose();</span><br><span class="line">        channel.close();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doClose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 停止心跳检测定时器</span></span><br><span class="line">        stopHeartbeatTimer();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startHeartbeatTimer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stopHeartbeatTimer();</span><br><span class="line">        <span class="keyword">if</span> (heartbeat &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            heartbeatTimer = scheduled.scheduleWithFixedDelay(</span><br><span class="line">                    <span class="keyword">new</span> HeartBeatTask(<span class="keyword">new</span> HeartBeatTask.ChannelProvider() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> Collection&lt;Channel&gt; <span class="title">getChannels</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                            <span class="keyword">return</span> Collections.&lt;Channel&gt;singletonList(HeaderExchangeClient.<span class="keyword">this</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;, heartbeat, heartbeatTimeout),</span><br><span class="line">                    heartbeat, heartbeat, TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">stopHeartbeatTimer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (heartbeatTimer != <span class="keyword">null</span> &amp;&amp; !heartbeatTimer.isCancelled()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                heartbeatTimer.cancel(<span class="keyword">true</span>);</span><br><span class="line">                scheduled.purge();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                    logger.warn(e.getMessage(), e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        heartbeatTimer = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略部分方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>HeaderExchangeClient</code>封装了心跳检测逻辑，然后通过调用<code>HeaderExchangeChannel</code>对象的同签名方法。下面我们来分析<code>HeaderExchangeChannel</code>的代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HeaderExchangeChannel</span> <span class="keyword">implements</span> <span class="title">ExchangeChannel</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Channel channel;</span><br><span class="line">    </span><br><span class="line">    HeaderExchangeChannel(Channel channel) &#123;</span><br><span class="line">        <span class="keyword">if</span> (channel == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"channel == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 这里的 channel 指向的是 NettyClient</span></span><br><span class="line">        <span class="keyword">this</span>.channel = channel;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseFuture <span class="title">request</span><span class="params">(Object request)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> request(request, channel.getUrl().getPositiveParameter(Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseFuture <span class="title">request</span><span class="params">(Object request, <span class="keyword">int</span> timeout)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RemotingException(..., <span class="string">"Failed to send request ...);</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        // 创建 Request 对象</span></span><br><span class="line"><span class="string">        Request req = new Request();</span></span><br><span class="line"><span class="string">        req.setVersion(Version.getProtocolVersion());</span></span><br><span class="line"><span class="string">        // 设置双向通信标志为 true</span></span><br><span class="line"><span class="string">        req.setTwoWay(true);</span></span><br><span class="line"><span class="string">        // 这里的 request 变量类型为 RpcInvocation</span></span><br><span class="line"><span class="string">        req.setData(request);</span></span><br><span class="line"><span class="string">                                        </span></span><br><span class="line"><span class="string">        // 创建 DefaultFuture 对象</span></span><br><span class="line"><span class="string">        DefaultFuture future = new DefaultFuture(channel, req, timeout);</span></span><br><span class="line"><span class="string">        try &#123;</span></span><br><span class="line"><span class="string">            // 调用 NettyClient 的 send 方法发送请求</span></span><br><span class="line"><span class="string">            channel.send(req);</span></span><br><span class="line"><span class="string">        &#125; catch (RemotingException e) &#123;</span></span><br><span class="line"><span class="string">            future.cancel();</span></span><br><span class="line"><span class="string">            throw e;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        // 返回 DefaultFuture 对象</span></span><br><span class="line"><span class="string">        return future;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>这个类的<code>request</code>方法，首先定义了一个<code>Request</code>对象，然后再将该对象传给<code>NettyClient</code>的<code>send</code>方法，进行后序的调用。而<code>NettyClient</code>本身并没有实现<code>send</code>方法，这个方法是通过继承<code>AbstractPeer</code>得到得。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractPeer</span> <span class="keyword">implements</span> <span class="title">Endpoint</span>, <span class="title">ChannelHandler</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(Object message)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="comment">// 该方法由 AbstractClient 类实现</span></span><br><span class="line">        send(message, url.getParameter(Constants.SENT_KEY, <span class="keyword">false</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略其他方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractClient</span> <span class="keyword">extends</span> <span class="title">AbstractEndpoint</span> <span class="keyword">implements</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(Object message, <span class="keyword">boolean</span> sent)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (send_reconnect &amp;&amp; !isConnected()) &#123;</span><br><span class="line">            connect();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取 Channel，getChannel 是一个抽象方法，具体由子类实现</span></span><br><span class="line">        Channel channel = getChannel();</span><br><span class="line">        <span class="keyword">if</span> (channel == <span class="keyword">null</span> || !channel.isConnected()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RemotingException(<span class="keyword">this</span>, <span class="string">"message can not send ..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 继续向下调用</span></span><br><span class="line">        channel.send(message, sent);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Channel <span class="title">getChannel</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略其他方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再默认得情况下，<code>Dubbo</code>使用得是<code>Netty作为底层得通信框架，下面我们来分析一下</code>NettyClient<code>类中</code>getChannel`方法得实现逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClient</span> <span class="keyword">extends</span> <span class="title">AbstractClient</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这里的 Channel 全限定名称为 org.jboss.netty.channel.Channel</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Channel channel;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> com.alibaba.dubbo.remoting.<span class="function">Channel <span class="title">getChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Channel c = channel;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span> || !c.isConnected())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 获取一个 NettyChannel 类型对象</span></span><br><span class="line">        <span class="keyword">return</span> NettyChannel.getOrAddChannel(c, getUrl(), <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyChannel</span> <span class="keyword">extends</span> <span class="title">AbstractChannel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentMap&lt;org.jboss.netty.channel.Channel, NettyChannel&gt; channelMap = </span><br><span class="line">        <span class="keyword">new</span> ConcurrentHashMap&lt;org.jboss.netty.channel.Channel, NettyChannel&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> org.jboss.netty.channel.Channel channel;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 私有构造方法 */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">NettyChannel</span><span class="params">(org.jboss.netty.channel.Channel channel, URL url, ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(url, handler);</span><br><span class="line">        <span class="keyword">if</span> (channel == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"netty channel == null;"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.channel = channel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> NettyChannel <span class="title">getOrAddChannel</span><span class="params">(org.jboss.netty.channel.Channel ch, URL url, ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 尝试从集合中获取 NettyChannel 实例</span></span><br><span class="line">        NettyChannel ret = channelMap.get(ch);</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果 ret = null，则创建一个新的 NettyChannel 实例</span></span><br><span class="line">            NettyChannel nc = <span class="keyword">new</span> NettyChannel(ch, url, handler);</span><br><span class="line">            <span class="keyword">if</span> (ch.isConnected()) &#123;</span><br><span class="line">                <span class="comment">// 将 &lt;Channel, NettyChannel&gt; 键值对存入 channelMap 集合中</span></span><br><span class="line">                ret = channelMap.putIfAbsent(ch, nc);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ret == <span class="keyword">null</span>) &#123;</span><br><span class="line">                ret = nc;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拿到<code>NettyChannel</code>实例之后，就可以进行后序的调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(Object message, <span class="keyword">boolean</span> sent)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.send(message, sent);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> success = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">int</span> timeout = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 发送消息(包含请求和响应消息)</span></span><br><span class="line">        ChannelFuture future = channel.write(message);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// sent 的值源于 &lt;dubbo:method sent="true/false" /&gt; 中 sent 的配置值，有两种配置值：</span></span><br><span class="line">        <span class="comment">//   1. true: 等待消息发出，消息发送失败将抛出异常</span></span><br><span class="line">        <span class="comment">//   2. false: 不等待消息发出，将消息放入 IO 队列，即刻返回</span></span><br><span class="line">        <span class="comment">// 默认情况下 sent = false；</span></span><br><span class="line">        <span class="keyword">if</span> (sent) &#123;</span><br><span class="line">            timeout = getUrl().getPositiveParameter(Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT);</span><br><span class="line">            <span class="comment">// 等待消息发出，若在规定时间没能发出，success 会被置为 false</span></span><br><span class="line">            success = future.await(timeout);</span><br><span class="line">        &#125;</span><br><span class="line">        Throwable cause = future.getCause();</span><br><span class="line">        <span class="keyword">if</span> (cause != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> cause;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RemotingException(<span class="keyword">this</span>, <span class="string">"Failed to send message ..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若 success 为 false，这里抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RemotingException(<span class="keyword">this</span>, <span class="string">"Failed to send message ..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此调用请求就发出去了，当然再Netty中还有出站数据的编码操作，这里就不分析了。</p><p>整个调用路径是这个样子的：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">proxy0#sayHello(String)</span><br><span class="line">  —&gt; InvokerInvocationHandler#invoke(Object, Method, Object[])</span><br><span class="line">    —&gt; MockClusterInvoker#invoke(Invocation)</span><br><span class="line">      —&gt; AbstractClusterInvoker#invoke(Invocation)</span><br><span class="line">        —&gt; FailoverClusterInvoker#doInvoke(Invocation, List&lt;Invoker&lt;T&gt;&gt;, LoadBalance)</span><br><span class="line">          —&gt; Filter#invoke(Invoker, Invocation)  // 包含多个 Filter 调用</span><br><span class="line">            —&gt; ListenerInvokerWrapper#invoke(Invocation) </span><br><span class="line">              —&gt; AbstractInvoker#invoke(Invocation) </span><br><span class="line">                —&gt; DubboInvoker#doInvoke(Invocation)</span><br><span class="line">                  —&gt; ReferenceCountExchangeClient#request(Object, int)</span><br><span class="line">                    —&gt; HeaderExchangeClient#request(Object, int)</span><br><span class="line">                      —&gt; HeaderExchangeChannel#request(Object, int)</span><br><span class="line">                        —&gt; AbstractPeer#send(Object)</span><br><span class="line">                          —&gt; AbstractClient#send(Object, boolean)</span><br><span class="line">                            —&gt; NettyChannel#send(Object, boolean)</span><br><span class="line">                              —&gt; NioClientSocketChannel#write(Object)</span><br></pre></td></tr></table></figure><h2><span id="服务提供方处理逻辑">服务提供方处理逻辑</span></h2><h3><span id="接收请求">接收请求</span></h3><p>前面说过，默认情况下 Dubbo 使用 Netty 作为底层的通信框架。Netty 检测到有数据入站后，首先会通过解码器对数据进行解码，并将解码后的数据传递给下一个入站处理器的指定方法。</p><p>这里直接分析请求数据的解码逻辑，忽略中间过程.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExchangeCodec</span> <span class="keyword">extends</span> <span class="title">TelnetCodec</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">decode</span><span class="params">(Channel channel, ChannelBuffer buffer)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> readable = buffer.readableBytes();</span><br><span class="line">        <span class="comment">// 创建消息头字节数组</span></span><br><span class="line">        <span class="keyword">byte</span>[] header = <span class="keyword">new</span> <span class="keyword">byte</span>[Math.min(readable, HEADER_LENGTH)];</span><br><span class="line">        <span class="comment">// 读取消息头数据</span></span><br><span class="line">        buffer.readBytes(header);</span><br><span class="line">        <span class="comment">// 调用重载方法进行后续解码工作</span></span><br><span class="line">        <span class="keyword">return</span> decode(channel, buffer, readable, header);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">decode</span><span class="params">(Channel channel, ChannelBuffer buffer, <span class="keyword">int</span> readable, <span class="keyword">byte</span>[] header)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 检查魔数是否相等</span></span><br><span class="line">        <span class="keyword">if</span> (readable &gt; <span class="number">0</span> &amp;&amp; header[<span class="number">0</span>] != MAGIC_HIGH</span><br><span class="line">                || readable &gt; <span class="number">1</span> &amp;&amp; header[<span class="number">1</span>] != MAGIC_LOW) &#123;</span><br><span class="line">            <span class="keyword">int</span> length = header.length;</span><br><span class="line">            <span class="keyword">if</span> (header.length &lt; readable) &#123;</span><br><span class="line">                header = Bytes.copyOf(header, readable);</span><br><span class="line">                buffer.readBytes(header, length, readable - length);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; header.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (header[i] == MAGIC_HIGH &amp;&amp; header[i + <span class="number">1</span>] == MAGIC_LOW) &#123;</span><br><span class="line">                    buffer.readerIndex(buffer.readerIndex() - header.length + i);</span><br><span class="line">                    header = Bytes.copyOf(header, i);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 通过 telnet 命令行发送的数据包不包含消息头，所以这里</span></span><br><span class="line">            <span class="comment">// 调用 TelnetCodec 的 decode 方法对数据包进行解码</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.decode(channel, buffer, readable, header);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 检测可读数据量是否少于消息头长度，若小于则立即返回 DecodeResult.NEED_MORE_INPUT</span></span><br><span class="line">        <span class="keyword">if</span> (readable &lt; HEADER_LENGTH) &#123;</span><br><span class="line">            <span class="keyword">return</span> DecodeResult.NEED_MORE_INPUT;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从消息头中获取消息体长度</span></span><br><span class="line">        <span class="keyword">int</span> len = Bytes.bytes2int(header, <span class="number">12</span>);</span><br><span class="line">        <span class="comment">// 检测消息体长度是否超出限制，超出则抛出异常</span></span><br><span class="line">        checkPayload(channel, len);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> tt = len + HEADER_LENGTH;</span><br><span class="line">        <span class="comment">// 检测可读的字节数是否小于实际的字节数</span></span><br><span class="line">        <span class="keyword">if</span> (readable &lt; tt) &#123;</span><br><span class="line">            <span class="keyword">return</span> DecodeResult.NEED_MORE_INPUT;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ChannelBufferInputStream is = <span class="keyword">new</span> ChannelBufferInputStream(buffer, len);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 继续进行解码工作</span></span><br><span class="line">            <span class="keyword">return</span> decodeBody(channel, is, header);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (is.available() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    StreamUtils.skipUnusedStream(is);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    logger.warn(e.getMessage(), e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面方法通过检测消息头中的魔数是否与规定的魔数相等，提前拦截掉非常规数据包，比如通过 telnet  命令行发出的数据包。接着再对消息体长度，以及可读字节数进行检测。最后调用 decodeBody  方法进行后续的解码工作，ExchangeCodec 中实现了 decodeBody 方法，但因其子类 DubboCodec  覆写了该方法，所以在运行时 DubboCodec 中的 decodeBody 方法会被调用。下面我们来看一下该方法的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboCodec</span> <span class="keyword">extends</span> <span class="title">ExchangeCodec</span> <span class="keyword">implements</span> <span class="title">Codec2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">decodeBody</span><span class="params">(Channel channel, InputStream is, <span class="keyword">byte</span>[] header)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 获取消息头中的第三个字节，并通过逻辑与运算得到序列化器编号</span></span><br><span class="line">        <span class="keyword">byte</span> flag = header[<span class="number">2</span>], proto = (<span class="keyword">byte</span>) (flag &amp; SERIALIZATION_MASK);</span><br><span class="line">        Serialization s = CodecSupport.getSerialization(channel.getUrl(), proto);</span><br><span class="line">        <span class="comment">// 获取调用编号</span></span><br><span class="line">        <span class="keyword">long</span> id = Bytes.bytes2long(header, <span class="number">4</span>);</span><br><span class="line">        <span class="comment">// 通过逻辑与运算得到调用类型，0 - Response，1 - Request</span></span><br><span class="line">        <span class="keyword">if</span> ((flag &amp; FLAG_REQUEST) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 对响应结果进行解码，得到 Response 对象。这个非本节内容，后面再分析</span></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 创建 Request 对象</span></span><br><span class="line">            Request req = <span class="keyword">new</span> Request(id);</span><br><span class="line">            req.setVersion(Version.getProtocolVersion());</span><br><span class="line">            <span class="comment">// 通过逻辑与运算得到通信方式，并设置到 Request 对象中</span></span><br><span class="line">            req.setTwoWay((flag &amp; FLAG_TWOWAY) != <span class="number">0</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 通过位运算检测数据包是否为事件类型</span></span><br><span class="line">            <span class="keyword">if</span> ((flag &amp; FLAG_EVENT) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 设置心跳事件到 Request 对象中</span></span><br><span class="line">                req.setEvent(Request.HEARTBEAT_EVENT);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Object data;</span><br><span class="line">                <span class="keyword">if</span> (req.isHeartbeat()) &#123;</span><br><span class="line">                    <span class="comment">// 对心跳包进行解码，该方法已被标注为废弃</span></span><br><span class="line">                    data = decodeHeartbeatData(channel, deserialize(s, channel.getUrl(), is));</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (req.isEvent()) &#123;</span><br><span class="line">                    <span class="comment">// 对事件数据进行解码</span></span><br><span class="line">                    data = decodeEventData(channel, deserialize(s, channel.getUrl(), is));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    DecodeableRpcInvocation inv;</span><br><span class="line">                    <span class="comment">// 根据 url 参数判断是否在 IO 线程上对消息体进行解码</span></span><br><span class="line">                    <span class="keyword">if</span> (channel.getUrl().getParameter(</span><br><span class="line">                            Constants.DECODE_IN_IO_THREAD_KEY,</span><br><span class="line">                            Constants.DEFAULT_DECODE_IN_IO_THREAD)) &#123;</span><br><span class="line">                        inv = <span class="keyword">new</span> DecodeableRpcInvocation(channel, req, is, proto);</span><br><span class="line">                        <span class="comment">// 在当前线程，也就是 IO 线程上进行后续的解码工作。此工作完成后，可将</span></span><br><span class="line">                        <span class="comment">// 调用方法名、attachment、以及调用参数解析出来</span></span><br><span class="line">                        inv.decode();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 仅创建 DecodeableRpcInvocation 对象，但不在当前线程上执行解码逻辑</span></span><br><span class="line">                        inv = <span class="keyword">new</span> DecodeableRpcInvocation(channel, req,</span><br><span class="line">                                <span class="keyword">new</span> UnsafeByteArrayInputStream(readMessageData(is)), proto);</span><br><span class="line">                    &#125;</span><br><span class="line">                    data = inv;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 设置 data 到 Request 对象中</span></span><br><span class="line">                req.setData(data);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                <span class="comment">// 若解码过程中出现异常，则将 broken 字段设为 true，</span></span><br><span class="line">                <span class="comment">// 并将异常对象设置到 Reqeust 对象中</span></span><br><span class="line">                req.setBroken(<span class="keyword">true</span>);</span><br><span class="line">                req.setData(t);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> req;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，decodeBody 对部分字段进行了解码，并将解码得到的字段封装到 Request 中。随后会调用  DecodeableRpcInvocation 的 decode  方法进行后续的解码工作。此工作完成后，可将调用方法名、attachment、以及调用参数解析出来。下面我们来看一下  DecodeableRpcInvocation 的 decode 方法逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DecodeableRpcInvocation</span> <span class="keyword">extends</span> <span class="title">RpcInvocation</span> <span class="keyword">implements</span> <span class="title">Codec</span>, <span class="title">Decodeable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">decode</span><span class="params">(Channel channel, InputStream input)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ObjectInput in = CodecSupport.getSerialization(channel.getUrl(), serializationType)</span><br><span class="line">                .deserialize(channel.getUrl(), input);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过反序列化得到 dubbo version，并保存到 attachments 变量中</span></span><br><span class="line">        String dubboVersion = in.readUTF();</span><br><span class="line">        request.setVersion(dubboVersion);</span><br><span class="line">        setAttachment(Constants.DUBBO_VERSION_KEY, dubboVersion);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过反序列化得到 path，version，并保存到 attachments 变量中</span></span><br><span class="line">        setAttachment(Constants.PATH_KEY, in.readUTF());</span><br><span class="line">        setAttachment(Constants.VERSION_KEY, in.readUTF());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过反序列化得到调用方法名</span></span><br><span class="line">        setMethodName(in.readUTF());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object[] args;</span><br><span class="line">            Class&lt;?&gt;[] pts;</span><br><span class="line">            <span class="comment">// 通过反序列化得到参数类型字符串，比如 Ljava/lang/String;</span></span><br><span class="line">            String desc = in.readUTF();</span><br><span class="line">            <span class="keyword">if</span> (desc.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                pts = DubboCodec.EMPTY_CLASS_ARRAY;</span><br><span class="line">                args = DubboCodec.EMPTY_OBJECT_ARRAY;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 将 desc 解析为参数类型数组</span></span><br><span class="line">                pts = ReflectUtils.desc2classArray(desc);</span><br><span class="line">                args = <span class="keyword">new</span> Object[pts.length];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 解析运行时参数</span></span><br><span class="line">                        args[i] = in.readObject(pts[i]);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (log.isWarnEnabled()) &#123;</span><br><span class="line">                            log.warn(<span class="string">"Decode argument failed: "</span> + e.getMessage(), e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 设置参数类型数组</span></span><br><span class="line">            setParameterTypes(pts);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 通过反序列化得到原 attachment 的内容</span></span><br><span class="line">            Map&lt;String, String&gt; map = (Map&lt;String, String&gt;) in.readObject(Map.class);</span><br><span class="line">            <span class="keyword">if</span> (map != <span class="keyword">null</span> &amp;&amp; map.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                Map&lt;String, String&gt; attachment = getAttachments();</span><br><span class="line">                <span class="keyword">if</span> (attachment == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    attachment = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 将 map 与当前对象中的 attachment 集合进行融合</span></span><br><span class="line">                attachment.putAll(map);</span><br><span class="line">                setAttachments(attachment);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 对 callback 类型的参数进行处理</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">                args[i] = decodeInvocationArgument(channel, <span class="keyword">this</span>, pts, i, args[i]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置参数列表</span></span><br><span class="line">            setArguments(args);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(StringUtils.toString(<span class="string">"Read invocation data failed."</span>, e));</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (in <span class="keyword">instanceof</span> Cleanable) &#123;</span><br><span class="line">                ((Cleanable) in).cleanup();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的方法通过反序列化将诸如 path、version、调用方法名、参数列表等信息依次解析出来，并设置到相应的字段中，最终得到一个具有完整调用信息的 DecodeableRpcInvocation 对象。</p><p>到这里，请求数据解码的过程就分析完了。</p><h3><span id="调用服务">调用服务</span></h3><p>解码器将数据包解析成 Request 对象后，NettyHandler 的 messageReceived  方法紧接着会收到这个对象，并将这个对象继续向下传递。这期间该对象会被依次传递给  NettyServer、MultiMessageHandler、HeartbeatHandler 以及  AllChannelHandler。最后由 AllChannelHandler 将该对象封装到 Runnable 实现类对象中，并将  Runnable 放入线程池中执行后续的调用逻辑。整个调用栈如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NettyHandler#messageReceived(ChannelHandlerContext, MessageEvent)</span><br><span class="line">  —&gt; AbstractPeer#received(Channel, Object)</span><br><span class="line">    —&gt; MultiMessageHandler#received(Channel, Object)</span><br><span class="line">      —&gt; HeartbeatHandler#received(Channel, Object)</span><br><span class="line">        —&gt; AllChannelHandler#received(Channel, Object)</span><br><span class="line">          —&gt; ExecutorService#execute(Runnable)    // 由线程池执行后续的调用逻辑</span><br></pre></td></tr></table></figure><h3><span id="线程派发模型">线程派发模型</span></h3><p>Dubbo将底层通信框架中接收请求的线程称为IO线程。如果一些事件处理逻辑可以很快执行完，比如只再内存打一个标记，此时直接在IO线程上执行该段逻辑即可。但如果事件的处理逻辑比较耗时，比如该段逻辑发起数据库查询或者HTTP请求。此时我就不应该让事件处理逻辑在IO线程上执行，而是应该派发到线程池中执行。原因也很简单，IO线程主要用于接收请求，如果IO线程被占满，将导致它请求接收新的请求。</p><p>在前文提到的原理图中，<code>Dispatcher</code>就是线程派发器。它的真实职责是创建具有线程派发能力的<code>Channelhandler</code>,比如<code>AllChannelHandler</code>,<code>MessageOnlyChannelHandler</code>和<code>ExecutionChannelHandler</code>等，其本身并不具有线程派发能力。</p><p><strong>Dubbo支持的不同线程派发策略</strong></p><table><thead><tr><th>策略</th><th>用途</th></tr></thead><tbody><tr><td>all（默认）</td><td>所有消息都派发到线程池，包括请求，响应，连接事件，断开事件等。</td></tr><tr><td>direct</td><td>所有消息都不派发的线程池，全部在IO线程上直接执行。</td></tr><tr><td>message</td><td>只是请求和响应消息派发到线程池，其它消息均在IO线程上执行</td></tr><tr><td>execution</td><td>只有请求派发到线程池，不含响应。其它消息均在IO线程上执行。</td></tr><tr><td>connection</td><td>在IO线程上，将连接断开事件放入队列，有序逐个执行，其它消息派发到线程池。</td></tr></tbody></table><p>在默认配置下，Dubbo使用<code>all</code>派发策略，即将所有的消息都派发到线程池中。下面我们来分析一下<code>AllChannelHandler</code>的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AllChannelHandler</span> <span class="keyword">extends</span> <span class="title">WrappedChannelHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AllChannelHandler</span><span class="params">(ChannelHandler handler, URL url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(handler, url);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 处理连接事件 */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connected</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="comment">// 获取线程池</span></span><br><span class="line">        ExecutorService cexecutor = getExecutorService();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 将连接事件派发到线程池中处理</span></span><br><span class="line">            cexecutor.execute(<span class="keyword">new</span> ChannelEventRunnable(channel, handler, ChannelState.CONNECTED));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ExecutionException(..., <span class="string">" error when process connected event ."</span>, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 处理断开事件 */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">disconnected</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        ExecutorService cexecutor = getExecutorService();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            cexecutor.execute(<span class="keyword">new</span> ChannelEventRunnable(channel, handler, ChannelState.DISCONNECTED));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ExecutionException(..., <span class="string">"error when process disconnected event ."</span>, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 处理请求和响应消息，这里的 message 变量类型可能是 Request，也可能是 Response */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">received</span><span class="params">(Channel channel, Object message)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        ExecutorService cexecutor = getExecutorService();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 将请求和响应消息派发到线程池中处理</span></span><br><span class="line">            cexecutor.execute(<span class="keyword">new</span> ChannelEventRunnable(channel, handler, ChannelState.RECEIVED, message));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="keyword">if</span>(message <span class="keyword">instanceof</span> Request &amp;&amp; t <span class="keyword">instanceof</span> RejectedExecutionException)&#123;</span><br><span class="line">                Request request = (Request)message;</span><br><span class="line">                <span class="comment">// 如果通信方式为双向通信，此时将 Server side ... threadpool is exhausted </span></span><br><span class="line">                <span class="comment">// 错误信息封装到 Response 中，并返回给服务消费方。</span></span><br><span class="line">                <span class="keyword">if</span>(request.isTwoWay())&#123;</span><br><span class="line">                    String msg = <span class="string">"Server side("</span> + url.getIp() + <span class="string">","</span> + url.getPort() </span><br><span class="line">                        + <span class="string">") threadpool is exhausted ,detail msg:"</span> + t.getMessage();</span><br><span class="line">                    Response response = <span class="keyword">new</span> Response(request.getId(), request.getVersion());</span><br><span class="line">                    response.setStatus(Response.SERVER_THREADPOOL_EXHAUSTED_ERROR);</span><br><span class="line">                    response.setErrorMessage(msg);</span><br><span class="line">                    <span class="comment">// 返回包含错误信息的 Response 对象</span></span><br><span class="line">                    channel.send(response);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ExecutionException(..., <span class="string">" error when process received event ."</span>, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 处理异常信息 */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">caught</span><span class="params">(Channel channel, Throwable exception)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        ExecutorService cexecutor = getExecutorService();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            cexecutor.execute(<span class="keyword">new</span> ChannelEventRunnable(channel, handler, ChannelState.CAUGHT, exception));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ExecutionException(..., <span class="string">"error when process caught event ..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请求对象会被封装 ChannelEventRunnable 中，ChannelEventRunnable 将会是服务调用过程的新起点。所以接下来我们以 ChannelEventRunnable 为起点向下探索。</p><h3><span id="调用服务">调用服务</span></h3><p>我们从<code>ChannelEventRunnable</code>开始分析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChannelEventRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ChannelHandler handler;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Channel channel;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ChannelState state;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Throwable exception;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object message;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 检测通道状态，对于请求或响应消息，此时 state = RECEIVED</span></span><br><span class="line">        <span class="keyword">if</span> (state == ChannelState.RECEIVED) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 将 channel 和 message 传给 ChannelHandler 对象，进行后续的调用</span></span><br><span class="line">                handler.received(channel, message);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                logger.warn(<span class="string">"... operation error, channel is ... message is ..."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 其他消息类型通过 switch 进行处理</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">switch</span> (state) &#123;</span><br><span class="line">            <span class="keyword">case</span> CONNECTED:</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    handler.connected(channel);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    logger.warn(<span class="string">"... operation error, channel is ..."</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> DISCONNECTED:</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">case</span> SENT:</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">case</span> CAUGHT:</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                logger.warn(<span class="string">"unknown state: "</span> + state + <span class="string">", message is "</span> + message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ChannelEventRunnable</code>仅仅是一个中转站，它的run方法中并不包含具体的调用逻辑，仅用于将参数传给其它的<code>ChannelHandler</code>对象进行处理，该对象类型为<code>DecodeHandler</code>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DecodeHandler</span> <span class="keyword">extends</span> <span class="title">AbstractChannelHandlerDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DecodeHandler</span><span class="params">(ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">received</span><span class="params">(Channel channel, Object message)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (message <span class="keyword">instanceof</span> Decodeable) &#123;</span><br><span class="line">            <span class="comment">// 对 Decodeable 接口实现类对象进行解码</span></span><br><span class="line">            decode(message);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (message <span class="keyword">instanceof</span> Request) &#123;</span><br><span class="line">            <span class="comment">// 对 Request 的 data 字段进行解码</span></span><br><span class="line">            decode(((Request) message).getData());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (message <span class="keyword">instanceof</span> Response) &#123;</span><br><span class="line">            <span class="comment">// 对 Request 的 result 字段进行解码</span></span><br><span class="line">            decode(((Response) message).getResult());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行后续逻辑</span></span><br><span class="line">        handler.received(channel, message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(Object message)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Decodeable 接口目前有两个实现类，</span></span><br><span class="line">        <span class="comment">// 分别为 DecodeableRpcInvocation 和 DecodeableRpcResult</span></span><br><span class="line">        <span class="keyword">if</span> (message != <span class="keyword">null</span> &amp;&amp; message <span class="keyword">instanceof</span> Decodeable) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 执行解码逻辑</span></span><br><span class="line">                ((Decodeable) message).decode();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                <span class="keyword">if</span> (log.isWarnEnabled()) &#123;</span><br><span class="line">                    log.warn(<span class="string">"Call Decodeable.decode failed: "</span> + e.getMessage(), e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>DecodeHandler</code>主要是包含了一些解码逻辑。之前提到请求解码可以在IO线程上执行，也可以在线程池中执行，这取决于运行时配置。<code>DecodeHandler</code>存在意义就是保证请求或响应对象可在线程池中被解码。解码完毕后，完全解码后的<code>Request</code>对象会继续先后传递，下一站是<code>HeaderExchangeHandler</code>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeaderExchangeHandler</span> <span class="keyword">implements</span> <span class="title">ChannelHandlerDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExchangeHandler handler;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeaderExchangeHandler</span><span class="params">(ExchangeHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"handler == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.handler = handler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">received</span><span class="params">(Channel channel, Object message)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        channel.setAttribute(KEY_READ_TIMESTAMP, System.currentTimeMillis());</span><br><span class="line">        ExchangeChannel exchangeChannel = HeaderExchangeChannel.getOrAddChannel(channel);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 处理请求对象</span></span><br><span class="line">            <span class="keyword">if</span> (message <span class="keyword">instanceof</span> Request) &#123;</span><br><span class="line">                Request request = (Request) message;</span><br><span class="line">                <span class="keyword">if</span> (request.isEvent()) &#123;</span><br><span class="line">                    <span class="comment">// 处理事件</span></span><br><span class="line">                    handlerEvent(channel, request);</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="comment">// 处理普通的请求</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 双向通信</span></span><br><span class="line">                    <span class="keyword">if</span> (request.isTwoWay()) &#123;</span><br><span class="line">                        <span class="comment">// 向后调用服务，并得到调用结果</span></span><br><span class="line">                        Response response = handleRequest(exchangeChannel, request);</span><br><span class="line">                        <span class="comment">// 将调用结果返回给服务消费端</span></span><br><span class="line">                        channel.send(response);</span><br><span class="line">                    &#125; </span><br><span class="line">                    <span class="comment">// 如果是单向通信，仅向后调用指定服务即可，无需返回调用结果</span></span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        handler.received(exchangeChannel, request.getData());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;      </span><br><span class="line">            <span class="comment">// 处理响应对象，服务消费方会执行此处逻辑，后面分析</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (message <span class="keyword">instanceof</span> Response) &#123;</span><br><span class="line">                handleResponse(channel, (Response) message);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (message <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">                <span class="comment">// telnet 相关，忽略</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                handler.received(exchangeChannel, message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            HeaderExchangeChannel.removeChannelIfDisconnected(channel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Response <span class="title">handleRequest</span><span class="params">(ExchangeChannel channel, Request req)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        Response res = <span class="keyword">new</span> Response(req.getId(), req.getVersion());</span><br><span class="line">        <span class="comment">// 检测请求是否合法，不合法则返回状态码为 BAD_REQUEST 的响应</span></span><br><span class="line">        <span class="keyword">if</span> (req.isBroken()) &#123;</span><br><span class="line">            Object data = req.getData();</span><br><span class="line"></span><br><span class="line">            String msg;</span><br><span class="line">            <span class="keyword">if</span> (data == <span class="keyword">null</span>)</span><br><span class="line">                msg = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span></span><br><span class="line">                (data <span class="keyword">instanceof</span> Throwable) msg = StringUtils.toString((Throwable) data);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                msg = data.toString();</span><br><span class="line">            res.setErrorMessage(<span class="string">"Fail to decode request due to: "</span> + msg);</span><br><span class="line">            <span class="comment">// 设置 BAD_REQUEST 状态</span></span><br><span class="line">            res.setStatus(Response.BAD_REQUEST);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取 data 字段值，也就是 RpcInvocation 对象</span></span><br><span class="line">        Object msg = req.getData();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 继续向下调用</span></span><br><span class="line">            Object result = handler.reply(channel, msg);</span><br><span class="line">            <span class="comment">// 设置 OK 状态码</span></span><br><span class="line">            res.setStatus(Response.OK);</span><br><span class="line">            <span class="comment">// 设置调用结果</span></span><br><span class="line">            res.setResult(result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="comment">// 若调用过程出现异常，则设置 SERVICE_ERROR，表示服务端异常</span></span><br><span class="line">            res.setStatus(Response.SERVICE_ERROR);</span><br><span class="line">            res.setErrorMessage(StringUtils.toString(e));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，我们看到了比较清晰的请求和响应逻辑。对于双向通信，HeaderExchangeHandler  首先向后进行调用，得到调用结果。然后将调用结果封装到 Response  对象中，最后再将该对象返回给服务消费方。如果请求不合法，或者调用失败，则将错误信息封装到 Response  对象中，并返回给服务消费方。接下来我们继续向后分析，把剩余的调用过程分析完。下面分析定义在 DubboProtocol  类中的匿名类对象逻辑，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboProtocol</span> <span class="keyword">extends</span> <span class="title">AbstractProtocol</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NAME = <span class="string">"dubbo"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> ExchangeHandler requestHandler = <span class="keyword">new</span> ExchangeHandlerAdapter() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">reply</span><span class="params">(ExchangeChannel channel, Object message)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (message <span class="keyword">instanceof</span> Invocation) &#123;</span><br><span class="line">                Invocation inv = (Invocation) message;</span><br><span class="line">                <span class="comment">// 获取 Invoker 实例</span></span><br><span class="line">                Invoker&lt;?&gt; invoker = getInvoker(channel, inv);</span><br><span class="line">                <span class="keyword">if</span> (Boolean.TRUE.toString().equals(inv.getAttachments().get(IS_CALLBACK_SERVICE_INVOKE))) &#123;</span><br><span class="line">                    <span class="comment">// 回调相关，忽略</span></span><br><span class="line">                &#125;</span><br><span class="line">                RpcContext.getContext().setRemoteAddress(channel.getRemoteAddress());</span><br><span class="line">                <span class="comment">// 通过 Invoker 调用具体的服务</span></span><br><span class="line">                <span class="keyword">return</span> invoker.invoke(inv);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RemotingException(channel, <span class="string">"Unsupported request: ..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 忽略其他方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Invoker&lt;?&gt; getInvoker(Channel channel, Invocation inv) <span class="keyword">throws</span> RemotingException &#123;</span><br><span class="line">        <span class="comment">// 忽略回调和本地存根相关逻辑</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> port = channel.getLocalAddress().getPort();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 计算 service key，格式为 groupName/serviceName:serviceVersion:port。比如：</span></span><br><span class="line">        <span class="comment">//   dubbo/com.alibaba.dubbo.demo.DemoService:1.0.0:20880</span></span><br><span class="line">        String serviceKey = serviceKey(port, path, inv.getAttachments().get(Constants.VERSION_KEY), inv.getAttachments().get(Constants.GROUP_KEY));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从 exporterMap 查找与 serviceKey 相对应的 DubboExporter 对象，</span></span><br><span class="line">        <span class="comment">// 服务导出过程中会将 &lt;serviceKey, DubboExporter&gt; 映射关系存储到 exporterMap 集合中</span></span><br><span class="line">        DubboExporter&lt;?&gt; exporter = (DubboExporter&lt;?&gt;) exporterMap.get(serviceKey);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (exporter == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RemotingException(channel, <span class="string">"Not found exported service ..."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 Invoker 对象，并返回</span></span><br><span class="line">        <span class="keyword">return</span> exporter.getInvoker();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 忽略其他方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上逻辑用于获取与指定服务对应的 Invoker 实例，并通过 Invoker 的 invoke 方法调用服务逻辑。invoke 方法定义在 AbstractProxyInvoker 中，代码如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractProxyInvoker</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Invoker</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 调用 doInvoke 执行后续的调用，并将调用结果封装到 RpcResult 中，并</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> RpcResult(doInvoke(proxy, invocation.getMethodName(), invocation.getParameterTypes(), invocation.getArguments()));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> RpcResult(e.getTargetException());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Failed to invoke remote proxy method ..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Object <span class="title">doInvoke</span><span class="params">(T proxy, String methodName, Class&lt;?&gt;[] parameterTypes, Object[] arguments)</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，doInvoke 是一个抽象方法，这个需要由具体的 Invoker 实例实现。Invoker 实例是在运行时通过 JavassistProxyFactory 创建的，创建逻辑如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavassistProxyFactory</span> <span class="keyword">extends</span> <span class="title">AbstractProxyFactory</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略其他方法</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">getInvoker</span><span class="params">(T proxy, Class&lt;T&gt; type, URL url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Wrapper wrapper = Wrapper.getWrapper(proxy.getClass().getName().indexOf(<span class="string">'$'</span>) &lt; <span class="number">0</span> ? proxy.getClass() : type);</span><br><span class="line">        <span class="comment">// 创建匿名类对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AbstractProxyInvoker&lt;T&gt;(proxy, type, url) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> Object <span class="title">doInvoke</span><span class="params">(T proxy, String methodName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      Class&lt;?&gt;[] parameterTypes,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      Object[] arguments)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                <span class="comment">// 调用 invokeMethod 方法进行后续的调用</span></span><br><span class="line">                <span class="keyword">return</span> wrapper.invokeMethod(proxy, methodName, parameterTypes, arguments);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Wrapper 是一个抽象类，其中 invokeMethod 是一个抽象方法。Dubbo 会在运行时通过 Javassist 框架为  Wrapper 生成实现类，并实现 invokeMethod 方法，该方法最终会根据调用信息调用具体的服务。以 DemoServiceImpl  为例，Javassist 为其生成的代理类如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/** Wrapper0 是在运行时生成的，大家可使用 Arthas 进行反编译 */</span><br><span class="line">public class Wrapper0 extends Wrapper implements ClassGenerator.DC &#123;</span><br><span class="line">    public static String[] pns;</span><br><span class="line">    public static Map pts;</span><br><span class="line">    public static String[] mns;</span><br><span class="line">    public static String[] dmns;</span><br><span class="line">    public static Class[] mts0;</span><br><span class="line"></span><br><span class="line">    // 省略其他方法</span><br><span class="line"></span><br><span class="line">    public Object invokeMethod(Object object, String string, Class[] arrclass, Object[] arrobject) throws InvocationTargetException &#123;</span><br><span class="line">        DemoService demoService;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 类型转换</span><br><span class="line">            demoService = (DemoService)object;</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Throwable throwable) &#123;</span><br><span class="line">            throw new IllegalArgumentException(throwable);</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 根据方法名调用指定的方法</span><br><span class="line">            if (&quot;sayHello&quot;.equals(string) &amp;&amp; arrclass.length == 1) &#123;</span><br><span class="line">                return demoService.sayHello((String)arrobject[0]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Throwable throwable) &#123;</span><br><span class="line">            throw new InvocationTargetException(throwable);</span><br><span class="line">        &#125;</span><br><span class="line">        throw new NoSuchMethodException(new StringBuffer().append(&quot;Not found method \&quot;&quot;).append(string).append(&quot;\&quot; in class com.alibaba.dubbo.demo.DemoService.&quot;).toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，整个服务调用过程就分析完了。最后把调用过程贴出来，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ChannelEventRunnable#run()</span><br><span class="line">  —&gt; DecodeHandler#received(Channel, Object)</span><br><span class="line">    —&gt; HeaderExchangeHandler#received(Channel, Object)</span><br><span class="line">      —&gt; HeaderExchangeHandler#handleRequest(ExchangeChannel, Request)</span><br><span class="line">        —&gt; DubboProtocol.requestHandler#reply(ExchangeChannel, Object)</span><br><span class="line">          —&gt; Filter#invoke(Invoker, Invocation)</span><br><span class="line">            —&gt; AbstractProxyInvoker#invoke(Invocation)</span><br><span class="line">              —&gt; Wrapper0#invokeMethod(Object, String, Class[], Object[])</span><br><span class="line">                —&gt; DemoServiceImpl#sayHello(String)</span><br></pre></td></tr></table></figure><h3><span id="服务提供方返回调用结果">服务提供方返回调用结果</span></h3><p>服务提供方调用指定服务后，会将调用结果封装到 Response 对象中，并将该对象返回给服务消费方。服务提供方也是通过 NettyChannel 的 send 方法将 Response 对象返回。具体的就不再分析了。</p><h2><span id="服务消费方接收调用结果">服务消费方接收调用结果</span></h2><p>服务消费方在收到响应数据后，首先要做的事情是对响应数据进行解码，得到 Response  对象。然后再将该对象传递给下一个入站处理器，这个入站处理器就是 NettyHandler。接下来 NettyHandler  会将这个对象继续向下传递，最后 AllChannelHandler 的 received  方法会收到这个对象，并将这个对象派发到线程池中。这个过程和服务提供方接收请求的过程是一样的，因此这里就不重复分析了。本节我们重点分析两个方面的内容，一是响应数据的解码过程，二是 Dubbo 如何将调用结果传递给用户线程的。下面先来分析响应数据的解码过程。</p><h3><span id="响应数据解码">响应数据解码</span></h3><p>响应数据解码的逻辑主要封装在<code>DubboCodec</code>中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboCodec</span> <span class="keyword">extends</span> <span class="title">ExchangeCodec</span> <span class="keyword">implements</span> <span class="title">Codec2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">decodeBody</span><span class="params">(Channel channel, InputStream is, <span class="keyword">byte</span>[] header)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span> flag = header[<span class="number">2</span>], proto = (<span class="keyword">byte</span>) (flag &amp; SERIALIZATION_MASK);</span><br><span class="line">        Serialization s = CodecSupport.getSerialization(channel.getUrl(), proto);</span><br><span class="line">        <span class="comment">// 获取请求编号</span></span><br><span class="line">        <span class="keyword">long</span> id = Bytes.bytes2long(header, <span class="number">4</span>);</span><br><span class="line">        <span class="comment">// 检测消息类型，若下面的条件成立，表明消息类型为 Response</span></span><br><span class="line">        <span class="keyword">if</span> ((flag &amp; FLAG_REQUEST) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 创建 Response 对象</span></span><br><span class="line">            Response res = <span class="keyword">new</span> Response(id);</span><br><span class="line">            <span class="comment">// 检测事件标志位</span></span><br><span class="line">            <span class="keyword">if</span> ((flag &amp; FLAG_EVENT) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 设置心跳事件</span></span><br><span class="line">                res.setEvent(Response.HEARTBEAT_EVENT);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 获取响应状态</span></span><br><span class="line">            <span class="keyword">byte</span> status = header[<span class="number">3</span>];</span><br><span class="line">            <span class="comment">// 设置响应状态</span></span><br><span class="line">            res.setStatus(status);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果响应状态为 OK，表明调用过程正常</span></span><br><span class="line">            <span class="keyword">if</span> (status == Response.OK) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Object data;</span><br><span class="line">                    <span class="keyword">if</span> (res.isHeartbeat()) &#123;</span><br><span class="line">                        <span class="comment">// 反序列化心跳数据，已废弃</span></span><br><span class="line">                        data = decodeHeartbeatData(channel, deserialize(s, channel.getUrl(), is));</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (res.isEvent()) &#123;</span><br><span class="line">                        <span class="comment">// 反序列化事件数据</span></span><br><span class="line">                        data = decodeEventData(channel, deserialize(s, channel.getUrl(), is));</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        DecodeableRpcResult result;</span><br><span class="line">                        <span class="comment">// 根据 url 参数决定是否在 IO 线程上执行解码逻辑</span></span><br><span class="line">                        <span class="keyword">if</span> (channel.getUrl().getParameter(</span><br><span class="line">                                Constants.DECODE_IN_IO_THREAD_KEY,</span><br><span class="line">                                Constants.DEFAULT_DECODE_IN_IO_THREAD)) &#123;</span><br><span class="line">                            <span class="comment">// 创建 DecodeableRpcResult 对象</span></span><br><span class="line">                            result = <span class="keyword">new</span> DecodeableRpcResult(channel, res, is,</span><br><span class="line">                                    (Invocation) getRequestData(id), proto);</span><br><span class="line">                            <span class="comment">// 进行后续的解码工作</span></span><br><span class="line">                            result.decode();</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">// 创建 DecodeableRpcResult 对象</span></span><br><span class="line">                            result = <span class="keyword">new</span> DecodeableRpcResult(channel, res,</span><br><span class="line">                                    <span class="keyword">new</span> UnsafeByteArrayInputStream(readMessageData(is)),</span><br><span class="line">                                    (Invocation) getRequestData(id), proto);</span><br><span class="line">                        &#125;</span><br><span class="line">                        data = result;</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 设置 DecodeableRpcResult 对象到 Response 对象中</span></span><br><span class="line">                    res.setResult(data);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    <span class="comment">// 解码过程中出现了错误，此时设置 CLIENT_ERROR 状态码到 Response 对象中</span></span><br><span class="line">                    res.setStatus(Response.CLIENT_ERROR);</span><br><span class="line">                    res.setErrorMessage(StringUtils.toString(t));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">// 响应状态非 OK，表明调用过程出现了异常</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 反序列化异常信息，并设置到 Response 对象中</span></span><br><span class="line">                res.setErrorMessage(deserialize(s, channel.getUrl(), is).readUTF());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 对请求数据进行解码，前面已分析过，此处忽略</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解码之后，通过<code>DecodeableRpcResult</code>进行调用结果的反序列化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DecodeableRpcResult</span> <span class="keyword">extends</span> <span class="title">RpcResult</span> <span class="keyword">implements</span> <span class="title">Codec</span>, <span class="title">Decodeable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Invocation invocation;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasDecoded &amp;&amp; channel != <span class="keyword">null</span> &amp;&amp; inputStream != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 执行反序列化操作</span></span><br><span class="line">                decode(channel, inputStream);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                <span class="comment">// 反序列化失败，设置 CLIENT_ERROR 状态到 Response 对象中</span></span><br><span class="line">                response.setStatus(Response.CLIENT_ERROR);</span><br><span class="line">                <span class="comment">// 设置异常信息</span></span><br><span class="line">                response.setErrorMessage(StringUtils.toString(e));</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                hasDecoded = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">decode</span><span class="params">(Channel channel, InputStream input)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ObjectInput in = CodecSupport.getSerialization(channel.getUrl(), serializationType)</span><br><span class="line">                .deserialize(channel.getUrl(), input);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 反序列化响应类型</span></span><br><span class="line">        <span class="keyword">byte</span> flag = in.readByte();</span><br><span class="line">        <span class="keyword">switch</span> (flag) &#123;</span><br><span class="line">            <span class="keyword">case</span> DubboCodec.RESPONSE_NULL_VALUE:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> DubboCodec.RESPONSE_VALUE:</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> DubboCodec.RESPONSE_WITH_EXCEPTION:</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">                </span><br><span class="line">            <span class="comment">// 返回值为空，且携带了 attachments 集合</span></span><br><span class="line">            <span class="keyword">case</span> DubboCodec.RESPONSE_NULL_VALUE_WITH_ATTACHMENTS:</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 反序列化 attachments 集合，并存储起来 </span></span><br><span class="line">                    setAttachments((Map&lt;String, String&gt;) in.readObject(Map.class));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IOException(StringUtils.toString(<span class="string">"Read response data failed."</span>, e));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">                </span><br><span class="line">            <span class="comment">// 返回值不为空，且携带了 attachments 集合</span></span><br><span class="line">            <span class="keyword">case</span> DubboCodec.RESPONSE_VALUE_WITH_ATTACHMENTS:</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 获取返回值类型</span></span><br><span class="line">                    Type[] returnType = RpcUtils.getReturnTypes(invocation);</span><br><span class="line">                    <span class="comment">// 反序列化调用结果，并保存起来</span></span><br><span class="line">                    setValue(returnType == <span class="keyword">null</span> || returnType.length == <span class="number">0</span> ? in.readObject() :</span><br><span class="line">                            (returnType.length == <span class="number">1</span> ? in.readObject((Class&lt;?&gt;) returnType[<span class="number">0</span>])</span><br><span class="line">                                    : in.readObject((Class&lt;?&gt;) returnType[<span class="number">0</span>], returnType[<span class="number">1</span>])));</span><br><span class="line">                    <span class="comment">// 反序列化 attachments 集合，并存储起来</span></span><br><span class="line">                    setAttachments((Map&lt;String, String&gt;) in.readObject(Map.class));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IOException(StringUtils.toString(<span class="string">"Read response data failed."</span>, e));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">                </span><br><span class="line">            <span class="comment">// 异常对象不为空，且携带了 attachments 集合</span></span><br><span class="line">            <span class="keyword">case</span> DubboCodec.RESPONSE_WITH_EXCEPTION_WITH_ATTACHMENTS:</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 反序列化异常对象</span></span><br><span class="line">                    Object obj = in.readObject();</span><br><span class="line">                    <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Throwable == <span class="keyword">false</span>)</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Response data error, expect Throwable, but get "</span> + obj);</span><br><span class="line">                    <span class="comment">// 设置异常对象</span></span><br><span class="line">                    setException((Throwable) obj);</span><br><span class="line">                    <span class="comment">// 反序列化 attachments 集合，并存储起来</span></span><br><span class="line">                    setAttachments((Map&lt;String, String&gt;) in.readObject(Map.class));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IOException(StringUtils.toString(<span class="string">"Read response data failed."</span>, e));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Unknown result flag, expect '0' '1' '2', get "</span> + flag);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (in <span class="keyword">instanceof</span> Cleanable) &#123;</span><br><span class="line">            ((Cleanable) in).cleanup();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="向用户线程传递调用结果">向用户线程传递调用结果</span></h3><p>响应数据解码完成后，Dubbo  会将响应对象派发到线程池上。要注意的是，线程池中的线程并非用户的调用线程，所以要想办法将响应对象从线程池线程传递到用户线程上。我们之前分析过用户线程在发送完请求后的动作，即调用 DefaultFuture 的 get  方法等待响应对象的到来。当响应对象到来后，用户线程会被唤醒，并通过<strong>调用编号</strong>获取属于自己的响应对象。下面我们来看一下整个过程对应的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeaderExchangeHandler</span> <span class="keyword">implements</span> <span class="title">ChannelHandlerDelegate</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">received</span><span class="params">(Channel channel, Object message)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        channel.setAttribute(KEY_READ_TIMESTAMP, System.currentTimeMillis());</span><br><span class="line">        ExchangeChannel exchangeChannel = HeaderExchangeChannel.getOrAddChannel(channel);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (message <span class="keyword">instanceof</span> Request) &#123;</span><br><span class="line">                <span class="comment">// 处理请求，前面已分析过，省略</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (message <span class="keyword">instanceof</span> Response) &#123;</span><br><span class="line">                <span class="comment">// 处理响应</span></span><br><span class="line">                handleResponse(channel, (Response) message);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (message <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">                <span class="comment">// telnet 相关，忽略</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                handler.received(exchangeChannel, message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            HeaderExchangeChannel.removeChannelIfDisconnected(channel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleResponse</span><span class="params">(Channel channel, Response response)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (response != <span class="keyword">null</span> &amp;&amp; !response.isHeartbeat()) &#123;</span><br><span class="line">            <span class="comment">// 继续向下调用</span></span><br><span class="line">            DefaultFuture.received(channel, response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultFuture</span> <span class="keyword">implements</span> <span class="title">ResponseFuture</span> </span>&#123;  </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition done = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Response response;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">received</span><span class="params">(Channel channel, Response response)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 根据调用编号从 FUTURES 集合中查找指定的 DefaultFuture 对象</span></span><br><span class="line">            DefaultFuture future = FUTURES.remove(response.getId());</span><br><span class="line">            <span class="keyword">if</span> (future != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 继续向下调用</span></span><br><span class="line">                future.doReceived(response);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                logger.warn(<span class="string">"The timeout response finally returned at ..."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            CHANNELS.remove(response.getId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReceived</span><span class="params">(Response res)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 保存响应对象</span></span><br><span class="line">            response = res;</span><br><span class="line">            <span class="keyword">if</span> (done != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 唤醒用户线程</span></span><br><span class="line">                done.signal();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">            invokeCallback(callback);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上逻辑是将响应对象保存到相应的 DefaultFuture 实例中，然后再唤醒用户线程，随后用户线程即可从 DefaultFuture 实例中获取到相应结果。</p><p><strong>为什么要有调用编号？</strong></p><p>一般情况下，服务消费方会并发调用多个服务，每个用户线程发送请求后，会调用不同 DefaultFuture 对象的 get 方法进行等待。  一段时间后，服务消费方的线程池会收到多个响应对象。这个时候要考虑一个问题，如何将每个响应对象传递给相应的 DefaultFuture  对象，且不出错。答案是通过调用编号。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Dubbo服务调用的基本过程如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/05/10/Y33nc8.png&quot; alt=&quot;Y33nc8.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;首先服务消费者通过代理对象Proxy发起远程调用，接着通过网络客户端将编码后的请求发送给服务提供方的网络层上。Server收到请求之后，首先要做的就是对数据包进行解码。然后将解码后的请求发送至分发器，再由分发器将请求发送到指定的线程池上，最后由线程池调用具体的服务。这就是一个远程调用请求的发送过程。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="https://zofun.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Dubbo" scheme="https://zofun.github.io/tags/Dubbo/"/>
    
  </entry>
  
  <entry>
    <title>InnoDB的锁</title>
    <link href="https://zofun.github.io/2020/05/04/InnoDB%E7%9A%84%E9%94%81/"/>
    <id>https://zofun.github.io/2020/05/04/InnoDB的锁/</id>
    <published>2020-05-04T14:20:00.000Z</published>
    <updated>2020-05-04T14:20:28.155Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="什么是锁">什么是锁？</span></h2><p>锁是数据库系统区别于文件系统的一个关键特性，锁机制用于管理对共享资源的并发访问。</p><h2><span id="lock和latch">lock和latch</span></h2><p>latch一般称为闩锁，因为其要求锁定的时间必须非常短，则应用的性能会非常的差。在InnoDB存储引擎中，latch由可以分为matuex（互斥量）和rwlock（读写锁）。其目的是用来保证并发线程操作临界资源的正确性，并且通常没有死锁检查机制。</p><p>lock的对象是事务，用来锁定的是数据库中的对象，如表、页、行。并且一般lock的对象仅在事务commit或rollback后进行释放。此外lock是有死锁检查机制的。</p><a id="more"></a><p><img src="https://s1.ax1x.com/2020/05/04/YCT7f1.png" alt="YCT7f1.png"></p><h2><span id="innodb存储引擎中的锁">InnoDB存储引擎中的锁</span></h2><h3><span id="锁的类型">锁的类型</span></h3><p>InnoDB存储引擎实现了两种标准的行级锁：</p><ul><li>共享锁（S Lock），允许事务读一行数据</li><li>排他锁（X Lock），允许事务删除或更新一行数据</li></ul><p><img src="https://s1.ax1x.com/2020/05/04/YC7NN9.png" alt="YC7NN9.png"></p><p>InnoDB存储引擎支持多粒度锁定，这种锁定允许事务在行级锁和标记锁上的锁定同时存在。为了支持不同粒度上进行加锁操作，InnoDB存储引擎支持一个额外的锁方式，称为意向锁。意向锁是将锁定的对象分为多个层次，意向锁意味着事务希望在更细粒度上进行加锁。</p><p>InnoDB存储引擎支持意向锁设计比较简练，其意向锁即为表级别的锁。设计目的主要是为了在一个事务中揭示下一行将被请求的锁类型。其支持两种意向锁：</p><ol><li>意向共享锁（IS Lock），事务想要获得一张表中某几行的共享锁。</li><li>意向排他锁（IX Lock），事务想要获得一张表中某几行的排他锁。</li></ol><p><img src="https://s1.ax1x.com/2020/05/04/YCXFcn.png" alt="YCXFcn.png"></p><h3><span id="一致性非锁定读">一致性非锁定读</span></h3><p>一致性非锁定读是指InnoDB存储引擎通过多版本控制的方式来读取当前执行时间数据库中行的数据。如果读取的行正在执行DELETE或UPDATE操作，这式读取操作不会因此区等待行上锁的释放。相反的，InnoDB存储引擎会区读取行的一个快照数据。快照数据是只该行的之前版本的数据，该实现是通过indo断来完成，而undo用来在事务中回滚数据，因此快照数据本身是没有额外的开销。此外，读取快照数据是不需要上锁的，因为没有事务需要对历史的数据进行修改操作。这种并发控制，其实就是多版本并发控制MVCC。</p><h3><span id="一致性锁定读">一致性锁定读</span></h3><p>在默认的配置下，事务的隔离级别为可重复读，innoDB存储引擎的select操作使用一致性非锁定读，但是在某些情况下，用户需要显示地对数据库读取操作进行加锁一保证数据逻辑地一致性。而这个时候就需要数据库支持加锁语句。InnoDB存储引擎对于select语句支持两种一致性地锁定读操作。</p><ul><li><p>select … for update(对读取地行加一个X锁)</p></li><li><p>select …lock in share mode（对读取地行加一个S锁）</p></li></ul><h3><span id="自增长与锁">自增长与锁</span></h3><p>在InnoDB存储引擎地内存结构中，对每个含有自镇长只地表都有一个自增长计数器。档含有自增长计数器地表进行插入操作时，这个计数器会被初始化。插入操作会根据这个自增长地计数器加一赋予自增长列。这个实现方式叫 <code>AUTO-INC Locking</code>.这种锁其实是采用一种特殊地表锁机制，为了提高插入地性能，锁不是在一个事务完成后才释放，而是在完成对自增长值插入地SQL语句后立即释放。</p><p>​    </p><h3><span id="外键和锁">外键和锁</span></h3><p>外键的主要用于引用完整性的约束检查，在InnoDB存储引擎中，对于一个外键列，如果没有显示地对这个列加索引，InnoDB存储引擎自动对其加一个索引，因为这样可以避免表锁。</p><p>对于外键值地插入或更新，首先要查询父表中地记录，即select父表，但是对于父表的select操作，不是使用一致性非锁定读的方式，因为这样会发生数据不一致的问题，因此这时使用的时select … lock in share mode方式，即主动对父表加一个s锁。如果这时父表上已经加了x锁，子表上的操作会被阻塞。</p><h2><span id="锁的算法">锁的算法</span></h2><h3><span id="行锁的三种算法">行锁的三种算法</span></h3><p>InnoDB存储引擎有三种行锁的算法，其分别是：</p><ul><li>Record Lock：单个行记录上的锁</li><li>Gap Lock：间隙锁，锁定一个范围，但不包含记录本身</li><li>Next-Key Lock：Gap Lock+record Lock，锁定一个范围，并且锁定记录本身。</li></ul><p>record lock总是会区锁定索引记录，如果innodb存储引擎表在建立的时候没有设置任何一个索引，那么这时InnoDB存储引擎会使用隐式的主键来进行锁定。</p><h3><span id="解决幻读问题">解决幻读问题</span></h3><p>幻读问题是指在同一事务中，连续两次同样的sql语句可能导致不同的结果，第二次的sql语句可能会返回之前不存在的行。InnoDB存储引擎采用Next-Key Locking的算法来避免幻读问题。</p><h2><span id="死锁">死锁</span></h2><h3><span id="死锁的概念">死锁的概念</span></h3><p>死锁是指两个或两个以上的事务在执行过程中，因争夺资源而造成的一种互相等待的现象。</p><h3><span id="解决方案">解决方案</span></h3><p>解决死锁的一种方案是超时，即当两个事务互相等待时，当一个等待时间超过设置的某一阈值时，其中一个事务进行回滚，另一个继续进行。</p><p>这种超时机制虽然简单，但是其仅通过超时后对事务进行回滚的方式来处理，或者说其时根据FIFO的顺序选择回滚对象。当若超时的事务所占的权重较大，如果事务操作更新了很多行，占用了较多的undo log，这时FIFO的方式，就显得不合适了，因为回滚这个事务的时间相对于另一个事务所占用的时间可能会很多。</p><p>因此除了超时机制之外，当前数据库还普遍采用了等待图的方式来进行死锁检测。较之超时的解决方案，这是一种更为主动的死锁检测方式。InnoDB存储引擎也采用这种方式。等待图要求数据库保存以下两种信息。</p><ul><li>锁的信息链表</li><li>事务等待链表</li></ul><p>通过上述信息可以够着出一张图，而在这个图种若存在回路，就代表存在死锁，因此资源间互相发生等待。</p><h2><span id="锁升级">锁升级</span></h2><p>锁升级时至当前锁粒度降低，举例来说，数据库可以把一个表的1000个行锁升级未页锁，或者间页锁升级未表锁。如果在数据库的设计中，认为锁是一种稀有资源，而且想要避免锁的开销，那数据库中会频繁出现锁升级现象。</p><p>InnoDB存储引擎不存在锁升级这个问题，因为其不是根据每个记录来产生行锁的，相反，其根据每个事务访问的每个页对锁进行管理的，采用的是位图的方式，因此不管一个事务锁住页中一个记录还是多个记录，其开销都是一致的。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是锁？&quot;&gt;&lt;a href=&quot;#什么是锁？&quot; class=&quot;headerlink&quot; title=&quot;什么是锁？&quot;&gt;&lt;/a&gt;什么是锁？&lt;/h2&gt;&lt;p&gt;锁是数据库系统区别于文件系统的一个关键特性，锁机制用于管理对共享资源的并发访问。&lt;/p&gt;
&lt;h2 id=&quot;lock和latch&quot;&gt;&lt;a href=&quot;#lock和latch&quot; class=&quot;headerlink&quot; title=&quot;lock和latch&quot;&gt;&lt;/a&gt;lock和latch&lt;/h2&gt;&lt;p&gt;latch一般称为闩锁，因为其要求锁定的时间必须非常短，则应用的性能会非常的差。在InnoDB存储引擎中，latch由可以分为matuex（互斥量）和rwlock（读写锁）。其目的是用来保证并发线程操作临界资源的正确性，并且通常没有死锁检查机制。&lt;/p&gt;
&lt;p&gt;lock的对象是事务，用来锁定的是数据库中的对象，如表、页、行。并且一般lock的对象仅在事务commit或rollback后进行释放。此外lock是有死锁检查机制的。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="https://zofun.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="InnoDB" scheme="https://zofun.github.io/tags/InnoDB/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot启动原理</title>
    <link href="https://zofun.github.io/2020/05/03/SpringBoot%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86/"/>
    <id>https://zofun.github.io/2020/05/03/SpringBoot启动原理/</id>
    <published>2020-05-03T06:25:00.000Z</published>
    <updated>2020-05-03T12:03:38.484Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="springboot启动">SpringBoot启动</span></h2><p>SpringBoot因为内置了tomcat或jetty服务器，不需要直接部署War文件，所以SpringBoot的程序起点是一个普通的主函数。主函数如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringbootStudyApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SpringbootStudyApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个SpringBoot的启动过程其实都是通过<code>@SpringBootApplication</code>注解和<code>SpringApplication.run</code>方法来实现的。</p><p>整个启动的过程可以概括为：</p><ol><li>读取所有依赖的<code>META-INF/spring.factories</code>文件，该文件指明了哪些依赖可以被自动加载。</li><li>根据<code>importSelector</code>类选择加载哪些依赖，使用<code>conditionOn</code>系列注解排除掉不需要的配置文件</li><li>将剩余的配置文件所代表的bean加载到IOC容器中。</li></ol><a id="more"></a><p>比如<code>spring-boot-2.1.8RELEASE.jar</code>中的<code>spring.factories</code>文件的内容是整个样子的(节选)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># PropertySource Loaders</span><br><span class="line">org.springframework.boot.env.PropertySourceLoader=\</span><br><span class="line">org.springframework.boot.env.PropertiesPropertySourceLoader,\</span><br><span class="line">org.springframework.boot.env.YamlPropertySourceLoader</span><br><span class="line"></span><br><span class="line"># Run Listeners</span><br><span class="line">org.springframework.boot.SpringApplicationRunListener=\</span><br><span class="line">org.springframework.boot.context.event.EventPublishingRunListener</span><br><span class="line"></span><br><span class="line"># Error Reporters</span><br><span class="line">org.springframework.boot.SpringBootExceptionReporter=\</span><br><span class="line">org.springframework.boot.diagnostics.FailureAnalyzers</span><br><span class="line"></span><br><span class="line"># Application Context Initializers</span><br><span class="line">org.springframework.context.ApplicationContextInitializer=\</span><br><span class="line">org.springframework.boot.context.ConfigurationWarningsApplicationContextInitializer,\</span><br><span class="line">org.springframework.boot.context.ContextIdApplicationContextInitializer,\</span><br><span class="line">org.springframework.boot.context.config.DelegatingApplicationContextInitializer,\</span><br><span class="line">org.springframework.boot.web.context.ServerPortInfoApplicationContextInitializer</span><br></pre></td></tr></table></figure><p>这个文件中的内容最终会被解析为<code>Map&lt;K,List&lt;V&gt;&gt;</code>这种格式。键和值都是一个类的全限定名。</p><h2><span id="跟踪源码探索原理">跟踪源码，探索原理</span></h2><p>我们从这段代码开始跟踪<code>SpringApplication.run(SpringbootStudyApplication.class, args);</code></p><p>这段代码经过重重调用最终来到了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(Class&lt;?&gt;[] primarySources, String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> SpringApplication(primarySources).run(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法完成了<code>SpringApplication</code>的实例化。具体的实例化过程如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SpringApplication</span><span class="params">(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">Assert.notNull(primarySources, <span class="string">"PrimarySources must not be null"</span>);</span><br><span class="line"><span class="keyword">this</span>.primarySources = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(Arrays.asList(primarySources));</span><br><span class="line"><span class="keyword">this</span>.webApplicationType = WebApplicationType.deduceFromClasspath();</span><br><span class="line">           <span class="comment">//将初始化器放到数组中</span></span><br><span class="line">setInitializers((Collection) </span><br><span class="line">                       getSpringFactoriesInstances(ApplicationContextInitializer.class));</span><br><span class="line">       <span class="comment">//把初始化的监听器加入到数组中</span></span><br><span class="line">setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));</span><br><span class="line">       <span class="comment">//获得主类</span></span><br><span class="line"><span class="keyword">this</span>.mainApplicationClass = deduceMainApplicationClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个<code>Application</code>的实例化过程中，下面这两行代码比较关键。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));</span><br><span class="line">setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));</span><br></pre></td></tr></table></figure><p>方法的具体实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">Collection&lt;T&gt; <span class="title">getSpringFactoriesInstances</span><span class="params">(Class&lt;T&gt; type, Class&lt;?&gt;[] parameterTypes, Object... args)</span> </span>&#123;</span><br><span class="line">ClassLoader classLoader = getClassLoader();</span><br><span class="line"><span class="comment">// Use names and ensure unique to protect against duplicates</span></span><br><span class="line">       <span class="comment">//获取FactoryClass的全限定名</span></span><br><span class="line">Set&lt;String&gt; names = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(SpringFactoriesLoader.loadFactoryNames(type, classLoader));</span><br><span class="line">       <span class="comment">//直接利用反射实例化对象</span></span><br><span class="line">List&lt;T&gt; instances = createSpringFactoriesInstances(type, parameterTypes, classLoader, args, names);</span><br><span class="line">AnnotationAwareOrderComparator.sort(instances);</span><br><span class="line"><span class="keyword">return</span> instances;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>loadFactoryNames</code>方法，其实就是从我们之前提到的<code></code>spring.factories<code>读取数据，然后以</code>Map<code>的形式进行存储的，</code>loadFactoryNames<code>就是从这个</code>Map`中取数据（类的全限定名）。</p><p>读取<code>spring.factories</code>的具体实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(<span class="meta">@Nullable</span> ClassLoader classLoader) &#123;</span><br><span class="line">    MultiValueMap&lt;String, String&gt; result = cache.get(classLoader);</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">try</span> &#123;</span><br><span class="line">        Enumeration&lt;URL&gt; urls = (classLoader != <span class="keyword">null</span> ?</span><br><span class="line">            <span class="comment">// FACTORIES_RESOURCE_LOCATION = "META-INF/spring.factories"    classLoader.getResources(FACTORIES_RESOURCE_LOCATION) :</span></span><br><span class="line">                ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));</span><br><span class="line">        result = <span class="keyword">new</span> LinkedMultiValueMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (urls.hasMoreElements()) &#123;</span><br><span class="line">            URL url = urls.nextElement();</span><br><span class="line">            UrlResource resource = <span class="keyword">new</span> UrlResource(url);</span><br><span class="line">            Properties properties = PropertiesLoaderUtils.loadProperties(resource);</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) &#123;</span><br><span class="line">                String factoryClassName = ((String) entry.getKey()).trim();</span><br><span class="line">                    <span class="keyword">for</span> (String factoryName : StringUtils.commaDelimitedListToStringArray((String) entry.getValue())) &#123;</span><br><span class="line">                    result.add(factoryClassName, factoryName.trim());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cache.put(classLoader, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unable to load factories from location ["</span> +</span><br><span class="line">                FACTORIES_RESOURCE_LOCATION + <span class="string">"]"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="comment">// like:</span></span><br><span class="line">    <span class="comment">// org.springframework.boot.autoconfigure.EnableAutoConfiguration -&gt; &#123;LinkedList@1446&#125; size = 118</span></span><br><span class="line">    <span class="comment">//   |</span></span><br><span class="line">    <span class="comment">//   |- org.springframework.boot.autoconfigure.EnableAutoConfiguration</span></span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拿到需要加载的类的全限定名之后，就通过反射进行实例化，然后返回。在<code>Application</code>的构造器中，拿到这些对象后，存入到List中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">private List&lt;ApplicationContextInitializer&lt;?&gt;&gt; initializers;</span><br><span class="line">private List&lt;ApplicationListener&lt;?&gt;&gt; listeners;</span><br></pre></td></tr></table></figure><p>到这个地方，我们已经拿到了所有的依赖类，那么SpringBoot是如何进行自动配置的呢？</p><p>其实前面我们看到的源码都是<code>SpingApplication</code>的实例化，整个实例化过程就完成了依赖类信息，而<code>run</code>方法其实就是完成装配的。具体的看下面的分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">StopWatch stopWatch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">stopWatch.start();</span><br><span class="line">ConfigurableApplicationContext context = <span class="keyword">null</span>;</span><br><span class="line">Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">configureHeadlessProperty();</span><br><span class="line">SpringApplicationRunListeners listeners = getRunListeners(args);</span><br><span class="line">listeners.starting();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">ApplicationArguments applicationArguments = <span class="keyword">new</span> DefaultApplicationArguments(args);</span><br><span class="line">ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments);</span><br><span class="line">configureIgnoreBeanInfo(environment);</span><br><span class="line">Banner printedBanner = printBanner(environment);</span><br><span class="line">context = createApplicationContext();</span><br><span class="line">exceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter.class,</span><br><span class="line"><span class="keyword">new</span> Class[] &#123; ConfigurableApplicationContext.class &#125;, context);</span><br><span class="line">prepareContext(context, environment, listeners, applicationArguments, printedBanner);</span><br><span class="line">           <span class="comment">//关键代码</span></span><br><span class="line">refreshContext(context);</span><br><span class="line">afterRefresh(context, applicationArguments);</span><br><span class="line">stopWatch.stop();</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</span><br><span class="line"><span class="keyword">new</span> StartupInfoLogger(<span class="keyword">this</span>.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);</span><br><span class="line">&#125;</span><br><span class="line">listeners.started(context);</span><br><span class="line">callRunners(context, applicationArguments);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">handleRunFailure(context, ex, exceptionReporters, listeners);</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">listeners.running(context);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">handleRunFailure(context, ex, exceptionReporters, <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>run</code>方法中最关键的就是<code>refreshContext(context);</code>。它实际上是调用了<code>refresh</code>方法，这个方法对应读过Spring源码的同学不会陌生。而我们bean的装配过程实际上就是由它完成的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line"><span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">prepareRefresh();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize message source for this context.</span></span><br><span class="line">initMessageSource();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">onRefresh();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">registerListeners();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">finishRefresh();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">logger.warn(<span class="string">"Exception encountered during context initialization - "</span> +</span><br><span class="line"><span class="string">"cancelling refresh attempt: "</span> + ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">destroyBeans();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reset 'active' flag.</span></span><br><span class="line">cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Propagate exception to caller.</span></span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">// Reset common introspection caches in Spring's core, since we</span></span><br><span class="line"><span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">resetCommonCaches();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>invokeBeanFactoryPostProcessors</code>会解析<code>@import</code>注解，并根据<code>@import</code>的属性进行下一步操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">invokeBeanFactoryPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());</span><br><span class="line"><span class="comment">// 省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeBeanFactoryPostProcessors</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            ConfigurableListableBeanFactory beanFactory, List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Invoke BeanDefinitionRegistryPostProcessors first, if any.</span></span><br><span class="line">    Set&lt;String&gt; processedBeans = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (beanFactory <span class="keyword">instanceof</span> BeanDefinitionRegistry) &#123;</span><br><span class="line">        BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;</span><br><span class="line">        List&lt;BeanFactoryPostProcessor&gt; regularPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;BeanDefinitionRegistryPostProcessor&gt; registryProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录是否是定义类的 Processor 或者普通的 Processor</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span></span><br><span class="line">        <span class="comment">// uninitialized to let the bean factory post-processors apply to them!</span></span><br><span class="line">        <span class="comment">// Separate between BeanDefinitionRegistryPostProcessors that implement</span></span><br><span class="line">        <span class="comment">// PriorityOrdered, Ordered, and the rest.</span></span><br><span class="line">        List&lt;BeanDefinitionRegistryPostProcessor&gt; currentRegistryProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="comment">// 应用 Bean 定义类的后置处理器</span></span><br><span class="line">        invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeBeanDefinitionRegistryPostProcessors</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            Collection&lt;? extends BeanDefinitionRegistryPostProcessor&gt; postProcessors, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (BeanDefinitionRegistryPostProcessor postProcessor : postProcessors) &#123;</span><br><span class="line">        postProcessor.postProcessBeanDefinitionRegistry(registry);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>invokerBeandefintionRegistryPostProcessors</code>函数对每一个定义类的后置处理器分别进行应用，<code>@Configure</code>的解析就在这个函数中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从注册表中的配置类派生更多的bean定义</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">this</span>.registriesPostProcessed.add(registryId);</span><br><span class="line">    <span class="comment">// Build and validate a configuration model based on the registry of Configuration classes.</span></span><br><span class="line">    processConfigBeanDefinitions(registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入最关键的类<code>ConfigurationClassPostProcessor</code>，这个类用户来注册所有的<code>@Configure</code>和<code>@Bean</code>, 它的<code>processConfigbeanDefinitions</code>函数如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processConfigBeanDefinitions</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">    List&lt;BeanDefinitionHolder&gt; configCandidates = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    String[] candidateNames = registry.getBeanDefinitionNames();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录所有候选的未加载的配置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return immediately if no @Configuration classes were found</span></span><br><span class="line">    <span class="keyword">if</span> (configCandidates.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按照 Ordered 对配置进行排序</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载自定义 bean 名命策略</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.environment == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.environment = <span class="keyword">new</span> StandardEnvironment();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Parse each @Configuration class</span></span><br><span class="line">    ConfigurationClassParser parser = <span class="keyword">new</span> ConfigurationClassParser(</span><br><span class="line">            <span class="keyword">this</span>.metadataReaderFactory, <span class="keyword">this</span>.problemReporter, <span class="keyword">this</span>.environment,</span><br><span class="line">            <span class="keyword">this</span>.resourceLoader, <span class="keyword">this</span>.componentScanBeanNameGenerator, registry);</span><br><span class="line"></span><br><span class="line">    Set&lt;BeanDefinitionHolder&gt; candidates = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(configCandidates);</span><br><span class="line">    Set&lt;ConfigurationClass&gt; alreadyParsed = <span class="keyword">new</span> HashSet&lt;&gt;(configCandidates.size());</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 解译候选集</span></span><br><span class="line">        parser.parse(candidates);</span><br><span class="line">        parser.validate();</span><br><span class="line"></span><br><span class="line">        Set&lt;ConfigurationClass&gt; configClasses = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(parser.getConfigurationClasses());</span><br><span class="line">        configClasses.removeAll(alreadyParsed);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Read the model and create bean definitions based on its content</span></span><br><span class="line">        <span class="keyword">this</span>.reader.loadBeanDefinitions(configClasses);</span><br><span class="line">        alreadyParsed.addAll(configClasses);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (!candidates.isEmpty());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes</span></span><br><span class="line">    <span class="keyword">if</span> (sbr != <span class="keyword">null</span> &amp;&amp; !sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) &#123;</span><br><span class="line">        sbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.metadataReaderFactory <span class="keyword">instanceof</span> CachingMetadataReaderFactory) &#123;</span><br><span class="line">        <span class="comment">// Clear cache in externally provided MetadataReaderFactory; this is a no-op</span></span><br><span class="line">        <span class="comment">// for a shared cache since it'll be cleared by the ApplicationContext.</span></span><br><span class="line">        ((CachingMetadataReaderFactory) <span class="keyword">this</span>.metadataReaderFactory).clearCache();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在解释候选集<code>parser.parse(candidates)</code>中，会调用<code>suorceClass=doProcessConfigurationClass(configClass,sourceClass)</code>方法依次解析注解，得到所有的候选集。该方法顺次解析<code>@PropertySource</code>，<code>@componentScan</code>,<code>@Import</code>,<code>@importResource</code>,<code>@Bean</code>父类。</p><p>解析完成之后，会找到所有以 <code>@PropertySource</code>、<code>@ComponentScan</code>、<code>@Import</code>、<code>@ImportResource</code>、<code>@Bean</code> 注解的类及其对象，如果有 <code>DeferredImportSelector</code>，会将其加入到 <code>deferredImportSelectorHandler</code> 中，并调用 <code>this.deferredImportSelectorHandler.process()</code> 对这些 <code>DeferredImportSelector</code> 进行处理。</p><p>实际上，在 spring boot 中，容器初始化的时候，主要就是对 <code>AutoConfigurationImportSelector</code> 进行处理。</p><p>Spring 会将 <code>AutoConfigurationImportSelector</code> 封装成一个 <code>AutoConfigurationGroup</code>，用于处理。最终会调用 <code>AutoConfigurationGroup</code> 的 <code>process</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(AnnotationMetadata annotationMetadata, DeferredImportSelector deferredImportSelector)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 主要通过该函数找到所有需要自动配置的类</span></span><br><span class="line">            AutoConfigurationEntry autoConfigurationEntry = ((AutoConfigurationImportSelector) deferredImportSelector)</span><br><span class="line">                    .getAutoConfigurationEntry(getAutoConfigurationMetadata(), annotationMetadata);</span><br><span class="line">            <span class="keyword">this</span>.autoConfigurationEntries.add(autoConfigurationEntry);</span><br><span class="line">            <span class="keyword">for</span> (String importClassName : autoConfigurationEntry.getConfigurations()) &#123;</span><br><span class="line">                <span class="keyword">this</span>.entries.putIfAbsent(importClassName, annotationMetadata);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">protected</span> AutoConfigurationEntry <span class="title">getAutoConfigurationEntry</span><span class="params">(AutoConfigurationMetadata autoConfigurationMetadata,</span></span></span><br><span class="line"><span class="function"><span class="params">    AnnotationMetadata annotationMetadata)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isEnabled(annotationMetadata)) &#123;</span><br><span class="line">        <span class="keyword">return</span> EMPTY_ENTRY;</span><br><span class="line">    &#125;</span><br><span class="line">    AnnotationAttributes attributes = getAttributes(annotationMetadata);</span><br><span class="line">    List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes);</span><br><span class="line">    configurations = removeDuplicates(configurations);</span><br><span class="line">    Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);</span><br><span class="line">    checkExcludedClasses(configurations, exclusions);</span><br><span class="line">    configurations.removeAll(exclusions);</span><br><span class="line">    configurations = filter(configurations, autoConfigurationMetadata);</span><br><span class="line">    fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AutoConfigurationEntry(configurations, exclusions);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;String&gt; <span class="title">getCandidateConfigurations</span><span class="params">(AnnotationMetadata metadata, AnnotationAttributes attributes)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(),</span><br><span class="line">            getBeanClassLoader());</span><br><span class="line">    <span class="keyword">return</span> configurations;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，我们可以看到 <code>process</code> 最终调用了我们非常熟悉的函数 <code>SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(), getBeanClassLoader());</code>，该方法以 <code>EnableAutoConfiguration</code> 类为键（<code>org.springframework.boot.autoconfigure.EnableAutoConfiguration</code>），取得所有的值。</p><p>在该函数中，还会调用 <code>configurations = filter(configurations, autoConfigurationMetadata)</code> 方法，将不需要的候选集全部排除。（该方法内部使用 <code>AutoConfigurationImportFilter</code> 的实现类排除）。</p><p>我们看一个常见的 <code>configuration</code>，即 <code>org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration</code>，这个类中有大量的 <code>@Bean</code> 注解的方法，用来产生 bean，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RequestMappingHandlerAdapter <span class="title">requestMappingHandlerAdapter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RequestMappingHandlerAdapter adapter = <span class="keyword">super</span>.requestMappingHandlerAdapter();</span><br><span class="line">    adapter.setIgnoreDefaultModelOnRedirect(</span><br><span class="line">            <span class="keyword">this</span>.mvcProperties == <span class="keyword">null</span> || <span class="keyword">this</span>.mvcProperties.isIgnoreDefaultModelOnRedirect());</span><br><span class="line">    <span class="keyword">return</span> adapter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>spring 通过读取所有所需要的 <code>AutoConfiguration</code>，就可以加载默认的上下文容器，实现自动注入。</strong></p><h2><span id="springboot常用注解简介">SpringBoot常用注解简介</span></h2><ol><li><p><code>@Configuration</code></p><p> 作用于类，用于定义配置类，可替换xml配置文件，被注解的类内部包含有一个或多个被<code>@Bean</code>注解的方法，这些方法会被<code>AnnotationConfigApplicationContext</code>或<code>AnncationConfigWebApplicationContext</code>类进行扫描，并用于构建bean定义，初始化spring容器。</p></li><li><p><code>@ComponentScan</code></p><p> 该注解会扫描<code>@Controller</code>,<code>@Service</code>,<code>@Repository</code>,<code>@component</code>注解到类到spring容器中。</p></li><li><p><code>@SpringBootApplication</code></p><p> 该注解包含了<code>@ComponentScan</code>注解，所以在使用中我们可以通过<code>@SpringBootApplication</code>注解的scanBasepackages属性进行配置。</p></li><li><p><code>@Conditional</code></p><p> 该注解作用于类，它可以根据代码中的条件装载不同的bean，在设置注解之前类需要实现<code>Condition</code>接口，然后对该实现接口的类设置是否装载条件。</p></li><li><p><code>@Import</code></p><p> 通过导入的方式实现吧实例加入spring容器中，可以在需要时间没有被spring管理的类导入至Spring容器中。</p></li><li><p><code>@ImportResource</code></p><p> 和<code>@Import</code>类似，区别就是该注解导入的是配置文件。</p></li><li><p><code>Component</code></p><p> 该注解是一个元注解，意思是可以注解其它类注解，如<code>@Controller</code> <code>@Service</code> <code>@Repository</code>。带此注解的类被看作组件，当使用基于注解的配置和类路径扫描的时候，这些类就会被实例化。</p></li><li><p><code>@SpringBootApplication</code></p><p> 这个注解是Spring Boot最核心的注解，用在SpringBoot的主类上，标识这是一个Spring Boot应用。用来开启Spring Boot的各项能力，实际上这个注解<code>@Configuration</code>,<code>@EnableAutoConfiguration</code>,<code>@ComponentScan</code>三个注解的组合.由于这些注解一般都是一起使用的。</p></li><li><p><code>@EnableAutoConfiguration</code></p><p> 允许Spring Boot自动配置注解，开启这个注解之后，Spring Boot就能根据当前类路径下的包或者类来配置Spring Bean。配置信息是从<code>META-INF/spring.factories</code>加载的。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;SpringBoot启动&quot;&gt;&lt;a href=&quot;#SpringBoot启动&quot; class=&quot;headerlink&quot; title=&quot;SpringBoot启动&quot;&gt;&lt;/a&gt;SpringBoot启动&lt;/h2&gt;&lt;p&gt;SpringBoot因为内置了tomcat或jetty服务器，不需要直接部署War文件，所以SpringBoot的程序起点是一个普通的主函数。主函数如下：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@SpringBootApplication&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SpringbootStudyApplication&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        SpringApplication.run(SpringbootStudyApplication.class, args);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;整个SpringBoot的启动过程其实都是通过&lt;code&gt;@SpringBootApplication&lt;/code&gt;注解和&lt;code&gt;SpringApplication.run&lt;/code&gt;方法来实现的。&lt;/p&gt;
&lt;p&gt;整个启动的过程可以概括为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;读取所有依赖的&lt;code&gt;META-INF/spring.factories&lt;/code&gt;文件，该文件指明了哪些依赖可以被自动加载。&lt;/li&gt;
&lt;li&gt;根据&lt;code&gt;importSelector&lt;/code&gt;类选择加载哪些依赖，使用&lt;code&gt;conditionOn&lt;/code&gt;系列注解排除掉不需要的配置文件&lt;/li&gt;
&lt;li&gt;将剩余的配置文件所代表的bean加载到IOC容器中。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="https://zofun.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="SpringBoot" scheme="https://zofun.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Maven和Git命令的一些总结</title>
    <link href="https://zofun.github.io/2020/05/02/Maven%E5%92%8CGit%E5%91%BD%E4%BB%A4%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93/"/>
    <id>https://zofun.github.io/2020/05/02/Maven和Git命令的一些总结/</id>
    <published>2020-05-02T08:26:00.000Z</published>
    <updated>2020-05-02T08:27:18.810Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="maven命令">Maven命令</span></h2><ol><li><p>创建Maven的普通Java项目</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mvn archetype:create</span><br><span class="line">-DgroupId=packageName</span><br><span class="line">- DartifactId=projectName</span><br></pre></td></tr></table></figure></li><li><p>创建Maven的Web项目：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mvn archetype:create</span><br><span class="line">    -DgroupId=packageName</span><br><span class="line">    -DartifactId=webappName</span><br><span class="line">    -DarchetypeArtifactId=maven-archetype-webapp</span><br></pre></td></tr></table></figure></li><li><p>编译源代码</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvc compile</span><br></pre></td></tr></table></figure> <a id="more"></a></li><li><p>编译测试代码</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn test-compile</span><br></pre></td></tr></table></figure></li><li><p>运行测试</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvc test</span><br></pre></td></tr></table></figure></li><li><p>产生site</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn site</span><br></pre></td></tr></table></figure></li><li><p>打包</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn package</span><br></pre></td></tr></table></figure></li><li><p>在本地的仓库中安装jar</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvc install</span><br></pre></td></tr></table></figure></li><li><p>清除产生的项目</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean</span><br></pre></td></tr></table></figure></li><li><p>上传到私服</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn deploy</span><br></pre></td></tr></table></figure></li></ol><p><code>mvn compile</code>与<code>mvn install</code>,<code>mvn deloy</code>的区别</p><ol><li><code>mvn compile</code>编译类文件</li><li><code>mvn install</code>包含<code>mvn compile</code>,<code>mvn  package</code>然后上传到本地仓库</li><li><code>mvn deploy</code>包含<code>mvn install</code>然后上传到私服</li></ol><h2><span id="git命令">Git命令</span></h2><ol><li><p>新建代码库</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git init # 在当前目录生成一个git代码库</span><br><span class="line">git init [project-name] # 新建一个目录，将其初始化为git代码库</span><br><span class="line">git clone [url] # 下载一个项目和它的整个代码历史</span><br></pre></td></tr></table></figure></li><li><p>增加/删除文件</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git add [file] # 添加指定文件到暂存区</span><br><span class="line">git add [dir] # 添加指定目录到暂存区</span><br><span class="line">git add . # 添加当前目录的所有文件到暂存区</span><br><span class="line">git rm [file] # 删除工作区文件，并且将这次删除放入暂存区</span><br><span class="line">git mv [file-original][fule-renamed] # 改名文件</span><br></pre></td></tr></table></figure></li><li><p>代码提交</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m [message] # 提交暂存区到仓库区</span><br></pre></td></tr></table></figure></li><li><p>分支管理</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git branch # 列出所有的本地分支</span><br><span class="line">git branch -r # 列出所有的远程分支</span><br><span class="line">git branch -a # 列出所有本地分支和远程分支</span><br><span class="line">git branch [branch-name] # 新建一个分支，但依然停留在当前分支</span><br><span class="line">git chechout -b [branch] # 新建一个分支，并切换到该分支</span><br></pre></td></tr></table></figure></li><li><p>标签</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git tag # 列出所有tag</span><br><span class="line">git tag [tag] # 新建一个tag在指定commit</span><br><span class="line">git tag -d [tag] # 删除本地tag</span><br><span class="line">git push origin :refs/tags/[tagName] # 删除远程分支</span><br><span class="line">git show [tag] # 查看tag信息</span><br><span class="line">git push [remote][tag] # 提交指定tag</span><br><span class="line">git checkout -b [branch][tag] # 新建一个分支，指向某个tag</span><br></pre></td></tr></table></figure></li><li><p>查看信息</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git status # 显示有变更的文件</span><br><span class="line">git log # 显示当前分支的版本历史</span><br><span class="line">git diff # 显示暂存区和工作区的代码差异</span><br><span class="line">git reflog # 显示当前分支的最近几次提价</span><br></pre></td></tr></table></figure></li><li><p>远程同步</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git remore update # 更新远程仓库</span><br><span class="line">git fetch [remote] # 下载远程仓库的所有变动</span><br><span class="line">git remote -v # 显示所有远程仓库</span><br><span class="line">git pull [remote][branch] #取回远程仓库的变换，并与本地分支合并</span><br><span class="line">git push [remote][branch] # 上传本地指定分支到远程仓库</span><br></pre></td></tr></table></figure></li><li><p>撤销</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git checkout [file] #恢复缓冲区的指定文件到工作区</span><br><span class="line">git checkout [commit][file] # 恢复某个commit的指定文件到暂存区和工作区</span><br><span class="line">git reset [file] # 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span><br><span class="line">git reset --hard # 重置暂存区与工作区，与上一次commit保持一致</span><br><span class="line">git reset [commit] #重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span><br><span class="line">git reset --hard [commit] # 重置当前分支的head为指定commit，同时重置暂存区和工作区，与指定commit一致</span><br><span class="line"></span><br><span class="line">git revert [commit] # 新建一个commit，用于册小指定commit，后置的所有变换都会被前者抵消，并且应用当前分支</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Maven命令&quot;&gt;&lt;a href=&quot;#Maven命令&quot; class=&quot;headerlink&quot; title=&quot;Maven命令&quot;&gt;&lt;/a&gt;Maven命令&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;创建Maven的普通Java项目&lt;/p&gt;
 &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;mvn archetype:create&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	-DgroupId=packageName&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	- DartifactId=projectName&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;创建Maven的Web项目：&lt;/p&gt;
 &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;mvn archetype:create&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    -DgroupId=packageName&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    -DartifactId=webappName&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    -DarchetypeArtifactId=maven-archetype-webapp&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;编译源代码&lt;/p&gt;
 &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;mvc compile&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="https://zofun.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Maven" scheme="https://zofun.github.io/tags/Maven/"/>
    
      <category term="Git" scheme="https://zofun.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>高可用Redis：Redis Cluster</title>
    <link href="https://zofun.github.io/2020/05/01/%E9%AB%98%E5%8F%AF%E7%94%A8Redis%EF%BC%9ARedis%20Cluster/"/>
    <id>https://zofun.github.io/2020/05/01/高可用Redis：Redis Cluster/</id>
    <published>2020-05-01T14:20:00.000Z</published>
    <updated>2020-05-01T14:23:03.286Z</updated>
    
    <content type="html"><![CDATA[<p>Redis Cluster是Redis官方提供的Redis集群功能。</p><h2><span id="为什么现需要redis-cluster">为什么现需要Redis Cluster</span></h2><ol><li>主从复制不能满足高可用的要求</li><li>随着业务的发展，需要更高的QPS</li><li>数据量的增长导致服务器内存不足以存储</li><li>网络流量的增长，业务的流量已经超过了服务器的网卡的上限值，可以考虑使用分布式技术来进行分流。</li><li>离线计算，需要中间环节缓冲等别的需求。</li></ol><h2><span id="数据分布">数据分布</span></h2><p>当单机的redis节点无法满足要求，按照分区规则把数据分到若干个子集中。<br><a id="more"></a></p><h3><span id="常见的数据分布方法">常见的数据分布方法</span></h3><h4><span id="顺序分布">顺序分布</span></h4><p>比如有1-100个数据，要保存的三个节点上，那么1-33号数据放在第一个节点上，34-66号数据放在第二个节点上，依此类推。</p><h4><span id="哈希分布">哈希分布</span></h4><p>对键进行hash后，根据哈希码，来进行分区。</p><p>常见的分区方式有：</p><ol><li>节点取余分区：对key进行hash之后，与节点数进行取余运算，根据余数不同保存在不同的节点上。该分区方式的问题就是不利于节点数量的调整。但节点数量变动时，大量的数据需要迁移。</li><li>一致性哈希分区：将所有的数据当作一个token环，token环中的数据范围时0到2的32次方，然后为每一个数据节点分配一个token范围值，这个节点就负责保存这个节点范围的数据。对每一个key进行hash运算，将哈希后的结果在哪个token范围内，则按照顺时针去找最近的节点，这个key就会被保存在这个节点上。</li><li>虚拟槽分区：虚拟槽分区时Redis Cluster采用的分区方式，预设虚拟槽，每个槽就相当于一个数字，有一定的范围。每个槽映射一个数据子集，一般比节点数大。Redis cluster中预设的虚拟槽的范围为0到16383</li></ol><p>虚拟槽分区的步骤：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.把16384槽按照节点数量进行平均分配，由节点进行管理</span><br><span class="line">2.对每个key按照CRC16规则进行hash运算</span><br><span class="line">3.把hash结果对16383进行取余</span><br><span class="line">4.把余数发送给Redis节点</span><br><span class="line">5.节点接收到数据，验证是否在自己管理的槽编号的范围</span><br><span class="line">    如果在自己管理的槽编号范围内，则把数据保存到数据槽中，然后返回执行结果</span><br><span class="line">    如果在自己管理的槽编号范围外，则会把数据发送给正确的节点，由正确的节点来把数据保存在对应的槽中</span><br></pre></td></tr></table></figure><p>虚拟槽分区的特点：<br>使用服务器端话管理节点，槽，数据<br>可以对数据进行打散，又可以保证数据分布均匀。</p><h2><span id="redis-cluster基本架构">Redis Cluster基本架构</span></h2><h3><span id="节点">节点</span></h3><p>Redis Cluster是分布式架构，即Redis Cluster中有多个节点，每个节点购汇负责数据读写操作，每个节点之间会进行通信，</p><h3><span id="meet操作">meet操作</span></h3><p>节点之间会互相通信<br>meet操作时节点之间完成相互通信的基础，meet操作有一定的频率和规则。</p><h3><span id="分配槽">分配槽</span></h3><p>把16384个槽平均分配给节点进行管理，每个节点只能对自己负责的槽进行读写。由于每个节点之间都彼此通信，每个节点都知道另外节点负责管理的槽范围。<br>客户端访问任意任意节点时，对数据key按照CRC16规则进行hash运算，然后对运算结果对16383进行取余，如果余数在当前访问的节点管理的槽的范围内，则直接返回对应的数据，否则会告诉客户端去哪个节点获取数据，由客户端去正确的节点获取数据。</p><h3><span id="复制">复制</span></h3><p>保证高可用，每个主节点都有一个从节点，当主节点故障，cluster会按照规则实现主备的高可用</p><h3><span id="客户端路由">客户端路由</span></h3><h4><span id="moved重定向">moved重定向</span></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 每个节点通过通信都会共享redis cluster中槽和集群中对应节点的关系</span><br><span class="line">2. 客户端向redis cluster的任意节点发送命令，接收命令的节点会根据CRC16规则进行hash算法与16383取余，计算自己的槽和对应节点</span><br><span class="line">3. 如果保存数据槽被分配给当前节点，则去槽中执行命令，并把命令执行结果返回给客户端</span><br><span class="line">4. 如果保存数据的槽不再当前节点的管理范围内，则向客户端返回moved重定向异常</span><br><span class="line">5. 客户端接收到节点返回的节点，如果时moved异常，则从moved异常中获取目标节点的信息</span><br><span class="line">6. 客户端向目标节点发送命令，获取命令执行命令。</span><br></pre></td></tr></table></figure><h3><span id="ask重定向">ask重定向</span></h3><p>对集群进行扩容和缩容时，需要对槽及槽中的数据进行迁移。<br>当客户端向某个节点发送命令，节点向客户端返回moved异常，告诉客户端数据对应的槽节点信息。如果此时正在进行集群拓展或者缩空操作，当客户端向正确的节点发送命令时，槽及槽中数据已经被迁移到被的节点了，就会返回ask。<br>步骤：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 客户端向目标节点发送命令，目标节点中的槽已经迁移到别的节点上，此时目标节点会返回ask转向给客户端</span><br><span class="line">2. 客户端向新的节点发送asking命令给新的节点，然后再次给新节点发送命令</span><br><span class="line">3. 新节点执行命令，把命令执行结果返回给客户端。</span><br></pre></td></tr></table></figure><h2><span id="故障发现">故障发现</span></h2><p>Redis cluster通过pin/pong消息实现故障发现，不需要sentinel。<br>ping/pong不仅能传递节点与槽的对应消息，也能传递其它状态，比如：节点主从状态，节点故障等。</p><h3><span id="主观下线">主观下线</span></h3><p>主观下线只代表一个节点对另一个节点的判断，不代表所有节点的认知。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 节点1定期发送ping消息给节点2</span><br><span class="line">2. 如果发送成功，代表节点2正常运行，节点2会响应pong消息给节点1，节点1更新与节点2的最后通信时间</span><br><span class="line">3. 如果发送失败，则节点1和节点2之间的通信异常判断连接，在下一个定时任务周期时，仍然会与节点2发送ping消息。</span><br><span class="line">4. 如果节点1发送与节点2最后通信时间超过node-timeout，则把节点2标识为pfail状态</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2020/05/01/JXzyVJ.png" alt="JXzyVJ.png"></p><h4><span id="客观下线">客观下线</span></h4><p>当半数以上持有槽的主节点都标记某节点主观下线时，可以保证判断的公平性。<br>客观下线流程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 某个节点接收到其它节点发送的ping信息，如果接收到的ping消息中包含了其它pfail节点，这个节点会将主观下线消息添加到自身的故障列表中，故障列表中包含了当前节点接收到的每一个节点对其它节点的状态信息。</span><br><span class="line">2. 当前节点把主观下线的消息内容添加到故障列表之后，会尝试对故障节点进行客观下线操作。</span><br></pre></td></tr></table></figure><h2><span id="故障恢复">故障恢复</span></h2><h3><span id="资格检查">资格检查</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">对从节点的资格进行检查，只有难过检查的从节点才可以开始进行故障恢复</span><br><span class="line">每个从节点检查与故障主节点的断线时间</span><br><span class="line">超过cluster-node-timeout * cluster-slave-validity-factor数字，则取消资格</span><br><span class="line">cluster-node-timeout默认为15秒，cluster-slave-validity-factor默认值为10</span><br><span class="line">如果这两个参数都使用默认值，则每个节点都检查与故障主节点的断线时间，如果超过150秒，则这个节点就没有成为替换主节点的可能性</span><br></pre></td></tr></table></figure><h3><span id="准备选举时间">准备选举时间</span></h3><p>使偏移量最大的从节点具备优先级成为主节点的条件。<br><img src="https://s1.ax1x.com/2020/05/01/Jjpo4A.png" alt="Jjpo4A.png"></p><h3><span id="选举投票">选举投票</span></h3><p>对选举出来的多个从节点进行投票，选出新的主节点<br><img src="https://s1.ax1x.com/2020/05/01/Jjpqjf.png" alt="Jjpqjf.png"></p><h3><span id="替换主节点">替换主节点</span></h3><p>当前从节点取消复制变成离节点。执行cluster del slot撤销故障主节点负责的槽，并执行cluster add slot把这些槽分配给自己<br>向集群广播自己的pong消息，表明已经替换了故障从节点</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redis Cluster是Redis官方提供的Redis集群功能。&lt;/p&gt;
&lt;h2 id=&quot;为什么现需要Redis-Cluster&quot;&gt;&lt;a href=&quot;#为什么现需要Redis-Cluster&quot; class=&quot;headerlink&quot; title=&quot;为什么现需要Redis Cluster&quot;&gt;&lt;/a&gt;为什么现需要Redis Cluster&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;主从复制不能满足高可用的要求&lt;/li&gt;
&lt;li&gt;随着业务的发展，需要更高的QPS&lt;/li&gt;
&lt;li&gt;数据量的增长导致服务器内存不足以存储&lt;/li&gt;
&lt;li&gt;网络流量的增长，业务的流量已经超过了服务器的网卡的上限值，可以考虑使用分布式技术来进行分流。&lt;/li&gt;
&lt;li&gt;离线计算，需要中间环节缓冲等别的需求。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;数据分布&quot;&gt;&lt;a href=&quot;#数据分布&quot; class=&quot;headerlink&quot; title=&quot;数据分布&quot;&gt;&lt;/a&gt;数据分布&lt;/h2&gt;&lt;p&gt;当单机的redis节点无法满足要求，按照分区规则把数据分到若干个子集中。&lt;br&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="https://zofun.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Redis" scheme="https://zofun.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>JVM是如何实现多态的</title>
    <link href="https://zofun.github.io/2020/04/23/JVM%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%A4%9A%E6%80%81%E7%9A%84/"/>
    <id>https://zofun.github.io/2020/04/23/JVM是如何实现多态的/</id>
    <published>2020-04-23T14:04:00.000Z</published>
    <updated>2020-04-23T14:05:59.393Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="java中的多态">Java中的多态</span></h2><p>多态是面向对象的三大核心概念之一。多态简单来讲就是父类引用指向子类对象。</p><p>在Java中要实现多态需要满足三个必要条件：<strong>继承、重写、父类引用指向子类对象</strong>。</p><p><code>Parent p=new Child();</code></p><p>多态的引入带来了这写好处：</p><ul><li>消除类型之间的耦合关系</li><li>可替换性</li><li>可扩充性</li><li>接口性</li><li>灵活性</li><li>简化性</li></ul><a id="more"></a><h2><span id="jvm是如何实现多态的">JVM是如何实现多态的</span></h2><h3><span id="jvm方法调用的背景知识">JVM方法调用的背景知识</span></h3><h4><span id="java的方法调用">Java的方法调用</span></h4><p>Java的class文件的编译过程中并不包含传统编译过程的链接阶段。class文件中的方法都是以符号引用的形式存储的，而不是方法的入口地址。这个特性使得Java具有强大的动态拓展的能力，但同时也增加了Java方法调用过程的复杂性。Java的方法需要在类加载期间或者运行期间才能确定真正的入口地址，即符号引用转换为直接引用。</p><p>JVM中提供了5种方法调用的字节码指令：</p><ul><li><code>invokestatic</code>:调用静态方法</li><li><code>invokespecial</code>:调用实例构造器<code>&lt;init&gt;</code>方法、私有方法和父类方法</li><li><code>invokevirtual</code>:调用虚方法</li><li><code>invokeinterface</code>：调用接口方法，会在运行是再确定一个实现此接口的对象</li><li><code>invokedynamic</code>：先在运行时动态解析处调用点限定符所用的方法，然后再执行该方法。</li></ul><p>只要能被<code>invokestatic</code>和<code>invokespecial</code>指令调用的方法，都可以在类加载过程中的解析阶段确定唯一的调用版本，符合这个条件的方法有：静态方法、私有方法、实例构造器和父类方法，它们在类加载过程中的解析阶段就会将符号引用解析为该方法的直接引用。这些方法可被称为非虚方法（也就是不涉及多态的方法）。</p><p>因此方法调用可以分为两种，一种是类加载过程中的解析阶段完成的，另一种要在运行时完成，叫作<strong>分派</strong>。</p><h3><span id="分派">分派</span></h3><p>正是因为多态的存在，使得在判断方法调用的版本的时候会存在选择的问题，这也是分派阶段存在的原因。</p><h4><span id="静态分派">静态分派</span></h4><p>编译器会根据变量的静态类型作为判断的依据选择合适的重载版本。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticDispatch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义三个静态内部类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Human</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Human human)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"human"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Man man)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"man"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Woman woman)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"woman"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//这两个对象的静态类型就是Human</span></span><br><span class="line">        Human man=<span class="keyword">new</span> Man();</span><br><span class="line">        Human woman=<span class="keyword">new</span> Woman();</span><br><span class="line">        </span><br><span class="line">        sayHello(man);</span><br><span class="line">        sayHello(woman);</span><br><span class="line"><span class="comment">//修改静态类型</span></span><br><span class="line">        sayHello((Man) man);</span><br><span class="line">        sayHello((Woman) woman);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">human</span></span><br><span class="line"><span class="comment">human</span></span><br><span class="line"><span class="comment">man</span></span><br><span class="line"><span class="comment">woman</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>静态分派就是Java语言是心啊重载的本质。jvm通过静态类型来选择具体的方法，完成符号引用到直接引用的转换。</p><h4><span id="动态分派">动态分派</span></h4><p>动态分派与多态的重写有关。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicDispatch</span>  </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义三个静态内部类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"human"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"man"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Human</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"woman"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Human man=<span class="keyword">new</span> Man();</span><br><span class="line">        Human woman=<span class="keyword">new</span> Woman();</span><br><span class="line">        man.sayHello();</span><br><span class="line">        woman.sayHello();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">运行结果：</span></span><br><span class="line"><span class="comment">man</span></span><br><span class="line"><span class="comment">woman</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>查看字节码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=3, args_size=1</span><br><span class="line">         0: new           #2                  // class test/DynamicDispatch$Man</span><br><span class="line">         3: dup</span><br><span class="line">         4: invokespecial #3                  // Method test/DynamicDispatch$Man.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         7: astore_1</span><br><span class="line">         8: new           #4                  // class test/DynamicDispatch$Woman</span><br><span class="line">        11: dup</span><br><span class="line">        12: invokespecial #5                  // Method test/DynamicDispatch$Woman.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">        15: astore_2</span><br><span class="line">        16: aload_1</span><br><span class="line">        17: invokevirtual #6                  // Method test/DynamicDispatch$Human.sayHello:()V</span><br><span class="line">        20: aload_2</span><br><span class="line">        21: invokevirtual #6                  // Method test/DynamicDispatch$Human.sayHello:()V</span><br><span class="line">        24: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 33: 0</span><br><span class="line">        line 34: 8</span><br><span class="line">        line 35: 16</span><br><span class="line">        line 36: 20</span><br><span class="line">        line 38: 24</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0      25     0  args   [Ljava/lang/String;</span><br><span class="line">            8      17     1   man   Ltest/DynamicDispatch$Human;</span><br><span class="line">           16       9     2 woman   Ltest/DynamicDispatch$Human;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从字节码中我们可以看出在完成man和woman两个对象的创建之后，它将创建的对象压入栈中。</p><p>然后通过<code>invokevirtual</code>进行方法调用。</p><p><code>invokevirtual</code>指令的运行时解析过程大致分为以下几个步骤：</p><ul><li>找到操作数栈顶的第一个元素所指向的对象的实际类型，记为C。</li><li>如果在类型C中找到与常量池中描述符和简单名称一样的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，返回<code>java.lang.IllegalAccessError</code>异常。</li><li>否则，按照继承关系从下到上依次对C的各个父类进行搜索和验证。</li><li>如果还没有找到合适的方法，则抛出<code>java.lang.AbstractMethodError</code>异常。</li></ul><p>由于<code>invokevirtual</code>指令执行的第一步就是在运行期间确定接收者的实际类型，所以两次调用中的<code>invokevirtual</code>指令把常量池中的类方法符号引用解析到了不同的直接引用上，这个过程就是Java语言中方法重写的本质。这种在运行期根据实际类型确定方法执行版本的分派过程叫做动态分派。</p><h3><span id="虚拟机是如何实现动态分配的">虚拟机是如何实现动态分配的</span></h3><p>由于动态分派是非常频繁的操作，而且动态分派的方法版本选择过程需要运行时在类的方法元数据中搜索合适的目标方法，因此虚拟机会进行优化。常用的方法就是为类在方法区中建立一个虚方法表（Virtual Method Table，在<code>invokeinterface</code>执行时也会用到接口方法表，Interface Method Table），使用虚方法表索引来替代元数据查找以提升性能。</p><p>虚方法表中存放着各个方法的实际入口地址。如果某个方法在子类中没有被重写，那子类的虚方法表里面的地址入口和父类相同方法的地址入口是一致的，都指向父类的实现入口。如果子类重写了父类的方法，子类方法表中的地址会替换为指向子类实现版本的入口地址。</p><p>为了程序实现上的方便，具有相同签名的方法，在父类和子类的虚方法表中都应该具有一样的索引号，这样当类型变换时，仅仅需要变更查找的方法表，就可以从不同的虚方法表中按索引转换出所需的入口地址。</p><p>方法表一般在类加载的连接阶段进行初始化，准备了类的变量初始值后，虚拟机会把该类的方法表也初始化完毕。</p><p><a href="https://blog.csdn.net/q982151756/article/details/81588284" target="_blank" rel="noopener">参考博客地址</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Java中的多态&quot;&gt;&lt;a href=&quot;#Java中的多态&quot; class=&quot;headerlink&quot; title=&quot;Java中的多态&quot;&gt;&lt;/a&gt;Java中的多态&lt;/h2&gt;&lt;p&gt;多态是面向对象的三大核心概念之一。多态简单来讲就是父类引用指向子类对象。&lt;/p&gt;
&lt;p&gt;在Java中要实现多态需要满足三个必要条件：&lt;strong&gt;继承、重写、父类引用指向子类对象&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Parent p=new Child();&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;多态的引入带来了这写好处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;消除类型之间的耦合关系&lt;/li&gt;
&lt;li&gt;可替换性&lt;/li&gt;
&lt;li&gt;可扩充性&lt;/li&gt;
&lt;li&gt;接口性&lt;/li&gt;
&lt;li&gt;灵活性&lt;/li&gt;
&lt;li&gt;简化性&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="https://zofun.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Java" scheme="https://zofun.github.io/tags/Java/"/>
    
      <category term="JVM" scheme="https://zofun.github.io/tags/JVM/"/>
    
  </entry>
  
</feed>
