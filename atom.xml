<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>个人博客</title>
  
  <subtitle>博观而约取 厚积而薄发</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zofun.github.io/"/>
  <updated>2020-05-02T08:27:18.810Z</updated>
  <id>https://zofun.github.io/</id>
  
  <author>
    <name>zofun</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Maven和Git命令的一些总结</title>
    <link href="https://zofun.github.io/2020/05/02/Maven%E5%92%8CGit%E5%91%BD%E4%BB%A4%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93/"/>
    <id>https://zofun.github.io/2020/05/02/Maven和Git命令的一些总结/</id>
    <published>2020-05-02T08:26:00.000Z</published>
    <updated>2020-05-02T08:27:18.810Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="maven命令">Maven命令</span></h2><ol><li><p>创建Maven的普通Java项目</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mvn archetype:create</span><br><span class="line">-DgroupId=packageName</span><br><span class="line">- DartifactId=projectName</span><br></pre></td></tr></table></figure></li><li><p>创建Maven的Web项目：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mvn archetype:create</span><br><span class="line">    -DgroupId=packageName</span><br><span class="line">    -DartifactId=webappName</span><br><span class="line">    -DarchetypeArtifactId=maven-archetype-webapp</span><br></pre></td></tr></table></figure></li><li><p>编译源代码</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvc compile</span><br></pre></td></tr></table></figure> <a id="more"></a></li><li><p>编译测试代码</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn test-compile</span><br></pre></td></tr></table></figure></li><li><p>运行测试</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvc test</span><br></pre></td></tr></table></figure></li><li><p>产生site</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn site</span><br></pre></td></tr></table></figure></li><li><p>打包</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn package</span><br></pre></td></tr></table></figure></li><li><p>在本地的仓库中安装jar</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvc install</span><br></pre></td></tr></table></figure></li><li><p>清除产生的项目</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean</span><br></pre></td></tr></table></figure></li><li><p>上传到私服</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn deploy</span><br></pre></td></tr></table></figure></li></ol><p><code>mvn compile</code>与<code>mvn install</code>,<code>mvn deloy</code>的区别</p><ol><li><code>mvn compile</code>编译类文件</li><li><code>mvn install</code>包含<code>mvn compile</code>,<code>mvn  package</code>然后上传到本地仓库</li><li><code>mvn deploy</code>包含<code>mvn install</code>然后上传到私服</li></ol><h2><span id="git命令">Git命令</span></h2><ol><li><p>新建代码库</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git init # 在当前目录生成一个git代码库</span><br><span class="line">git init [project-name] # 新建一个目录，将其初始化为git代码库</span><br><span class="line">git clone [url] # 下载一个项目和它的整个代码历史</span><br></pre></td></tr></table></figure></li><li><p>增加/删除文件</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git add [file] # 添加指定文件到暂存区</span><br><span class="line">git add [dir] # 添加指定目录到暂存区</span><br><span class="line">git add . # 添加当前目录的所有文件到暂存区</span><br><span class="line">git rm [file] # 删除工作区文件，并且将这次删除放入暂存区</span><br><span class="line">git mv [file-original][fule-renamed] # 改名文件</span><br></pre></td></tr></table></figure></li><li><p>代码提交</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m [message] # 提交暂存区到仓库区</span><br></pre></td></tr></table></figure></li><li><p>分支管理</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git branch # 列出所有的本地分支</span><br><span class="line">git branch -r # 列出所有的远程分支</span><br><span class="line">git branch -a # 列出所有本地分支和远程分支</span><br><span class="line">git branch [branch-name] # 新建一个分支，但依然停留在当前分支</span><br><span class="line">git chechout -b [branch] # 新建一个分支，并切换到该分支</span><br></pre></td></tr></table></figure></li><li><p>标签</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git tag # 列出所有tag</span><br><span class="line">git tag [tag] # 新建一个tag在指定commit</span><br><span class="line">git tag -d [tag] # 删除本地tag</span><br><span class="line">git push origin :refs/tags/[tagName] # 删除远程分支</span><br><span class="line">git show [tag] # 查看tag信息</span><br><span class="line">git push [remote][tag] # 提交指定tag</span><br><span class="line">git checkout -b [branch][tag] # 新建一个分支，指向某个tag</span><br></pre></td></tr></table></figure></li><li><p>查看信息</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git status # 显示有变更的文件</span><br><span class="line">git log # 显示当前分支的版本历史</span><br><span class="line">git diff # 显示暂存区和工作区的代码差异</span><br><span class="line">git reflog # 显示当前分支的最近几次提价</span><br></pre></td></tr></table></figure></li><li><p>远程同步</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git remore update # 更新远程仓库</span><br><span class="line">git fetch [remote] # 下载远程仓库的所有变动</span><br><span class="line">git remote -v # 显示所有远程仓库</span><br><span class="line">git pull [remote][branch] #取回远程仓库的变换，并与本地分支合并</span><br><span class="line">git push [remote][branch] # 上传本地指定分支到远程仓库</span><br></pre></td></tr></table></figure></li><li><p>撤销</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git checkout [file] #恢复缓冲区的指定文件到工作区</span><br><span class="line">git checkout [commit][file] # 恢复某个commit的指定文件到暂存区和工作区</span><br><span class="line">git reset [file] # 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span><br><span class="line">git reset --hard # 重置暂存区与工作区，与上一次commit保持一致</span><br><span class="line">git reset [commit] #重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span><br><span class="line">git reset --hard [commit] # 重置当前分支的head为指定commit，同时重置暂存区和工作区，与指定commit一致</span><br><span class="line"></span><br><span class="line">git revert [commit] # 新建一个commit，用于册小指定commit，后置的所有变换都会被前者抵消，并且应用当前分支</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Maven命令&quot;&gt;&lt;a href=&quot;#Maven命令&quot; class=&quot;headerlink&quot; title=&quot;Maven命令&quot;&gt;&lt;/a&gt;Maven命令&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;创建Maven的普通Java项目&lt;/p&gt;
 &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;mvn archetype:create&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	-DgroupId=packageName&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	- DartifactId=projectName&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;创建Maven的Web项目：&lt;/p&gt;
 &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;mvn archetype:create&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    -DgroupId=packageName&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    -DartifactId=webappName&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    -DarchetypeArtifactId=maven-archetype-webapp&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;编译源代码&lt;/p&gt;
 &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;mvc compile&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="https://zofun.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Maven" scheme="https://zofun.github.io/tags/Maven/"/>
    
      <category term="Git" scheme="https://zofun.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>高可用Redis：Redis Cluster</title>
    <link href="https://zofun.github.io/2020/05/01/%E9%AB%98%E5%8F%AF%E7%94%A8Redis%EF%BC%9ARedis%20Cluster/"/>
    <id>https://zofun.github.io/2020/05/01/高可用Redis：Redis Cluster/</id>
    <published>2020-05-01T14:20:00.000Z</published>
    <updated>2020-05-01T14:23:03.286Z</updated>
    
    <content type="html"><![CDATA[<p>Redis Cluster是Redis官方提供的Redis集群功能。</p><h2><span id="为什么现需要redis-cluster">为什么现需要Redis Cluster</span></h2><ol><li>主从复制不能满足高可用的要求</li><li>随着业务的发展，需要更高的QPS</li><li>数据量的增长导致服务器内存不足以存储</li><li>网络流量的增长，业务的流量已经超过了服务器的网卡的上限值，可以考虑使用分布式技术来进行分流。</li><li>离线计算，需要中间环节缓冲等别的需求。</li></ol><h2><span id="数据分布">数据分布</span></h2><p>当单机的redis节点无法满足要求，按照分区规则把数据分到若干个子集中。<br><a id="more"></a></p><h3><span id="常见的数据分布方法">常见的数据分布方法</span></h3><h4><span id="顺序分布">顺序分布</span></h4><p>比如有1-100个数据，要保存的三个节点上，那么1-33号数据放在第一个节点上，34-66号数据放在第二个节点上，依此类推。</p><h4><span id="哈希分布">哈希分布</span></h4><p>对键进行hash后，根据哈希码，来进行分区。</p><p>常见的分区方式有：</p><ol><li>节点取余分区：对key进行hash之后，与节点数进行取余运算，根据余数不同保存在不同的节点上。该分区方式的问题就是不利于节点数量的调整。但节点数量变动时，大量的数据需要迁移。</li><li>一致性哈希分区：将所有的数据当作一个token环，token环中的数据范围时0到2的32次方，然后为每一个数据节点分配一个token范围值，这个节点就负责保存这个节点范围的数据。对每一个key进行hash运算，将哈希后的结果在哪个token范围内，则按照顺时针去找最近的节点，这个key就会被保存在这个节点上。</li><li>虚拟槽分区：虚拟槽分区时Redis Cluster采用的分区方式，预设虚拟槽，每个槽就相当于一个数字，有一定的范围。每个槽映射一个数据子集，一般比节点数大。Redis cluster中预设的虚拟槽的范围为0到16383</li></ol><p>虚拟槽分区的步骤：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.把16384槽按照节点数量进行平均分配，由节点进行管理</span><br><span class="line">2.对每个key按照CRC16规则进行hash运算</span><br><span class="line">3.把hash结果对16383进行取余</span><br><span class="line">4.把余数发送给Redis节点</span><br><span class="line">5.节点接收到数据，验证是否在自己管理的槽编号的范围</span><br><span class="line">    如果在自己管理的槽编号范围内，则把数据保存到数据槽中，然后返回执行结果</span><br><span class="line">    如果在自己管理的槽编号范围外，则会把数据发送给正确的节点，由正确的节点来把数据保存在对应的槽中</span><br></pre></td></tr></table></figure><p>虚拟槽分区的特点：<br>使用服务器端话管理节点，槽，数据<br>可以对数据进行打散，又可以保证数据分布均匀。</p><h2><span id="redis-cluster基本架构">Redis Cluster基本架构</span></h2><h3><span id="节点">节点</span></h3><p>Redis Cluster是分布式架构，即Redis Cluster中有多个节点，每个节点购汇负责数据读写操作，每个节点之间会进行通信，</p><h3><span id="meet操作">meet操作</span></h3><p>节点之间会互相通信<br>meet操作时节点之间完成相互通信的基础，meet操作有一定的频率和规则。</p><h3><span id="分配槽">分配槽</span></h3><p>把16384个槽平均分配给节点进行管理，每个节点只能对自己负责的槽进行读写。由于每个节点之间都彼此通信，每个节点都知道另外节点负责管理的槽范围。<br>客户端访问任意任意节点时，对数据key按照CRC16规则进行hash运算，然后对运算结果对16383进行取余，如果余数在当前访问的节点管理的槽的范围内，则直接返回对应的数据，否则会告诉客户端去哪个节点获取数据，由客户端去正确的节点获取数据。</p><h3><span id="复制">复制</span></h3><p>保证高可用，每个主节点都有一个从节点，当主节点故障，cluster会按照规则实现主备的高可用</p><h3><span id="客户端路由">客户端路由</span></h3><h4><span id="moved重定向">moved重定向</span></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 每个节点通过通信都会共享redis cluster中槽和集群中对应节点的关系</span><br><span class="line">2. 客户端向redis cluster的任意节点发送命令，接收命令的节点会根据CRC16规则进行hash算法与16383取余，计算自己的槽和对应节点</span><br><span class="line">3. 如果保存数据槽被分配给当前节点，则去槽中执行命令，并把命令执行结果返回给客户端</span><br><span class="line">4. 如果保存数据的槽不再当前节点的管理范围内，则向客户端返回moved重定向异常</span><br><span class="line">5. 客户端接收到节点返回的节点，如果时moved异常，则从moved异常中获取目标节点的信息</span><br><span class="line">6. 客户端向目标节点发送命令，获取命令执行命令。</span><br></pre></td></tr></table></figure><h3><span id="ask重定向">ask重定向</span></h3><p>对集群进行扩容和缩容时，需要对槽及槽中的数据进行迁移。<br>当客户端向某个节点发送命令，节点向客户端返回moved异常，告诉客户端数据对应的槽节点信息。如果此时正在进行集群拓展或者缩空操作，当客户端向正确的节点发送命令时，槽及槽中数据已经被迁移到被的节点了，就会返回ask。<br>步骤：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 客户端向目标节点发送命令，目标节点中的槽已经迁移到别的节点上，此时目标节点会返回ask转向给客户端</span><br><span class="line">2. 客户端向新的节点发送asking命令给新的节点，然后再次给新节点发送命令</span><br><span class="line">3. 新节点执行命令，把命令执行结果返回给客户端。</span><br></pre></td></tr></table></figure><h2><span id="故障发现">故障发现</span></h2><p>Redis cluster通过pin/pong消息实现故障发现，不需要sentinel。<br>ping/pong不仅能传递节点与槽的对应消息，也能传递其它状态，比如：节点主从状态，节点故障等。</p><h3><span id="主观下线">主观下线</span></h3><p>主观下线只代表一个节点对另一个节点的判断，不代表所有节点的认知。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 节点1定期发送ping消息给节点2</span><br><span class="line">2. 如果发送成功，代表节点2正常运行，节点2会响应pong消息给节点1，节点1更新与节点2的最后通信时间</span><br><span class="line">3. 如果发送失败，则节点1和节点2之间的通信异常判断连接，在下一个定时任务周期时，仍然会与节点2发送ping消息。</span><br><span class="line">4. 如果节点1发送与节点2最后通信时间超过node-timeout，则把节点2标识为pfail状态</span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2020/05/01/JXzyVJ.png" alt="JXzyVJ.png"></p><h4><span id="客观下线">客观下线</span></h4><p>当半数以上持有槽的主节点都标记某节点主观下线时，可以保证判断的公平性。<br>客观下线流程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 某个节点接收到其它节点发送的ping信息，如果接收到的ping消息中包含了其它pfail节点，这个节点会将主观下线消息添加到自身的故障列表中，故障列表中包含了当前节点接收到的每一个节点对其它节点的状态信息。</span><br><span class="line">2. 当前节点把主观下线的消息内容添加到故障列表之后，会尝试对故障节点进行客观下线操作。</span><br></pre></td></tr></table></figure><h2><span id="故障恢复">故障恢复</span></h2><h3><span id="资格检查">资格检查</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">对从节点的资格进行检查，只有难过检查的从节点才可以开始进行故障恢复</span><br><span class="line">每个从节点检查与故障主节点的断线时间</span><br><span class="line">超过cluster-node-timeout * cluster-slave-validity-factor数字，则取消资格</span><br><span class="line">cluster-node-timeout默认为15秒，cluster-slave-validity-factor默认值为10</span><br><span class="line">如果这两个参数都使用默认值，则每个节点都检查与故障主节点的断线时间，如果超过150秒，则这个节点就没有成为替换主节点的可能性</span><br></pre></td></tr></table></figure><h3><span id="准备选举时间">准备选举时间</span></h3><p>使偏移量最大的从节点具备优先级成为主节点的条件。<br><img src="https://s1.ax1x.com/2020/05/01/Jjpo4A.png" alt="Jjpo4A.png"></p><h3><span id="选举投票">选举投票</span></h3><p>对选举出来的多个从节点进行投票，选出新的主节点<br><img src="https://s1.ax1x.com/2020/05/01/Jjpqjf.png" alt="Jjpqjf.png"></p><h3><span id="替换主节点">替换主节点</span></h3><p>当前从节点取消复制变成离节点。执行cluster del slot撤销故障主节点负责的槽，并执行cluster add slot把这些槽分配给自己<br>向集群广播自己的pong消息，表明已经替换了故障从节点</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redis Cluster是Redis官方提供的Redis集群功能。&lt;/p&gt;
&lt;h2 id=&quot;为什么现需要Redis-Cluster&quot;&gt;&lt;a href=&quot;#为什么现需要Redis-Cluster&quot; class=&quot;headerlink&quot; title=&quot;为什么现需要Redis Cluster&quot;&gt;&lt;/a&gt;为什么现需要Redis Cluster&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;主从复制不能满足高可用的要求&lt;/li&gt;
&lt;li&gt;随着业务的发展，需要更高的QPS&lt;/li&gt;
&lt;li&gt;数据量的增长导致服务器内存不足以存储&lt;/li&gt;
&lt;li&gt;网络流量的增长，业务的流量已经超过了服务器的网卡的上限值，可以考虑使用分布式技术来进行分流。&lt;/li&gt;
&lt;li&gt;离线计算，需要中间环节缓冲等别的需求。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;数据分布&quot;&gt;&lt;a href=&quot;#数据分布&quot; class=&quot;headerlink&quot; title=&quot;数据分布&quot;&gt;&lt;/a&gt;数据分布&lt;/h2&gt;&lt;p&gt;当单机的redis节点无法满足要求，按照分区规则把数据分到若干个子集中。&lt;br&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="https://zofun.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Redis" scheme="https://zofun.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>JVM是如何实现多态的</title>
    <link href="https://zofun.github.io/2020/04/23/JVM%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%A4%9A%E6%80%81%E7%9A%84/"/>
    <id>https://zofun.github.io/2020/04/23/JVM是如何实现多态的/</id>
    <published>2020-04-23T14:04:00.000Z</published>
    <updated>2020-04-23T14:05:59.393Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="java中的多态">Java中的多态</span></h2><p>多态是面向对象的三大核心概念之一。多态简单来讲就是父类引用指向子类对象。</p><p>在Java中要实现多态需要满足三个必要条件：<strong>继承、重写、父类引用指向子类对象</strong>。</p><p><code>Parent p=new Child();</code></p><p>多态的引入带来了这写好处：</p><ul><li>消除类型之间的耦合关系</li><li>可替换性</li><li>可扩充性</li><li>接口性</li><li>灵活性</li><li>简化性</li></ul><a id="more"></a><h2><span id="jvm是如何实现多态的">JVM是如何实现多态的</span></h2><h3><span id="jvm方法调用的背景知识">JVM方法调用的背景知识</span></h3><h4><span id="java的方法调用">Java的方法调用</span></h4><p>Java的class文件的编译过程中并不包含传统编译过程的链接阶段。class文件中的方法都是以符号引用的形式存储的，而不是方法的入口地址。这个特性使得Java具有强大的动态拓展的能力，但同时也增加了Java方法调用过程的复杂性。Java的方法需要在类加载期间或者运行期间才能确定真正的入口地址，即符号引用转换为直接引用。</p><p>JVM中提供了5种方法调用的字节码指令：</p><ul><li><code>invokestatic</code>:调用静态方法</li><li><code>invokespecial</code>:调用实例构造器<code>&lt;init&gt;</code>方法、私有方法和父类方法</li><li><code>invokevirtual</code>:调用虚方法</li><li><code>invokeinterface</code>：调用接口方法，会在运行是再确定一个实现此接口的对象</li><li><code>invokedynamic</code>：先在运行时动态解析处调用点限定符所用的方法，然后再执行该方法。</li></ul><p>只要能被<code>invokestatic</code>和<code>invokespecial</code>指令调用的方法，都可以在类加载过程中的解析阶段确定唯一的调用版本，符合这个条件的方法有：静态方法、私有方法、实例构造器和父类方法，它们在类加载过程中的解析阶段就会将符号引用解析为该方法的直接引用。这些方法可被称为非虚方法（也就是不涉及多态的方法）。</p><p>因此方法调用可以分为两种，一种是类加载过程中的解析阶段完成的，另一种要在运行时完成，叫作<strong>分派</strong>。</p><h3><span id="分派">分派</span></h3><p>正是因为多态的存在，使得在判断方法调用的版本的时候会存在选择的问题，这也是分派阶段存在的原因。</p><h4><span id="静态分派">静态分派</span></h4><p>编译器会根据变量的静态类型作为判断的依据选择合适的重载版本。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticDispatch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义三个静态内部类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Human</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Human human)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"human"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Man man)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"man"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Woman woman)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"woman"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//这两个对象的静态类型就是Human</span></span><br><span class="line">        Human man=<span class="keyword">new</span> Man();</span><br><span class="line">        Human woman=<span class="keyword">new</span> Woman();</span><br><span class="line">        </span><br><span class="line">        sayHello(man);</span><br><span class="line">        sayHello(woman);</span><br><span class="line"><span class="comment">//修改静态类型</span></span><br><span class="line">        sayHello((Man) man);</span><br><span class="line">        sayHello((Woman) woman);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">human</span></span><br><span class="line"><span class="comment">human</span></span><br><span class="line"><span class="comment">man</span></span><br><span class="line"><span class="comment">woman</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>静态分派就是Java语言是心啊重载的本质。jvm通过静态类型来选择具体的方法，完成符号引用到直接引用的转换。</p><h4><span id="动态分派">动态分派</span></h4><p>动态分派与多态的重写有关。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicDispatch</span>  </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义三个静态内部类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"human"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"man"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Human</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"woman"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Human man=<span class="keyword">new</span> Man();</span><br><span class="line">        Human woman=<span class="keyword">new</span> Woman();</span><br><span class="line">        man.sayHello();</span><br><span class="line">        woman.sayHello();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">运行结果：</span></span><br><span class="line"><span class="comment">man</span></span><br><span class="line"><span class="comment">woman</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>查看字节码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=3, args_size=1</span><br><span class="line">         0: new           #2                  // class test/DynamicDispatch$Man</span><br><span class="line">         3: dup</span><br><span class="line">         4: invokespecial #3                  // Method test/DynamicDispatch$Man.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         7: astore_1</span><br><span class="line">         8: new           #4                  // class test/DynamicDispatch$Woman</span><br><span class="line">        11: dup</span><br><span class="line">        12: invokespecial #5                  // Method test/DynamicDispatch$Woman.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">        15: astore_2</span><br><span class="line">        16: aload_1</span><br><span class="line">        17: invokevirtual #6                  // Method test/DynamicDispatch$Human.sayHello:()V</span><br><span class="line">        20: aload_2</span><br><span class="line">        21: invokevirtual #6                  // Method test/DynamicDispatch$Human.sayHello:()V</span><br><span class="line">        24: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 33: 0</span><br><span class="line">        line 34: 8</span><br><span class="line">        line 35: 16</span><br><span class="line">        line 36: 20</span><br><span class="line">        line 38: 24</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0      25     0  args   [Ljava/lang/String;</span><br><span class="line">            8      17     1   man   Ltest/DynamicDispatch$Human;</span><br><span class="line">           16       9     2 woman   Ltest/DynamicDispatch$Human;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从字节码中我们可以看出在完成man和woman两个对象的创建之后，它将创建的对象压入栈中。</p><p>然后通过<code>invokevirtual</code>进行方法调用。</p><p><code>invokevirtual</code>指令的运行时解析过程大致分为以下几个步骤：</p><ul><li>找到操作数栈顶的第一个元素所指向的对象的实际类型，记为C。</li><li>如果在类型C中找到与常量池中描述符和简单名称一样的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，返回<code>java.lang.IllegalAccessError</code>异常。</li><li>否则，按照继承关系从下到上依次对C的各个父类进行搜索和验证。</li><li>如果还没有找到合适的方法，则抛出<code>java.lang.AbstractMethodError</code>异常。</li></ul><p>由于<code>invokevirtual</code>指令执行的第一步就是在运行期间确定接收者的实际类型，所以两次调用中的<code>invokevirtual</code>指令把常量池中的类方法符号引用解析到了不同的直接引用上，这个过程就是Java语言中方法重写的本质。这种在运行期根据实际类型确定方法执行版本的分派过程叫做动态分派。</p><h3><span id="虚拟机是如何实现动态分配的">虚拟机是如何实现动态分配的</span></h3><p>由于动态分派是非常频繁的操作，而且动态分派的方法版本选择过程需要运行时在类的方法元数据中搜索合适的目标方法，因此虚拟机会进行优化。常用的方法就是为类在方法区中建立一个虚方法表（Virtual Method Table，在<code>invokeinterface</code>执行时也会用到接口方法表，Interface Method Table），使用虚方法表索引来替代元数据查找以提升性能。</p><p>虚方法表中存放着各个方法的实际入口地址。如果某个方法在子类中没有被重写，那子类的虚方法表里面的地址入口和父类相同方法的地址入口是一致的，都指向父类的实现入口。如果子类重写了父类的方法，子类方法表中的地址会替换为指向子类实现版本的入口地址。</p><p>为了程序实现上的方便，具有相同签名的方法，在父类和子类的虚方法表中都应该具有一样的索引号，这样当类型变换时，仅仅需要变更查找的方法表，就可以从不同的虚方法表中按索引转换出所需的入口地址。</p><p>方法表一般在类加载的连接阶段进行初始化，准备了类的变量初始值后，虚拟机会把该类的方法表也初始化完毕。</p><p><a href="https://blog.csdn.net/q982151756/article/details/81588284" target="_blank" rel="noopener">参考博客地址</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Java中的多态&quot;&gt;&lt;a href=&quot;#Java中的多态&quot; class=&quot;headerlink&quot; title=&quot;Java中的多态&quot;&gt;&lt;/a&gt;Java中的多态&lt;/h2&gt;&lt;p&gt;多态是面向对象的三大核心概念之一。多态简单来讲就是父类引用指向子类对象。&lt;/p&gt;
&lt;p&gt;在Java中要实现多态需要满足三个必要条件：&lt;strong&gt;继承、重写、父类引用指向子类对象&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Parent p=new Child();&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;多态的引入带来了这写好处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;消除类型之间的耦合关系&lt;/li&gt;
&lt;li&gt;可替换性&lt;/li&gt;
&lt;li&gt;可扩充性&lt;/li&gt;
&lt;li&gt;接口性&lt;/li&gt;
&lt;li&gt;灵活性&lt;/li&gt;
&lt;li&gt;简化性&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="https://zofun.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="JVM" scheme="https://zofun.github.io/tags/JVM/"/>
    
      <category term="Java" scheme="https://zofun.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>MySQL主从复制</title>
    <link href="https://zofun.github.io/2020/04/16/MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
    <id>https://zofun.github.io/2020/04/16/MySQL主从复制/</id>
    <published>2020-04-16T09:28:00.000Z</published>
    <updated>2020-04-16T09:29:03.571Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="前言">前言</span></h2><p>随着业务的增长，一台数据服务器已经满足不了需求了，负载过重。这个时候就需要减压了，实现负载均衡读写分离，一主一丛或一主多从。</p><p>主服务器只负责写，而从服务器只负责写，从而提高了效率减轻压力。</p><p>主从复制有可以分为：</p><ul><li>主从同步：当用户写数据主服务器必须和从服务器同步了才告诉用户写入成功，等待时间比较长。</li><li>主从异步：只要用户访问写数据主服务器，立即返回给用户。</li><li>主从半同步：当用户访问写数据主服务器写入并同步<strong>其中一个从服务器</strong>就返回给用户成功</li></ul><a id="more"></a><h2><span id="主从复制的形式">主从复制的形式</span></h2><ol><li><p>一主一从</p><p> <img src="https://s1.ax1x.com/2020/04/16/Jk7ZVI.png" alt="Jk7ZVI.png"></p></li><li><p>一主多从</p></li></ol><p><img src="https://s1.ax1x.com/2020/04/16/Jk7mIP.png" alt="Jk7mIP.png"></p><ol start="3"><li>多主一从</li></ol><p><img src="https://s1.ax1x.com/2020/04/16/Jk71MQ.png" alt="Jk71MQ.png"></p><ol start="4"><li>双主复制</li></ol><p><img src="https://s1.ax1x.com/2020/04/16/Jk7UiV.png" alt="Jk7UiV.png"></p><ol start="5"><li>级联复制</li></ol><p><img src="https://pic4.zhimg.com/v2-be1bf038ce647dc46bf5abe5b4c48ad7_b.jpg" alt="img"></p><h2><span id="主从复制的基本原理">主从复制的基本原理</span></h2><p>MySQL复制是基于主服务器在二进制日志跟踪所有对数据库的更改。因此，要进行复制，必须在主服务器上启用二进制日志。每个从服务器从主服务器接收已经记录到日志的数据。当一个从服务器连接到主服务器时，它通知主服务器从服务器日志重读取最后一个更新成功的位置。从服务器接收从那时发生起的任何更新，并在主机上执行相同的更新。然后封锁等待主服务器通知的更新。从服务器执行备份不会干扰主服务器，在备份过程重主服务器可以继续处理更新。</p><h2><span id="主从复制的好处">主从复制的好处</span></h2><ol><li>主服务器出现问题，可以切换到从服务器</li><li>可以进行数据库层面的读写分离</li><li>可以在从数据库上进行日常备份</li></ol><h2><span id="复制过程">复制过程</span></h2><p><img src="https://s1.ax1x.com/2020/04/16/Jk7xyQ.png" alt="Jk7xyQ.png"></p><p>其中binary log是主服务器的二进制日志</p><p>relay log：从服务器的中继日志</p><p><strong>第一步：</strong>master在每个事务更新数据完成之前，将该记录串行的写入到binlog文件中。</p><p><strong>第二步：</strong>salve开启一个IO线程，该线程在master上打开一个普通连接，主要工作是处理binlog。如果读取进入已经跟上master，就进入睡眠状态等待master产生新的事件。IO线程的最终目的是将这些事件写入到中继日志中。</p><p><strong>第三步：</strong>SQL Thread会读取中继日志，并顺序执行该日志中的SQL事件，从而与主服务器中的数据保持一致。</p><h3><span id="建立请求的主从的详细流程">建立请求的主从的详细流程</span></h3><ol><li>当从服务器连接主服务器是，主服务器会创建一个log dump线程，用于发送binlog的内容。在读取binlog的内容的操作中，会对象主节点上的binlog加锁，当读取完成并发送给从服务器后解锁。</li><li>当从节点上执行<code>start slave</code>命令之后，从节点会创建一个IO线程用来连接主节点，请求主库中更新binlog。IO线程接收主节点binlog dump进程发来的更新之后，保持到relay-log中。</li><li>从节点SQL线程负责读取realy-log中的内容，解析成具体的操作执行，最终保证主从数据的一致性。</li></ol><h2><span id="两种不同的复制方式">两种不同的复制方式</span></h2><p>MySQL支持两种不同的日志格式，这两种日志格式也体现了各自的复制方式。</p><h3><span id="基于语句的复制">基于语句的复制</span></h3><p>基于语句的复制相当于逻辑复制，即二进制日志中记录了操作的语句，通过这些语句在从数据库中重放来实现复制。这种方式简单，二进制文件小，传输带宽占用小。但是基于语句更新依赖于其它因素，比如插入数据时利用了时间戳。因此在开发当中，我们应该尽量将业务逻辑逻辑放在代码层，而不应该放在MySQL中，不易拓展。</p><h3><span id="基于行数据">基于行数据</span></h3><p>基于行的复制相当于物理复制，即二进制日志中记录的时实际更新数据的每一行，这样导致复制的压力比较大，日志占用的空间大，传输带宽占用大。但是这种方式比基于语句的复制根据精确。</p><h2><span id="延迟问题">延迟问题</span></h2><p>当主库的TPS并发较高的时候，由于主库上面时多线程写入的，而从库的SQL线程是单线程的，导致从库SQL可能会跟不上主库的处理速度。</p><h3><span id="解决方案">解决方案</span></h3><ul><li>网络方面：尽量 保证主库和从库直接的网络稳定，延迟较小。</li><li>硬件方面：从库配置更好的硬件，提升随机写的性能。</li><li>配置方面：尽量使MySQL的操作在内存中完成，减少磁盘操作。或升级MySQL5.7版本使用并行复制。</li><li>建构方面：在事务中尽量对主库读写，其它非事务的读在从库。消除一部分延迟带来的数据库不一致。增加缓存降低一些从库的负载。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;随着业务的增长，一台数据服务器已经满足不了需求了，负载过重。这个时候就需要减压了，实现负载均衡读写分离，一主一丛或一主多从。&lt;/p&gt;
&lt;p&gt;主服务器只负责写，而从服务器只负责写，从而提高了效率减轻压力。&lt;/p&gt;
&lt;p&gt;主从复制有可以分为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主从同步：当用户写数据主服务器必须和从服务器同步了才告诉用户写入成功，等待时间比较长。&lt;/li&gt;
&lt;li&gt;主从异步：只要用户访问写数据主服务器，立即返回给用户。&lt;/li&gt;
&lt;li&gt;主从半同步：当用户访问写数据主服务器写入并同步&lt;strong&gt;其中一个从服务器&lt;/strong&gt;就返回给用户成功&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="https://zofun.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="MySQL" scheme="https://zofun.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>再读线程池源码</title>
    <link href="https://zofun.github.io/2020/04/13/%E5%86%8D%E8%AF%BB%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%BA%90%E7%A0%81/"/>
    <id>https://zofun.github.io/2020/04/13/再读线程池源码/</id>
    <published>2020-04-13T09:36:00.000Z</published>
    <updated>2020-04-13T09:36:39.779Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="概述">概述</span></h2><p>线程池故名思意就是存放线程的池子。线程是JVM的稀缺资源，使用线程池可以减少线程的创建和销毁的次数，<strong>降低系统的资源消耗</strong>。当有任务到达的时候，无效等待创建新的线程便能立即执行，<strong>提高了响应速度</strong>。使用线程池还可以<strong>方便对线程进行管理</strong>。</p><p><code>ThreadPoolExecuter</code>是线程池框架的一个核心类，下面就对<code>ThreadPoolExecuter</code>进行分析。</p><a id="more"></a><h2><span id="属性">属性</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程池的控制状态,用高3位来表示线程池的运行状态,低29位来表示线程池中工作线程的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line">    <span class="comment">//值为29,用来表示偏移量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line">    <span class="comment">//线程池的最大容量,其值的二进制为:00011111111111111111111111111111（29个1）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程池的运行状态，总共有5个状态，用高3位来表示</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//任务缓存队列，用来存放等待执行的任务</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//全局锁，对线程池状态等属性修改时需要使用这个锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程池中工作线程的集合，访问和修改需要持有全局锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> HashSet&lt;Worker&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition termination = mainLock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程池中曾经出现过的最大线程数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> largestPoolSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//已完成任务的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> completedTaskCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程工厂</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> ThreadFactory threadFactory;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//任务拒绝策略</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> RejectedExecutionHandler handler;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程存活时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> keepAliveTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//是否允许核心线程超时</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> allowCoreThreadTimeOut;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//核心池大小，若allowCoreThreadTimeOut被设置，核心线程全部空闲超时被回收的情况下会为0</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> corePoolSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最大池大小，不得超过CAPACITY</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> maximumPoolSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//默认的任务拒绝策略</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> RejectedExecutionHandler defaultHandler =</span><br><span class="line">        <span class="keyword">new</span> AbortPolicy();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> RuntimePermission shutdownPerm =</span><br><span class="line">        <span class="keyword">new</span> RuntimePermission(<span class="string">"modifyThread"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AccessControlContext acc;</span><br></pre></td></tr></table></figure><h3><span id="线程池的状态">线程池的状态</span></h3><p>通过<code>ThreadPoolExecutor</code>中的属性，我们可以知道线程池一共有五种状态。</p><ul><li>RUNNING: 当线程池处于当前状态时，能够接收新任务，并且能够对已添加的任务进行处理。</li><li>SHUTDOWN:当线程池处于当前状态，不能够接收新任务，但是能够处理已经添加的任务。</li><li>STOP：处于当前状态的线程池，不能接收新任务，不能处理已经收的任务，并且会中断正在处理的任务。</li><li>TIDYING：当所有任务已经终止，且<code>ctl</code>记录的任务数量为0时，线程池处于DIDYING状态。处于该状态的线程池会执行钩子函数<code>terminated()</code></li><li>TERMINATED：线程池彻底终止。</li></ul><p>线程池中<code>ctl</code>变量的高3位用来记录线程池的状态，低29位用来表示线程池中工作线程的个数。</p><h3><span id="拒绝策略">拒绝策略</span></h3><ul><li><code>AbortPolicy</code>：丢弃任务，并抛出<code>RejectedExecutionException</code>异常。</li><li><code>DiscardPolicy</code>:丢弃任务，不会抛出任务</li><li><code>DiscardOldestPolicy</code>：丢弃队列最前面的任务，然后重新提交被拒绝的任务。</li><li><code>CallerRunsPolicy</code>:由调用线程处理该任务</li></ul><p>当然我们也可以通过<code>RejectedExecutionHandler</code>接口自定义自己的拒绝策略。</p><h2><span id="核心方法">核心方法</span></h2><h3><span id="提交任务">提交任务</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="keyword">null</span>);</span><br><span class="line">        execute(ftask);</span><br><span class="line">        <span class="keyword">return</span> ftask;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>submit</code>方法中最终调用了<code>execute</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="comment">//获取线程池的状态变量</span></span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">       <span class="comment">//如果工作线程数小于核心线程数</span></span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">            <span class="comment">//创建worker</span></span><br><span class="line">            <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">           <span class="comment">//创建worker失败后再次获取线程池控制状态</span></span><br><span class="line">            c = ctl.get();</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">//如果线程池处于Running状态，就将任务加入阻塞队列</span></span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">            <span class="comment">// 再次检查，获取线程池控制状态，防止在任务入队的过程中线程池关闭了或者线程池中没有线程了</span></span><br><span class="line">            <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">            <span class="comment">//线程池不处于RUNNING状态，且将任务从workQueue移除成功</span></span><br><span class="line">            <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">                <span class="comment">//采取任务拒绝策略</span></span><br><span class="line">                reject(command);</span><br><span class="line">            <span class="comment">//worker数量等于0</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">                <span class="comment">//创建worker</span></span><br><span class="line">                addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//(3)</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))  <span class="comment">//创建worker</span></span><br><span class="line">            reject(command);  <span class="comment">//如果创建worker失败，采取任务拒绝策略</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>整个流程如下：</p><ul><li>如果线程池中的工作线程数小于corePoolSize，则创建新线程来执行任务</li><li>如果工作线程数量大于或等于corePoolSize，则将任务加入BlockingQueue</li><li>若无法将任务加入阻塞队列，且工作线程数小于最大线程数，则创建新的线程来执行任务</li><li>当工作线程数量达到最大线程数，则创建工作线程失败，采取任务拒绝策略</li></ul><p><img src="https://s1.ax1x.com/2020/04/13/GjhqSg.png" alt="GjhqSg.png"></p><h3><span id="创建线程">创建线程</span></h3><p>我们在<code>execute</code>方法的实现中可以看出、创建线程并执行任务由<code>addWorker</code>方法来负责，代码实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//addWorker有两个参数:Runnable类型的firstTask,用于指定新增的线程执行的第一个任务;boolean类型的core,表示是否创建核心线程</span></span><br><span class="line"><span class="comment">//该方法的返回值代表是否成功新增一个线程</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">        retry:</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">            <span class="comment">//获取线程池的当前运行状态</span></span><br><span class="line">            <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// (1)</span></span><br><span class="line">            <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">                ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">                   firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                   ! workQueue.isEmpty()))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">                <span class="comment">//线程数超标，不能再创建线程，直接返回</span></span><br><span class="line">                <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                    wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">//CAS操作递增workCount</span></span><br><span class="line">                <span class="comment">//如果成功，那么创建线程前的所有条件校验都满足了，准备创建线程执行任务，退出retry循环</span></span><br><span class="line">                <span class="comment">//如果失败，说明有其他线程也在尝试往线程池中创建线程(往线程池提交任务可以是并发的)，则继续往下执行</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                    <span class="keyword">break</span> retry;</span><br><span class="line">                <span class="comment">//重新获取线程池控制状态</span></span><br><span class="line">                c = ctl.get();</span><br><span class="line">                <span class="comment">// 如果线程池的状态发生了变更,如有其他线程关闭了这个线程池,那么需要回到外层的for循环</span></span><br><span class="line">                <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                    <span class="keyword">continue</span> retry;</span><br><span class="line">                <span class="comment">//如果只是CAS操作失败的话，进入内层的for循环就可以了</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//到这里，创建线程前的所有条件校验都满足了，可以开始创建线程来执行任务</span></span><br><span class="line">        <span class="comment">//worker是否已经启动</span></span><br><span class="line">        <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//是否已将这个worker添加到workers这个HashSet中</span></span><br><span class="line">        <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">        Worker w = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建一个worker，从这里可以看出对线程的包装</span></span><br><span class="line">            w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">            <span class="comment">//取出worker中的线程对象,Worker的构造方法会调用ThreadFactory来创建一个新的线程</span></span><br><span class="line">            <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">            <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//获取全局锁, 并发的访问线程池workers对象必须加锁,持有锁的期间线程池也不会被关闭</span></span><br><span class="line">                <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">                <span class="comment">//加锁</span></span><br><span class="line">                mainLock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//重新获取线程池的运行状态</span></span><br><span class="line">                    <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//小于SHUTTDOWN即RUNNING</span></span><br><span class="line">                    <span class="comment">//等于SHUTDOWN并且firstTask为null,不接受新的任务,但是会继续执行等待队列中的任务</span></span><br><span class="line">                    <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                        (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                        <span class="comment">//worker里面的thread不能是已启动的</span></span><br><span class="line">                        <span class="keyword">if</span> (t.isAlive())</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                       <span class="comment">//将新创建的线程加入到线程池中</span></span><br><span class="line">                        workers.add(w);</span><br><span class="line">                        <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                        <span class="comment">// 更新largestPoolSize</span></span><br><span class="line">                        <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                            largestPoolSize = s;</span><br><span class="line">                        workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    mainLock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//线程添加线程池成功，则启动新创建的线程</span></span><br><span class="line">                <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                    t.start();</span><br><span class="line">                    workerStarted = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//若线程启动失败,做一些清理工作,例如从workers中移除新添加的worker并递减wokerCount</span></span><br><span class="line">            <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">                addWorkerFailed(w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回线程是否启动成功</span></span><br><span class="line">        <span class="keyword">return</span> workerStarted;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>该方法主要完成这几件事情：</p><ul><li>原子性的增加workerCount</li><li>将用户给定的任务封装成为一个worker，并将此worker添加进workers集合中</li><li>启动worker对应的线程</li><li>若线程启动失败，回滚worker的创建动作，即从worker中溢出新添加的worker，并原子性的减少workerCount。</li></ul><h3><span id="工作线程">工作线程</span></h3><p>从之前的代码中，我们可以发现，线程池中正在执行任务的是worker对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span></span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br></pre></td></tr></table></figure><p>worker的属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用来封装worker的线程，线程池中真正运行的线程,通过线程工厂创建而来</span></span><br><span class="line">      <span class="keyword">final</span> Thread thread;</span><br><span class="line">      <span class="comment">//worker所对应的第一个任务，可能为空</span></span><br><span class="line">      Runnable firstTask;</span><br><span class="line">      <span class="comment">//记录当前线程完成的任务数</span></span><br><span class="line">      <span class="keyword">volatile</span> <span class="keyword">long</span> completedTasks;</span><br></pre></td></tr></table></figure><p>worker的构造器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Worker(Runnable firstTask) &#123;</span><br><span class="line">            <span class="comment">//设置AQS的state为-1，在执行runWorker()方法之前阻止线程中断</span></span><br><span class="line">            setState(-<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//初始化第一个任务</span></span><br><span class="line">            <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">            <span class="comment">//利用指定的线程工厂创建一个线程，注意，参数是Worker实例本身this</span></span><br><span class="line">            <span class="comment">//也就是当执行start方法启动线程thread时，真正执行的是Worker类的run方法</span></span><br><span class="line">            <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>worker类继承了AQS类，重写了其相应的方法，是实现了一个自定义的同步器，实现了不可重入锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//是否持有独占锁</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getState() != <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//尝试获取锁</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">//设置独占线程</span></span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//尝试释放锁</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//设置独占线程为null</span></span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">            setState(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取锁</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span>        </span>&#123; acquire(<span class="number">1</span>); &#125;</span><br><span class="line">        <span class="comment">//尝试获取锁</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span>  </span>&#123; <span class="keyword">return</span> tryAcquire(<span class="number">1</span>); &#125;</span><br><span class="line">        <span class="comment">//释放锁</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span>      </span>&#123; release(<span class="number">1</span>); &#125;</span><br><span class="line">        <span class="comment">//是否持有锁</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> isHeldExclusively(); &#125;</span><br></pre></td></tr></table></figure><p>worker类还提供了一个中断线程thread的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">interruptIfStarted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Thread t;</span><br><span class="line">            <span class="comment">//AQS状态大于等于0，worker对应的线程不为null，且该线程没有被中断</span></span><br><span class="line">            <span class="keyword">if</span> (getState() &gt;= <span class="number">0</span> &amp;&amp; (t = thread) != <span class="keyword">null</span> &amp;&amp; !t.isInterrupted()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    t.interrupt();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3><span id="线程复用机制">线程复用机制</span></h3><p>worker中的线程start后，实际上是调用的<code>runWorker</code>方法。 该方法实现了线程池中的线程复用机制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取当前线程</span></span><br><span class="line">        Thread wt = Thread.currentThread();</span><br><span class="line">        <span class="comment">//获取w的firstTask</span></span><br><span class="line">        Runnable task = w.firstTask;</span><br><span class="line">        <span class="comment">//设置w的firstTask为null</span></span><br><span class="line">        w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 释放锁，设置AQS的state为0，允许中断</span></span><br><span class="line">        w.unlock();</span><br><span class="line">        <span class="comment">//用于标识线程是否异常终止，finally中processWorkerExit()方法会有不同逻辑</span></span><br><span class="line">        <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//循环调用getTask()获取任务,不断从任务缓存队列获取任务并执行</span></span><br><span class="line">            <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//进入循环内部，代表已经获取到可执行的任务，则对worker对象加锁，保证线程在执行任务过程中不会被中断</span></span><br><span class="line">                w.lock();</span><br><span class="line">                <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||  <span class="comment">//若线程池状态大于等于STOP，那么意味着该线程要中断</span></span><br><span class="line">                     (Thread.interrupted() &amp;&amp;      <span class="comment">//线程被中断</span></span><br><span class="line">                      runStateAtLeast(ctl.get(), STOP))) &amp;&amp;  <span class="comment">//且是因为线程池内部状态变化而被中断</span></span><br><span class="line">                    !wt.isInterrupted())           <span class="comment">//确保该线程未被中断</span></span><br><span class="line">                    <span class="comment">//发出中断请求</span></span><br><span class="line">                    wt.interrupt();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//开始执行任务前的Hook方法</span></span><br><span class="line">                    beforeExecute(wt, task);</span><br><span class="line">                    Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//到这里正式开始执行任务</span></span><br><span class="line">                        task.run();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                        thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                        thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                        thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="comment">//执行任务后的Hook方法</span></span><br><span class="line">                        afterExecute(task, thrown);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//置空task，准备通过getTask()获取下一个任务</span></span><br><span class="line">                    task = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="comment">//completedTasks递增</span></span><br><span class="line">                    w.completedTasks++;</span><br><span class="line">                    <span class="comment">//释放掉worker持有的独占锁</span></span><br><span class="line">                    w.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//到这里，线程执行结束，需要执行结束线程的一些清理工作</span></span><br><span class="line">            <span class="comment">//线程执行结束可能有两种情况：</span></span><br><span class="line">            <span class="comment">//1.getTask()返回null，也就是说，这个worker的使命结束了，线程执行结束</span></span><br><span class="line">            <span class="comment">//2.任务执行过程中发生了异常</span></span><br><span class="line">            <span class="comment">//第一种情况，getTask()返回null，那么getTask()中会将workerCount递减</span></span><br><span class="line">            <span class="comment">//第二种情况，workerCount没有进行处理，这个递减操作会在processWorkerExit()中处理</span></span><br><span class="line">            processWorkerExit(w, completedAbruptly);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>该方法主要完成了这些事情：</p><ul><li>运行第一个任务<code>firstTask</code>之后，循环调用<code>getTask</code>方法从同步队列中获取任务并执行。</li><li>获取到任务就对worker对象加锁，保证线程在执行任务的过程中不会被中断，任务执行完会释放锁。</li><li>在执行任务的前后，可以根据业务场景重写<code>beforeExecute</code>和<code>afterExecute</code>等钩子函数。</li><li>线程执行结束后，调用<code>processWorkerExit</code>方法执行结束的一些清理工作。</li></ul><h3><span id="从队列中取任务">从队列中取任务</span></h3><p>从之前的源码中我们可以看出 <code>getTask</code>方法用来不断地从任务缓存队列中获取任务并交给线程执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//标识当前线程是否超时未能获取到task对象</span></span><br><span class="line">        <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//获取线程池的控制状态</span></span><br><span class="line">            <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">            <span class="comment">//获取线程池的运行状态</span></span><br><span class="line">            <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果线程池状态大于等于STOP，或者处于SHUTDOWN状态，并且阻塞队列为空，线程池工作线程数量递减，方法返回null，回收线程</span></span><br><span class="line">            <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">                decrementWorkerCount();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取worker数量</span></span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//标识当前线程在空闲时，是否应该超时回收</span></span><br><span class="line">            <span class="comment">// 如果allowCoreThreadTimeOut为ture，或当前线程数大于核心池大小，则需要超时回收</span></span><br><span class="line">            <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果worker数量大于maximumPoolSize(有可能调用了 setMaximumPoolSize(),导致worker数量大于maximumPoolSize)</span></span><br><span class="line">            <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))  <span class="comment">//或者获取任务超时</span></span><br><span class="line">                &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;  <span class="comment">//workerCount大于1或者阻塞队列为空（在阻塞队列不为空时，需要保证至少有一个工作线程）</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                    <span class="comment">//线程池工作线程数量递减，方法返回null，回收线程</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">//线程池工作线程数量递减失败，跳过剩余部分，继续循环</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//如果允许超时回收，则调用阻塞队列的poll()，只在keepAliveTime时间内等待获取任务，一旦超过则返回null</span></span><br><span class="line">                <span class="comment">//否则调用take()，如果队列为空，线程进入阻塞状态，无限时等待任务，直到队列中有可取任务或者响应中断信号退出</span></span><br><span class="line">                Runnable r = timed ?</span><br><span class="line">                    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                    workQueue.take();</span><br><span class="line">                <span class="comment">//若task不为null，则返回成功获取的task对象</span></span><br><span class="line">                <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> r;</span><br><span class="line">                <span class="comment">// 若返回task为null，表示线程空闲时间超时，则设置timeOut为true</span></span><br><span class="line">                timedOut = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">                <span class="comment">//如果此worker发生了中断，采取的方案是重试，没有超时</span></span><br><span class="line">                <span class="comment">//在哪些情况下会发生中断？调用setMaximumPoolSize()，shutDown()，shutDownNow()</span></span><br><span class="line">                timedOut = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>该方法在不同地情况下有不同地返回：</p><ol><li>线程池处于running状态，阻塞队列不为空，该方法返回task对象。</li><li>线程池处于shutdown状态，阻塞队列不为空，返回空间获取地task对象。</li><li>线程池状态大于等于stop状态，返回null，回收线程</li><li>线程池处于shutdown状态，阻塞队列位空，返回null，回收线程</li><li>worker数量大于最大线程数，返回null，回收线程。</li><li>线程空闲时间超时，返回null，回收线程。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;线程池故名思意就是存放线程的池子。线程是JVM的稀缺资源，使用线程池可以减少线程的创建和销毁的次数，&lt;strong&gt;降低系统的资源消耗&lt;/strong&gt;。当有任务到达的时候，无效等待创建新的线程便能立即执行，&lt;strong&gt;提高了响应速度&lt;/strong&gt;。使用线程池还可以&lt;strong&gt;方便对线程进行管理&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ThreadPoolExecuter&lt;/code&gt;是线程池框架的一个核心类，下面就对&lt;code&gt;ThreadPoolExecuter&lt;/code&gt;进行分析。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="https://zofun.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="源码" scheme="https://zofun.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="Java" scheme="https://zofun.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JVM之分代收集算法</title>
    <link href="https://zofun.github.io/2020/04/12/JVM%E4%B9%8B%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95/"/>
    <id>https://zofun.github.io/2020/04/12/JVM之分代收集算法/</id>
    <published>2020-04-12T11:52:00.000Z</published>
    <updated>2020-04-12T12:58:20.090Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="对象分类">对象分类</span></h2><p>JVM将对象分成不同的分代，然后根据每个分代的特点采取不同的垃圾回收算法。</p><ul><li>新生代：朝生夕灭的对象，比如方法的局部变量。</li><li>老年代：存活的比较久，但是还是要死的对象。比如缓存对象，单例对象等。</li><li>永久代：对象生成后几乎不灭的对象，例如加载过的类对象。</li></ul><p>永久代是在方法区/元空间。新生代和老年代是在堆区。</p><a id="more"></a><h2><span id="新生代的垃圾回收">新生代的垃圾回收</span></h2><p>新生代采用的是复制算法，因为新生代对象的存活率比价低，因此可以不使用50%的内存作为空闲。一般的，使用两块10%的内存作为空闲和活动空间，而另外80%的内存，则是用来分配给新建的对象的。一旦发生GC，就将10%的活动区间与另外的80%中内存转移到10%的空闲区间中，接下来90%的内存会被释放，以此类推。</p><p><img src="https://s1.ax1x.com/2020/04/11/GHH8fg.png" alt="GHH8fg.png"></p><h3><span id="hotspot实现的复制算法流程">HotSpot实现的复制算法流程</span></h3><ol><li>当Eden区满的时候，会触发第一次Minor gc，把还存活的对象复制到Survivor From区；当Eden区再次触发Minor gc的时候，会扫描Eden 区和Survivor From区，将存活的对象复制到Survivor To区，然后将Eden区和From区清空。</li><li>当后续Eden区又发生了Minor gc的时候，会堆Eden和To区域进行垃圾回收，存活的对象复制到From区域，并将Eden区和To区域清空。</li><li>部分对象会在From和To区域中复制来复制去，如此交换15次（可配置），最终如果还是存活，就存入到老年代。</li></ol><h3><span id="一个对象的内存分配过程">一个对象的内存分配过程</span></h3><p><img src="https://s1.ax1x.com/2020/04/12/GLtsG4.png" alt="GLtsG4.png"></p><h3><span id="什么是空间分配担保机制">什么是空间分配担保机制</span></h3><p>当发生minor gc的时候，JVM会首先检查老年代最大的可用连续空间是否运行大于最大新生代所有对象的总和，如果大于，那么这次YGC是安全的，如果不大于的话，JVM就需要判断HandlerpromotionFailure是否运行空间分配担保。</p><p>新生代采用的是复制算法，S0和S1始终只使用其中一块内存，当出现YGC后大部分的对象仍然存活的话，就需要老年代进行分配担保，把Survior区无法容纳的对象直接晋升到老年代。</p><p>那么这种空间分配担保的前提是老年代还有容纳的空间，一共有多少对象会活下来，再实际完成内存回收之前是无法明确知道的，所以只好取之前每次回收晋升到老年代对象容量的平均值最为经验值，与老年代的剩余空间做比较，决定是否进行Major GC来让老年代腾出更多的空间。</p><h3><span id="新生代收集器">新生代收集器</span></h3><h4><span id="serial收集器">Serial收集器</span></h4><p>它是一个单线程收集器，并且在工作的时候，需要暂停所有的工作线程（STW)，直到它收集结束。</p><p>优点：简单而高效，对于限定单个CPU的环境来说，Serial收集器由于没有线程切换的开销，效率较高。</p><p>缺点：需要停止用户线程。</p><p>适用环境：client模式下的默认新生代收集器。</p><h4><span id="parnew收集器">ParNew收集器</span></h4><p>它其实是Serial收集器的多线程版本，只能在新生代中使用。该收集器的并行度和CPU数量相同。</p><p>适用环境：Server模式下的默认新生代收集器。</p><h4><span id="parallel-scavenge收集器">Parallel Scavenge收集器</span></h4><p>它也是一种并行的新生代垃圾收集器。采用的是复制算法。</p><p>它的特点是可以达成一个可控的吞吐量。</p><h2><span id="老年代">老年代</span></h2><p>老年代一般采用的标记清除算法。标记清除算法可以分为两个步骤：</p><ul><li>标记过程：找到所有的可能访问的对象，做个指定的标记。</li><li>清除过程：遍历堆内存，把未标记的对象进行回收。</li></ul><h3><span id="老年代收集器">老年代收集器</span></h3><h4><span id="serial-old收集器">Serial Old收集器</span></h4><p>它是一个单线程的收集器，采用的标记整理算法，。</p><h4><span id="parallel-old收集器">Parallel Old收集器</span></h4><p>Pareller Old收集器的老年代版本，使用多线程和“标记-整理”算法。</p><p>在注重吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge加Paralllel Old收集器。</p><h4><span id="cms收集器">CMS收集器</span></h4><p>CMS是老年代收集器，在收集过程中可以与用户线程并发操作。CMS牺牲了系统的吞吐量来追求收集速度，适合追求垃圾收集速度的服务器上。</p><p>CMS处理过程有七个步骤：</p><ul><li>初始标记，会导致STW</li><li>并发标记，与用户线程同时运行</li><li>预清理，与用户线程同时运行</li><li>可被终止的预清理，与用户线程同时运行</li><li>重新标记，会导致STW</li><li>并发清除，与用户线程同时运行</li><li>并发重置状态等待下次CMS的触发，与用户线程同时运行。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;对象分类&quot;&gt;&lt;a href=&quot;#对象分类&quot; class=&quot;headerlink&quot; title=&quot;对象分类&quot;&gt;&lt;/a&gt;对象分类&lt;/h2&gt;&lt;p&gt;JVM将对象分成不同的分代，然后根据每个分代的特点采取不同的垃圾回收算法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;新生代：朝生夕灭的对象，比如方法的局部变量。&lt;/li&gt;
&lt;li&gt;老年代：存活的比较久，但是还是要死的对象。比如缓存对象，单例对象等。&lt;/li&gt;
&lt;li&gt;永久代：对象生成后几乎不灭的对象，例如加载过的类对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;永久代是在方法区/元空间。新生代和老年代是在堆区。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="https://zofun.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="JVM" scheme="https://zofun.github.io/tags/JVM/"/>
    
      <category term="Java" scheme="https://zofun.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>并发编程之volatile</title>
    <link href="https://zofun.github.io/2020/04/10/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8Bvolatile/"/>
    <id>https://zofun.github.io/2020/04/10/并发编程之volatile/</id>
    <published>2020-04-10T11:52:00.000Z</published>
    <updated>2020-04-10T11:52:36.541Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="volatile的定义和实现原理">volatile的定义和实现原理</span></h2><p>在Java语言规范中将volatile定义如下：Java编程语言允许线程访问共享变量，为了确保共享变量能被准确和一致的更新，线程应该通过排他锁单独获得这个变量。Java语言提供了volatile，在某型情况下比使用锁更加方便。如果一个字段被声明为volatile，Java线程内存模型确保所有线程看到这个变量的值是一致的。</p><a id="more"></a><p>当我们对有volatile修饰的变量进行写操作的时候，会在下一行汇编加一个<code>Lock</code>指令。</p><p><code>Lock</code>前缀的指令在多核处理器下会引起两件事情；</p><ol><li>将当前处理器缓存行写回到系统内存</li><li>这个写回的操作会使其它CPU里缓存了该内存地址的数据无效。</li></ol><h2><span id="volatile的内存语义">volatile的内存语义</span></h2><p><strong>锁的happens-before规则保证释放锁和获取锁的两个线程之间的内存可见性</strong>，这意味着对一个volatile变量的读，总是能看到对这个volatile变量最后的写入。</p><p><strong>锁的语义决定了临界区代码的执行具有原子性。</strong>这意味着，即使使64位的long型和double型变量，只要它使volatile变量，最该变量的读/写具有原子性。</p><p>volatile变量自身具有以下特性：</p><ul><li>可见性。对一个volatile变量的读，总是能看到对这个volatile变量最后的写入。</li><li>原子性：对任意单个volatile变量的读/写具有原子性，当类似于volatile++这种复合操作不具有原子性。</li></ul><p><strong>volatile写的内存语义</strong>如下：</p><ul><li>当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存。</li></ul><p><strong>volatile读的内存语义</strong>如下：</p><ul><li>当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效。</li></ul><h3><span id="volatile内存语义的实现">volatile内存语义的实现</span></h3><p>为了实现volatile内存语义，JMM会分别限制这两种类型的重排序。为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。</p><ul><li>在每个volatile写操作之前插入一个StoreStore屏障</li><li>在每个volatile写操作的后面插入一个StoreLoad屏障</li><li>在每个volatile读操作的后面插入一个LoadLoad屏障</li><li>在每个volatile读操作的后面插入一个LoadStore屏障。</li></ul><h2><span id="volatile的使用优化">volatile的使用优化</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 队列中的头部节点 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> f?inal PaddedAtomicReference&lt;QNode&gt; head;</span><br><span class="line"><span class="comment">/** 队列中的尾部节点 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> f?inal PaddedAtomicReference&lt;QNode&gt; tail;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PaddedAtomicReference</span> &lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AtomicReference</span> <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"><span class="comment">// 使用很多4个字节的引用追加到64个字节</span></span><br><span class="line">Object p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, pa, pb, pc, pd, pe;</span><br><span class="line">PaddedAtomicReference(T r) &#123;</span><br><span class="line"><span class="keyword">super</span>(r);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicReference</span> &lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> V value;</span><br><span class="line"><span class="comment">// 省略其他代码</span></span><br><span class="line">｝</span><br></pre></td></tr></table></figure><p>在上面这段代码中，通过追加字节来优化系统的性能。这是因为在目前多少的CPU中，缓存行的宽度为64字节，如果队列头节点和尾节点都不足64字节的话，那么处理器就会将头接点和尾节点读入同一个缓存行中，当一个处理器试图修改头节点的时候，将会把整个缓存行锁定，在缓存一致性的机制的作用下，会导致其它处理器不能访问自己高速缓存中的尾节点。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;volatile的定义和实现原理&quot;&gt;&lt;a href=&quot;#volatile的定义和实现原理&quot; class=&quot;headerlink&quot; title=&quot;volatile的定义和实现原理&quot;&gt;&lt;/a&gt;volatile的定义和实现原理&lt;/h2&gt;&lt;p&gt;在Java语言规范中将volatile定义如下：Java编程语言允许线程访问共享变量，为了确保共享变量能被准确和一致的更新，线程应该通过排他锁单独获得这个变量。Java语言提供了volatile，在某型情况下比使用锁更加方便。如果一个字段被声明为volatile，Java线程内存模型确保所有线程看到这个变量的值是一致的。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="https://zofun.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Java" scheme="https://zofun.github.io/tags/Java/"/>
    
      <category term="多线程" scheme="https://zofun.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>多线程之连续打印ABC</title>
    <link href="https://zofun.github.io/2020/04/07/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E8%BF%9E%E7%BB%AD%E6%89%93%E5%8D%B0ABC/"/>
    <id>https://zofun.github.io/2020/04/07/多线程之连续打印ABC/</id>
    <published>2020-04-07T02:50:00.000Z</published>
    <updated>2020-04-07T02:50:10.239Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="题目">题目</span></h2><p>实例化三个线程，一个线程打印a，一个线程打印b，一个线程打印c，三个线程同时执行，要求打印出10个连着的abc。</p><p>问题为三线程间的同步唤醒操作，主要的目的就是使程序按ThreadA-&gt;ThreadB-&gt;ThreadC-&gt;ThreadA循环执行三个线程</p><a id="more"></a><h3><span id="使用两个锁来实现">使用两个锁来实现</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RcSyncPrinter</span>  </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Printer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Object preLock;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Object lock;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> printChar;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Printer</span><span class="params">(Object preLock, Object lock, <span class="keyword">char</span> printChar)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.preLock = preLock;</span><br><span class="line">            <span class="keyword">this</span>.lock = lock;</span><br><span class="line">            <span class="keyword">this</span>.printChar = printChar;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (preLock)&#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">                        System.out.println(printChar);</span><br><span class="line">                        lock.notifyAll();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(i &lt; <span class="number">10</span> - <span class="number">1</span>)&#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="comment">// 通过preLock等待被唤醒</span></span><br><span class="line">                            preLock.wait();</span><br><span class="line"></span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Object lockA = <span class="keyword">new</span> Object();</span><br><span class="line">        <span class="keyword">final</span> Object lockB = <span class="keyword">new</span> Object();</span><br><span class="line">        <span class="keyword">final</span> Object lockC = <span class="keyword">new</span> Object();</span><br><span class="line">        Printer printerA = <span class="keyword">new</span> Printer(lockC, lockA,  <span class="string">'A'</span>);</span><br><span class="line">        Printer printerB = <span class="keyword">new</span> Printer(lockA, lockB, <span class="string">'B'</span>);</span><br><span class="line">        Printer printerC = <span class="keyword">new</span> Printer(lockB, lockC, <span class="string">'C'</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(printerA).start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(printerB).start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(printerC).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> RcSyncPrinter syncPrinter = <span class="keyword">new</span> RcSyncPrinter();</span><br><span class="line">        syncPrinter.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="使用一个锁和状态变量实现推荐写法">使用一个锁和状态变量实现(推荐写法)</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RcSyncPrinter</span>  </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//状态变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Printer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//打印锁</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Object lock;</span><br><span class="line">        <span class="comment">//打印状态</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> printState;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> nextPrintState;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> printChar;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Printer</span><span class="params">(Object lock, <span class="keyword">int</span> printState, <span class="keyword">int</span> nextPrintState, <span class="keyword">char</span> printChar)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.lock = lock;</span><br><span class="line">            <span class="keyword">this</span>.printState = printState;</span><br><span class="line">            <span class="keyword">this</span>.nextPrintState = nextPrintState;</span><br><span class="line">            <span class="keyword">this</span>.printChar = printChar;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">                    <span class="keyword">while</span> (state!=printState)&#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            lock.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(printChar);</span><br><span class="line">                    state=nextPrintState;</span><br><span class="line">                    lock.notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">        Printer printerA = <span class="keyword">new</span> Printer(lock, <span class="number">1</span>, <span class="number">2</span>, <span class="string">'A'</span>);</span><br><span class="line">        Printer printerB = <span class="keyword">new</span> Printer(lock, <span class="number">2</span>, <span class="number">3</span>, <span class="string">'B'</span>);</span><br><span class="line">        Printer printerC = <span class="keyword">new</span> Printer(lock, <span class="number">3</span>, <span class="number">1</span>, <span class="string">'C'</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(printerA).start();</span><br><span class="line">        <span class="comment">//Thread.sleep(1000);</span></span><br><span class="line">        <span class="keyword">new</span> Thread(printerB).start();</span><br><span class="line">        <span class="comment">//Thread.sleep(1000);</span></span><br><span class="line">        <span class="keyword">new</span> Thread(printerC).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> RcSyncPrinter syncPrinter = <span class="keyword">new</span> RcSyncPrinter();</span><br><span class="line">        syncPrinter.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="通过一个reentrantlock和三个conditon实现推荐">通过一个ReentrantLock和三个conditon实现(推荐)</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RcSyncPrinter</span>  </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Printer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">private</span> ReentrantLock lock;</span><br><span class="line">       <span class="keyword">private</span> Condition thisCondition;</span><br><span class="line">       <span class="keyword">private</span> Condition  nextCondition;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> printChar;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Printer</span><span class="params">(ReentrantLock lock, Condition thisCondition, Condition nextCondition, <span class="keyword">char</span> printChar)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.lock = lock;</span><br><span class="line">            <span class="keyword">this</span>.thisCondition = thisCondition;</span><br><span class="line">            <span class="keyword">this</span>.nextCondition = nextCondition;</span><br><span class="line">            <span class="keyword">this</span>.printChar = printChar;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                    System.out.println(printChar);</span><br><span class="line">                    nextCondition.signalAll();</span><br><span class="line">                    <span class="keyword">if</span> (i &lt; <span class="number">9</span>) &#123;</span><br><span class="line">                        thisCondition.await();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        <span class="keyword">final</span> Condition conditionA = lock.newCondition();</span><br><span class="line">        <span class="keyword">final</span> Condition conditionB = lock.newCondition();</span><br><span class="line">        <span class="keyword">final</span> Condition conditionC = lock.newCondition();</span><br><span class="line">        <span class="keyword">final</span> Object lockA = <span class="keyword">new</span> Object();</span><br><span class="line">        <span class="keyword">final</span> Object lockB = <span class="keyword">new</span> Object();</span><br><span class="line">        <span class="keyword">final</span> Object lockC = <span class="keyword">new</span> Object();</span><br><span class="line">        Printer printerA = <span class="keyword">new</span> Printer(lock, conditionA,conditionB,<span class="string">'A'</span>);</span><br><span class="line">        Printer printerB = <span class="keyword">new</span> Printer(lock, conditionB, conditionC,<span class="string">'B'</span>);</span><br><span class="line">        Printer printerC = <span class="keyword">new</span> Printer(lock, conditionC, conditionA,<span class="string">'C'</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(printerA).start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(printerB).start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(printerC).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> RcSyncPrinter syncPrinter = <span class="keyword">new</span> RcSyncPrinter();</span><br><span class="line">        syncPrinter.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;实例化三个线程，一个线程打印a，一个线程打印b，一个线程打印c，三个线程同时执行，要求打印出10个连着的abc。&lt;/p&gt;
&lt;p&gt;问题为三线程间的同步唤醒操作，主要的目的就是使程序按ThreadA-&amp;gt;ThreadB-&amp;gt;ThreadC-&amp;gt;ThreadA循环执行三个线程&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="https://zofun.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Java" scheme="https://zofun.github.io/tags/Java/"/>
    
      <category term="多线程" scheme="https://zofun.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>算法之DFS</title>
    <link href="https://zofun.github.io/2020/04/05/%E7%AE%97%E6%B3%95%E4%B9%8BDFS/"/>
    <id>https://zofun.github.io/2020/04/05/算法之DFS/</id>
    <published>2020-04-05T12:06:00.000Z</published>
    <updated>2020-04-05T12:07:03.122Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="dfs">DFS</span></h2><p>深度优先搜索是在得到一个新节点时立即堆新节点进行遍历。DFS常用来求解这种可达性问题。</p><p>在实现DFS时需要考虑以下两个问题：</p><ul><li>栈，使用栈来保存当前节点信息，当遍历新节点返回时能够继续遍历当前节点。可以使用递归栈。</li><li>标记：需要记录那些节点已经遍历过了。</li></ul><h3><span id="695-岛屿的最大面积">695. 岛屿的最大面积</span></h3><p>给定一个包含了一些 0 和 1 的非空二维数组 grid 。</p><p>一个 岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在水平或者竖直方向上相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。</p><p>找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为 0 。)</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[[0,0,1,0,0,0,0,1,0,0,0,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,1,1,1,0,0,0],</span><br><span class="line"> [0,1,1,0,1,0,0,0,0,0,0,0,0],</span><br><span class="line"> [0,1,0,0,1,1,0,0,1,0,1,0,0],</span><br><span class="line"> [0,1,0,0,1,1,0,0,1,1,1,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,0,0,0,1,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,1,1,1,0,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,1,1,0,0,0,0]]</span><br></pre></td></tr></table></figure><p>对于上面这个给定矩阵应返回 6。注意答案不应该是 11 ，因为岛屿只能包含水平或垂直的四个方向的 1 。</p><h4><span id="解法">解法</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[][] direction=&#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">  <span class="keyword">int</span> m,n;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(grid.length==<span class="number">0</span>||grid[<span class="number">0</span>].length==<span class="number">0</span>)&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      m=grid.length;</span><br><span class="line">      n=grid[<span class="number">0</span>].length;</span><br><span class="line">      <span class="keyword">int</span> maxArea=<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">              maxArea=Math.max(maxArea,dfs(grid,i,j));</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> maxArea;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] grid,<span class="keyword">int</span> r,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(r&lt;<span class="number">0</span>||r&gt;m||c&lt;<span class="number">0</span>||c&gt;n||grid[r][c]==<span class="number">0</span>)&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">int</span> area=<span class="number">1</span>; <span class="comment">//（r，c）为陆地</span></span><br><span class="line">      grid[r][c]=<span class="number">0</span>;<span class="comment">//标记为已经遍历</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span>[] d : direction) &#123;</span><br><span class="line">        area+=dfs(grid, r+d[<span class="number">0</span>], c+d[<span class="number">1</span>]);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> area;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/max-area-of-island/" target="_blank" rel="noopener">leetcode原题地址</a></p><a id="more"></a><h3><span id="200-岛屿的数量">200. 岛屿的数量</span></h3><p>给定一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">11000</span><br><span class="line">11000</span><br><span class="line">00100</span><br><span class="line">00011</span><br><span class="line"></span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/number-of-islands/" target="_blank" rel="noopener">leetcode原题地址</a></p><h4><span id="解法">解法</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[][] direction=&#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">  <span class="keyword">int</span> m,n;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(grid.length==<span class="number">0</span>||grid[<span class="number">0</span>].length==<span class="number">0</span>)&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      m=grid.length;</span><br><span class="line">      n=grid[<span class="number">0</span>].length;</span><br><span class="line">      <span class="keyword">int</span> isLand=<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">              <span class="keyword">if</span> (grid[i][j]!=<span class="string">'0'</span>)&#123;</span><br><span class="line">                  dfs(grid,i,j);</span><br><span class="line">              &#125;</span><br><span class="line">              isLand++;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> isLand;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] grid,<span class="keyword">int</span> r,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(r&lt;<span class="number">0</span>||r&gt;=m||c&lt;<span class="number">0</span>||c&gt;=n||grid[r][c]==<span class="string">'0'</span>)&#123;</span><br><span class="line">          <span class="keyword">return</span> ;</span><br><span class="line">      &#125;</span><br><span class="line">      grid[r][c]=<span class="string">'0'</span>;<span class="comment">//标记为已经遍历</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span>[] d : direction) &#123;</span><br><span class="line">        dfs(grid, r+d[<span class="number">0</span>], c+d[<span class="number">1</span>]);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3><span id="朋友圈">朋友圈</span></h3><p>班上有 N 名学生。其中有些人是朋友，有些则不是。他们的友谊具有是传递性。如果已知 A 是 B 的朋友，B 是 C 的朋友，那么我们可以认为 A 也是 C 的朋友。所谓的朋友圈，是指所有朋友的集合。</p><p>给定一个 N * N 的矩阵 M，表示班级中学生之间的朋友关系。如果M[i][j] = 1，表示已知第 i 个和 j 个学生互为朋友关系，否则为不知道。你必须输出所有学生中的已知的朋友圈总数。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">[[1,1,0],</span><br><span class="line"> [1,1,0],</span><br><span class="line"> [0,0,1]]</span><br><span class="line">输出: 2 </span><br><span class="line">说明：已知学生0和学生1互为朋友，他们在一个朋友圈。</span><br><span class="line">第2个学生自己在一个朋友圈。所以返回2.</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/friend-circles/" target="_blank" rel="noopener">leetcode原题地址</a></p><h4><span id="解法">解法</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="keyword">int</span>[][] M)</span> </span>&#123;</span><br><span class="line">    n=M.length;</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span>[] hasVisited=<span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!hasVisited[i])&#123;</span><br><span class="line">            dfs(M,hasVisited,i);</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] arr,<span class="keyword">boolean</span>[] hasVisited,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    hasVisited[i]=<span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;n;k++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i][k]==<span class="number">1</span>&amp;&amp;!hasVisited[k])&#123;</span><br><span class="line"></span><br><span class="line">            dfs(arr,hasVisited,k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="130-被围绕的区域">130. 被围绕的区域</span></h3><p>给定一个二维的矩阵，包含 ‘X’ 和 ‘O’（字母 O）。</p><p>找到所有被 ‘X’ 围绕的区域，并将这些区域里所有的 ‘O’ 用 ‘X’ 填充。</p><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X X X X</span><br><span class="line">X O O X</span><br><span class="line">X X O X</span><br><span class="line">X O X X</span><br></pre></td></tr></table></figure><p>运行你的函数后，矩阵变为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X X X X</span><br><span class="line">X X X X</span><br><span class="line">X X X X</span><br><span class="line">X O X X</span><br></pre></td></tr></table></figure><p>解释:</p><p>被围绕的区间不会存在于边界上，换句话说，任何边界上的 ‘O’ 都不会被填充为 ‘X’。 任何不在边界上，或不与边界上的 ‘O’ 相连的 ‘O’ 最终都会被填充为 ‘X’。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。</p><p><a href="https://leetcode-cn.com/problems/surrounded-regions/" target="_blank" rel="noopener">leetcode原题地址</a></p><h4><span id="解法">解法</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> m;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span>[][] direction=&#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (board == <span class="keyword">null</span> || board.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        m = board.length;</span><br><span class="line">        n = board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            dfs(board, i, <span class="number">0</span>);</span><br><span class="line">            dfs(board, i, n - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dfs(board, <span class="number">0</span>, i);</span><br><span class="line">            dfs(board, m - <span class="number">1</span>, i);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">'T'</span>) &#123;</span><br><span class="line">                    board[i][j] = <span class="string">'O'</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (board[i][j] == <span class="string">'O'</span>) &#123;</span><br><span class="line">                    board[i][j] = <span class="string">'X'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (r &lt; <span class="number">0</span> || r &gt;= m || c &lt; <span class="number">0</span> || c &gt;= n || board[r][c] != <span class="string">'O'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;board[r][c] = <span class="string">'T'</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] d : direction) &#123;</span><br><span class="line">            dfs(board, r + d[<span class="number">0</span>], c + d[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3><span id="417-太平洋大西洋水流问题">417. 太平洋大西洋水流问题</span></h3><p>给定一个 m x n 的非负整数矩阵来表示一片大陆上各个单元格的高度。“太平洋”处于大陆的左边界和上边界，而“大西洋”处于大陆的右边界和下边界。</p><p>规定水流只能按照上、下、左、右四个方向流动，且只能从高到低或者在同等高度上流动。</p><p>请找出那些水流既可以流动到“太平洋”，又能流动到“大西洋”的陆地单元的坐标。</p><p>提示：</p><pre><code>输出坐标的顺序不重要m 和 n 都小于150</code></pre><p>示例：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">给定下面的 5x5 矩阵:</span><br><span class="line"></span><br><span class="line">  太平洋 ~   ~   ~   ~   ~ </span><br><span class="line">       ~  1   2   2   3  (5) *</span><br><span class="line">       ~  3   2   3  (4) (4) *</span><br><span class="line">       ~  2   4  (5)  3   1  *</span><br><span class="line">       ~ (6) (7)  1   4   5  *</span><br><span class="line">       ~ (5)  1   1   2   4  *</span><br><span class="line">          *   *   *   *   * 大西洋</span><br><span class="line"></span><br><span class="line">返回:</span><br><span class="line"></span><br><span class="line">[[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] (上图中带括号的单元).</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/pacific-atlantic-water-flow/" target="_blank" rel="noopener">leetcode原题地址</a></p><h4><span id="解法">解法</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> m, n;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[][] matrix;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[][] direction = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pacificAtlantic(<span class="keyword">int</span>[][] matrix) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ret = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    m = matrix.length;</span><br><span class="line">    n = matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">this</span>.matrix = matrix;</span><br><span class="line">    <span class="keyword">boolean</span>[][] canReachP = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">    <span class="keyword">boolean</span>[][] canReachA = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        dfs(i, <span class="number">0</span>, canReachP);</span><br><span class="line">        dfs(i, n - <span class="number">1</span>, canReachA);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        dfs(<span class="number">0</span>, i, canReachP);</span><br><span class="line">        dfs(m - <span class="number">1</span>, i, canReachA);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (canReachP[i][j] &amp;&amp; canReachA[i][j]) &#123;</span><br><span class="line">                ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                list.add(i);</span><br><span class="line">                list.add(j);</span><br><span class="line">                ret.add(list);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> c, <span class="keyword">boolean</span>[][] canReach)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (canReach[r][c]) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    canReach[r][c] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] d : direction) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextR = d[<span class="number">0</span>] + r;</span><br><span class="line">        <span class="keyword">int</span> nextC = d[<span class="number">1</span>] + c;</span><br><span class="line">        <span class="keyword">if</span> (nextR &lt; <span class="number">0</span> || nextR &gt;= m || nextC &lt; <span class="number">0</span> || nextC &gt;= n</span><br><span class="line">                || matrix[r][c] &gt; matrix[nextR][nextC]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(nextR, nextC, canReach);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;DFS&quot;&gt;&lt;a href=&quot;#DFS&quot; class=&quot;headerlink&quot; title=&quot;DFS&quot;&gt;&lt;/a&gt;DFS&lt;/h2&gt;&lt;p&gt;深度优先搜索是在得到一个新节点时立即堆新节点进行遍历。DFS常用来求解这种可达性问题。&lt;/p&gt;
&lt;p&gt;在实现DFS时需要考虑以下两个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;栈，使用栈来保存当前节点信息，当遍历新节点返回时能够继续遍历当前节点。可以使用递归栈。&lt;/li&gt;
&lt;li&gt;标记：需要记录那些节点已经遍历过了。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;695-岛屿的最大面积&quot;&gt;&lt;a href=&quot;#695-岛屿的最大面积&quot; class=&quot;headerlink&quot; title=&quot;695. 岛屿的最大面积&quot;&gt;&lt;/a&gt;695. 岛屿的最大面积&lt;/h3&gt;&lt;p&gt;给定一个包含了一些 0 和 1 的非空二维数组 grid 。&lt;/p&gt;
&lt;p&gt;一个 岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在水平或者竖直方向上相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。&lt;/p&gt;
&lt;p&gt;找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为 0 。)&lt;/p&gt;
&lt;p&gt;示例 1:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[[0,0,1,0,0,0,0,1,0,0,0,0,0],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; [0,0,0,0,0,0,0,1,1,1,0,0,0],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; [0,1,1,0,1,0,0,0,0,0,0,0,0],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; [0,1,0,0,1,1,0,0,1,0,1,0,0],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; [0,1,0,0,1,1,0,0,1,1,1,0,0],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; [0,0,0,0,0,0,0,0,0,0,1,0,0],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; [0,0,0,0,0,0,0,1,1,1,0,0,0],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; [0,0,0,0,0,0,0,1,1,0,0,0,0]]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;对于上面这个给定矩阵应返回 6。注意答案不应该是 11 ，因为岛屿只能包含水平或垂直的四个方向的 1 。&lt;/p&gt;
&lt;h4 id=&quot;解法&quot;&gt;&lt;a href=&quot;#解法&quot; class=&quot;headerlink&quot; title=&quot;解法&quot;&gt;&lt;/a&gt;解法&lt;/h4&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[][] direction=&amp;#123;&amp;#123;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&amp;#125;,&amp;#123;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&amp;#125;,&amp;#123;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&amp;#125;,&amp;#123;-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&amp;#125;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; m,n;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;maxAreaOfIsland&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[][] grid)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(grid.length==&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;||grid[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;].length==&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      m=grid.length;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      n=grid[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;].length;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; maxArea=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;i&amp;lt;m;i++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;j&amp;lt;n;j++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              maxArea=Math.max(maxArea,dfs(grid,i,j));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; maxArea;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;dfs&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[][] grid,&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; r,&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; c)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(r&amp;lt;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;||r&amp;gt;m||c&amp;lt;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;||c&amp;gt;n||grid[r][c]==&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; area=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;//（r，c）为陆地&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      grid[r][c]=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;//标记为已经遍历&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[] d : direction) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        area+=dfs(grid, r+d[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;], c+d[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; area;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/max-area-of-island/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;leetcode原题地址&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="https://zofun.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Java" scheme="https://zofun.github.io/tags/Java/"/>
    
      <category term="算法" scheme="https://zofun.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法之栈和队列</title>
    <link href="https://zofun.github.io/2020/04/04/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    <id>https://zofun.github.io/2020/04/04/算法之栈和队列/</id>
    <published>2020-04-04T13:29:00.000Z</published>
    <updated>2020-04-04T12:53:26.089Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="栈和队列">栈和队列</span></h2><h3><span id="232用栈实现队列">232.用栈实现队列</span></h3><p>使用栈实现队列的下列操作：</p><pre><code>push(x) -- 将一个元素放入队列的尾部。pop() -- 从队列首部移除元素。peek() -- 返回队列首部的元素。empty() -- 返回队列是否为空。</code></pre><p>示例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MyQueue queue = <span class="keyword">new</span> MyQueue();</span><br><span class="line"></span><br><span class="line">queue.push(<span class="number">1</span>);</span><br><span class="line">queue.push(<span class="number">2</span>);  </span><br><span class="line">queue.peek();  <span class="comment">// 返回 1</span></span><br><span class="line">queue.pop();   <span class="comment">// 返回 1</span></span><br><span class="line">queue.empty(); <span class="comment">// 返回 false</span></span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/implement-queue-using-stacks/" target="_blank" rel="noopener">leetcode原题地址</a></p><a id="more"></a><h4><span id="解法">解法</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; in;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; out;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Initialize your data structure here.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            in=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">            out=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Push element x to the back of queue.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        in.push(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Removes the element from in front of queue and returns that element.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(out.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span> (!in.isEmpty())&#123;</span><br><span class="line">                out.push(in.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> out.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get the front element.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(out.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span> (!in.isEmpty())&#123;</span><br><span class="line">                out.push(in.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> out.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns whether the queue is empty.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> in.isEmpty()&amp;&amp;out.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="225-用队列实现栈">225. 用队列实现栈</span></h3><p>使用队列实现栈的下列操作：</p><pre><code>push(x) -- 元素 x 入栈pop() -- 移除栈顶元素top() -- 获取栈顶元素empty() -- 返回栈是否为空</code></pre><p>注意:</p><pre><code>你只能使用队列的基本操作-- 也就是 push to back, peek/pop from front, size, 和 is empty 这些操作是合法的。你所使用的语言也许不支持队列。 你可以使用 list 或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。你可以假设所有操作都是有效的（例如, 对一个空的栈不会调用 pop 或者 top 操作）。</code></pre><p><a href="https://leetcode-cn.com/problems/implement-stack-using-queues/" target="_blank" rel="noopener">leetcode原题地址</a></p><h4><span id="解法">解法</span></h4><p>在将一个元素 x 插入队列时，为了维护原来的后进先出顺序，需要让 x 插入队列首部。而队列的默认插入顺序是队列<br>尾部，因此在将 x 插入队列尾部之后，需要让除了 x 之外的所有元素出队列，再入队列。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Queue&lt;Integer&gt; queue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        queue=<span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Push element x onto stack. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        queue.add(x);</span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size-<span class="number">1</span>;i++ )&#123;</span><br><span class="line">            queue.add(queue.poll());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Removes the element on top of the stack and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> queue.poll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Get the top element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> queue.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns whether the stack is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> queue.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="155-最小栈">155. 最小栈</span></h3><p>设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。</p><pre><code>push(x) -- 将元素 x 推入栈中。pop() -- 删除栈顶的元素。top() -- 获取栈顶元素。getMin() -- 检索栈中的最小元素。</code></pre><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MinStack minStack = new MinStack();</span><br><span class="line">minStack.push(-2);</span><br><span class="line">minStack.push(0);</span><br><span class="line">minStack.push(-3);</span><br><span class="line">minStack.getMin();   --&gt; 返回 -3.</span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();      --&gt; 返回 0.</span><br><span class="line">minStack.getMin();   --&gt; 返回 -2.</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/min-stack/" target="_blank" rel="noopener">leetcode原题地址</a></p><h4><span id="解法">解法</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stack;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; minStack;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> min;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        minStack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        min=Integer.MAX_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        stack.push(x);</span><br><span class="line">        min=Math.min(min,x);</span><br><span class="line">        minStack.push(min);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        minStack.pop();</span><br><span class="line">        stack.pop();</span><br><span class="line">        min=minStack.isEmpty()?Integer.MAX_VALUE:minStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="20-有效的括号">20. 有效的括号</span></h3><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</p><p>有效字符串需满足：</p><pre><code>左括号必须用相同类型的右括号闭合。左括号必须以正确的顺序闭合。</code></pre><p>注意空字符串可被认为是有效字符串。</p><p><a href="https://leetcode-cn.com/problems/valid-parentheses/" target="_blank" rel="noopener">leetcode原题地址</a></p><h4><span id="解法">解法</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">       </span><br><span class="line">       Stack&lt;Character&gt; stack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;chars.length;i++)&#123;</span><br><span class="line">           <span class="keyword">char</span> ch=chars[i];</span><br><span class="line">           <span class="keyword">if</span>(ch==<span class="string">'('</span>||ch==<span class="string">'&#123;'</span>||ch==<span class="string">'['</span>)&#123;</span><br><span class="line">               stack.push(ch);</span><br><span class="line">           &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">if</span>(stack.isEmpty())&#123;</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">char</span> cStack = stack.pop();</span><br><span class="line">               <span class="keyword">boolean</span> b1 = ch == <span class="string">')'</span> &amp;&amp; cStack != <span class="string">'('</span>;</span><br><span class="line">               <span class="keyword">boolean</span> b2 = ch == <span class="string">']'</span> &amp;&amp; cStack != <span class="string">'['</span>;</span><br><span class="line">               <span class="keyword">boolean</span> b3 = ch == <span class="string">'&#125;'</span> &amp;&amp; cStack != <span class="string">'&#123;'</span>;</span><br><span class="line">               <span class="keyword">if</span> (b1 || b2 || b3) &#123;</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3><span id="739-每日温度">739. 每日温度</span></h3><p>根据每日 气温 列表，请重新生成一个列表，对应位置的输出是需要再等待多久温度才会升高超过该日的天数。如果之后都不会升高，请在该位置用 0 来代替。</p><p>例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。</p><p>提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。</p><p><a href="https://leetcode-cn.com/problems/daily-temperatures/" target="_blank" rel="noopener">leetcode原题地址</a></p><h4><span id="解法">解法</span></h4><p>在遍历数组时用栈把数组中的数存起来，如果当前遍历的数比栈顶元素来的大，说明栈顶元素的下一个比它大的数就是当前元素。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] dailyTemperatures(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line">    Stack&lt;Integer&gt; indexs=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] result=<span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span> (!indexs.isEmpty()&amp;&amp;arr[i]&gt;arr[indexs.peek()])&#123;</span><br><span class="line">            <span class="keyword">int</span> preIndex=indexs.pop();</span><br><span class="line">            result[preIndex]=i-preIndex;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        indexs.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="503-下一个更大的元素ii">503. 下一个更大的元素Ⅱ</span></h3><p>给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,1]</span><br><span class="line">输出: [2,-1,2]</span><br><span class="line">解释: 第一个 1 的下一个更大的数是 2；</span><br><span class="line">数字 2 找不到下一个更大的数； </span><br><span class="line">第二个 1 的下一个最大的数需要循环搜索，结果也是 2。</span><br></pre></td></tr></table></figure><p>注意: 输入数组的长度不会超过 10000。</p><p><a href="https://leetcode-cn.com/problems/next-greater-element-ii/" target="_blank" rel="noopener">leetcode原题地址</a></p><h4><span id="解法">解法</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] nextGreaterElements(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] result=<span class="keyword">new</span>  <span class="keyword">int</span>[nums.length];</span><br><span class="line">    Arrays.fill(result,-<span class="number">1</span>);</span><br><span class="line">    Stack&lt;Integer&gt; stack=<span class="keyword">new</span> Stack();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length*<span class="number">2</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> num=nums[i%nums.length];</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()&amp;&amp;num&gt;nums[stack.peek()])&#123;</span><br><span class="line">            result[stack.pop()]=num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i&lt;nums.length)&#123;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;栈和队列&quot;&gt;&lt;a href=&quot;#栈和队列&quot; class=&quot;headerlink&quot; title=&quot;栈和队列&quot;&gt;&lt;/a&gt;栈和队列&lt;/h2&gt;&lt;h3 id=&quot;232-用栈实现队列&quot;&gt;&lt;a href=&quot;#232-用栈实现队列&quot; class=&quot;headerlink&quot; title=&quot;232.用栈实现队列&quot;&gt;&lt;/a&gt;232.用栈实现队列&lt;/h3&gt;&lt;p&gt;使用栈实现队列的下列操作：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;push(x) -- 将一个元素放入队列的尾部。
pop() -- 从队列首部移除元素。
peek() -- 返回队列首部的元素。
empty() -- 返回队列是否为空。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;示例:&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;MyQueue queue = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; MyQueue();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;queue.push(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;queue.push(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;queue.peek();  &lt;span class=&quot;comment&quot;&gt;// 返回 1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;queue.pop();   &lt;span class=&quot;comment&quot;&gt;// 返回 1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;queue.empty(); &lt;span class=&quot;comment&quot;&gt;// 返回 false&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/implement-queue-using-stacks/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;leetcode原题地址&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="https://zofun.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Java" scheme="https://zofun.github.io/tags/Java/"/>
    
      <category term="算法" scheme="https://zofun.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法之链表</title>
    <link href="https://zofun.github.io/2020/04/03/%E7%AE%97%E6%B3%95%E4%B9%8B%E9%93%BE%E8%A1%A8/"/>
    <id>https://zofun.github.io/2020/04/03/算法之链表/</id>
    <published>2020-04-03T13:29:00.000Z</published>
    <updated>2020-04-03T13:29:08.270Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="链表">链表</span></h2><h3><span id="160-相交链表">160. 相交链表</span></h3><p>编写一个程序，找到两个单链表相交的起始节点。</p><p><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/" target="_blank" rel="noopener">leetcode原题地址</a></p><h4><span id="解法">解法</span></h4><p>设 A 的长度为 a + c，B 的长度为 b + c，其中 c 为尾部公共部分长度，可知 a + c + b = b + c + a。<br>当访问 A 链表的指针访问到链表尾部时，令它从链表 B 的头部开始访问链表 B；同样地，当访问 B 链表的指针访问<br>到链表尾部时，令它从链表 A 的头部开始访问链表 A。这样就能控制访问 A 和 B 两个链表的指针能同时访问到交<br>点  .</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这道题的意思是必定有相交的</span></span><br><span class="line">    ListNode curA=headA;</span><br><span class="line">    ListNode curB=headB;</span><br><span class="line">    <span class="keyword">while</span> (curA!=curB)&#123;</span><br><span class="line">        curA=(curA==<span class="keyword">null</span>)?headB:curA.next;</span><br><span class="line">        curB=(curB==<span class="keyword">null</span>)?headA:curB.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> curA;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h3><span id="206-反转链表">206. 反转链表</span></h3><p>反转一个单链表。</p><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure><p>进阶:<br>你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</p><p><a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener">leetcode原题地址</a></p><h4><span id="解法">解法</span></h4><ol><li>递归解法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="keyword">null</span>||head.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode next=head.next;</span><br><span class="line">    <span class="comment">//反转 1-&gt;2-&gt;3 就可以看成 反转（2-&gt;3）+1</span></span><br><span class="line">    ListNode node = reverseList(head.next);</span><br><span class="line">    <span class="comment">//next.next就是反转后的链表的尾节点</span></span><br><span class="line">    next.next=head;</span><br><span class="line">    <span class="comment">//head是两个链表合并后的最后一个节点，因此heae.next需要设置尾null</span></span><br><span class="line">    head.next=<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>头插法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">      ListNode tmpHead=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">while</span> (head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">          ListNode next=head.next;</span><br><span class="line">          head.next=tmpHead.next;</span><br><span class="line">          tmpHead.next=head;</span><br><span class="line">          head=next;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>  tmpHead.next;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>直接反转法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">     ListNode pre=<span class="keyword">null</span>;</span><br><span class="line">     ListNode cur=head;</span><br><span class="line">     ListNode next=<span class="keyword">null</span>;</span><br><span class="line">     <span class="keyword">while</span> (cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">         next=cur.next;</span><br><span class="line">         <span class="comment">//反转</span></span><br><span class="line">         cur.next=pre;</span><br><span class="line">         <span class="comment">//pre后移</span></span><br><span class="line">         pre=cur;</span><br><span class="line">         <span class="comment">//后移</span></span><br><span class="line">         cur=next;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> pre;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3><span id="21-合并两个有序链表">21. 合并两个有序链表</span></h3><p>将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">leetcode原题地址</a></p><h4><span id="解法">解法</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l1==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(l2==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(l1.val&lt;l2.val)&#123;</span><br><span class="line">        l1.next=mergeTwoLists(l1.next,l2);</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        l2.next=mergeTwoLists(l1,l2.next);</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上是递归解法，也可以使用非递归。</p><h3><span id="83-删除排序链表中的重复元素">83. 删除排序链表中的重复元素</span></h3><p>给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。</p><p>示例 1:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span></span><br><span class="line">输出: <span class="number">1</span>-&gt;<span class="number">2</span></span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">3</span></span><br><span class="line">输出: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span></span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/" target="_blank" rel="noopener">leetcode原题地址</a></p><h4><span id="解法">解法</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>||head.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        head.next=deleteDuplicates(head.next);</span><br><span class="line">        <span class="keyword">return</span> head.val==head.next.val?head.next:head;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3><span id="19-删除链表的倒数第n个节点">19. 删除链表的倒数第N个节点</span></h3><p>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.</span><br><span class="line"></span><br><span class="line">当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.</span><br></pre></td></tr></table></figure><p>说明：</p><p>给定的 n 保证是有效的。</p><p>进阶：</p><p>你能尝试使用一趟扫描实现吗？</p><p><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noopener">leetcode原题地址</a></p><h4><span id="解法">解法</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       ListNode fast=head;</span><br><span class="line">       ListNode slow=head;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">           fast=fast.next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(fast==<span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> head;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">while</span> (fast.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           fast=fast.next;</span><br><span class="line">           slow=slow.next;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       slow.next=slow.next.next;</span><br><span class="line">       <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3><span id="34-两两交换链表中的节点">34. 两两交换链表中的节点</span></h3><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p><p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3.</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/" target="_blank" rel="noopener">leetcode原题地址</a></p><h4><span id="解法">解法</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">       ListNode node = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">       node.next = head;</span><br><span class="line">       ListNode pre = node;</span><br><span class="line">       <span class="keyword">while</span> (pre.next != <span class="keyword">null</span> &amp;&amp; pre.next.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">           ListNode l1 = pre.next, l2 = pre.next.next;</span><br><span class="line">           ListNode next = l2.next;</span><br><span class="line">           l1.next = next;</span><br><span class="line">           l2.next = l1;</span><br><span class="line">           pre.next = l2;pre = l1;</span><br><span class="line">       &#125; </span><br><span class="line">       <span class="keyword">return</span> node.next;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3><span id="445-两数相加ii">445. 两数相加Ⅱ</span></h3><p>给定两个非空链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储单个数字。将这两数相加会返回一个新的链表。</p><p>你可以假设除了数字 0 之外，这两个数字都不会以零开头。</p><p>进阶:</p><p>如果输入链表不能修改该如何处理？换句话说，你不能对列表中的节点进行翻转。</p><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: (7 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">输出: 7 -&gt; 8 -&gt; 0 -&gt; 7</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/add-two-numbers-ii/" target="_blank" rel="noopener">leetcode原题地址</a></p><h4><span id="解法">解法</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       Stack&lt;Integer&gt; stackA = buildStack(l1);</span><br><span class="line">       Stack&lt;Integer&gt; stackB = buildStack(l2);</span><br><span class="line">       ListNode tmpHead=<span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">       <span class="keyword">int</span> carry=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span> (!stackA.isEmpty()||!stackB.isEmpty()||carry!=<span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> A =stackA.isEmpty()?<span class="number">0</span>: stackA.pop();</span><br><span class="line">            <span class="keyword">int</span> B =stackB.isEmpty()?<span class="number">0</span>: stackB.pop();</span><br><span class="line">            ListNode node = <span class="keyword">new</span> ListNode((A + B+carry) % <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">            carry=(A+B+carry)/<span class="number">10</span>;</span><br><span class="line">            node.next=tmpHead.next;</span><br><span class="line">            tmpHead.next=node;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> tmpHead.next;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> Stack&lt;Integer&gt; <span class="title">buildStack</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">       Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">       <span class="keyword">while</span> (head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           stack.push(head.val);</span><br><span class="line">           head=head.next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> stack;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3><span id="725-分隔链表">725. 分隔链表</span></h3><p>给定一个头结点为 root 的链表, 编写一个函数以将链表分隔为 k 个连续的部分。</p><p>每部分的长度应该尽可能的相等: 任意两部分的长度差距不能超过 1，也就是说可能有些部分为 null。</p><p>这k个部分应该按照在链表中出现的顺序进行输出，并且排在前面的部分的长度应该大于或等于后面的长度。</p><p>返回一个符合上述规则的链表的列表。</p><p>举例： 1-&gt;2-&gt;3-&gt;4, k = 5 // 5 结果 [ [1], [2], [3], [4], null ]</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">root = [1, 2, 3], k = 5</span><br><span class="line">输出: [[1],[2],[3],[],[]]</span><br><span class="line">解释:</span><br><span class="line">输入输出各部分都应该是链表，而不是数组。</span><br><span class="line">例如, 输入的结点 root 的 val= 1, root.next.val = 2, \root.next.next.val = 3, 且 root.next.next.next = null。</span><br><span class="line">第一个输出 output[0] 是 output[0].val = 1, output[0].next = null。</span><br><span class="line">最后一个元素 output[4] 为 null, 它代表了最后一个部分为空链表。</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">root = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], k = 3</span><br><span class="line">输出: [[1, 2, 3, 4], [5, 6, 7], [8, 9, 10]]</span><br><span class="line">解释:</span><br><span class="line">输入被分成了几个连续的部分，并且每部分的长度相差不超过1.前面部分的长度大于等于后面部分的长度。</span><br></pre></td></tr></table></figure><p>提示:</p><pre><code>root 的长度范围： [0, 1000].输入的每个节点的大小范围：[0, 999].k 的取值范围： [1, 50].</code></pre><p><a href="https://leetcode-cn.com/problems/split-linked-list-in-parts/" target="_blank" rel="noopener">leetcode原题地址</a></p><h4><span id="解法">解法</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode[] splitListToParts(ListNode root, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">int</span> N = <span class="number">0</span>;</span><br><span class="line">        ListNode cur = root;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;N++;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">int</span> mod = N % k;</span><br><span class="line">        <span class="keyword">int</span> size = N / k;</span><br><span class="line">        ListNode[] ret = <span class="keyword">new</span> ListNode[k];</span><br><span class="line">        cur = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; cur != <span class="keyword">null</span> &amp;&amp; i &lt; k; i++) &#123;</span><br><span class="line">            ret[i] = cur;</span><br><span class="line">            <span class="keyword">int</span> curSize = size + (mod-- &gt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; curSize - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">            ListNode next = cur.next;</span><br><span class="line">            cur.next = <span class="keyword">null</span>;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;链表&quot;&gt;&lt;a href=&quot;#链表&quot; class=&quot;headerlink&quot; title=&quot;链表&quot;&gt;&lt;/a&gt;链表&lt;/h2&gt;&lt;h3 id=&quot;160-相交链表&quot;&gt;&lt;a href=&quot;#160-相交链表&quot; class=&quot;headerlink&quot; title=&quot;160. 相交链表&quot;&gt;&lt;/a&gt;160. 相交链表&lt;/h3&gt;&lt;p&gt;编写一个程序，找到两个单链表相交的起始节点。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/intersection-of-two-linked-lists/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;leetcode原题地址&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;解法&quot;&gt;&lt;a href=&quot;#解法&quot; class=&quot;headerlink&quot; title=&quot;解法&quot;&gt;&lt;/a&gt;解法&lt;/h4&gt;&lt;p&gt;设 A 的长度为 a + c，B 的长度为 b + c，其中 c 为尾部公共部分长度，可知 a + c + b = b + c + a。&lt;br&gt;当访问 A 链表的指针访问到链表尾部时，令它从链表 B 的头部开始访问链表 B；同样地，当访问 B 链表的指针访问&lt;br&gt;到链表尾部时，令它从链表 A 的头部开始访问链表 A。这样就能控制访问 A 和 B 两个链表的指针能同时访问到交&lt;br&gt;点  .&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; ListNode &lt;span class=&quot;title&quot;&gt;getIntersectionNode&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(ListNode headA, ListNode headB)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//这道题的意思是必定有相交的&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ListNode curA=headA;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ListNode curB=headB;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (curA!=curB)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        curA=(curA==&lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;)?headB:curA.next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        curB=(curB==&lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;)?headA:curB.next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; curA;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="https://zofun.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Java" scheme="https://zofun.github.io/tags/Java/"/>
    
      <category term="算法" scheme="https://zofun.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法之动态规划</title>
    <link href="https://zofun.github.io/2020/03/31/%E7%AE%97%E6%B3%95%E4%B9%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>https://zofun.github.io/2020/03/31/算法之动态规划/</id>
    <published>2020-03-31T14:11:00.000Z</published>
    <updated>2020-03-31T14:11:54.392Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="动态规划">动态规划</span></h2><p>动态规划和递归都是见原问题拆成多个子问题然后求解，它们之间最本质的区别是，动态规划保存了子问题的解，避免重复计算。</p><h3><span id="70-爬楼梯">70. 爬楼梯</span></h3><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p>注意：给定 n 是一个正整数。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入： 2</span><br><span class="line">输出： 2</span><br><span class="line">解释： 有两种方法可以爬到楼顶。</span><br><span class="line"></span><br><span class="line">1.  1 阶 + 1 阶</span><br><span class="line">2.  2 阶</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入： 3</span><br><span class="line">输出： 3</span><br><span class="line">解释： 有三种方法可以爬到楼顶。</span><br><span class="line"></span><br><span class="line">1.  1 阶 + 1 阶 + 1 阶</span><br><span class="line">2.  1 阶 + 2 阶</span><br><span class="line">3.  2 阶 + 1 阶</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/climbing-stairs/" target="_blank" rel="noopener">leetcode原题地址</a></p><a id="more"></a><h4><span id="解法">解法</span></h4><p>这道题是一道非常经典的题。我们今天尝试使用动态规划来解它。<br>$$<br>dp[n]=dp[n-1]+dp[n-2]<br>$$<br>到达第n阶楼梯的走法等于到达第n-1阶然后在走一阶加上到达n-2阶的走法然后再走两步。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(n&lt;<span class="number">2</span>)&#123;</span><br><span class="line">          <span class="keyword">return</span> n;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//dp[3]=dp[2]+dp[1]</span></span><br><span class="line">      <span class="keyword">int</span> pre1=<span class="number">2</span>; <span class="comment">//dp[2]</span></span><br><span class="line">      <span class="keyword">int</span> pre2=<span class="number">1</span>; <span class="comment">//dp[1]</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;i++)&#123;</span><br><span class="line">          <span class="keyword">int</span> cur=pre1+pre2;</span><br><span class="line">          pre2=pre1;</span><br><span class="line">          pre1=cur;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> pre1;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3><span id="198-打家劫舍">198. 打家劫舍</span></h3><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,1]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。</span><br><span class="line">     偷窃到的最高金额 = 1 + 3 = 4 。</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,7,9,3,1]</span><br><span class="line">输出: 12</span><br><span class="line">解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。</span><br><span class="line">     偷窃到的最高金额 = 2 + 9 + 1 = 12 。</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/house-robber/" target="_blank" rel="noopener">leetcode原题地址</a></p><h4><span id="解法">解法</span></h4><p>$$<br>dp[n]=max(dp[n-2]+nums[n],dp[n-1])<br>$$</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//dp[n]=max(dp[n-2]+nums[n],dp[n-1])</span></span><br><span class="line">       <span class="comment">//这种写法比直接利用dp数组更节省空间</span></span><br><span class="line">       <span class="keyword">int</span> pre2=<span class="number">0</span>;<span class="comment">//dp[n-2]</span></span><br><span class="line">       <span class="keyword">int</span> pre1=<span class="number">0</span>;<span class="comment">//dp[n-1]</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">           <span class="keyword">int</span> cur=Math.max(pre2+nums[i],pre1);</span><br><span class="line">           pre2=pre1;</span><br><span class="line">           pre1=cur;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> pre1;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3><span id="213-打家劫舍">213. 打家劫舍</span></h3><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,3,2]</span><br><span class="line">输出: 3</span><br><span class="line">解释: 你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,1]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。</span><br><span class="line">     偷窃到的最高金额 = 1 + 3 = 4 。</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/house-robber-ii/" target="_blank" rel="noopener">leetcode原题地址</a></p><h4><span id="解法">解法</span></h4><p>这道题的原理和上一题类似，但是因为是环形的，所以第一家和最后一家只能选择一个偷。所以我们将这两个方案都计算一下，比较得到最佳方案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span>(nums==<span class="keyword">null</span>||nums.length==<span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(nums.length==<span class="number">1</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> Math.max(rob(nums,<span class="number">0</span>,nums.length-<span class="number">2</span>),rob(nums,<span class="number">1</span>,nums.length-<span class="number">1</span>));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">       <span class="comment">//dp[n]=max(dp[n-1],dp[n-2]+nums[n]);</span></span><br><span class="line">       <span class="keyword">int</span> pre1=<span class="number">0</span>; <span class="comment">//dp[n-1]</span></span><br><span class="line">       <span class="keyword">int</span> pre2=<span class="number">0</span>; <span class="comment">//dp[n-2]</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;=end;i++)&#123;</span><br><span class="line">           <span class="keyword">int</span> cur=Math.max(pre1,pre2+nums[i]);</span><br><span class="line">           pre2=pre1;</span><br><span class="line">           pre1=cur;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> pre1;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3><span id="64-最小路径和">64. 最小路径和</span></h3><p>给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p><p>说明：每次只能向下或者向右移动一步。</p><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  [1,3,1],</span><br><span class="line">  [1,5,1],</span><br><span class="line">  [4,2,1]</span><br><span class="line">]</span><br><span class="line">输出: 7</span><br><span class="line">解释: 因为路径 1→3→1→1→1 的总和最小。</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/minimum-path-sum/" target="_blank" rel="noopener">leetcode原题地址</a></p><h4><span id="解法">解法</span></h4><p>$$<br>dp[i,j]=grid[i,j]+min(dp[i+1,j],dp[i,j+1])<br>$$</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[grid[<span class="number">0</span>].length];</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = grid.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> j = grid[<span class="number">0</span>].length - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">              <span class="keyword">if</span>(i == grid.length - <span class="number">1</span> &amp;&amp; j != grid[<span class="number">0</span>].length - <span class="number">1</span>)</span><br><span class="line">                  dp[j] = grid[i][j] +  dp[j + <span class="number">1</span>];</span><br><span class="line">              <span class="keyword">else</span> <span class="keyword">if</span>(j == grid[<span class="number">0</span>].length - <span class="number">1</span> &amp;&amp; i != grid.length - <span class="number">1</span>)</span><br><span class="line">                  dp[j] = grid[i][j] + dp[j];</span><br><span class="line">              <span class="keyword">else</span> <span class="keyword">if</span>(j != grid[<span class="number">0</span>].length - <span class="number">1</span> &amp;&amp; i != grid.length - <span class="number">1</span>)</span><br><span class="line">                  dp[j] = grid[i][j] + Math.min(dp[j], dp[j + <span class="number">1</span>]);</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                  dp[j] = grid[i][j];</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3><span id="62-不同路径">62. 不同路径</span></h3><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角。</p><p>问总共有多少条不同的路径？</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: m = 3, n = 2</span><br><span class="line">输出: 3</span><br><span class="line">解释:</span><br><span class="line">从左上角开始，总共有 3 条路径可以到达右下角。</span><br><span class="line"></span><br><span class="line">1. 向右 -&gt; 向右 -&gt; 向下</span><br><span class="line">2. 向右 -&gt; 向下 -&gt; 向右</span><br><span class="line">3. 向下 -&gt; 向右 -&gt; 向右</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: m = 7, n = 3</span><br><span class="line">输出: 28</span><br></pre></td></tr></table></figure><p>提示：</p><pre><code>1 &lt;= m, n &lt;= 100题目数据保证答案小于等于 2 * 10 ^ 9</code></pre><p><a href="https://leetcode-cn.com/problems/unique-paths/" target="_blank" rel="noopener">leetcode原题地址</a></p><h4><span id="解法">解法</span></h4><p>$$<br>dp[i,j]=dp[i-1,j]+dp[i,j-1]<br>$$</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span>[][] dp=<span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">           dp[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">           dp[<span class="number">0</span>][j]=<span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">               dp[i][j]=dp[i-<span class="number">1</span>][j]+dp[i][j-<span class="number">1</span>];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3><span id="303-区域和检索-数组不可变">303. 区域和检索-数组不可变</span></h3><p>给定一个整数数组  nums，求出数组从索引 i 到 j  (i ≤ j) 范围内元素的总和，包含 i,  j 两点。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给定 nums = [-2, 0, 3, -5, 2, -1]，求和函数为 sumRange()</span><br><span class="line"></span><br><span class="line">sumRange(0, 2) -&gt; 1</span><br><span class="line">sumRange(2, 5) -&gt; -1</span><br><span class="line">sumRange(0, 5) -&gt; -3</span><br></pre></td></tr></table></figure><p>说明:</p><pre><code>你可以假设数组不可变。会多次调用 sumRange 方法。</code></pre><p><a href="https://leetcode-cn.com/problems/range-sum-query-immutable/" target="_blank" rel="noopener">leetcode原题地址</a></p><h4><span id="解法">解法</span></h4><p>求区间i-j的和，可以转换为sum[j+1]-sum[j]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] sums;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">NumArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       sums=<span class="keyword">new</span> <span class="keyword">int</span>[nums.length+<span class="number">1</span>];</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=nums.length;i++)&#123;</span><br><span class="line"></span><br><span class="line">           sums[i]=sums[i-<span class="number">1</span>]+nums[i-<span class="number">1</span>];</span><br><span class="line">          </span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> sums[j+<span class="number">1</span>]-sums[i];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3><span id="343-整数拆分">343. 整数拆分</span></h3><p>给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 2</span><br><span class="line">输出: 1</span><br><span class="line">解释: 2 = 1 + 1, 1 × 1 = 1。</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: 10</span><br><span class="line">输出: 36</span><br><span class="line">解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。</span><br><span class="line"></span><br><span class="line">说明: 你可以假设 n 不小于 2 且不大于 58。</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/integer-break/" target="_blank" rel="noopener">leetcode原题地址</a></p><h4><span id="解法">解法</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">integerBreak</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//dp[i]=max(dp[i],max(j*dp[i-j],j*(i-j)))</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">      dp[<span class="number">1</span>]=dp[<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=n;i++)&#123;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">              dp[i]=Math.max(dp[i],Math.max(j*dp[i-j],j*(i-j)));</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> dp[n];</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3><span id="300-最长上升子序列">300. 最长上升子序列</span></h3><p>给定一个无序的整数数组，找到其中最长上升子序列的长度。</p><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [10,9,2,5,3,7,101,18]</span><br><span class="line">输出: 4 </span><br><span class="line">解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。</span><br></pre></td></tr></table></figure><p>说明:</p><pre><code>可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。你算法的时间复杂度应该为 O(n2) 。</code></pre><p>进阶: 你能将算法的时间复杂度降低到 O(n log n) 吗?</p><p><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">leetcode原题地址</a></p><h4><span id="解法">解法</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">         <span class="keyword">int</span> max=<span class="number">1</span>;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;nums.length;j++)&#123;</span><br><span class="line">             <span class="keyword">if</span>(nums[i]&gt;nums[j])&#123;</span><br><span class="line">                 dp[i]=Math.max(max,dp[j]+<span class="number">1</span>);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         dp[i]=max;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> ret=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;dp.length;i++)&#123;</span><br><span class="line">     </span><br><span class="line">           <span class="keyword">if</span>(dp[i]&gt;ret)&#123;</span><br><span class="line">               ret =dp[i];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> ret;</span><br><span class="line">       </span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;动态规划&quot;&gt;&lt;a href=&quot;#动态规划&quot; class=&quot;headerlink&quot; title=&quot;动态规划&quot;&gt;&lt;/a&gt;动态规划&lt;/h2&gt;&lt;p&gt;动态规划和递归都是见原问题拆成多个子问题然后求解，它们之间最本质的区别是，动态规划保存了子问题的解，避免重复计算。&lt;/p&gt;
&lt;h3 id=&quot;70-爬楼梯&quot;&gt;&lt;a href=&quot;#70-爬楼梯&quot; class=&quot;headerlink&quot; title=&quot;70. 爬楼梯&quot;&gt;&lt;/a&gt;70. 爬楼梯&lt;/h3&gt;&lt;p&gt;假设你正在爬楼梯。需要 n 阶你才能到达楼顶。&lt;/p&gt;
&lt;p&gt;每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？&lt;/p&gt;
&lt;p&gt;注意：给定 n 是一个正整数。&lt;/p&gt;
&lt;p&gt;示例 1：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入： 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出： 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释： 有两种方法可以爬到楼顶。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1.  1 阶 + 1 阶&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2.  2 阶&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;示例 2：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入： 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出： 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释： 有三种方法可以爬到楼顶。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1.  1 阶 + 1 阶 + 1 阶&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2.  1 阶 + 2 阶&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3.  2 阶 + 1 阶&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/climbing-stairs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;leetcode原题地址&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="https://zofun.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Java" scheme="https://zofun.github.io/tags/Java/"/>
    
      <category term="算法" scheme="https://zofun.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法之排序</title>
    <link href="https://zofun.github.io/2020/03/30/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%8E%92%E5%BA%8F/"/>
    <id>https://zofun.github.io/2020/03/30/算法之排序/</id>
    <published>2020-03-30T01:44:00.000Z</published>
    <updated>2020-03-30T07:39:32.815Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="排序">排序</span></h2><h3><span id="215数组中的第k个最大元素">215.数组中的第k个最大元素</span></h3><p>在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,2,1,5,6,4] 和 k = 2</span><br><span class="line">输出: 5</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,2,3,1,2,4,5,5,6] 和 k = 4</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><p>说明:</p><p>你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。</p><p><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/" target="_blank" rel="noopener">leetcode原题地址</a></p><a id="more"></a><h4><span id="解法">解法</span></h4><ol><li>是用堆排序</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//小顶堆</span></span><br><span class="line">       PriorityQueue&lt;Integer&gt; pq=<span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">           pq.add(num);</span><br><span class="line">           <span class="keyword">if</span>(pq.size()&gt;k)&#123;</span><br><span class="line">               pq.poll();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> pq.poll();</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(NlogK)，空间复杂度为O(K)</p><ol start="2"><li>使用快排</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">       sort(nums);</span><br><span class="line">       <span class="keyword">return</span> nums[k-<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">       doSort(arr,<span class="number">0</span>,arr.length-<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSort</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line">           <span class="keyword">int</span> pivot = partition(arr, left, right);</span><br><span class="line">           doSort(arr,left,pivot-<span class="number">1</span>);</span><br><span class="line">           doSort(arr,pivot,right);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//寻找枢轴</span></span><br><span class="line">       <span class="keyword">int</span> mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">       <span class="keyword">int</span> pivot=arr[mid];</span><br><span class="line">       <span class="keyword">while</span> (left&lt;=right)&#123;</span><br><span class="line">           <span class="keyword">while</span> (right&gt;=<span class="number">0</span>&amp;&amp;arr[right]&lt;pivot)&#123;</span><br><span class="line">               right--;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">while</span> (left&lt;arr.length&amp;&amp;arr[left]&gt;pivot)&#123;</span><br><span class="line">               left++;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(left&lt;=right)&#123;</span><br><span class="line">               swap(arr, left, right);</span><br><span class="line">               left++;</span><br><span class="line">               right--;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> left;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> tmp=arr[a];</span><br><span class="line">       arr[a]=arr[b];</span><br><span class="line">       arr[b]=tmp;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>快速选择</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> l=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> r=nums.length-<span class="number">1</span>;</span><br><span class="line">       k=nums.length-k;</span><br><span class="line">       <span class="keyword">while</span> (l&lt;r)&#123;</span><br><span class="line">           <span class="keyword">int</span> p = partition(nums, l, r);</span><br><span class="line">           <span class="keyword">if</span>(p==k)&#123;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span>(p&gt;k)&#123;</span><br><span class="line">               r=p-<span class="number">1</span>;</span><br><span class="line">           &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">               l=p+<span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> nums[k];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> l, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = l, j = h + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (a[++i] &lt; a[l] &amp;&amp; i &lt; h) &#123;&#125;;</span><br><span class="line">            <span class="keyword">while</span> (a[--j] &gt; a[l] &amp;&amp; j &gt; l) &#123;&#125;;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= j) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(a, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">        swap(a, l, j);</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp=arr[a];</span><br><span class="line">        arr[a]=arr[b];</span><br><span class="line">        arr[b]=tmp;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3><span id="347-前k个高频元素">347. 前k个高频元素</span></h3><p>给定一个非空的整数数组，返回其中出现频率前 k 高的元素。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,1,1,2,2,3], k = 2</span><br><span class="line">输出: [1,2]</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1], k = 1</span><br><span class="line">输出: [1]</span><br></pre></td></tr></table></figure><p>说明：</p><pre><code>你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。你的算法的时间复杂度必须优于 O(n log n) , n 是数组的大小。</code></pre><p><a href="https://leetcode-cn.com/problems/top-k-frequent-elements/" target="_blank" rel="noopener">leetcode原题地址</a></p><h4><span id="解法">解法</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">topKFrequent</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用hashmap统计频率</span></span><br><span class="line">        HashMap&lt;Integer, Integer&gt; count = <span class="keyword">new</span> HashMap();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n: nums) &#123;</span><br><span class="line">            count.put(n, count.getOrDefault(n, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        PriorityQueue&lt;Integer&gt; heap =</span><br><span class="line">                <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;((n1, n2) -&gt; count.get(n1) - count.get(n2));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//建立堆</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n: count.keySet()) &#123;</span><br><span class="line">            heap.add(n);</span><br><span class="line">            <span class="keyword">if</span> (heap.size() &gt; k)&#123;</span><br><span class="line">                heap.poll();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; top_k = <span class="keyword">new</span> LinkedList();</span><br><span class="line">        <span class="keyword">while</span> (!heap.isEmpty()) &#123;</span><br><span class="line">            top_k.add(heap.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(top_k);</span><br><span class="line">        <span class="keyword">return</span> top_k;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3><span id="75-颜色分类">75. 颜色分类</span></h3><p>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p><p>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p><p>注意:<br>不能使用代码库中的排序函数来解决这道题。</p><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,0,2,1,1,0]</span><br><span class="line">输出: [0,0,1,1,2,2]</span><br></pre></td></tr></table></figure><p>进阶：</p><pre><code>一个直观的解决方案是使用计数排序的两趟扫描算法。首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。你能想出一个仅使用常数空间的一趟扫描算法吗？</code></pre><p><a href="https://leetcode-cn.com/problems/sort-colors/" target="_blank" rel="noopener">leetcode原题地址</a></p><h4><span id="解法">解法</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> zero = -<span class="number">1</span>, one = <span class="number">0</span>, two = nums.length;</span><br><span class="line">        <span class="keyword">while</span> (one &lt; two) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[one] == <span class="number">0</span>) &#123;</span><br><span class="line">                swap(nums, ++zero, one++);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[one] == <span class="number">2</span>) &#123;</span><br><span class="line">                swap(nums, --two, one);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ++one;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp=arr[a];</span><br><span class="line">    arr[a]=arr[b];</span><br><span class="line">    arr[b]=tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;排序&quot;&gt;&lt;a href=&quot;#排序&quot; class=&quot;headerlink&quot; title=&quot;排序&quot;&gt;&lt;/a&gt;排序&lt;/h2&gt;&lt;h3 id=&quot;215-数组中的第k个最大元素&quot;&gt;&lt;a href=&quot;#215-数组中的第k个最大元素&quot; class=&quot;headerlink&quot; title=&quot;215.数组中的第k个最大元素&quot;&gt;&lt;/a&gt;215.数组中的第k个最大元素&lt;/h3&gt;&lt;p&gt;在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。&lt;/p&gt;
&lt;p&gt;示例 1:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: [3,2,1,5,6,4] 和 k = 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;示例 2:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: [3,2,3,1,2,4,5,5,6] 和 k = 4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;说明:&lt;/p&gt;
&lt;p&gt;你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/kth-largest-element-in-an-array/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;leetcode原题地址&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="https://zofun.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Java" scheme="https://zofun.github.io/tags/Java/"/>
    
      <category term="算法" scheme="https://zofun.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法之双指针</title>
    <link href="https://zofun.github.io/2020/03/29/%E7%AE%97%E6%B3%95%E4%B9%8B%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    <id>https://zofun.github.io/2020/03/29/算法之双指针/</id>
    <published>2020-03-29T08:53:00.000Z</published>
    <updated>2020-03-29T08:53:22.594Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="双指针">双指针</span></h2><p>双指针主要用于遍历数组，两个指针指向不同的元素，从而协同完成任务。</p><a id="more"></a><h3><span id="167-两数之和-ii-输入有序数组">167. 两数之和 II - 输入有序数组</span></h3><p>给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。</p><p>函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。</p><p>说明:</p><pre><code>返回的下标值（index1 和 index2）不是从零开始的。你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。</code></pre><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: numbers = [2, 7, 11, 15], target = 9</span><br><span class="line">输出: [1,2]</span><br><span class="line">解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/" target="_blank" rel="noopener">leetcode原题地址</a></p><h4><span id="解答">解答</span></h4><p>我们使用两个指针，一个指针从数组的左边开始，一个指针从数组的右边开始。</p><p>如果两个指针所指数据等于target，那么就直接返回；如果小于target，那么左指针右移动；</p><p>如果大于target，则右指针左移。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line">       <span class="keyword">int</span> minIndex=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> maxIndex=numbers.length-<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">int</span>[] result=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">       <span class="keyword">while</span> (minIndex&lt;maxIndex)&#123;</span><br><span class="line">           <span class="keyword">int</span> sum=numbers[minIndex]+numbers[maxIndex];</span><br><span class="line">           <span class="keyword">if</span>(sum==target)&#123;</span><br><span class="line">               <span class="comment">//返回结果的下标不是从零开始的</span></span><br><span class="line">               result[<span class="number">0</span>]=++minIndex;</span><br><span class="line">               result[<span class="number">1</span>]=++maxIndex;</span><br><span class="line">               <span class="keyword">return</span> result;</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum&gt;target)&#123;</span><br><span class="line">               maxIndex--;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               minIndex++;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3><span id="633平方数之和">633.平方数之和</span></h3><p>给定一个非负整数 c ，你要判断是否存在两个整数 a 和 b，使得 a2 + b2 = c。</p><p>示例1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 5</span><br><span class="line">输出: True</span><br><span class="line">解释: 1 * 1 + 2 * 2 = 5</span><br></pre></td></tr></table></figure><p>示例2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 3</span><br><span class="line">输出: False</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/sum-of-square-numbers/" target="_blank" rel="noopener">leetcode原题地址</a></p><h4><span id="解答">解答</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">judgeSquareSum</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> b=(<span class="keyword">int</span>) Math.sqrt(c);</span><br><span class="line">        <span class="keyword">while</span> (a&lt;=b)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp=a*a+b*b;</span><br><span class="line">            <span class="keyword">if</span>(tmp==c)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(tmp&lt;c)&#123;</span><br><span class="line">                a++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                b--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3><span id="345-反转字符串中的元音字母">345. 反转字符串中的元音字母</span></h3><p>编写一个函数，以字符串作为输入，反转该字符串中的元音字母。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;hello&quot;</span><br><span class="line">输出: &quot;holle&quot;</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;leetcode&quot;</span><br><span class="line">输出: &quot;leotcede&quot;</span><br></pre></td></tr></table></figure><p>说明:<br>元音字母不包含字母”y”。</p><p><a href="https://leetcode-cn.com/problems/reverse-vowels-of-a-string/" target="_blank" rel="noopener">leetcode原题地址</a></p><h4><span id="解法">解法</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> HashSet&lt;Character&gt; set=<span class="keyword">new</span> HashSet&lt;&gt;(</span><br><span class="line">            Arrays.asList(<span class="string">'a'</span>,<span class="string">'e'</span>,<span class="string">'i'</span>,<span class="string">'o'</span>,<span class="string">'u'</span>,<span class="string">'A'</span>,<span class="string">'E'</span>,<span class="string">'I'</span>,<span class="string">'O'</span>,<span class="string">'U'</span>));</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseVowels</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right=chars.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left&lt;right)&#123;</span><br><span class="line">            <span class="keyword">while</span> (right&gt;=<span class="number">0</span>&amp;&amp;!set.contains(chars[right]))&#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (left&lt;chars.length&amp;&amp;!set.contains(chars[left]))&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line">                swap(chars,left,right);</span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(chars);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span>[] chars,<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> tmp=chars[a];</span><br><span class="line">        chars[a]=chars[b];</span><br><span class="line">        chars[b]=tmp;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3><span id="680-验证回文字符串ii">680 验证回文字符串Ⅱ</span></h3><p>给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;aba&quot;</span><br><span class="line">输出: True</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;abca&quot;</span><br><span class="line">输出: True</span><br><span class="line">解释: 你可以删除c字符。</span><br></pre></td></tr></table></figure><p>注意:</p><pre><code>字符串只包含从 a-z 的小写字母。字符串的最大长度是50000。</code></pre><p><a href="https://leetcode.com/problems/valid-palindrome-ii/description/" target="_blank" rel="noopener">leetcode原题地址</a></p><h4><span id="解法">解法</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end=s.length()-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (start&lt;end)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(start)!=s.charAt(end))&#123;</span><br><span class="line">               <span class="keyword">return</span> isPalinerome(s,start,end-<span class="number">1</span>)||isPalinerome(s,start+<span class="number">1</span>,end);</span><br><span class="line">            &#125;</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPalinerome</span><span class="params">(String str,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (start&lt;end)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str.charAt(start)!=str.charAt(end))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="141-环形链表">141. 环形链表</span></h3><p>给定一个链表，判断链表中是否有环。</p><p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [3,2,0,-4], pos = 1</span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2], pos = 0</span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1], pos = -1</span><br><span class="line">输出：false</span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure><p>进阶：</p><p>你能用 O(1)（即，常量）内存解决此问题吗？</p><p><a href="https://leetcode-cn.com/problems/linked-list-cycle/" target="_blank" rel="noopener">leetcode原题地址</a></p><h4><span id="解法">解法</span></h4><p>快慢指针法，一个指针一次只走一步，另一个指针一次走2步。如果链表中有环，那么它们一定会相遇。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode slow=head;</span><br><span class="line">        ListNode fast=head;</span><br><span class="line">        <span class="keyword">while</span> (fast!=<span class="keyword">null</span>&amp;&amp;fast.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            slow=slow.next;</span><br><span class="line">            fast=fast.next.next;</span><br><span class="line">            <span class="keyword">if</span>(fast==slow)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3><span id="524通过删除字母匹配到字典中最长单词">524.通过删除字母匹配到字典中最长单词</span></h3><p>给定一个字符串和一个字符串字典，找到字典里面最长的字符串，该字符串可以通过删除给定字符串的某些字符来得到。如果答案不止一个，返回长度最长且字典顺序最小的字符串。如果答案不存在，则返回空字符串。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;abpcplea&quot;, d = [&quot;ale&quot;,&quot;apple&quot;,&quot;monkey&quot;,&quot;plea&quot;]</span><br><span class="line"></span><br><span class="line">输出: </span><br><span class="line">&quot;apple&quot;</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;abpcplea&quot;, d = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</span><br><span class="line"></span><br><span class="line">输出: </span><br><span class="line">&quot;a&quot;</span><br></pre></td></tr></table></figure><p>说明:</p><pre><code>所有输入的字符串只包含小写字母。字典的大小不会超过 1000。所有输入的字符串长度不会超过 1000。</code></pre><p><a href="https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting/" target="_blank" rel="noopener">leetcode原题地址</a></p><h4><span id="解法">解法</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">findLongestWord</span><span class="params">(String s, List&lt;String&gt; d)</span> </span>&#123;</span><br><span class="line">    String longestWord = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">for</span> (String target : d) &#123;</span><br><span class="line">        <span class="keyword">int</span> l1 = longestWord.length(), l2 = target.length();</span><br><span class="line">        <span class="keyword">if</span> (l1 &gt; l2 || (l1 == l2 &amp;&amp; longestWord.compareTo(target) &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span> (isValid(s, target)) &#123;</span><br><span class="line">            longestWord = target;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> longestWord;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s,String target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; s.length() &amp;&amp; j &lt; target.length()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i) == target.charAt(j)) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> j == target.length();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;双指针&quot;&gt;&lt;a href=&quot;#双指针&quot; class=&quot;headerlink&quot; title=&quot;双指针&quot;&gt;&lt;/a&gt;双指针&lt;/h2&gt;&lt;p&gt;双指针主要用于遍历数组，两个指针指向不同的元素，从而协同完成任务。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="https://zofun.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Java" scheme="https://zofun.github.io/tags/Java/"/>
    
      <category term="算法" scheme="https://zofun.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法:矩形覆盖</title>
    <link href="https://zofun.github.io/2020/03/29/%E7%AE%97%E6%B3%95%EF%BC%9A%E7%9F%A9%E5%BD%A2%E8%A6%86%E7%9B%96/"/>
    <id>https://zofun.github.io/2020/03/29/算法：矩形覆盖/</id>
    <published>2020-03-29T03:08:00.000Z</published>
    <updated>2020-03-29T03:08:59.150Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="题目描述">题目描述</span></h2><p>我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？ </p><p><a href="https://www.nowcoder.com/practice/72a5a919508a4251859fb2cfb987a0e6?tpId=13&amp;tqId=11163&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">牛客网在线测试</a></p><a id="more"></a><h2><span id="解题思路">解题思路</span></h2><p>当n为1时，只有一种覆盖方法；当n为2 时，有两种覆盖方法；可以先覆盖 2*1 的矩形，再覆盖 2*(n-1) 的矩形；或者先覆盖 2*2 的矩形，再覆盖 2*(n-2)<br>的矩形。而覆盖 2*(n-1) 和 2*(n-2) 的矩形可以看成子问题。</p><p><img src="https://s1.ax1x.com/2020/03/29/GE4hUs.png" alt="GE4hUs.png"></p><h2><span id="解题代码">解题代码</span></h2><ol><li>递归写法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">RectCover</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target&lt;=<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> target;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> RectCover(target-<span class="number">1</span>)+RectCover(target-<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>非递归写法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">RectCover</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> pre2 = <span class="number">1</span>, pre1 = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            result = pre2 + pre1;</span><br><span class="line">            pre2 = pre1;</span><br><span class="line">            pre1 = result;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？ &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.nowcoder.com/practice/72a5a919508a4251859fb2cfb987a0e6?tpId=13&amp;amp;tqId=11163&amp;amp;tPage=1&amp;amp;rp=1&amp;amp;ru=/ta/coding-interviews&amp;amp;qru=/ta/coding-interviews/question-ranking&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;牛客网在线测试&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="https://zofun.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Java" scheme="https://zofun.github.io/tags/Java/"/>
    
      <category term="算法" scheme="https://zofun.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法:用两个栈实现队列</title>
    <link href="https://zofun.github.io/2020/03/29/%E7%AE%97%E6%B3%95%EF%BC%9A%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
    <id>https://zofun.github.io/2020/03/29/算法：用两个栈实现队列/</id>
    <published>2020-03-29T02:21:00.000Z</published>
    <updated>2020-03-29T02:22:00.576Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="题目描述">题目描述</span></h2><p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p><p><a href="https://www.nowcoder.com/practice/54275ddae22f475981afa2244dd448c6?tpId=13&amp;tqId=11158&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">牛客网在线测试</a></p><a id="more"></a><h2><span id="解题思路">解题思路</span></h2><p>我们使用两个栈，in栈用来处理入栈操作，out栈用来处理出栈操作。一个元素进入in栈之后，出栈的顺序被反转，当元素需要出栈的时候，需要先进入out栈，此时元素出栈顺序再次反转，这样就和队列出栈的顺序一致了。</p><h2><span id="解题代码">解题代码</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;Integer&gt; in = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">   Stack&lt;Integer&gt; out = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       in.push(node);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(out.isEmpty())&#123;</span><br><span class="line">           <span class="keyword">while</span> (!in.isEmpty())&#123;</span><br><span class="line">               <span class="comment">//将in栈中的数据，加入到out栈，此时out栈的顺序就是出队列顺序</span></span><br><span class="line">               out.push(in.pop());</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(out.isEmpty())&#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"队列空"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> out.pop();</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.nowcoder.com/practice/54275ddae22f475981afa2244dd448c6?tpId=13&amp;amp;tqId=11158&amp;amp;tPage=1&amp;amp;rp=1&amp;amp;ru=/ta/coding-interviews&amp;amp;qru=/ta/coding-interviews/question-ranking&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;牛客网在线测试&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="https://zofun.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Java" scheme="https://zofun.github.io/tags/Java/"/>
    
      <category term="算法" scheme="https://zofun.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法:重建二叉树</title>
    <link href="https://zofun.github.io/2020/03/28/%E7%AE%97%E6%B3%95%EF%BC%9A%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://zofun.github.io/2020/03/28/算法：重建二叉树/</id>
    <published>2020-03-28T03:57:00.000Z</published>
    <updated>2020-03-28T03:57:08.364Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="题目描述">题目描述</span></h2><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p><p><a href="https://www.nowcoder.com/practice/8a19cbe657394eeaac2f6ea9b0f6fcf6?tpId=13&amp;tqId=11157&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">牛客网在线测试</a></p><a id="more"></a><h2><span id="解题思路">解题思路</span></h2><p>解决这个题的关键是要清楚前序遍历序列和中序遍历序列的特点。</p><p>前序遍历序列的结构是这个样子的<code>(根节点，左子树的节点...,右子树的节点...)</code></p><p>而中序遍历序列的结构是这个样子的<code>(左子树的节点...,根节点,右子树的节点...)</code></p><p>根据遍历序列的特点，我们可以通过先序遍历序列找到根节点的值，然后根据根节点的值，再利用中序遍历的值，可以拿到左右子树的节点值。</p><h2><span id="解题代码">解题代码</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//记录中序遍历序列每个值所对应的下标</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;Integer,Integer&gt; indexOfInOrders=<span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span> [] pre,<span class="keyword">int</span> [] in)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;in.length;i++)&#123;</span><br><span class="line">            indexOfInOrders.put(in[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> reConstructBinaryTree(pre,<span class="number">0</span>,pre.length-<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span>[] pre,<span class="keyword">int</span> preL,<span class="keyword">int</span> preR,<span class="keyword">int</span> inL)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preL&gt;preR)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//先序遍历序列的第一个节点就是根节点</span></span><br><span class="line">        TreeNode root=<span class="keyword">new</span> TreeNode(pre[preL]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> inIndex = indexOfInOrders.get(root.val);</span><br><span class="line">        <span class="keyword">int</span> leftTreeSize=inIndex-inL;</span><br><span class="line">        root.left=reConstructBinaryTree(pre,preL+<span class="number">1</span>,preL+leftTreeSize,inL);</span><br><span class="line">        root.right=reConstructBinaryTree(pre,preL+leftTreeSize+<span class="number">1</span>,preR,inL+leftTreeSize+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.nowcoder.com/practice/8a19cbe657394eeaac2f6ea9b0f6fcf6?tpId=13&amp;amp;tqId=11157&amp;amp;tPage=1&amp;amp;rp=1&amp;amp;ru=/ta/coding-interviews&amp;amp;qru=/ta/coding-interviews/question-ranking&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;牛客网在线测试&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="https://zofun.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Java" scheme="https://zofun.github.io/tags/Java/"/>
    
      <category term="算法" scheme="https://zofun.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法:二叉树的下一个结点</title>
    <link href="https://zofun.github.io/2020/03/28/%E7%AE%97%E6%B3%95%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E7%BB%93%E7%82%B9/"/>
    <id>https://zofun.github.io/2020/03/28/算法：二叉树的下一个结点/</id>
    <published>2020-03-28T03:57:00.000Z</published>
    <updated>2020-03-29T02:01:12.973Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="题目描述">题目描述</span></h2><p>给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</p><p><a href="https://www.nowcoder.com/practice/9023a0c988684a53960365b889ceaf5e?tpId=13&amp;tqId=11210&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">牛客网在线测试</a></p><a id="more"></a><h2><span id="解题思路">解题思路</span></h2><ol><li>如果一个节点的右子树不为空，那么该节点的下一个节点是右子树的最左节点</li><li>如果一个节点的右子树为空，那么该节点的下一个节点是向上找第一个左链接指向的树包含该节点的祖先节点</li></ol><h2><span id="解题代码">解题代码</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeLinkNode <span class="title">GetNext</span><span class="params">(TreeLinkNode pNode)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(pNode.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">          TreeLinkNode right = pNode.right;</span><br><span class="line">          <span class="keyword">while</span> (right.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">              right=right.left;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> right;</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">while</span> (pNode.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">              TreeLinkNode parent = pNode.next;</span><br><span class="line">              <span class="keyword">if</span> (parent.left == pNode) &#123;</span><br><span class="line">                  <span class="keyword">return</span> parent;</span><br><span class="line">              &#125;</span><br><span class="line">              pNode = pNode.next;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.nowcoder.com/practice/9023a0c988684a53960365b889ceaf5e?tpId=13&amp;amp;tqId=11210&amp;amp;tPage=1&amp;amp;rp=1&amp;amp;ru=/ta/coding-interviews&amp;amp;qru=/ta/coding-interviews/question-ranking&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;牛客网在线测试&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="https://zofun.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Java" scheme="https://zofun.github.io/tags/Java/"/>
    
      <category term="算法" scheme="https://zofun.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法：从头到尾打印链表</title>
    <link href="https://zofun.github.io/2020/03/28/%E7%AE%97%E6%B3%95%EF%BC%9A%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/"/>
    <id>https://zofun.github.io/2020/03/28/算法：从尾到头打印链表/</id>
    <published>2020-03-28T02:50:00.000Z</published>
    <updated>2020-03-28T02:50:58.174Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="题目描述">题目描述</span></h2><p>从尾到头打印链表</p><p><a href="https://www.nowcoder.com/practice/d0267f7f55b3412ba93bd35cfa8e8035?tpId=13&amp;tqId=11156&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">牛客网在线测试</a></p><h2><span id="解题思路">解题思路</span></h2><h3><span id="使用递归">使用递归</span></h3><p>要逆序打印链表<code>1-&gt;2-&gt;3</code>，可以先打印链表<code>2-&gt;3</code>再打印节点1。而打印俩表<code>2-&gt;3</code>可以看作一个新的链表，可以再次调用求解函数对其进行逆序输出。</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">       ArrayList&lt;Integer&gt; list=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">       <span class="keyword">if</span>(listNode!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           list.addAll(printListFromTailToHead(listNode.next));</span><br><span class="line">           list.add(listNode.val);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> list;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3><span id="使用头插法">使用头插法</span></h3><p>使用头插法可以得到一个逆序的链表。然后遍历输出这个逆序链表即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//临时的空节点作为头节点</span></span><br><span class="line">       ListNode head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">       <span class="comment">//使用头插法</span></span><br><span class="line">       <span class="keyword">while</span> (listNode!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           ListNode tmp=listNode.next;</span><br><span class="line">           listNode.next=head.next;</span><br><span class="line">           head.next=listNode;</span><br><span class="line">           listNode=tmp;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       ArrayList&lt;Integer&gt; result=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       ListNode cur=head.next;</span><br><span class="line">       <span class="keyword">while</span> (cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           result.add(cur.val);</span><br><span class="line">           cur=cur.next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3><span id="使用栈">使用栈</span></h3><p>栈具有后进先出的特点，在遍历链表时间将值按顺序放入栈，最后出栈即尾逆序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">       Stack&lt;Integer&gt; stack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">       ListNode cur=listNode;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span> (cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           stack.push(cur.val);</span><br><span class="line">           cur=cur.next;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       ArrayList&lt;Integer&gt; result=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">           result.add(stack.pop());</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">       </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;从尾到头打印链表&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.nowcoder.com/practice/d0267f7f55b3412ba93bd35cfa8e8035?tpId=13&amp;amp;tqId=11156&amp;amp;tPage=1&amp;amp;rp=1&amp;amp;ru=/ta/coding-interviews&amp;amp;qru=/ta/coding-interviews/question-ranking&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;牛客网在线测试&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;解题思路&quot;&gt;&lt;a href=&quot;#解题思路&quot; class=&quot;headerlink&quot; title=&quot;解题思路&quot;&gt;&lt;/a&gt;解题思路&lt;/h2&gt;&lt;h3 id=&quot;使用递归&quot;&gt;&lt;a href=&quot;#使用递归&quot; class=&quot;headerlink&quot; title=&quot;使用递归&quot;&gt;&lt;/a&gt;使用递归&lt;/h3&gt;&lt;p&gt;要逆序打印链表&lt;code&gt;1-&amp;gt;2-&amp;gt;3&lt;/code&gt;，可以先打印链表&lt;code&gt;2-&amp;gt;3&lt;/code&gt;再打印节点1。而打印俩表&lt;code&gt;2-&amp;gt;3&lt;/code&gt;可以看作一个新的链表，可以再次调用求解函数对其进行逆序输出。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="https://zofun.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Java" scheme="https://zofun.github.io/tags/Java/"/>
    
      <category term="算法" scheme="https://zofun.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法：二维数组中的查找</title>
    <link href="https://zofun.github.io/2020/03/28/%E7%AE%97%E6%B3%95%EF%BC%9A%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/"/>
    <id>https://zofun.github.io/2020/03/28/算法：二维数组中的查找/</id>
    <published>2020-03-28T02:10:00.000Z</published>
    <updated>2020-03-28T02:10:20.666Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="题目描述">题目描述</span></h2><p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Consider the following matrix:</span><br><span class="line">[</span><br><span class="line">[1, 4, 7, 11, 15],</span><br><span class="line">[2, 5, 8, 12, 19],</span><br><span class="line">[3, 6, 9, 16, 22],</span><br><span class="line">[10, 13, 14, 17, 24],</span><br><span class="line">[18, 21, 23, 26, 30]</span><br><span class="line">] </span><br><span class="line">Given target = 5, return true.</span><br><span class="line">Given target = 20, return false.</span><br></pre></td></tr></table></figure><a id="more"></a><p><a href="https://www.nowcoder.com/practice/abc3fe2ce8e146608e868a70efebf62e?tpId=13&amp;tqId=11154&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">牛客在线测试</a></p><h2><span id="解题思路">解题思路</span></h2><p>通过观察二维数组，我们可以发现二维数组中的一个数，小于它的数一定在其左边，大于它的数一定在其下边。我们利用这个规律，从右上角开始查找。通过target与当前元素的大小关系来缩小查找区间。</p><h2><span id="解题代码">解题代码</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> [][] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array==<span class="keyword">null</span>||array.length==<span class="number">0</span>||array[<span class="number">0</span>].length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> row=array.length;</span><br><span class="line">        <span class="keyword">int</span> col=array[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> r=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> c=col-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (r&lt;row&amp;&amp;c&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(target==array[r][c])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target&lt;array[r][c])&#123;</span><br><span class="line">                c--;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                r++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Consider the following matrix:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[1, 4, 7, 11, 15],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[2, 5, 8, 12, 19],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[3, 6, 9, 16, 22],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[10, 13, 14, 17, 24],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[18, 21, 23, 26, 30]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;] &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Given target = 5, return true.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Given target = 20, return false.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="https://zofun.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Java" scheme="https://zofun.github.io/tags/Java/"/>
    
      <category term="算法" scheme="https://zofun.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
