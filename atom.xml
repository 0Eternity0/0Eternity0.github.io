<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>个人博客</title>
  
  <subtitle>博观而约取 厚积而薄发</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-12-24T13:28:22.120Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>爱写代码的小书童</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>变强日记18</title>
    <link href="http://yoursite.com/2019/12/24/%E5%8F%98%E5%BC%BA%E6%97%A5%E8%AE%B018/"/>
    <id>http://yoursite.com/2019/12/24/变强日记18/</id>
    <published>2019-12-24T13:22:56.000Z</published>
    <updated>2019-12-24T13:28:22.120Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="主要内容">主要内容</span></h2><ol><li>TCP协议是如何保证传输的可靠性的</li><li>算法题：序列化二叉树</li></ol><a id="more"></a><h2><span id="tcp协议是如何保证传输的可靠性的">TCP协议是如何保证传输的可靠性的</span></h2><p>TCP提供了一种面向连接的，可靠的字节流服务。两个使用TCP协议的应用在通信之前必须要先建立TCP连接。<br>为了保证可靠性，TCP主要依靠以下几种方法：</p><ol><li>数据包校验：目的是检测数据在传输过程中的任何变化，如哦检验出包有问题，则丢弃报文段并且不会给响应，这时TCP超时后会进行重发。</li><li>对失序数据包重排序：既然TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此TCP报文段的到达也可能会失序。TCP将对失序数据进行重新排序，然后才交给应用层；</li><li>丢弃重复数据：对于重复数据，能够丢弃重复数据；</li><li>应答机制：当TCP收到发自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒；</li><li>超时重发：当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段；</li><li>流量控制：TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制。TCP使用的流量控制协议是可变大小的滑动窗口协议。</li></ol><h2><span id="算法题序列化二叉树">算法题：序列化二叉树</span></h2><p>题目：<br>请实现两个函数，分别用来序列化和反序列化二叉树<br>二叉树的序列化是指：把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串，从而使得内存中建立起来的二叉树可以持久保存。序列化可以基于先序、中序、后序、层序的二叉树遍历方式来进行修改，序列化的结果是一个字符串，序列化时通过 某种符号表示空节点（#），以 ！ 表示一个结点值的结束（value!）。<br>二叉树的反序列化是指：根据某种遍历顺序得到的序列化字符串结果str，重构二叉树。</p><p>解法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">Serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若根节点为空，返回“#,”</span></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"#,"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 新建StringBudffer，存储节点值</span></span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer(root.val+<span class="string">","</span>);</span><br><span class="line">    <span class="comment">// 递归左子树</span></span><br><span class="line">    sb.append(Serialize(root.left));</span><br><span class="line">    <span class="comment">// 递归右子树</span></span><br><span class="line">    sb.append(Serialize(root.right));</span><br><span class="line">    <span class="comment">// 返回StringBuffer的字符串值</span></span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode <span class="title">Deserialize</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    String[] ss = str.split(<span class="string">","</span>);</span><br><span class="line">    <span class="comment">// 用字符串数组构建字符串队列</span></span><br><span class="line">    Queue&lt;String&gt; q = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ss.length; i++)&#123;</span><br><span class="line">        q.add(ss[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归生成二叉树</span></span><br><span class="line">    <span class="keyword">return</span> preOrder(q);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> TreeNode <span class="title">preOrder</span><span class="params">(Queue&lt;String&gt; q)</span></span>&#123;</span><br><span class="line">    <span class="comment">// “弹出”队列下一个字符串</span></span><br><span class="line">    String val = q.poll();</span><br><span class="line">    <span class="comment">// 如果值为'#'说明是空结点</span></span><br><span class="line">    <span class="keyword">if</span>(val.equals(<span class="string">"#"</span>))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果值不为'#'，用该值的整型值构建节点</span></span><br><span class="line">    TreeNode node = <span class="keyword">new</span> TreeNode(Integer.valueOf(val));</span><br><span class="line">    <span class="comment">// 遍历构建节点左子树</span></span><br><span class="line">    node.left = preOrder(q);</span><br><span class="line">    <span class="comment">// 遍历构建节点右子树</span></span><br><span class="line">    node.right = preOrder(q);</span><br><span class="line">    <span class="comment">// 返回节点</span></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;主要内容&quot;&gt;&lt;a href=&quot;#主要内容&quot; class=&quot;headerlink&quot; title=&quot;主要内容&quot;&gt;&lt;/a&gt;主要内容&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;TCP协议是如何保证传输的可靠性的&lt;/li&gt;
&lt;li&gt;算法题：序列化二叉树&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
    
      <category term="变强日记" scheme="http://yoursite.com/tags/%E5%8F%98%E5%BC%BA%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>变强日记17</title>
    <link href="http://yoursite.com/2019/12/21/%E5%8F%98%E5%BC%BA%E6%97%A5%E8%AE%B017/"/>
    <id>http://yoursite.com/2019/12/21/变强日记17/</id>
    <published>2019-12-21T13:22:56.000Z</published>
    <updated>2019-12-21T12:12:49.099Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="主要内容">主要内容</span></h2><ol><li>spring:BeanFactory和ApplicationContext有什么区别？</li><li>算法：删除链表中重复的节点<a id="more"></a><h2><span id="beanfactory和applicationcontext有什么区别">BeanFactory和ApplicationContext有什么区别？</span></h2>BeanFactory和ApplicationContext都是spring的核心接口，其中ApplicationContext是BeanFactory的子接口。</li></ol><p>BeanFactory是spring中最底层的接口，包含了各种bean的定义，读取bean的配置文档，管理bean的加载，实例化控制bean的生命周期，维护bean之间的依赖关系。ApplicationContext接口除了提供BeanFacttory提供的功能之外，还提供了更加完备的框架功能：</p><ol><li>继承MessageSource，支持国际化</li><li>统一的资源文件访问方式</li><li>同时加载多个配置文件</li><li>载入多个有继承关系的上下文，使得每个上下文都专注于特定的层次。</li></ol><p>BeanFactory采用的是延迟加载的方式来注入Bean，即只有在使用某个bean的时候，才对bean进行加载实例化。而ApplicationContext是在容器启动时候，就一次性创建了所有的bean。</p><p>BeanFactory通常是一个编程的方式创建的，而ApplicationContext还能以声明的方式创建，如使用ClassLoader。</p><p>BeanFactory和ApplicationContext都支持BeanPostProessor、BeanfactoryPostProcess的使用，两者的区别在于BeanFactory需要手动注册，而ApplicationContext是自动注册。</p><h2><span id="算法删除链表中重复的节点">算法：删除链表中重复的节点</span></h2><p>题目：<br>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5</p><p>分析：<br>这种题，一般画图就可以形象化，代码写起来就比较容易了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplication</span><span class="params">(ListNode pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode tmpHead=<span class="keyword">new</span> ListNode(Integer.MAX_VALUE);</span><br><span class="line">        tmpHead.next=pHead;</span><br><span class="line">        ListNode cur=tmpHead;</span><br><span class="line">        ListNode next;</span><br><span class="line">        ListNode cur2;</span><br><span class="line">        <span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            next=cur.next;</span><br><span class="line">            cur2=next;</span><br><span class="line">            len=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (next!=<span class="keyword">null</span>&amp;&amp;cur2!=<span class="keyword">null</span>&amp;&amp;next.val==cur2.val)&#123;</span><br><span class="line">                cur2=cur2.next;</span><br><span class="line">                len++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(len&gt;<span class="number">1</span>)&#123;</span><br><span class="line">                cur.next=cur2;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cur=cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tmpHead.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;主要内容&quot;&gt;&lt;a href=&quot;#主要内容&quot; class=&quot;headerlink&quot; title=&quot;主要内容&quot;&gt;&lt;/a&gt;主要内容&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;spring:BeanFactory和ApplicationContext有什么区别？&lt;/li&gt;
&lt;li&gt;算法：删除链表中重复的节点
    
    </summary>
    
    
    
      <category term="变强日记" scheme="http://yoursite.com/tags/%E5%8F%98%E5%BC%BA%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>变强日记16</title>
    <link href="http://yoursite.com/2019/12/20/%E5%8F%98%E5%BC%BA%E6%97%A5%E8%AE%B016/"/>
    <id>http://yoursite.com/2019/12/20/变强日记16/</id>
    <published>2019-12-20T13:22:56.000Z</published>
    <updated>2019-12-20T12:56:20.843Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="主要内容">主要内容</span></h2><ol><li>redis的过期策略和内存淘汰机制</li><li>算法：字符流中第一个不重复的字符</li></ol><a id="more"></a><h2><span id="redis的过期策略和内存淘汰机制">redis的过期策略和内存淘汰机制</span></h2><h3><span id="redis的过期策略">redis的过期策略</span></h3><p>redis给键值对设置的过期时间的命令主要有两种：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expire key 10 # 给制定的key设置过期时间为10秒</span><br><span class="line">setex key 10 value # 给key的值设置为value，其过期时间为10秒</span><br></pre></td></tr></table></figure></p><p>那么redis到底是如何处理这些过期的时间呢？<br>redis采用的定期删除和惰性删除的方式<br>定时删除：redis默认是每隔100ms就随机抽取一些设置了过期时间的key，检测是否过期，并进行处理。定时删除并不能保证所有已经过期的key都被删除。所以还需要惰性删除的机制。</p><p>惰性删除：是指在获取某个key的时候，redis会再次检测一下，这个key是否过期，如果过期了，这个时候就进行删除。</p><p>因此，如果定时删除漏掉了许多的key，且没有进行惰性删除，那么会怎么样？内存中堆积大量过期的key，导致redis的内存耗尽，就需要内存淘汰机制。</p><h3><span id="内存淘汰机制">内存淘汰机制</span></h3><p>如果redis的内存占用过多的时候，此时会进行内存淘汰，内存淘汰的策略主要有以下几种：<br>noeviction:当内存不足以容纳新写入的数据时，新写入操作报错。<br>allkey-lru:当内存不足以容纳新写入的数据时，在键空间中移除最近最少使用的key。（这个时最常见的）<br>allkey-random:当内存不足以容纳新写入的数据时，在键空间中随机移除某个key。<br>volatile-lru:当内存不足以容纳新写入的数据时,在设置了过期时间的键空间中，移除最近最少使用的key。<br>volatile-random:当内存不足以容纳新写入的数据时,在设置了过期时间的键空间中，随机移除某个key。<br>volatile-ttl:当内存不足以容纳新写入的数据时,在设置了过期时间的键空间中，有更早过期时间的key优先移除。</p><h2><span id="算法字符流中第一个不重复的字符">算法：字符流中第一个不重复的字符</span></h2><p>题目：<br>请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l“。</p><p>分析：使用一个map来记录目前字符出现的次数，一个来记录字符出现的次序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span>[] count=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">int</span>[] index=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Insert one char from stringstream</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">char</span> ch)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        count[ch]++;</span><br><span class="line">        index[ch]=num++;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//return the first appearence once char in current stringstream</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">FirstAppearingOnce</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> minIndex=num;</span><br><span class="line">       <span class="keyword">char</span> ch=<span class="string">'#'</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">256</span>;i++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(count[i]==<span class="number">1</span>&amp;&amp;index[i]&lt;minIndex)&#123;</span><br><span class="line">               ch=(<span class="keyword">char</span>)i;</span><br><span class="line">               minIndex=index[i];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> ch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;主要内容&quot;&gt;&lt;a href=&quot;#主要内容&quot; class=&quot;headerlink&quot; title=&quot;主要内容&quot;&gt;&lt;/a&gt;主要内容&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;redis的过期策略和内存淘汰机制&lt;/li&gt;
&lt;li&gt;算法：字符流中第一个不重复的字符&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
    
      <category term="变强日记" scheme="http://yoursite.com/tags/%E5%8F%98%E5%BC%BA%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>软件项目管理期末复习</title>
    <link href="http://yoursite.com/2019/12/19/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"/>
    <id>http://yoursite.com/2019/12/19/软件项目管理期末复习/</id>
    <published>2019-12-19T13:22:56.000Z</published>
    <updated>2019-12-19T14:10:34.882Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="软件项目管理">软件项目管理</span></h1><ol><li>项目定义<br>项目是为了创造一个<strong>唯一</strong>的产品或提供一个唯一的服务而进行的<strong>临时性</strong>的努力。<br>项目：由一组有起止日期的、相互协调的受控活动所组成的独特过程，该过程要达到符合包括时间、成本和资源的约束条件在内的规定要求的目标。<br>Project:unique process, consisting of a set of coordinated and controlled activities with start and finish dates, undertaken to achieve  an objective conforming to specific requirements, including the constrains of time, cost and resources. </li></ol><a id="more"></a><ol start="2"><li>运作与项目的区别<br>运作（Operations）,连续不断，周而复始的活动<br>项目（Project），临时性、一次性的活动</li></ol><p>项目是一次性的，日常运作时重复进行的。项目时目标导向的，日常运作时通过效率和有效性体现的。项目时通过项目经理及其团队工作完成的，而日常运作时职能式的线性管理。项目存在大量的变更管理，而日常运作则基本保存连贯性的。</p><ol start="3"><li>项目的特征</li></ol><ul><li>有明确的目标</li><li>项目之间的活动具有相关性</li><li>限定的周期</li><li>有独特性</li><li>资源成本的约束性</li><li>项目的不确定性</li></ul><ol start="4"><li><p>实现项目目标的制约因素<br>工作范围，成本，进度计划，客户满意度<br>项目的三重约束：时间，功能，费用</p></li><li><p>软件项目管理活动<br>定义项目范围，分析风险，确定资源，资金和工作量预算，制定时间计划</p></li><li><p>软件项目管理的定义<br>软件项目管理是为了使软件项目能够按照预定的成本、进度、质量顺利完成，而对成本、人员、进度、质量、风险等进行分析和管理的活动。</p></li><li><p>九大领域知识<br>九大领域知识分别是：范围管理（scope）、时间管理（time）、成本管理(cost)、质量管理(quality)、人力资源管理(HR)、沟通管理(comm)、采购管理(procurement)、风险管理(risk)和整体管理(inteqration)。 其中范围、时间、成本和质量是项目管理的四大核心领域。</p></li><li><p>5个标准化过程组<br>启动过程组：确定一个项目或一个阶段可以开始了<br>计划过程组：进行计划并保持一个可操作的进度安排，确保实现项目的既定商业目标<br>执行过程组：协调人力和其他资源、执行计划<br>控制过程组：通过监督和检查过程，确保项目达到目标，必要时采取一些修正措施<br>收尾过程组：取得项目或阶段的正式认可并有序结束该项目或阶段</p></li><li><p>项目管理的5要素</p></li></ol><ul><li>技术（Technical）</li><li>方法（methodology）</li><li>团队建设(Team Building)</li><li>信息(Information)</li><li>沟通(communication:80% jobs)</li></ul><ol start="10"><li>需要权衡的三个方面<br>质量，进度，成本</li><li>战略上的范围<br>人员（People），问题（Problem），过程（Process）</li><li>The Management Spectrum(管理涉及的范围)<br>Prople(most important),product,process,project</li><li>The stakeholders<br>Senior managers（高级管理）,Project(technical) managers(项目（技术）管理者)，Practitioners（开发人员）,Customers（客户）,End-users（最终用户）</li><li>team leader<br>how to lead<br>how to collaborate(如何合作)<br>how to motivate<br>how to organize（如何组织）<br>how to create good ideas</li><li>The MOI Model（领导能力）<br>Motivation,Organization,Ideas or innovation（理想和创新）</li><li><p>项目负责人的四个关键品质<br>Problem solving,Managerial identity（管理身份）,Achievement(成就）,Influence and team building(影响力和团队建设).</p></li><li><p>项目经理可以使用的九条影响和能力<br>权力，任务，预算，提升，资金，处罚，工作挑战，专门技术，友谊</p></li><li><p>选择软件项目团队结构应考虑的因素：</p></li></ol><ul><li>the difficulty of the problem to be solved (待解决的问题的难度)</li><li>the size fo the resultant programs in lines of code or function points（开发规模，以代码行或功能点来度量）</li><li>the time that the team will stay together （team lifetime）（团队成员需要共同工作的时间（团队生存期））</li><li>the degree to which the problem can be modularized（能够对问题做模块化划分的程度）</li><li>the required quality and reliability of the system to be built（待开发系统的质量要求和可靠性要求）</li><li>the rigidity of the delivery date(交付日期的严格程度)</li><li>the degree of sociability(communication) required for rhe project(项目所需要的友好交流程度)</li></ul><ol start="19"><li>the structure of a software team</li></ol><ul><li>closed paradigm&gt;structures a team along a traditional hierarchy of authority(封闭式范型，按照传统的权力层次来组织团队)</li><li>random paradigm&gt;structures a team loosely and depends on individual initiative of the team members.(随机式范型，松散地组织团队，团队工作依赖于团队成员个人地主动性)</li><li>open paradigm&gt;attempts to structure a team in a manner that achieves some of the controls associated with the closed paradigm but also much of the innovation that occurs when using the random paradigm（试图以一种既具有封闭式范型地控制性，又包含随机式范型地创新性地方式来组织团队）</li><li>synchronous paradigm&gt; relies on the natural compartmentaliztion of a problem and organizes team members to work on pieces of the probles with little active communication among themselves.(同步式范型，依赖于问题地自然划分，组织团队成员各自解决问题的一部分，它们之间没有什么主动地交流)</li></ul><ol start="20"><li>各种团队范型的适用范围</li></ol><ul><li>close paradigm:开发的软件与过去做过的产品相识，难以进行创新性的工作</li><li>random paradigm：需要创新和技术突破时，有优势，当需要“有序执行”才能完成工作，该结构陷入困境</li><li>open paradigm:解决复杂问题，效率相对其它方式低</li><li>synchronous paradigm：问题自然划分，团队人员各自解决问题一部分，缺乏主动交流。</li></ul><ol start="29"><li>agile philosophy</li></ol><ul><li>customer satisfaction(客户满意)</li><li>early incremental delivery（尽快的增量交付）</li><li>small,highly motivated project teams（小型，高积极性的团队）</li><li>informal methods（非正式的方法）</li><li>minimal software engineering work products（最小的软件工程工作产品）</li><li>overall development simplicity （整体开发简单化）</li></ul><ol start="30"><li>the product scope</li></ol><ul><li>context:项目环境，要开发的软件如何适用于大型系统、产品或业务环境</li><li>information objectives:信息目标。软件要产生哪些客户可见的数据对象作为输出？需要什么数据对象作为输入？</li><li>Function and performance：功能和性能。</li></ul><p><strong>software project scope must be unambiguous and understandable at the management and technical levels.（在管理层和技术层都必须是无歧义可理解的）</strong></p><ol start="31"><li>common-sense approach to projects（针对项目的易于理解的方法）</li></ol><ul><li>start on the right foot(在正确的基础上开始工作)</li><li>maintain momentum(保持动力)</li><li>track progress(跟踪进度)</li><li>make smart decisions(做出英明的决策)</li><li>conduct a postmorterm analysis(进行事后分析)</li></ul><ol start="32"><li>W5HH原则</li></ol><ul><li>why is the system beging developed?</li><li>what will be done?</li><li>when will it be accomplished?</li><li>who is responsible?</li><li>where are they organizationally located?</li><li>how will the job be done technically and managerially?</li><li>how much of each resource will be needed?</li></ul><ol start="33"><li><p>立项流程<br><img src="https://s2.ax1x.com/2019/12/16/Q5U6wq.png" alt="Q5U6wq.png"></p></li><li><p>敏捷宣言<br>个体和交互胜过过程和工具。可以工作的软件胜过面面俱到的文档。客户合作胜过合同谈判。响应变化胜过遵循计划。</p></li><li><p>XP(extremem programming)极限编程模型<br>实施原则：快速反馈（Rapid feedback）,假设简单(Assuming simplicity),包容变化(Embracting change)</p></li><li><p>软件需求定义<br>需求是指用户对软件的功能和性能的要求。</p></li><li><p>软件需求管理的过程<br>需求获取阶段： 需求获取–&gt;需求分析–&gt;需求规格bianxie–&gt;需求验证<br>需求变更： 需求变更</p></li><li><p>需求分析<br>需求分析是为了最终用户所看到的系统建立一个概念模型，是对需求的抽象描述。</p></li><li><p>需求验证</p></li></ol><ul><li>需求是正确的吗</li><li>需求是一致的吗</li><li>需求是完全的吗</li><li>需求是实际可行的吗</li><li>需求是必要的吗</li><li>需求是可检验的吗</li><li>需求是可跟踪的吗</li><li>最后签字</li></ul><ol start="40"><li>需求变更管理</li></ol><ul><li>确定需求变革控制过程</li><li>建立变更控制委员会</li><li>进行绣球变更影响分析</li><li>跟踪所有受需求变革影响的工作产品</li><li>建立需求基准版本和需求控制版本文档</li><li>维护需求变更的历史记录</li><li>跟踪每项需求的状态</li><li>衡量需求稳定性</li></ul><ol start="41"><li>需求建模的基本方法</li></ol><ul><li>原型方法<br>需求分析，原型开发，原型评价</li><li>结构化分析法<br>面向数据流的方法，自顶向下逐步求精的方法；根据软件内部数据传递、变换的关系进行分析的（DFD,DD,系统流程图）</li><li>面向对象的用例分析法<br>基于面向对象的情景分析方法；从用户角度出发考虑的功能需求；用例是系统向用户提供一个有价值的结果的某项功能。（Use case diagram,Sequence diagram,State diagram,Activity Diagram）</li><li>功能列表法</li></ul><ol start="42"><li>任务分解的定义<br>任务分解：将一个项目分解为更多的工作项目会子项目，使项目变得更小，更易管理，更易操作。<br>任务分解的结果：WBS（work breakdown structure 任务分解结构），WBS使对项目由粗到细的分解过程，面向交付成果的，WBS组织并定义了整个项目范围。</li></ol><p>工作包(work packages)：是wbs的最低层次的可交付成果，工作包应当由唯一主题负责。</p><ol start="43"><li>任务分解的方法</li></ol><ul><li>类比</li><li>模板参照</li><li>自上而下</li><li>至下而上</li></ul><ol start="44"><li>任务分解的基本步骤</li></ol><ul><li>确认并分解项目的组成要素(WBS编号)</li><li>确定分解标准</li><li>确定分解是否详细</li><li>确定项目交付成果（可以编制WBS字典）</li><li>验证分解的正确性</li></ul><ol start="45"><li>检验分解结果的标准</li></ol><ul><li>最底层的要素是否是实现目标的充分必要条件</li><li>最底层要素是否由重复的</li><li>每个要素是否清晰完整定义</li><li>最底层要输是否由定义清晰的责任人</li><li>是否可以进行成本估算和进度安排</li></ul><ol start="46"><li>WBS任务分解建议</li></ol><ul><li>最底层是可控的和可管理的，但是不必过细</li><li>每个work package必须有一个提交物</li><li>定义任务完成的标准</li><li>有利于责任分配</li><li>推荐任务分解到40小时以内</li></ul><ol start="47"><li><p>任务分解的方式<br>按照生存期阶段分解：规划，需求，设计，编码，测试，提交<br>按照产品组成分解：招生管理，分班管理，学生档案管理，学生成绩管理<br>按功能分解的例子：<br><img src="https://s2.ax1x.com/2019/12/18/Q7Xc1s.md.png" alt="Q7Xc1s.md.png"></p></li><li><p>项目估算<br>before the project can begin,the software team should estimate the <strong>work to be done</strong>,the <strong>resources</strong> that will be required,and the <strong>time</strong> that will elapse from start to finish.（在项目启动前我们应该估计项目从开始到结束所花费的成本，资源，工作量及时间）</p></li><li><p>什么是项目计划<br>software priject management begins with a set of activities that are collectively called project planning.</p></li><li><p>软件项目计划包含的五大主要活动<br>sofeware project planning encompasses five major activities-estimation,scheduling,risk analysis,quality management planning,and change management.</p></li></ol><p>estimation:your attempt to determine how much money,effort,resources,and time it will take to build a specific software-based system or product.</p><ol start="51"><li><p>由谁来做软件项目计划<br>software project managers-using information solicited from project stakeholders and software metrics data collected from past projects.(从项目设众处获得信息和从过去项目中收集的软件度量数据)</p></li><li><p>软件项目估计的步骤</p></li></ol><ul><li>Estimation begins with <strong>a description of the scope of the product</strong>.(评估始于对产品范围的估计)</li><li>The project is then decomposed into a set of smaller problems,and each of these is estimated using historical data and experience as guides.（然后将问题分成一组较小的问题，并以历史数据和经验为指导，对每个小问题进行估计）</li><li>Problem complexity and risk are considered before a final estimate is made.（在进行最终评估之前，需要考虑问题的复杂性和风险）</li></ul><ol start="53"><li><p>项目估计的工作产品<br>A simple table delineating the tasks to be performed,the functions to be implemented,and the cost,effort,and time involved for each is generated.(生成一个简单的表，其中描述了要执行的任务，要实现的功能以及每种任务的成本、工作和时间)</p></li><li><p>关于估算</p></li></ol><ul><li>估算不是很准确，有误差</li><li>项目经验数据非常重要</li><li>不要太迷信某些数学模型</li></ul><ol start="55"><li><p>软件项目规模<br>软件项目规模即工作量，例如软件规划，软件管理，需求，设计，编码，测试，以及后期的维护等任务。<br>单位有：LOC（Loc of Code源代码长度的测量）,FP(Fuction Point，用系统的功能数量来测量),人月，人天，人年</p></li><li><p>软件项目的成本</p></li></ol><ul><li>完成软件规模相应付出的代价</li><li>待开发的软件项目需要的资金</li><li>人的劳动的消耗所需要的代价是软件产品的主要成本</li></ul><ol start="57"><li>对软件工程工作的资源，成本及进度进行估算时，需要</li></ol><ul><li>experience（经验）</li><li>access to good historical information(metrics)(有用的历史信息，度量)</li><li>the courage to commit to quantitative perdictions when qualitative information is all that exists.（当只存在定性的信息时，还要有进行定量预言的勇气）</li></ul><p>Extimation carries inherent risk,and this risk leads to uncertainty.（估算具有内在风险，这种风险导致了不确定性）</p><ol start="58"><li>估算的风险的主要因素</li></ol><ul><li>project complexity（项目的复杂性）</li><li>Project size（项目大小）</li><li>The degree of structural uncertainty(结构化不确定度)</li><li>The availablity of historical information（历史信息的有效性）</li></ul><ol start="59"><li>Project Planning task set</li></ol><ul><li>Establish project scope</li><li>Determine feasibility</li><li>Analyze risks</li><li>Define required resources<br>  determine require human resources<br>  define reusable software resources<br>  indntify environmental resources</li><li>Estimate cost and effort<br>  decompose the problem<br>  develop two or more estimates using size,function points,process tasks or use-cases<br>  reconcile the estimates(调用不同的估算)</li><li>Develop a project schedule<br>  establish a meaningful task set<br>  define a task network（定义任务网络）<br>  use scheduling tools to develop a timeline chart（使用进度计划工具制定时间表）<br>  define schedule tracking mechanismsd(定义进度跟踪机制）</li></ul><ol start="60"><li><p>To Understand Scope<br>the customers needs,the business context（商业环境）,the project boundaries（项目边界）,the customer’s motivation（客户动机）,the likely paths for change（项目可变更的路径）…</p></li><li><p>software scope describes</p></li></ol><ul><li>the functions and features that are to be delivered to end-users.(将要交给最终用户的功能和特性)</li><li>the data that are input and output（输入和输出数据）</li><li>the “context” that is presented to users as a consequence of using the software.（作为使用软件的结果呈现给用户的“内容”）</li><li>the performance (processing and response time)constraints (external hardware,available memory,etc),interfaces ,and reliability that bound the system.（界定系统的性能，约束条件，接口和可靠性）</li></ul><ol start="62"><li>Four characteristics of each resource:</li></ol><ul><li>description of the resource（资源的描述）</li><li>A statement of availability(可用性说明)</li><li>Time when the resource will be required（何时需要资源）</li><li>Duration of time that that the resource will be applied（使用资源的持续时间）</li></ul><ol start="63"><li>Resuable Software Resources</li></ol><ul><li>Off-the-shelf components(成品构件)</li><li>Full-experience components（具有完全经验的构件）</li><li>Partial-experience components（具有部分经验构件）</li><li>New components（新构件）</li></ul><ol start="64"><li>estimation strategies（估算策略）</li></ol><ul><li>delay estimation until late in the project（将估算推迟到项目后期）</li><li>Base estimates on similar projects that have already been eompleted(根据以完成的类似项目估算)</li><li>use relatively simple decomposition techniques to generate project cost and effort estimates.（使用简单分解技术，进行项目成本和工作量估算）</li><li>Use one or more empirical models for software cost and effort estimation.(使用一个或多个经验模型进行成本和工作量估算）</li></ul><ol start="65"><li>Decomposition Techology</li></ol><ul><li>decomposition of the problem and decompostion of the process.（问题分解和过程分解）</li><li>Estimation uses one or both forms of partitioning.</li><li>But before an estimate can be made,you must understand the scope of the software to be built and generate an estimate of its “size”</li></ul><ol start="66"><li>Problem-based Estimation 基于问题的估算</li></ol><ul><li>Applying baseing productivity metrics (LOC/pm,FP/pm)to LOC or FP,we can derive cost or effort for the function.(利用LOC/pm，FP/pm等生产率度量，我们能得到功能的成本和工作量)</li><li>For LOC estimation,decomposition is often taken to considerable levels of detail（对于LOC估计，分解得越详细越好）</li><li>For FP estimation,information domain characteristics-input,output,data files,inquiries and external interfaces must be required。(FP估计的五个信息域，输入，输出，数据文件，查询，和外部接口)</li></ul><ol start="67"><li><p>估计变量<br><img src="https://s2.ax1x.com/2019/12/18/QHUbR0.png" alt="QHUbR0.png"><br>Sopt乐观估计，Sm(最可能估计)，Spess(加权平均值)</p></li><li><p>Function-based metrics<br>information domani:<br>number of external inputs（EIS，外部输入）<br>number of external outputs（EOS，外部输出）<br>number of external inquiries （EQS，外部查询）<br>number of internal logical files（ILFS，外部文件数）<br>number of external interface files（EIFS，外部接口文件数）</p></li></ol><p>count total的计算方法：<br><img src="https://s2.ax1x.com/2019/12/18/QHBNuV.md.png" alt="QHBNuV.md.png"></p><p>VAF（适应性因子）Fi(i 1 to 14),一共有14个适应性因子，每个的取值为0-5<br><img src="https://s2.ax1x.com/2019/12/18/QHDUxI.md.png" alt="QHDUxI.md.png"></p><p>FP=count total*(0.65+0.01*Σ(Fi))</p><p>综合练习：<br><img src="https://s2.ax1x.com/2019/12/18/QHrRte.md.png" alt="QHrRte.md.png"></p><ol start="69"><li>Process-Based estimation</li></ol><ul><li>Process-based estimation begins with a delineation of software functions obtained from the project scope.</li><li>A series of framework activities must be performed for each function.</li><li>Function and related framework activities may be represented as part of table similar to the one presented in the following table.</li></ul><p><img src="https://s2.ax1x.com/2019/12/18/QHsej1.png" alt="QHsej1.png"></p><ol start="70"><li>Estimation with use cases</li></ol><ul><li>Use cases provide a software team with insight into <strong>software scope and requirements</strong>.</li><li>Once use cases have been developed they can be used to estimate the projected “size” of a software project.</li></ul><p>Use cases dont address the complexity of the functions and features that are described.Use cases can describe complex behavior that involve many functions and features.</p><ol start="71"><li>The characteristics which affect the computation of use case points.(UCP)</li></ol><ul><li>the number and complexity of the use cases in the system(系统中用例的数量和复杂度)</li><li>vaious nonfunctional requirements(such as portability,performance,maintainability) that are not written as use case (The technical requirements of the use case such as concurrency,security and performance)（系统中非功能需求的数量和复杂度，因为这些需求并不是作为用例编写的）</li><li>The environment in which the project will be developed(eg.the programming language,the software team’s motivation)(Variouts environmental factors such as the development team’s experience and knowledge)（项目开发的环境）</li></ul><ol start="72"><li>利用UCP来进行估计<br>UCP=UUCP<em>TCP</em>ECF</li></ol><p>UUCP:unadjusted use case points<br>TCP:technical complexity factor<br>ECF:Environment complexity factor</p><p>Compute a total unadjusted use case weight(UUCS)<br><img src="https://s2.ax1x.com/2019/12/19/QqR1C6.png" alt="QqR1C6.png"></p><p>compate the total unadjusted actor weight（UAW）<br><img src="https://s2.ax1x.com/2019/12/19/QqRsxS.png" alt="QqRsxS.png"></p><p>compute unadjusted use case point（UUCP）<br>UUCP=UAW+UUCW<br><img src="https://s2.ax1x.com/2019/12/19/QqRgbj.md.png" alt="QqRgbj.md.png"></p><p>compute technical complexity factors(TCFs)<br><img src="https://s2.ax1x.com/2019/12/19/QqRHr4.md.png" alt="QqRHr4.md.png"></p><p>Technical complexity Factors一共有13个，每个都有不同的权重(TCF_weight)，对每个技术复杂因子都要估计一个复杂性（value）。</p><p>compute Environmental complexty Factors（ECF）<br><img src="https://s2.ax1x.com/2019/12/19/QqWlZj.md.png" alt="QqWlZj.md.png"><br>环境因子有8个</p><p>最终计算：<br>UCP=UUCP<em>TCP</em>ECF</p><p>Effor=UCP*PF （例如Effort=73*20=1460hours）<br>PF：Productivity Factors</p><ol start="73"><li>Empirical Estimation Models（经验估算模型）<br>Use empirically derived formulas to predict effort as a function of LOC or FP.(经验模型使用经验公式来预测工作量，该工作量是LOC或FP的函数)</li></ol><p>The model should be tested by applying data collected from completed projected.（该模型应用已有数据对他进行验证）</p><p><img src="https://s2.ax1x.com/2019/12/19/QqbX8J.md.png" alt="QqbX8J.md.png"></p><ol start="74"><li>COCOMO-II Model构造性成本模型<br>使用条件：</li></ol><ul><li>Application composition model.Used during the early stages of software ennineering,when prototyping of user interfaces,consideration of software and system and system interaction,assessment of performance,and evaluation of technology maturity are paramount.(应用组装模型)</li><li>Early desgin stage model.Used once requirements have been stabilized and basic software architechture has been established.（早期设计阶段模型）</li><li>Post-architecture-stage model.Uesed during the constuction of the software.（体系结构后阶段模型）</li></ul><p>composition model uses object points which includes:<br>counts of screens SC<br>counts of reports RC<br>counts of components CC<br><img src="https://s2.ax1x.com/2019/12/19/QqjMOs.md.png" alt="QqjMOs.md.png"><br><img src="https://s2.ax1x.com/2019/12/19/QqjGkV.md.png" alt="QqjGkV.md.png"><br><img src="https://s2.ax1x.com/2019/12/19/QqjdX9.md.png" alt="QqjdX9.md.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;软件项目管理&quot;&gt;&lt;a href=&quot;#软件项目管理&quot; class=&quot;headerlink&quot; title=&quot;软件项目管理&quot;&gt;&lt;/a&gt;软件项目管理&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;项目定义&lt;br&gt;项目是为了创造一个&lt;strong&gt;唯一&lt;/strong&gt;的产品或提供一个唯一的服务而进行的&lt;strong&gt;临时性&lt;/strong&gt;的努力。&lt;br&gt;项目：由一组有起止日期的、相互协调的受控活动所组成的独特过程，该过程要达到符合包括时间、成本和资源的约束条件在内的规定要求的目标。&lt;br&gt;Project:unique process, consisting of a set of coordinated and controlled activities with start and finish dates, undertaken to achieve  an objective conforming to specific requirements, including the constrains of time, cost and resources. &lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>变强日记15</title>
    <link href="http://yoursite.com/2019/12/18/%E5%8F%98%E5%BC%BA%E6%97%A5%E8%AE%B015/"/>
    <id>http://yoursite.com/2019/12/18/变强日记15/</id>
    <published>2019-12-18T13:22:56.000Z</published>
    <updated>2019-12-18T14:22:07.739Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="主要内容">主要内容</span></h2><ol><li>MySQL中TRUNCATE和DELETE的区别</li><li>算法题：使用位运算来代替加减运算符</li></ol><a id="more"></a><h2><span id="mysql中truncate和delete的区别">MySQL中TRUNCATE和DELETE的区别?</span></h2><p>初次看到这个题目，说实在的非常的茫然，因为我好像从来没有用到过<code>TRUNCATE</code>这个关键字(PS:看来我就是一个连SQL都不会写的lz)，下面是学习后的辨析，总结：</p><ol><li>是否可以使用条件<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> student <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span>; <span class="comment"># 可以携带条件，删除满足条件的记录</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> student; <span class="comment"># 删除表中所有的数据</span></span><br></pre></td></tr></table></figure></li></ol><p>delete是可以是使用条件的,而truncate是不能使用条件的<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">truncate</span> <span class="keyword">table</span> student</span><br></pre></td></tr></table></figure></p><p>而且delete和truncate都是只删除数据，会保留数据表的。</p><ol start="2"><li><p>是否可以回滚<br>因为delete是数据操作语言(DML),因此是可以回滚的。而truncate是数据定义语言(DDL),是无法被回滚的。</p></li><li><p>效率<br>也正是因为truncate是不支持回滚的，因此需要处理事务日志，因此trucate删除数据更加快，且耗费的资源更少。</p></li></ol><h2><span id="算法题使用位运算来代替加减运算符">算法题：使用位运算来代替加减运算符</span></h2><p>例题：<br>[leetcode371]:两整数之和 不使用运算符 + 和 - ，计算两整数 a 、b之和。</p><p>分析：<br>要使用位运算来代替加减运算，就需要分析一波。位运算是如何实现加法的。 0 + 0 =0 0 + 1 =1 1 + 0 =1 1 + 1 =0（进位1） 很明显的规律就是相同位为0，不同位为1.也就是异或。<br>那么它的进位有什么特点呢？ 比如：5+4<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">        0101</span><br><span class="line">    +   0100</span><br><span class="line">        ——————</span><br><span class="line">进位为：0100</span><br></pre></td></tr></table></figure></p><p>很明显，进位就是按位与。 但是进位是应该放在高一位的，所以我们需要将进位结果左移一位。<br>所以我们的解放方案是：</p><ol><li>a+b的计算方案拆分为(a+b的无进位结果)+(a+b的进位结果)</li><li>循环这个操作，直到进位为0为止（可以递归）</li></ol><p>解法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(b==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//直到进位为0，就直接返回无进位结果</span></span><br><span class="line">            <span class="keyword">return</span> a; <span class="comment">//语句一</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//计算进位</span></span><br><span class="line">        <span class="keyword">int</span> out=(a&amp;b)&lt;&lt;<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//计算无进位结果</span></span><br><span class="line">        <span class="keyword">int</span> n=a^b;</span><br><span class="line">        <span class="comment">//递归调用，直到达到递归基线，也就是语句一</span></span><br><span class="line">        <span class="keyword">return</span> getSum(n, out);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;主要内容&quot;&gt;&lt;a href=&quot;#主要内容&quot; class=&quot;headerlink&quot; title=&quot;主要内容&quot;&gt;&lt;/a&gt;主要内容&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;MySQL中TRUNCATE和DELETE的区别&lt;/li&gt;
&lt;li&gt;算法题：使用位运算来代替加减运算符&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
    
      <category term="变强日记" scheme="http://yoursite.com/tags/%E5%8F%98%E5%BC%BA%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>变强日记14</title>
    <link href="http://yoursite.com/2019/12/17/%E5%8F%98%E5%BC%BA%E6%97%A5%E8%AE%B014/"/>
    <id>http://yoursite.com/2019/12/17/变强日记14/</id>
    <published>2019-12-17T13:22:56.000Z</published>
    <updated>2019-12-17T13:22:31.472Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="主要内容">主要内容</span></h2><ol><li>MySQL索引什么时候会失效</li><li>算法题：圆圈中最后剩下的数</li></ol><a id="more"></a><h2><span id="mysql索引什么时候会失效">MySQL索引什么时候会失效</span></h2><p>首先进行一个简单的总结，索引失效大致可以分为以下几种情况：</p><ol><li>复合索引使用不当导致索引失效</li><li>like是以“%”开头的情况</li><li>使用OR关键字的查询语句</li><li>其它</li></ol><p>下面对这些情况分别进行分析：</p><h3><span id="复合索引使用不当导致索引失效">复合索引使用不当导致索引失效</span></h3><p>复合索引又被称为联合索引。是指两个或两个以上的列上的索引。对于复合索引，MySQL从左到右的使用索引中的字段，一个查询可以只使用复合索引中的部分，当必须时最左侧的部分。</p><p>假如我们现在有这么一张表：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">test</span>(</span><br><span class="line">       a <span class="built_in">int</span>,</span><br><span class="line">       b <span class="built_in">int</span>,</span><br><span class="line">       c <span class="built_in">int</span>,</span><br><span class="line">       <span class="keyword">KEY</span> a(a,b,c)</span><br><span class="line">  );</span><br></pre></td></tr></table></figure></p><p><code>select * from test where a=1,b=2,c=3</code>这个查询使用到了a，b，c三个索引<br><code>select * from test where a=1,b=2</code>这个查询使用到了a，b两个索引<br><code>select * from test where a=1,c=3</code>这个查询只使用到了a这个所用，因为没有使用b这个索引，导致了c索引失效</p><p><code>select * form test where a=1,b&gt;2,c=3</code>，这个查询使用到了a,b，但没有使用到c，因为b是范围值，所以之后的索引c失效了</p><p><code>select * from test where a&gt;1,b=2,c=3</code>，这个查询只有a用到了索引，b，c索引失效了。</p><p><code>select * from test where b=2.c=3</code>这个查询没有用到任何的索引，b，c都失效了</p><p><code>select * from test where a=1 order by b</code>这个查询用到了索引a，并且排序也用到了索引b</p><p><code>select * from test where a=1 order by c</code>这个查询用到了索引a，但是排序并没有用到任何索引</p><h3><span id="like是以开头的情况">like是以“%”开头的情况</span></h3><p>比如如下的SQL<br><code>select * from test where a like &#39;%efg&#39;</code>这个查询因为”%”出现在了最开头，所以造成了索引失效.</p><p>而如果不是在开头，索引就不会失效.<br><code>select * from test where a like &#39;ef%&#39;</code>这个查询就用到了索引</p><p>那么如何让<code>like &#39;%字符串%&#39;</code>用上索引呢？<br>可以使用覆盖索引来解决，是查询的字段都包含在索引里，这样能用上索引</p><h3><span id="使用or关键字的查询语句">使用OR关键字的查询语句</span></h3><p><code>select * from test where a=2 or b=3</code>这个查询是能够使用到索引的，当查询条件中只有or关键字，且or前后的两个条件中列都是索引时，索引才会生效。</p><h3><span id="其它">其它</span></h3><p>比如在索引列上进行了计算，函数，类型转换等会造成索引失效。<br>使用 <code>is null</code> <code>is not null</code>也无法使用索引<br>字符串不加单引号也会照成索引失效</p><h2><span id="算法题圆圈中最后剩下的数">算法题：圆圈中最后剩下的数</span></h2><p>题目：</p><p>每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1)</p><p>如果没有小朋友，请返回-1</p><p>分析：这个就是一个典型的约瑟夫环问题，可以使用链表或数组来实现。</p><p>解法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">LastRemaining_Solution</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(n&lt;<span class="number">1</span>||m&lt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; list=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cur=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (list.size()&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">                cur++;</span><br><span class="line">                <span class="keyword">if</span>(cur==list.size())&#123;</span><br><span class="line">                    cur=<span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            list.remove(cur);</span><br><span class="line">            cur--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;主要内容&quot;&gt;&lt;a href=&quot;#主要内容&quot; class=&quot;headerlink&quot; title=&quot;主要内容&quot;&gt;&lt;/a&gt;主要内容&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;MySQL索引什么时候会失效&lt;/li&gt;
&lt;li&gt;算法题：圆圈中最后剩下的数&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
    
      <category term="变强日记" scheme="http://yoursite.com/tags/%E5%8F%98%E5%BC%BA%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>变强日记13</title>
    <link href="http://yoursite.com/2019/12/16/%E5%8F%98%E5%BC%BA%E6%97%A5%E8%AE%B013/"/>
    <id>http://yoursite.com/2019/12/16/变强日记13/</id>
    <published>2019-12-16T15:37:56.000Z</published>
    <updated>2019-12-16T13:02:00.637Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="主要内容">主要内容</span></h2><ol><li>CAS原理</li><li>算法：寻找数组中只出现一次的数字</li></ol><a id="more"></a><h2><span id="cas的原理">CAS的原理</span></h2><ol><li><p>什么是CAS？<br>CAS即（commpare and swap），是用于实现多线程同步到原子指令，它将内存中的内容与给定值进行比较，只有在相同的情况下，才将内存位置的内容修改为型的给定值，这是作为单个原子操作完成的。原子性保证新值基于最新信息计算，如果该值在同一时间被另一个线程更新，则写入将失败。Java1.5之后引入了CAS.在<code>java.util.concurrent.atomic</code>包下有大量的运用。</p></li><li><p>对于CAS的理解<br>假如现在两个线程都要去修改一个变量A值为1.那么这两个线程对于该变量的预期值都为1，假如第一个线程修改变量A的值为2，并从工作内存将变量A更新为2。对于线程线程二。此时变量A的值为2了，不再是预期值1了，那么第二个线程就会更新失败。<br>通俗的讲，CPU去更新一个值，但如果想更改的值不是预期的值，那么就更新失败，因为之前肯定有其它操作更改了这个值。</p></li></ol><p>CAS的伪代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">备份旧数据</span><br><span class="line">基于旧数据构造新数据</span><br><span class="line">&#125;<span class="keyword">while</span>(!CAS(内存地址,预期的旧数据（即备份的旧数据 ）,新数据))</span><br></pre></td></tr></table></figure></p><ol start="3"><li><p>CAS的开销<br>CAS是CPU指令级的操作，是一个原子操作，所以速度是非常快的，但不代表CAS就没有开销。CAS的开销主要是cache同步带来的开销。CAS操作其实也是在自己的工作内存中进行的，这就需要确保缓存的一致性，但相比使用锁，CAS的开销是非常小的。</p></li><li><p>CAS存在的问题？<br>之前提到：CPU去更新一个值，但如果想更改的值不是预期的值，那么就更新失败，因为之前肯定有其它操作更改了这个值。那如果现在内存中值是预期的值，那么之前就一定没有其它操作更新过这个值吗？显然是不能保证之前没有其它操作更新过这个值，因为假如预期值为A，该内存中的值可能经历了A-B-A的变化。这也就是CAS的ABA问题。解决ABA问题，可以引入“版本号”。</p></li></ol><p>除了ABA问题之外，CAS还不适合高并发的场景，如果更新失败，那么线程会不断重试更新，在线程竞争激烈的情况下，重试的过程会持续很久。线程不断尝试而导致等待被称为自旋。因此在高并发的情况下，使用锁更好。</p><h2><span id="算法寻找数组中只出现一次的数字">算法：寻找数组中只出现一次的数字</span></h2><ol><li><p>首先看一道简化的：<br>题目：<br>leetcode[136]:只出现一次的数字. 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素<br>分析：<br>这种题型我们可以使用位运算来解决，使用位运算中的异或来解决，异或有个特性即偶数个相同的数字异或后为0.利用这个特性就可以很快解决该问题了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num:nums)&#123;</span><br><span class="line">            result^=num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>更加难一点的题<br>题目：<br>一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。<br>分析：上一道题，我们直到了如何在成对的数字中找出唯一的一个单个的数字，但是这道题，需要我们找出两个只出现一次的数字，所以，我们需要将这些数组分为两个部分，每个部分各含一个只出现一次的数字。<br>我们还是将所有的数字依次异或，最后得到一个结果，成对的数字异或后为0，那么结果中某一位存在1，则必然是这两个单个出现的数在这一位不同，根据这一位，将数组分为两个部分，然后，按照上一道题的方法，就可以找出，每个部分中，只出现一次的数字了。</p></li></ol><p>解答：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//num1,num2分别为长度为1的数组。传出参数</span></span><br><span class="line"><span class="comment">//将num1[0],num2[0]设置为返回结果</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FindNumsAppearOnce</span><span class="params">(<span class="keyword">int</span> [] array,<span class="keyword">int</span> num1[] , <span class="keyword">int</span> num2[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> xor=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> item : array) &#123;</span><br><span class="line">            xor^=item;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> index=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> ((index&amp;xor)==<span class="number">0</span>) &#123;</span><br><span class="line">            index = index &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> resultA=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> resultB=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>((array[i]&amp;index)==<span class="number">0</span>) &#123;</span><br><span class="line">                resultA^=array[i];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                resultB^=array[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        num1[<span class="number">0</span>]=resultA;</span><br><span class="line">        num2[<span class="number">0</span>]=resultB;</span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;主要内容&quot;&gt;&lt;a href=&quot;#主要内容&quot; class=&quot;headerlink&quot; title=&quot;主要内容&quot;&gt;&lt;/a&gt;主要内容&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;CAS原理&lt;/li&gt;
&lt;li&gt;算法：寻找数组中只出现一次的数字&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
    
      <category term="变强日记" scheme="http://yoursite.com/tags/%E5%8F%98%E5%BC%BA%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>变强日记12</title>
    <link href="http://yoursite.com/2019/12/12/%E5%8F%98%E5%BC%BA%E6%97%A5%E8%AE%B012/"/>
    <id>http://yoursite.com/2019/12/12/变强日记12/</id>
    <published>2019-12-12T15:37:56.000Z</published>
    <updated>2019-12-12T14:15:15.382Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="主要内容">主要内容</span></h2><ol><li>深拷贝与浅拷贝</li><li>算法：把数组排成最小的数</li></ol><a id="more"></a><h2><span id="深拷贝与浅拷贝">深拷贝与浅拷贝</span></h2><h3><span id="浅拷贝">浅拷贝</span></h3><p>浅拷贝对于基本类型的属性会直接进行值传递，也就是对于基本类型的属性会复制一份给新的对象。而对于引用类型的属性，浅拷贝会进行<strong>引用</strong>的传递。因为传递的是引用，因此复制后的对象的此属性和原对象的属性<strong>指向同一个对象</strong>。<br>一段代码来证明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引用对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RefObj</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyObj</span>  <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="comment">//一定要实现标记接口Colneable否则会报CloneNotSupportedException异常</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> val; <span class="comment">//基本类型的属性</span></span><br><span class="line">    <span class="keyword">private</span> RefObj ref; <span class="comment">//引用类型的属性</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyObj</span><span class="params">(<span class="keyword">int</span> val,RefObj ref)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val=val;</span><br><span class="line">        <span class="keyword">this</span>.ref=ref;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> MyObj A = <span class="keyword">new</span> MyObj(<span class="number">1</span>, <span class="keyword">new</span> RefObj());</span><br><span class="line">        <span class="keyword">final</span> MyObj clone = (MyObj)A.clone();</span><br><span class="line">        System.out.println(A == clone); <span class="comment">//输出false</span></span><br><span class="line">        System.out.println(A.ref == clone.ref); <span class="comment">//输出true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="深拷贝">深拷贝</span></h3><p>深拷贝对于基本类型的变量的处理方法和浅拷贝一致，都是复制一份给新的对象。而对于引用类型，深拷贝会复制引用的对象，然后让克隆产生的新对象中的对应属性指向这个复制的引用对象。</p><p>那么如何实现深拷贝呢？<br>常见的有两种方法，一种是重新<code>Cloneable</code>接口中的<code>clone()</code>方法</p><ol><li>方案一：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RefObj</span>  <span class="keyword">implements</span>  <span class="title">Cloneable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="comment">//这个地方进行重写主要为了是改变clone()的访问级别</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyObj</span>  <span class="keyword">implements</span>  <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> RefObj ref;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyObj</span><span class="params">(<span class="keyword">int</span> val,RefObj ref)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val=val;</span><br><span class="line">        <span class="keyword">this</span>.ref=ref;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        MyObj clone = (MyObj)<span class="keyword">super</span>.clone();</span><br><span class="line">        <span class="comment">//让新对象的ref指向一个复制的新的对象</span></span><br><span class="line">        clone.ref= (RefObj) clone.ref.clone();</span><br><span class="line">        <span class="keyword">return</span> clone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> MyObj A = <span class="keyword">new</span> MyObj(<span class="number">1</span>, <span class="keyword">new</span> RefObj());</span><br><span class="line">        <span class="keyword">final</span> MyObj clone = (MyObj)A.clone();</span><br><span class="line">        System.out.println(A == clone); <span class="comment">//输出false</span></span><br><span class="line">        System.out.println(A.ref == clone.ref); <span class="comment">//输出false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>方案二，通过序列化来实现深拷贝<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RefObj</span>  <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyObj</span>  <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> RefObj ref;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyObj</span><span class="params">(<span class="keyword">int</span> val,RefObj ref)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val=val;</span><br><span class="line">        <span class="keyword">this</span>.ref=ref;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> MyObj obj = <span class="keyword">new</span> MyObj(<span class="number">1</span>, <span class="keyword">new</span> RefObj());</span><br><span class="line">        ByteArrayOutputStream baos=<span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream oos=<span class="keyword">new</span> ObjectOutputStream(baos);</span><br><span class="line">        oos.writeObject(obj);</span><br><span class="line"></span><br><span class="line">        oos.flush();</span><br><span class="line"></span><br><span class="line">        ObjectInputStream ois=<span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> ByteArrayInputStream(baos.toByteArray()));</span><br><span class="line">        <span class="keyword">final</span> MyObj cloneObj = (MyObj) ois.readObject();</span><br><span class="line"></span><br><span class="line">        System.out.println(obj == cloneObj); <span class="comment">//输出flase</span></span><br><span class="line">        System.out.println(obj.ref == cloneObj.ref);<span class="comment">//输出flase</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><em>必须实现标记接口Serializable</em></p><h2><span id="算法把数组排成最小的数">算法：把数组排成最小的数</span></h2><p>题目：<br>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。</p><p>思路：<br>任意两个拼接后进行比较，比如:s1+s2,和s2+s1，如果s1+s2大，那说明s2应该放前面，所以按这个规则，s2就应该排在s1前面.按照这个比较的方法，按照冒泡排序的思路，对数组进行排序即可，最后拼接。</p><p>解法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">PrintMinNumber</span><span class="params">(<span class="keyword">int</span> [] numbers)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numbers.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;numbers.length-i-<span class="number">1</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">long</span> a=Long.valueOf(numbers[j]+<span class="string">""</span>+numbers[j+<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">long</span> b=Long.valueOf(numbers[j+<span class="number">1</span>]+<span class="string">""</span>+numbers[j]);</span><br><span class="line">                <span class="keyword">if</span>(b&lt;a)&#123;</span><br><span class="line">                    <span class="keyword">int</span> tmp=numbers[j];</span><br><span class="line">                    numbers[j]=numbers[j+<span class="number">1</span>];</span><br><span class="line">                    numbers[j+<span class="number">1</span>]=tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder sb=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numbers.length;i++)&#123;</span><br><span class="line">            sb.append(numbers[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;主要内容&quot;&gt;&lt;a href=&quot;#主要内容&quot; class=&quot;headerlink&quot; title=&quot;主要内容&quot;&gt;&lt;/a&gt;主要内容&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;深拷贝与浅拷贝&lt;/li&gt;
&lt;li&gt;算法：把数组排成最小的数&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
    
      <category term="变强日记" scheme="http://yoursite.com/tags/%E5%8F%98%E5%BC%BA%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>变强日记10</title>
    <link href="http://yoursite.com/2019/12/09/%E5%8F%98%E5%BC%BA%E6%97%A5%E8%AE%B010/"/>
    <id>http://yoursite.com/2019/12/09/变强日记10/</id>
    <published>2019-12-09T15:37:56.000Z</published>
    <updated>2019-12-09T14:13:51.105Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="主要内容">主要内容</span></h2><ol><li>快速失败(fail-fast)和安全失败(fail-safe)的区别是什么？</li><li>算法：二叉树中和为某一值的路径</li></ol><a id="more"></a><h2><span id="快速失败fail-fast和安全失败fail-safe的区别是什么">快速失败(fail-fast)和安全失败(fail-safe)的区别是什么？</span></h2><h3><span id="什么是快速失败">什么是快速失败？</span></h3><p>在使用迭代器遍历一个集合对象时，迭代器是直接访问的集合中的内容，并且如果遍历过程中对集合对象的结构进行了修改，就会抛出<code>ConcurrentModeficationException</code><br>在集合类中维护了一个<code>protected transient int modCount = 0;</code>每当读集合的结构发送修改的时候，该值就会进行自增。而在迭代器中也维护了一个<code>expectedModCount</code>.在hashNext()/next()方法中会进行一个判断，但检测到<code>modCount != expectedModCount</code>就会抛出异常<code>ConcurrentModificationException</code>。<br>如果集合发送了变化但modCount的值又刚好等于expectedModCount的话，就不会抛出异常。因此不能依赖这个异常是否抛出而进行并发操作的编程，这个异常只建议用来检测并发修改的bug。</p><h3><span id="什么是安全失败">什么是安全失败?</span></h3><p>在使用安全失败机制的集合容器中，在遍历时不是直接在集合内容上访问的，而是复制原有的集合的内容，在拷贝的集合上进行遍历。因此在原集合上的修改对于迭代器来说是不知道的。<br><code>java.util.concurrent</code>包下的容器都是安全失败，可以在多线程下并发使用，并发修改。</p><h2><span id="算法二叉树中和为某一值的路径">算法：二叉树中和为某一值的路径</span></h2><p>题目描述：<br>输入一颗二叉树的跟节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)</p><p>解法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result=<span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Integer&gt; list=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root,<span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        list.add(root.val);</span><br><span class="line">        target-=root.val;</span><br><span class="line">        <span class="keyword">if</span>(target==<span class="number">0</span>&amp;&amp;root.left==<span class="keyword">null</span>&amp;&amp;root.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(list));</span><br><span class="line">        &#125;</span><br><span class="line">        FindPath(root.left,target);</span><br><span class="line">        FindPath(root.right,target);</span><br><span class="line">        list.remove(list.size()-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;主要内容&quot;&gt;&lt;a href=&quot;#主要内容&quot; class=&quot;headerlink&quot; title=&quot;主要内容&quot;&gt;&lt;/a&gt;主要内容&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;快速失败(fail-fast)和安全失败(fail-safe)的区别是什么？&lt;/li&gt;
&lt;li&gt;算法：二叉树中和为某一值的路径&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
    
      <category term="变强日记" scheme="http://yoursite.com/tags/%E5%8F%98%E5%BC%BA%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>变强日记11</title>
    <link href="http://yoursite.com/2019/12/09/%E5%8F%98%E5%BC%BA%E6%97%A5%E8%AE%B011/"/>
    <id>http://yoursite.com/2019/12/09/变强日记11/</id>
    <published>2019-12-09T15:37:56.000Z</published>
    <updated>2019-12-10T13:41:56.783Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="主要内容">主要内容</span></h2><ol><li>volatile关键字</li><li>算法题：找出出现次数超过一半的数</li></ol><a id="more"></a><h2><span id="volatile关键字">volatile关键字</span></h2><h3><span id="几个相关的基础概念">几个相关的基础概念</span></h3><p>共享变量：共享变量是指能够同时被多个线程访问到的变量，共享变量是存放在堆中的，而所有方法内的临时变量都不是共享变量。<br>重排序：重排序是为了提高指令的运行效率，在编译时或运行时堆指令的执行顺序进行调整的机制。指令重排序都遵循”as-if-serial”语意，即不管怎么重排序，单线程的执行结果不能被改变。<br>可见性：内存的可见性是指线程之间的可见性，一个线程的修改状态对另外一个线程时可见的。比如当线程A去修改了共享变量flag后，线程B去读共享变量flag一定读取到的是最新修改的flag。共享变量的可见性不是理所当然的，<strong>很多时候因为计算机内部的的cache和指令重排序的影响是不能保证可见性的</strong>。</p><h3><span id="volatile的原理">volatile的原理</span></h3><p>volatile修饰的变量不允许线程内部cache缓存和重排序，线程读取数据的时候直接读取内存，同时volatile不会对变量加锁，因此性能会比synchronized好。<br>还有一种说法是：读取一个volatile关键字会使相应的处理器执行刷新处理器缓存的动作，写一个volatile关键字会使得相应的处理器执行冲刷处理器缓存的动作。</p><h2><span id="算法题找出出现次数超过一半的数">算法题：找出出现次数超过一半的数</span></h2><p>题目：<br>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0</p><p>解法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> result=array[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(array.length==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(result==array[i])&#123;</span><br><span class="line">               count++;</span><br><span class="line">           &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">               count--;</span><br><span class="line">               <span class="keyword">if</span>(count==<span class="number">0</span>)&#123;</span><br><span class="line">                   result=array[i];</span><br><span class="line">                   count=<span class="number">1</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> item : array) &#123;</span><br><span class="line">            <span class="keyword">if</span>(item==result)&#123;</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num&gt;array.length/<span class="number">2</span>?result:<span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;主要内容&quot;&gt;&lt;a href=&quot;#主要内容&quot; class=&quot;headerlink&quot; title=&quot;主要内容&quot;&gt;&lt;/a&gt;主要内容&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;volatile关键字&lt;/li&gt;
&lt;li&gt;算法题：找出出现次数超过一半的数&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
    
      <category term="变强日记" scheme="http://yoursite.com/tags/%E5%8F%98%E5%BC%BA%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>变强日记9</title>
    <link href="http://yoursite.com/2019/12/08/%E5%8F%98%E5%BC%BA%E6%97%A5%E8%AE%B09/"/>
    <id>http://yoursite.com/2019/12/08/变强日记9/</id>
    <published>2019-12-08T15:37:56.000Z</published>
    <updated>2019-12-08T03:22:05.361Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="主要内容">主要内容</span></h2><ol><li>概括的解释下线程的几种可用状态</li><li>算法：判断一个序列是不是二叉查找树的后序遍历</li></ol><a id="more"></a><h2><span id="概括的解释下线程的几种可用状态">概括的解释下线程的几种可用状态</span></h2><p>线程有五个状态，它们分别是：</p><ol><li>新建：新创建了一个线程对象</li><li>可运行的：线程对象创建完成后，其它线程调用了该线程的start()方法.</li><li>运行：可运行状态下的线程获得了CPU时间片，执行程序代码</li><li>阻塞：线程因为某些原因放弃了CPU的使用权。暂时停止运行，直到到达可运行的状态。阻塞又可分为<br>等待阻塞，即调用了线程的wait方法；<br>同步阻塞：运行的线程在获取对象的同步锁时，如果该同步锁被其它线程占用，该线程就会被JVM放入锁池中。<br>其它阻塞：如调用了线程的sleep方法，或者发出IO请求时</li><li>死亡，因为代码执行结束或发生异常退出后，线程就死亡了，这是不可逆的。<br><img src="https://s2.ax1x.com/2019/12/08/QUqnoT.png" alt="QUqnoT.png"></li></ol><h2><span id="算法判断一个序列是不是二叉查找树的后序遍历">算法：判断一个序列是不是二叉查找树的后序遍历</span></h2><p>题目：<br>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。</p><p>解析：<br>二叉查找树有一个特定，左子树中的值都小于根节点，右子树的值都大于根节点。我们可以根据这个来递归判断。后序遍历序列的结构是左子树+右子树+根节点。找到根节点后递归按二叉树的特点判断即可。</p><p>解法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">VerifySquenceOfBST</span><span class="params">(<span class="keyword">int</span> [] sequence)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sequence==<span class="keyword">null</span>||sequence.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> help(sequence,<span class="number">0</span>,sequence.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">help</span><span class="params">(<span class="keyword">int</span>[] seq,<span class="keyword">int</span>  begin,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(begin&gt;=end)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> root=seq[end];</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//寻找左右子树的分界点</span></span><br><span class="line">        <span class="keyword">for</span>(i=begin;i&lt;end;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(seq[i]&gt;root)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断右子树有无小于root的值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;end;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(seq[j]&lt;root)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> help(seq,begin,i-<span class="number">1</span>)&amp;&amp;help(seq,i,end-<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;主要内容&quot;&gt;&lt;a href=&quot;#主要内容&quot; class=&quot;headerlink&quot; title=&quot;主要内容&quot;&gt;&lt;/a&gt;主要内容&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;概括的解释下线程的几种可用状态&lt;/li&gt;
&lt;li&gt;算法：判断一个序列是不是二叉查找树的后序遍历&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
    
      <category term="变强日记" scheme="http://yoursite.com/tags/%E5%8F%98%E5%BC%BA%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>变强日记8</title>
    <link href="http://yoursite.com/2019/12/07/%E5%8F%98%E5%BC%BA%E6%97%A5%E8%AE%B08/"/>
    <id>http://yoursite.com/2019/12/07/变强日记8/</id>
    <published>2019-12-07T15:37:56.000Z</published>
    <updated>2019-12-07T14:20:32.283Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="主要内容">主要内容</span></h2><ol><li>Redis的持久化机制</li><li>算法题：栈的压入、弹出序列<a id="more"></a></li></ol><h2><span id="redis的持久化机制">Redis的持久化机制</span></h2><p>Redis有两种持久化的方式，一种是RDB持久化，一种是AOF持久化。</p><h3><span id="rdb持久化">RDB持久化</span></h3><p>RDB持久化是通过快照的方式完成的，但符合某型条件的时候，redis会自动将内存中所有的数据以压缩二进制文件的方式生成一份副本并存储在磁盘上。<br>触发Redis持久化的条件：</p><ol><li>客户端执行save或者bgsave生成快照（一个会阻塞，一个不会阻塞）</li><li>根据配置文件save m n规则进行自动快照</li><li>主从复制，主库会执行bgsave命令生成快照</li><li>客户端执行数据库清除命令FLUSHALL时候，触发快照</li><li>客户端执行shutdown关闭redis时，触发快照</li></ol><p><strong>在生存RDB文件的时候，程序会对数据库中的键进行检查，已过期的键不会被保存到新创建的RDB文件中。</strong></p><h3><span id="aof持久化">AOF持久化</span></h3><p>AOF（Append only file），AOF可以将redis执行的每一条写命令追加到磁盘文件中。在Redis启动时优先使用AOF文件来恢复数据库状态。在默认情况下。redis是不开启AOF持久化的，开启AOF持久化需要配置appendonly为yes。</p><p>redis AOF持久化可以分为以下几个阶段：</p><ol><li>追加写入</li><li>同步命令到磁盘</li><li>文件重写<br>redis AOF文件会随着文件的命令的不断写入而不断增大。为此必须重写AOF减小文件大小<br>redis AOF文件的重写策略如下：</li></ol><ul><li>重复或无效的命令不写入</li><li>过期的数据不写入</li><li>多条命令合并写入</li></ul><p><strong>如果数据库中的某个键已经过期了，但是它还没有被惰性删除或定期删除，那么AOF将不会受任何的影响。</strong></p><h2><span id="算法">算法</span></h2><p>题目：<br>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p><p>思路：<br>新建一个栈，将数组pushA中的元素一个一个的压入栈中，每次压栈后进行判断，当栈顶元素等于数组B时，就将其出栈，当循环结束时，判断栈是否为空，若为空则返回true</p><p>解法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsPopOrder</span><span class="params">(<span class="keyword">int</span> [] pushA,<span class="keyword">int</span> [] popA)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(pushA.length!=popA.length)&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">      Stack&lt;Integer&gt; stack=<span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;pushA.length;i++)&#123;</span><br><span class="line">          stack.push(pushA[i]);</span><br><span class="line">          <span class="keyword">while</span> (!stack.isEmpty()&amp;&amp;stack.peek()==popA[j])&#123;</span><br><span class="line">              stack.pop();</span><br><span class="line">              j++;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;主要内容&quot;&gt;&lt;a href=&quot;#主要内容&quot; class=&quot;headerlink&quot; title=&quot;主要内容&quot;&gt;&lt;/a&gt;主要内容&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;Redis的持久化机制&lt;/li&gt;
&lt;li&gt;算法题：栈的压入、弹出序列
    
    </summary>
    
    
    
      <category term="变强日记" scheme="http://yoursite.com/tags/%E5%8F%98%E5%BC%BA%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>变强日记7</title>
    <link href="http://yoursite.com/2019/12/06/%E5%8F%98%E5%BC%BA%E6%97%A5%E8%AE%B07/"/>
    <id>http://yoursite.com/2019/12/06/变强日记7/</id>
    <published>2019-12-06T15:37:56.000Z</published>
    <updated>2019-12-06T15:55:51.487Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="主要内容">主要内容</span></h2><ol><li>布隆过滤器</li><li>有序链表的合并</li></ol><a id="more"></a><h2><span id="布隆过滤器">布隆过滤器</span></h2><h3><span id="什么是布隆过滤器">什么是布隆过滤器</span></h3><p>布隆过滤器是一种概率型数据结构。布隆过滤器的基本结构就是一个bit数组和一些hash函数。<br><img src="https://s2.ax1x.com/2019/12/06/QY546U.png" alt="QY546U.png"><br>如图所示，比如插入“baidu”，首先通过对“baidu”使用三个hash函数，得到三个值，并将这三个值作为bit数组的下标，进行标记。这样我们就记录了“baidu”这个字符串的存在性。（只能说明它可能存在）</p><p>假如我们要判断“baidu”这个字符串是否存在，首先使用之前一样的三个hash函数，得到三个hash值，在到bit数组中查看这三个位置是否被标记。如果都被标记了，说明”baidu“可能存在;否则，说明一定不存在。</p><p>很重要的一点是，<strong>布隆过滤器能说明一定不存在，但不能说明一定存在</strong>。而且布隆过滤器是<strong>不能删除</strong>的，因为一些值所使用的bit位会重合。</p><h3><span id="布隆过滤器的用途">布隆过滤器的用途</span></h3><p>减少磁盘IO或者网络请求。比如我们在使用redis作为缓存的数据库的情况下，为了避免缓存穿透。我们就可以使用布隆过滤器，我们可以使用布隆过滤器存储那些有的数据。每次请求时，使用布隆过滤器判断是否有这个数据，通过布隆过滤器判断没有的数据，可以直接返回，而不需要取查数据库了。这样就可以避免缓存击穿。</p><p>什么是缓存击穿？<br>在使用了缓存的系统中，有些黑客会恶意构造一些不存在的数据，使得缓存每次都不命中，导致每次都需要取数据库中查询（验证）。使得缓存失去了它存在的意义。</p><h2><span id="有序链表的合并">有序链表的合并</span></h2><p>题目：<br>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p><p>解答：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">Merge</span><span class="params">(ListNode list1,ListNode list2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//合并后的链表的头，首先创建一个头，可以shi'de</span></span><br><span class="line">        ListNode head = <span class="keyword">new</span> ListNode(<span class="number">0</span>); </span><br><span class="line">        ListNode cur=head;</span><br><span class="line">        ListNode curA=list1;</span><br><span class="line">        ListNode curB=list2;</span><br><span class="line">        <span class="keyword">while</span> (curA!=<span class="keyword">null</span>&amp;&amp;curB!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(curA.val&lt;=curB.val)&#123;</span><br><span class="line">                cur.next=curA;</span><br><span class="line">               curA=curA.next;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                cur.next=curB;</span><br><span class="line">                curB=curB.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur=cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//处理剩下的节点，下面两个while循环只会执行一个</span></span><br><span class="line">        <span class="keyword">while</span> (curA!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            cur.next=curA;</span><br><span class="line">            cur=cur.next;</span><br><span class="line">            curA=curA.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (curB!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            cur.next=curB;</span><br><span class="line">            cur=cur.next;</span><br><span class="line">            curB=curB.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//舍弃刚才为了方便创建的头节点</span></span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>图解：<br><img src="https://s2.ax1x.com/2019/12/06/QYhz8K.png" alt="QYhz8K.png"><br><em>还是画图来得直接</em></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;主要内容&quot;&gt;&lt;a href=&quot;#主要内容&quot; class=&quot;headerlink&quot; title=&quot;主要内容&quot;&gt;&lt;/a&gt;主要内容&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;布隆过滤器&lt;/li&gt;
&lt;li&gt;有序链表的合并&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
    
      <category term="变强日记" scheme="http://yoursite.com/tags/%E5%8F%98%E5%BC%BA%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>变强日记6</title>
    <link href="http://yoursite.com/2019/12/05/%E5%8F%98%E5%BC%BA%E6%97%A5%E8%AE%B06/"/>
    <id>http://yoursite.com/2019/12/05/变强日记6/</id>
    <published>2019-12-05T15:37:56.000Z</published>
    <updated>2019-12-05T15:37:57.845Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="主要内容">主要内容</span></h2><ol><li>进程和线程的区别是什么？</li><li>单链表的反转</li></ol><a id="more"></a><h2><span id="进程和线程的区别是什么">进程和线程的区别是什么？</span></h2><h3><span id="什么是进程">什么是进程？</span></h3><p>进程是操作系统分配资源的基本单元。是程序执行的一个实例。对应着操作系统中一个正在运行的程序。</p><h3><span id="什么是线程">什么是线程？</span></h3><p>线程是进程执行任务的基本单元。线程是进程的一个实体，是进程的一条执行路径。线程是进程的一个特定执行路径。当一个线程修改了进程的资源，它的兄弟线程可以立即看到这种变化。</p><h3><span id="它们的区别">它们的区别</span></h3><ol><li>地址空间和其它资源<br>进程是操作系统分配资源的独立单元。因此进程之间资源是不能共享的。同一个进程内的线程可以共享进程内的资源。且不同进程中的线程也是独立的。</li><li>通信<br>进程间的通信比较的复杂，一般通过管道，信号量，共享内存，消息队列等方式。而同一进程下的线程通信却非常的简单，可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性</li><li>调度和切换<br>线程的切换要比进程的切换快得多。</li><li>在多线程OS中<br>进程是一个<strong>不可执行</strong>的实体。多线程OS中执行任务的基本单位是线程。</li></ol><h2><span id="单链表的反转">单链表的反转</span></h2><p>题目：<br>输入一个链表，反转链表后，输出新链表的表头。<br>单链表的反转是一个非常常见的题型。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(head==<span class="keyword">null</span>||head.next==<span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> head;</span><br><span class="line">       &#125;</span><br><span class="line">       ListNode pre = <span class="keyword">null</span>; <span class="comment">// 当前节点的前一个节点</span></span><br><span class="line">       ListNode cur=head; <span class="comment">//当前节点</span></span><br><span class="line">       ListNode next = <span class="keyword">null</span>; <span class="comment">// 当前节点的下一个节点</span></span><br><span class="line">       <span class="keyword">while</span>( cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">           next = cur.next; <span class="comment">// 记录当前节点的下一个节点位置；</span></span><br><span class="line">           cur.next = pre; <span class="comment">// 让当前节点指向前一个节点位置，完成反转</span></span><br><span class="line">           pre = cur; <span class="comment">// pre 往右走</span></span><br><span class="line">           cur = next;<span class="comment">// 当前节点往右继续走</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//循环结束时cur==null,那么它的前一个节点即pre就是指向</span></span><br><span class="line">       <span class="comment">//翻转后的头节点</span></span><br><span class="line">       <span class="keyword">return</span> pre;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>解释：<br><img src="https://s2.ax1x.com/2019/12/05/QGWcPU.png" alt="QGWcPU.png"><br><em>写得仓促，字丑见谅</em><br>这个地方有个可以优化的地方，就是完全可以用head代替cur。为了逻辑清晰，上面的代码依然使用了cur。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;主要内容&quot;&gt;&lt;a href=&quot;#主要内容&quot; class=&quot;headerlink&quot; title=&quot;主要内容&quot;&gt;&lt;/a&gt;主要内容&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;进程和线程的区别是什么？&lt;/li&gt;
&lt;li&gt;单链表的反转&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
    
      <category term="变强日记" scheme="http://yoursite.com/tags/%E5%8F%98%E5%BC%BA%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>变强日记5</title>
    <link href="http://yoursite.com/2019/12/04/%E5%8F%98%E5%BC%BA%E6%97%A5%E8%AE%B05/"/>
    <id>http://yoursite.com/2019/12/04/变强日记5/</id>
    <published>2019-12-04T09:22:56.000Z</published>
    <updated>2019-12-04T15:46:45.657Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="主要内容">主要内容</span></h2><ol><li>Java接口和抽象类的区别是什么？ </li><li>快速幂算法</li></ol><a id="more"></a><h2><span id="java接口和抽象类的区别是什么">Java接口和抽象类的区别是什么？</span></h2><h3><span id="什么是接口">什么是接口？</span></h3><p>接口是方法的集合。接口不是类。接口不能用于实例化对象，接口也没有构造方法，接口中的所有方法必须是抽象方法，<strong>接口不能包含成员变量，除了static和final修饰的变量</strong>。</p><h3><span id="什么是抽象类">什么是抽象类？</span></h3><p>如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。<strong>*抽象类除了没法直接被实例化之外，与普通的类没有什么区别</strong>，它依然有<strong>构造器</strong>，成员变量，成员方法。抽象类因为不能被直接实例化，因此抽象类是用来继承的。</p><h3><span id="它们的区别">它们的区别</span></h3><ol><li>接口中的所有方法都必须是抽象方法，当时抽象类可以同时包含抽象和非抽象的方法。</li><li>类可以实现多个接口，但是只能继承一个抽象类。</li><li>接口中声明的成员变量默认都是final的，而抽象类没有这个限制。</li><li>接口中的方法默认是public的，而抽象类中的方法可以任意指定。</li><li>抽象类可以在不实现接口方法的情况下实现接口。</li></ol><h2><span id="快速幂算法">快速幂算法</span></h2><p>题目描述：<br>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。<br>保证base和exponent不同时为0</p><p>代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">double</span> result=<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">boolean</span> flag=<span class="keyword">true</span>;</span><br><span class="line">       <span class="keyword">if</span>(exponent&lt;<span class="number">0</span>)&#123;</span><br><span class="line">           flag=<span class="keyword">false</span>;</span><br><span class="line">           exponent*=-<span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">while</span> (exponent&gt;<span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">if</span>(exponent%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">               exponent=exponent/<span class="number">2</span>; <span class="comment">//指数缩小为原来的一半</span></span><br><span class="line">               base*=base; <span class="comment">//底数扩大为原来的平方</span></span><br><span class="line">           &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">//指数为奇数的情况</span></span><br><span class="line">               exponent--;<span class="comment">//将指数化为(偶数+1)的形式</span></span><br><span class="line">               result=result*base;<span class="comment">//计算分离上面出来的那个一次方</span></span><br><span class="line">               exponent/=<span class="number">2</span>;</span><br><span class="line">               base*=base;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">return</span> flag?result:<span class="number">1</span>/result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>分析：<br>在进行幂运算的时候，最简单的方式就是利用循环。想要实现“快速”就得从减少循环的次数入手。首先看一组举例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//计算2的8次方，需要循环8次，而其等价写法</span><br><span class="line">//4的4次方只需要4次循环，这就是减少循环次数优化</span><br><span class="line">//幂计算的基本思路。我们通过变化，不断减小幂，增加第</span><br><span class="line">//从而使得循环次数不断减少</span><br><span class="line">2^8=(2^2)^(4)</span><br><span class="line"></span><br><span class="line">//当不是所有的幂都能被2整除的，这个时候我们需要一点小小的变换技巧</span><br><span class="line">2^7=(2^2)^(3)*2</span><br></pre></td></tr></table></figure></p><p>这些变换的技巧基本属于初中数学的范畴，我们只需要注意幂为偶数，和奇数的两种情况即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;主要内容&quot;&gt;&lt;a href=&quot;#主要内容&quot; class=&quot;headerlink&quot; title=&quot;主要内容&quot;&gt;&lt;/a&gt;主要内容&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;Java接口和抽象类的区别是什么？ &lt;/li&gt;
&lt;li&gt;快速幂算法&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
    
      <category term="变强日记" scheme="http://yoursite.com/tags/%E5%8F%98%E5%BC%BA%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Spring Bean的加载流程</title>
    <link href="http://yoursite.com/2019/11/30/Spring%20Bean%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/11/30/Spring Bean的加载流程/</id>
    <published>2019-11-30T09:22:56.000Z</published>
    <updated>2019-11-30T09:26:36.787Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="bean加载的总体流程">Bean加载的总体流程</span></h2><p>以这行代码为起点，探究这背后到底经历了什么？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyTestBean bean=(MyTestBean)bf.getBean(<span class="string">"MyTestBean"</span>)；</span><br></pre></td></tr></table></figure></p><ol><li>调用<code>getBean(&quot;MyTestBean&quot;)</code>背后实际是调用了<code>doGetBean(name,null,null,false)</code><br><code>doGetBean</code>方法。这个方法干的事情有些多，但总结起来就这们几步：</li></ol><ul><li>通过传入的的name参数，提取beanName属性.这个地方有可能会有疑问，传入的name不就是bean的Name吗。其实不然，因为spring还允许有别名。</li><li>尝试使用直接从缓存获取，或者sinletionFactories中的ObjectFactory中获取，具体的也就是在<code>Object sharedInstance = getSingleton(beanName);</code>代码中。这里的缓存其实就是指<code>DefaultSingletonBeanRegistry</code>类中的<code>singletonObjects:Map</code>。这个缓存就是一个<code>ConcurrentHashMap</code>其中键为BeanName，值就是对应的Bean。<a id="more"></a>具体的代码实现如下:<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*这个方法中蕴含了解决循环依赖的原理</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, <span class="keyword">boolean</span> allowEarlyReference)</span> </span>&#123;</span><br><span class="line"><span class="comment">//尝试从缓存中拿该bean</span></span><br><span class="line">Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line"><span class="comment">//如果缓存中没有该bean，且该bean正在创建中</span></span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line"><span class="comment">/**尝试从提前暴露缓存中拿到该bean</span></span><br><span class="line"><span class="comment"> *这个earlySingletonObjects也是一个map</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果从提前暴露缓存中拿也没拿到，且是允许提前引用的</span></span><br><span class="line"><span class="comment"> * 就尝试从singletonFactories中获取</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ObjectFactory&lt;?&gt; singletonFactory = <span class="keyword">this</span>.singletonFactories.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果获取到了该bean的单例工厂，就从单例工厂中来获取</span></span><br><span class="line"><span class="comment"> * 该bean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">singletonObject = singletonFactory.getObject();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将获取到的对象加入，提前暴露缓存，这个时候，其实还不能算作bean</span></span><br><span class="line"><span class="comment"> * 因为该对象还没有走完bean的生命周期</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line"><span class="comment">//从单例工厂缓存中移除该bean的单例工厂</span></span><br><span class="line"><span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> singletonObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>回到刚才的<code>doGetBean</code>方法，通过<code>getSingleton</code>方法的一番努力，如果拿到了bean，现在我们可以返回实例了。<br>这一步是由<code>bean = getObjectForBeanInstance(sharedInstance, name, beanName, null)</code>来实现<br>但值得注意的是，<strong>有些存在beanFactory的时候，spring并不是返回的实例本身，而是返回指定方法返回的实例</strong>。这个地方有点绕，其实很好理解，因为spring创建bean本身就有两种创建方法（大分类），一种是利用构造器，一种是利用工厂方法（又可分为静态工厂和实例工厂）。如果是利用工厂方法，我们当然不能直接返回工厂对象咯，而是应该返回该工厂对象中getObejct()方法返回的对象。</p><ul><li>如果没有拿到bean，那<code>doGetBean</code>还要经过一番努力。如果已经加载的类中不包括beanName（已经加载的类存在beanDefinitionMap中，值得注意的BeanDefintion对应Bean的关系，就像Class对应Object的关系一样）。那么就尝试从<code>parentBeanFactory</code>中获取BeanFactory，如果每找到就递归到BeanFactory中去找。</li><li><p>如果不仅仅做类型检测而是需要创建bean，就将该beanName记录为正在创建的状态。这个一步由这段代码实现:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">         <span class="keyword">if</span> (!typeCheckOnly) &#123;</span><br><span class="line">markBeanAsCreated(beanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>进行属性的准备，如果是子bean的话，需要合并父类的相关属性，这个也很好理解，如果一个类有继承的父类的时候，它本身包含的属性是不完整的，它还有一部分属性在它的父类中体现。这一步主要由这段代码实现:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">checkMergedBeanDefinition(mbd, beanName, args);</span><br></pre></td></tr></table></figure></li><li><p>如果存在依赖，这需要递归实例化依赖的bean。这里涉及一个不太常见的用法<code>depend-on</code>。这一步主要由这段代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">String[] dependsOn = mbd.getDependsOn();</span><br><span class="line"><span class="keyword">if</span> (dependsOn != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (String dep : dependsOn) &#123;</span><br><span class="line"><span class="keyword">if</span> (isDependent(beanName, dep)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">"Circular depends-on relationship between '"</span> + beanName + <span class="string">"' and '"</span> + dep + <span class="string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line">registerDependentBean(dep, beanName);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">getBean(dep);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">"'"</span> + beanName + <span class="string">"' depends on missing bean '"</span> + dep + <span class="string">"'"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建了bean之后，就可以实例化mbd本身了。这个时候，又分为了两种情况，一种是单例的创建，一种是原型的创建。</p></li><li>类型的转换</li></ul><h2><span id="创建bean">创建Bean</span></h2><p>createBean函数负责创建bean。这个函数在<code>doGetBean</code>方法中调用过。现在进入这个方法内部，查看其具体实现。<br>首先这个方法的声明是这样的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)</span></span></span><br></pre></td></tr></table></figure></p><p>它主要干了这些事情：</p><ol><li>调用<code>Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);</code>,根据设置的class属性和className来解析Class。这个方法的内部没有什么特别的。并且利用该方法得到的resolvedClass来初始化<code>mbdToUse:RootBeanDefinition</code></li><li>验证准备覆盖的方法<code>mbdToUse.prepareMethodOverrides();</code>.说人话，就是对override属性进行标记及验证。</li><li>通过调用<code>Object bean = resolveBeforeInstantiation(beanName, mbdToUse);</code>给bean后置处理器一个通过代理类替换目标类的机会。这个地方需要注意。</li><li>调用<code>Object beanInstance = doCreateBean(beanName, mbdToUse, args);</code>来进行Bean的创建</li></ol><h2><span id="循环依赖">循环依赖</span></h2><p>什么是循环依赖？<br>循环依赖就是循环引用。就是两个或多个bean相互之间持有对方。比如beanA中引用了beanB，而beanB中引用了beanA。那么这两个bean之间就形成了循环依赖。<strong>值得注意的是循环依赖不等于循环调用。</strong>循环调用是方法调用之间成环。循环调用是无解的。</p><p>spring是如何解决循环依赖的？<br>要回答回答这个问题，首先要清楚，spring中bean有哪几种循环依赖，哪些循环依赖是可以解决的。</p><h3><span id="循环依赖的分类">循环依赖的分类</span></h3><ol><li>构造器循环依赖<br>这种依赖的成因是因为构造器注入形成的循环依赖。这种依赖是无解的。因此，我们不太建议使用构造器注入。至于为什么无法解决构造器循环依赖，原因其实非常的简单。举例：假如beanA在调用构造器的时候，发现需要beanB作为参数，然后去调用beanB的构造器，发现又需要beanA作为参数，这种情况根本没得搞，死循环了。</li><li>setter循环依赖<br>表示通过setter注入方式构成的循环依赖。setter循环依赖在单例作用域下是可以解决的。spring通过提前暴露完成实例化的bean来解决setter循环依赖。举个栗子：beanA实例化后，进行属性赋值的时候，发现它需要通过setter注入beanB,然后他就去实例化beanB，beanB实例化之后，在beanB属性赋值的时候，发现需要注入beanA，这个时候因为beanA已经提前暴露了（它现在还没完整的创建），beanB发现了beanA，然后直接把beanA注入即可，这个时候beanB的属性赋值阶段，已经完成了，这个时候我们再看beanA，这个时候直接把beanB注入beanA即可了，这样循环依赖就解决了。</li></ol><p><strong>在解决循环依赖的过程中，很关键的两点是：哪些bean正在创建需要透明；bean实例化之后，就可暴露出来，供其它bean注入。</strong></p><ol start="3"><li>prototype范围的依赖处理<br>prototype范围的循环依赖也是无解的，因为spring不会缓存prototype范围的对象，因此无法实现提前暴露。</li></ol><h2><span id="常规的bean的创建">常规的bean的创建</span></h2><h3><span id="总体的流程">总体的流程</span></h3><p>所谓的常规的，就是指在<code>createBean</code>中调用了<code>Object bean = resolveBeforeInstantiation(beanName, mbdToUse);</code>后，并没有创建代理，就调用<code>doCreateBean</code>。该方法进行的就是常规的bean的创建。</p><p>这个类主要做了这些事情：</p><ol><li><p>如果是单例则首先清除缓存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">instanceWrapper = <span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>根据bean所指定的策略创建实例,将beanDefinition转换为BeanWrapper，这个方法的内部实现其实比较复杂。如果存在工厂方法，就使用工厂方法进行初始化；如果有多个构造器，则根据参数匹配构造器来初始化；如果没有工厂方法，也不存在带参数的构造器，则使用默认构造方法进行实例化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br></pre></td></tr></table></figure></li><li><p>判断是否需要提前曝光，根据这些条件来进行判断：单例&amp;允许循环依赖&amp;当前bean正在创建过程中。当需要提前曝光时，在bean创建完成之前将创建实例的ObjectFactory加入工厂</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">isSingletonCurrentlyInCreation(beanName));</span><br><span class="line"><span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Eagerly caching bean '"</span> + beanName +</span><br><span class="line"><span class="string">"' to allow for resolving potential circular references"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为避免后期循环依赖，可以在bean初始化完成之前将创建实例的ObjectFactory加入工厂</span></span><br><span class="line"><span class="comment"> *getEarlyBeanReference需要注意，AOP就是在这将advice织入bean的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>属性填充，也就是在这个地方，就可能出现循环依赖，如果存在依赖其它bean的属性，则会递归初始化bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">populateBean(beanName, mbd, instanceWrapper);</span><br></pre></td></tr></table></figure></li><li><p>调用初始化方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br></pre></td></tr></table></figure></li><li><p>检测依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">removeSingletonIfCreatedForTypeCheckOnly(dependentBean)<span class="keyword">for</span> (String dependentBean : dependentBeans) &#123;</span><br><span class="line"><span class="keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">actualDependentBeans.add(dependentBean);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><code>removeSingletonIfCreatedForTypeCheckOnly(dependentBean)</code>方法所做的事情就是去一个<code>alreadyCreated:Map</code>中看，该bean所依赖的bean，是否已经被创建了，如果被创建了，就将该bean从三级缓存和<code>registeredSingletons:map</code>中删除，并返回true。如果所依赖的bean已经被创建，就将该bean加入<code>actualDependentBeans:Set</code>.完成对所有的依赖的bean的检测之后，如果<code>actualDependentBeans:Set</code>不为空，就抛出循环依赖异常（这个地方值得注意的是，如果一个bean创建成功了，那么它所依赖的bean也一定是创建了的，如果它所依赖的bean没有被创建，这就说明存在循环依赖）</p><ol start="7"><li><p>根据scopse注册bean<br>所谓的注册就是将bean加入一个<code>disposableBeans:map</code>中去。便于在销毁时使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br></pre></td></tr></table></figure></li><li><p>完成创建并返回</p></li></ol><h3><span id="完成bean实例化的createbeaninstance方法">完成bean实例化的createBeanInstance方法</span></h3><p><code>instanceWrapper = createBeanInstance(beanName, mbd, args);</code>这个方法主要完成了bean的实例化。这也是bean生命周期的第一步。<br>这个方法主要做以下几件事情：</p><ol><li>拿到beanName对应的class<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName);</span><br></pre></td></tr></table></figure></li></ol><p>像class这些信息在spring初始化的使用就已经拿到了。这个敌法只是取出来就可以了。</p><ol start="2"><li>如果有相应的工厂方法，就使用工厂方法创建bean<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mbd.getFactoryMethodName() != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> instantiateUsingFactoryMethod(beanName, mbd, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>spring创建bean无非就是两种方案，一个是利用工厂方法，一个是利用构造器。如果没有对应的工厂方法，那就只好使用构造器来实例化。</p><ol start="3"><li>没有对应的工厂方法，就使用构造器来实例化。先锁定构造方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;</span><br><span class="line"><span class="keyword">if</span> (mbd.resolvedConstructorOrFactoryMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">resolved = <span class="keyword">true</span>;</span><br><span class="line">autowireNecessary = mbd.constructorArgumentsResolved;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>因为一个类可能有多个构造方法，所以这个地方需要根据参数来确定调用哪个构造函数或工厂方法。因为这个操作是比较费时的所以spring采用了缓存的机制。</p><ol start="4"><li><p>经过解析，调用相应的构造方法进行初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果已经解析过勒，则使用解析好的构造函数方法，而无需再次锁定</span></span><br><span class="line"><span class="keyword">if</span> (resolved) &#123;</span><br><span class="line"><span class="keyword">if</span> (autowireNecessary) &#123;</span><br><span class="line"><span class="comment">//构造函数自动注入</span></span><br><span class="line"><span class="keyword">return</span> autowireConstructor(beanName, mbd, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//使用默认构造函数注入</span></span><br><span class="line"><span class="keyword">return</span> instantiateBean(beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果需要根据参数来解析构造函数，就执行以下几步</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Candidate constructors for autowiring?</span></span><br><span class="line">Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);</span><br><span class="line"><span class="keyword">if</span> (ctors != <span class="keyword">null</span> || mbd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR ||</span><br><span class="line">mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) &#123;</span><br><span class="line"><span class="keyword">return</span> autowireConstructor(beanName, mbd, ctors, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>带参数的实例化，其实非常的复杂，因为它充满了不确定性。</p><h2><span id="容器功能的拓展">容器功能的拓展</span></h2><p>ApplicationContext对BeanFactory进行了拓展。ApplicationContext包含了BeanFactory的所有功能。<br>从这行代码，为起点来看它背后的东西：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext bf=<span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"beanFactory.xml"</span>);</span><br></pre></td></tr></table></figure></p><ol><li>首先它调用了一个有参构造器<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(String configLocation)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="keyword">this</span>(<span class="keyword">new</span> String[] &#123;configLocation&#125;, <span class="keyword">true</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>它又调用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">String[] configLocations, <span class="keyword">boolean</span> refresh, @Nullable ApplicationContext parent)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">super</span>(parent);</span><br><span class="line"><span class="comment">//将配置文件以路径数组的方式传入</span></span><br><span class="line">setConfigLocations(configLocations);</span><br><span class="line"><span class="keyword">if</span> (refresh) &#123;</span><br><span class="line">refresh();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="2"><li>设置了配置文件的路径，之后就可以进行配置文件的解析和各种功能的实现了。这些东西都是在<code>refresh</code>方法中实现了。<br>完整的代码如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line"><span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line"><span class="comment">//准备刷新的上下文环境</span></span><br><span class="line">prepareRefresh();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line"><span class="comment">//初始化BeanFactory并进行xml文件的读取</span></span><br><span class="line">ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line"><span class="comment">//对beanFactory进行功能上的填充</span></span><br><span class="line">prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line"><span class="comment">//子类覆盖方法做额外的处理</span></span><br><span class="line">postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line"><span class="comment">//调用各种beanFactory处理器</span></span><br><span class="line">invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line"><span class="comment">//注册拦截bean创建的bean处理器</span></span><br><span class="line">registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize message source for this context.</span></span><br><span class="line"><span class="comment">//为上下文初始化message源，即不同的语言的消息体，国际化处理</span></span><br><span class="line">initMessageSource();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line"><span class="comment">//初始化应用消息广播器</span></span><br><span class="line">initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line"><span class="comment">//留给子类来初始化其它的bean</span></span><br><span class="line">onRefresh();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check for listener beans and register them.</span></span><br><span class="line"><span class="comment">//在所有的bean中查找listener bean，并注册到消息广播器中</span></span><br><span class="line">registerListeners();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line"><span class="comment">//初始化剩下的非懒加载的单实例</span></span><br><span class="line">finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line"><span class="comment">//完成刷新过程</span></span><br><span class="line">finishRefresh();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">logger.warn(<span class="string">"Exception encountered during context initialization - "</span> +</span><br><span class="line"><span class="string">"cancelling refresh attempt: "</span> + ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">destroyBeans();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reset 'active' flag.</span></span><br><span class="line">cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Propagate exception to caller.</span></span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">// Reset common introspection caches in Spring's core, since we</span></span><br><span class="line"><span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">resetCommonCaches();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>它主要做了这些事情：</p><ul><li>初始化前的准备工作。例如对系统属性或者环境变量进行准备和验证</li><li><p>初始化beanFactory并进行xml文件的读取。因为ApplicationContext包含了BeanFactory所提供的一切特征，在这一步就是利用BeanFactroy中的xml文件读取的相关功能。也就是从这一步开始ApplicationContext已经包含了一个BeanFactory了。这段代码可以佐证：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title">obtainFreshBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">refreshBeanFactory();</span><br><span class="line"><span class="comment">//这一步就创建了一个BeanFactory</span></span><br><span class="line">ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Bean factory for "</span> + getDisplayName() + <span class="string">": "</span> + beanFactory);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> beanFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对BeanFactory进行各种功能填充，常见的<code>@Autowired</code>就是在这一步增加支持的。</p></li><li>子类覆盖方法做额外的处理。通过这个拓展点，可以方便程序员来拓展spring的功能</li><li>调用各种beanFactoty处理器</li><li>注册拦截bean创建的bean处理器，这一步并没有调用，真正调用的是在getBean的时候</li><li>为上下文初始化message源，对不同语言的消息题进行国际化处理。</li><li>初始化应用消息广播器。</li><li>留给子类来初始化其它的bean</li><li>在所有的注册的bean中查找 listener bean，注册到消息广播器中。</li><li>初始化涉嫌的单实例</li><li>完成刷新过程</li></ul><h3><span id="重要步骤细节分析">重要步骤细节分析</span></h3><p><strong>1. 环境准备</strong><br>环境准备调用的是<code>protected void prepareRefresh()</code>方法，该方法的内部实现，有行关键的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//留给子类覆盖的，这个方法内部是空的</span></span><br><span class="line">initPropertySources();</span><br><span class="line"><span class="comment">//验证所需的属性文件是否都已经放入环境中了</span></span><br><span class="line">getEnvironment().validateRequiredProperties();</span><br></pre></td></tr></table></figure></p><p>其实这两行代码基本没做什么实际的事情，包括第二行代码，因为实际上因为没有什么需要验证的属性，所以第二行代码也没有做什么实际的事情。这两行的代码的意义在于，提供了拓展点。通过重写<code>initPropertySources()</code>来实现个性化的属性处理，之后再利用<code>validateRequiredProperties</code>对属性进行验证。</p><p><strong>2. 加载BeanFactory</strong></p><p>获取<code>BeanFactory</code>,这个工作由这行代码实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br></pre></td></tr></table></figure></p><p>也正是从这个地方开始，ApplicationContext有了BeanFactory的全部功能。<br><code>obtainFreshBeanFactory()</code>方法中调用了<code>refreshBeanFactory()</code>方法，由这个方法来完成了BeanFactory的初始化工作。<br>这个方法完成的首要工作就是创建<code>beanFactory：DefaultListableBeanFactory</code>,这个对象非常的重要，它整个IOC容器的关键。之后是指定序列化ID，定制BeanFactory，加载BeanDefinition，最后使用全局变量记录BeanFactory实例。</p><p><strong>3. 加载beanDefinition</strong><br>加载beanDefeinition的第一步就是初始化用于读取配置文件的<code>beanDefinitionReader:XmlBeanDefinitionReader</code>.创建成功之后，对<code>beanDefinitionReader</code>做环境变量的设置之后，就可以使用<code>loadBeanDefinitions(beanDefinitionReader)</code>读取并解析spring配置文件，来加载BeanDefinitinon。</p><p><strong>4. 功能拓展</strong><br>spring在<code>prepareBeanFactory(ConfigurableListableBeanFactory beanFactory)</code>,方法中完成了ApplicationContext的功能的拓展。<br>主要是添加了以下几个方面的拓展：</p><ol><li>增加对spEL语言的支持</li><li>证件对属性编辑器的支持</li><li>增加对一些内置类的信息注入。</li><li>设置了依赖功能可能忽略的接口</li><li>注册了一些固定依赖的属性</li><li>增加了AspectJ的支持</li><li>将相关环境变量及属性注册以单例模式注册</li></ol><p><strong>5. BeanFactory的后处理</strong><br>BeanFactory作为spring中容器功能的基础，用于存放所有已经加载的bean，为了保证程序的高可拓展性，Spring针对BeanFactory做了大量的拓展。PostProcessor等都是在这个地方实现的。<br>后处理主要做了这些事情：</p><ol><li>激活BeanFactoryPostProcessor<br><code>invokeBeanFactoryPostProcessors(beanFactory);</code>调用了所有的后置处理器，其中首先调用所有的硬编码配置的后置处理器，其后调用了配置注册的后置处理器。在执行的时候，它会按照配置中order属性来按一定的顺序来执行那些后置处理器。spring通过三个list来记录这些后置处理器。它们分别是：</li><li><code>registryPostProcessors</code>记录通过硬编码方式注册的<code>BeanDefinitionRegistryPostProcessor</code>类型的处理器</li><li><code>regularPostProcessors</code>记录通过硬编码方式注册的<code>BeanFactoryPostProcessor</code>类型的处理器</li><li><code>registryPostProcessorBeans</code>记录通过配置方式注册的<code>BeanDefinitonRegistryPostProcessor</code>类型的处理器。</li></ol><p><strong>6. 注册BeanPostProcessor</strong><br>实现了对BeanFactoryPostProcessor的调用之后，就要进行BeanPostProcessor的注册了。spring中许多的功能都是通过后处理器的方式来拓展的。BeanPostProcessor的处理与BeanFactoryPostProcessor的处理几位相似。在注册之前需要根据 <code>PriorityOrdered</code>进行排序，根据<code>Ordered</code>进行排序或者无序。</p><p><strong>7. 初始化消息资源</strong><br>初始化消息资源是为了进行国际化处理。在确定特定类型的本地化信息的时候，，需要两个条件，一个是“语言条件”，另一个是“国家/地区的类型”。spring定义了国际化信息的<code>MessageSource</code>接口。</p><p><strong>8. 初始化ApplicationEventMulticaster</strong><br>首先来展示一下Spring事件监听器的简单用法：<br>1.定义监听事件<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> classs TestEvent extends ApplicationEvent&#123;</span><br><span class="line">    <span class="keyword">public</span> String msg;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestEvent</span><span class="params">(Object source)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(source);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestEvent</span><span class="params">(Object source,String msg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(source);</span><br><span class="line">        <span class="keyword">this</span>.msg=msg;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="2"><li><p>定义监听器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationEvent event)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(event <span class="keyword">instanceof</span> TestEvent)&#123;</span><br><span class="line">            TestEvent testEvent=(TestEvent)event;</span><br><span class="line">            testEvent.print();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写配置文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"testListener"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.test.event.TestListener"</span>/&gt;</span><br></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ApplicationContext context=<span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"classpath:applicationContext.xml"</span>);</span><br><span class="line">        TestEvent event=<span class="keyword">new</span> TestEvent(<span class="string">"hello"</span>,<span class="string">"msg"</span>);</span><br><span class="line">        context.publishEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>控制台输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msg</span><br></pre></td></tr></table></figure></p><p>具体的操作由<code>initApplicationEventMulticaster();</code>来实现，它无非就处理了两种情况一种是：如果用户自定义了事件广播器，那么使用用户自定义的事件广播器。第二种情况：如果用户没有自定义事件广播器，那么使用默认的ApllicationEventMulticaster。<br><strong>这个地方运用了设计模式的观察者模式</strong>.<br>当spring事件产生的时候会默认使用<code>SimpleApplicationEventMulticaster</code>的<code>multicastEvent</code>来广播事件，Spring会遍历所有的监听器，并使用监听器的<code>onApplicationEvent</code>方法来进行监听器的处理。因此其实每个监听器都可以收到事件，是否进行处理则由监听器来决定。</p><p><strong>9. 注册监听器</strong><br>注册监听器由<code>registerListeners();</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerListeners</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//硬编码方式注册的监听器处理</span></span><br><span class="line"><span class="keyword">for</span> (ApplicationListener&lt;?&gt; listener : getApplicationListeners()) &#123;</span><br><span class="line">getApplicationEventMulticaster().addApplicationListener(listener);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 配置文件注册的监听器处理</span></span><br><span class="line">String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">for</span> (String listenerBeanName : listenerBeanNames) &#123;</span><br><span class="line">getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Publish early application events now that we finally have a multicaster...</span></span><br><span class="line">Set&lt;ApplicationEvent&gt; earlyEventsToProcess = <span class="keyword">this</span>.earlyApplicationEvents;</span><br><span class="line"><span class="keyword">this</span>.earlyApplicationEvents = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (earlyEventsToProcess != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (ApplicationEvent earlyEvent : earlyEventsToProcess) &#123;</span><br><span class="line">getApplicationEventMulticaster().multicastEvent(earlyEvent);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>10. 初始化非延时加载的单例</strong><br>其中包括<code>ConversionService</code>的配置,配置冻结以及非延迟加载的bean的初始化工作。所谓的冻结配置就是注册的bean的定义将不被修改或进行任何进一步的处理。ApplicationContext实现的默认行为就是在启动时将所有单例bean提前进行实例化。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Bean加载的总体流程&quot;&gt;&lt;a href=&quot;#Bean加载的总体流程&quot; class=&quot;headerlink&quot; title=&quot;Bean加载的总体流程&quot;&gt;&lt;/a&gt;Bean加载的总体流程&lt;/h2&gt;&lt;p&gt;以这行代码为起点，探究这背后到底经历了什么？&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;MyTestBean bean=(MyTestBean)bf.getBean(&lt;span class=&quot;string&quot;&gt;&quot;MyTestBean&quot;&lt;/span&gt;)；&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;调用&lt;code&gt;getBean(&amp;quot;MyTestBean&amp;quot;)&lt;/code&gt;背后实际是调用了&lt;code&gt;doGetBean(name,null,null,false)&lt;/code&gt;&lt;br&gt;&lt;code&gt;doGetBean&lt;/code&gt;方法。这个方法干的事情有些多，但总结起来就这们几步：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;通过传入的的name参数，提取beanName属性.这个地方有可能会有疑问，传入的name不就是bean的Name吗。其实不然，因为spring还允许有别名。&lt;/li&gt;
&lt;li&gt;尝试使用直接从缓存获取，或者sinletionFactories中的ObjectFactory中获取，具体的也就是在&lt;code&gt;Object sharedInstance = getSingleton(beanName);&lt;/code&gt;代码中。这里的缓存其实就是指&lt;code&gt;DefaultSingletonBeanRegistry&lt;/code&gt;类中的&lt;code&gt;singletonObjects:Map&lt;/code&gt;。这个缓存就是一个&lt;code&gt;ConcurrentHashMap&lt;/code&gt;其中键为BeanName，值就是对应的Bean。
    
    </summary>
    
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>变强日记4</title>
    <link href="http://yoursite.com/2019/11/16/%E5%8F%98%E5%BC%BA%E6%97%A5%E8%AE%B04/"/>
    <id>http://yoursite.com/2019/11/16/变强日记4/</id>
    <published>2019-11-16T09:23:56.000Z</published>
    <updated>2019-11-16T09:24:23.276Z</updated>
    
    <content type="html"><![CDATA[<p>最近被spring的源码搞自闭了，有好几天没写这个分类的文章了。</p><h2><span id="主要内容">主要内容</span></h2><ol><li>Hashmap的一些知识点</li><li>Java实现二叉搜索树<a id="more"></a><h2><span id="hashmap的一些知识点">Hashmap的一些知识点</span></h2>JDK8以后采用了数组+链表+红黑树的方式来实现hashmap；使用链表存储的优势是可以降低内存的使用率，而红黑树的优点是查询效率更高。<h3><span id="hashmap的扩容">Hashmap的扩容</span></h3><strong>扩容的过程？</strong><br>hashmap的扩容一般是发生在插入元素的时候，当数组的使用率超过负载因子的时候（默认值是0.75），便会进行扩容。扩容为原来的两倍。<br><strong>为什么总是2倍扩容，为什么初始容量是2的n次幂？</strong><br>因为插入元素时，需要利用key的hashcode来找到对应的桶位，java并没有采用取模的方式来确定桶位，而是<strong>采用length-1进行与运算来确定桶位</strong>。如果length是2的倍数，那么length-1的二进制就是全为1的，这样在与key的hashcode进行与运算，hashcode的每一位都能够起到作用。（如果length-1的二进制某一位为0，那么key的hashcode对应的位，无论是1还是0，结果都一样，都是0，显然，这一位在确定桶位的时候，就没有了意义）<h3><span id="为什么要使用红黑树而是不avl树">为什么要使用红黑树，而是不AVL树？</span></h3>AVL树和红黑树都是常见的平衡二叉树。AVL更加严格平衡，因此能够有更好的查询效率。对于插入密集型任务红黑树更加适合。<h3><span id="并发环境下使用hashmap会导致什么问题">并发环境下使用HashMap会导致什么问题</span></h3>因为hashmap不是线程安全的，不适用于多线程环境。</li><li>可能导致get无限循环<br>在对现场rehash的过程中可能会形成循环链表，导致查找元素的时候一直无法遍历完整个链表，从而出现死循环。最终导致CPU使用率100%。 其原因在于并发下Rehash可能导致循环链表的实现。</li><li>可能导致put丢失<br>在put的时候，如果两个产生hash碰撞，导致两个线程得到同样的index去存储，导致覆盖丢失的情况。</li></ol><h2><span id="java实现二叉查找树">java实现二叉查找树</span></h2><p>二叉树的中的关键字总是以满足二叉搜索树的性质的方式来存储的：<br>设x是二叉搜索树的一个节点。如果y是x左子树的一个节点 ，那么y.key&lt;=x.key。如果y是x的右子树中的一个节点，那么y.key&gt;=x.key.</p><p>二叉查找树的插入，查找，更新比较简单。而删除操作比较复杂，尤其是待删除的节点既有左子树又有右子树的情况，非常的复杂。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二叉查找树</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;value&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BSTree</span> &lt;<span class="title">key</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">key</span>&gt;,<span class="title">value</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该二叉查找树的根</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 节点内部类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> key k;</span><br><span class="line">        <span class="keyword">private</span> value v;</span><br><span class="line">        <span class="keyword">private</span> Node left;</span><br><span class="line">        <span class="keyword">private</span> Node right;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(key k,value val)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.k=k;</span><br><span class="line">            <span class="keyword">this</span>.v=val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 二叉查找树的插入</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(key k,value v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//如果当前树是空树，就进行插入</span></span><br><span class="line">            root=<span class="keyword">new</span> Node(k,v);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node cur=root;</span><br><span class="line">        Node parent=<span class="keyword">new</span> Node();</span><br><span class="line">        <span class="keyword">boolean</span> isLeftTree=<span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            parent=cur;</span><br><span class="line">            <span class="keyword">if</span>(cur.k.compareTo(k)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                cur=cur.right;</span><br><span class="line">                isLeftTree=<span class="keyword">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                cur=cur.left;</span><br><span class="line">                isLeftTree=<span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//新节点</span></span><br><span class="line">        Node newNode =<span class="keyword">new</span> Node(k,v);</span><br><span class="line">        <span class="keyword">if</span>(isLeftTree)&#123;</span><br><span class="line">            parent.left=newNode;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            parent.right=newNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">delete</span><span class="params">(key k)</span></span>&#123;</span><br><span class="line">        Node cur=root;</span><br><span class="line">        Node parent=root;</span><br><span class="line">        <span class="keyword">boolean</span> isLeftTree=<span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//首先查找待删除的节点的位置</span></span><br><span class="line">        <span class="keyword">while</span> (cur.k!=k)&#123;</span><br><span class="line">            parent=cur;</span><br><span class="line">            <span class="keyword">if</span>(k.compareTo(cur.k)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                cur=cur.left;</span><br><span class="line">                isLeftTree=<span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                cur=cur.right;</span><br><span class="line">                isLeftTree=<span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cur==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//待删除节点是叶子节点的情况</span></span><br><span class="line">        <span class="keyword">if</span>(cur.left==<span class="keyword">null</span>&amp;&amp;cur.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur==root)&#123;</span><br><span class="line">                root=<span class="keyword">null</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>  <span class="keyword">if</span>(isLeftTree)&#123;</span><br><span class="line">                parent.left=<span class="keyword">null</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                parent.right=<span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cur.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//当前节点只有左孩子</span></span><br><span class="line">            <span class="keyword">if</span>(cur==root)&#123;</span><br><span class="line">                root=cur.left;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(isLeftTree)&#123;</span><br><span class="line">                parent.left=cur.left;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                parent.right=cur.left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cur.left==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//当前节点只有右孩子</span></span><br><span class="line">            <span class="keyword">if</span>(cur==root)&#123;</span><br><span class="line">                root=cur.right;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(isLeftTree)&#123;</span><br><span class="line">                parent.left=cur.right;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                parent.right=cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//待删除的节点有既有左孩子，又有右孩子的情况</span></span><br><span class="line">            Node successor=getSuccessor(cur);</span><br><span class="line">            <span class="keyword">if</span>(cur==root)&#123;</span><br><span class="line">                root=successor;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(isLeftTree)&#123;</span><br><span class="line">                parent.left=successor;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                parent.right=successor;</span><br><span class="line">            &#125;</span><br><span class="line">            successor.left=cur.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对以待删除的节点为根的树进行旋转</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> delNode</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">getSuccessor</span><span class="params">(Node delNode)</span></span>&#123;</span><br><span class="line">        Node successorParent=delNode;</span><br><span class="line">        Node successor=delNode;</span><br><span class="line">        Node cur=delNode.right;</span><br><span class="line">        <span class="keyword">while</span> (cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            successorParent=successor;</span><br><span class="line">            successor=cur;</span><br><span class="line">            cur=cur.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(successor!=delNode.right)&#123;</span><br><span class="line">            successorParent.left=successor.right;</span><br><span class="line">            successor.right=delNode.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> successor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查找</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> value <span class="title">get</span><span class="params">(key k)</span></span>&#123;</span><br><span class="line">        Node cur=root;</span><br><span class="line">        <span class="keyword">while</span> (cur.k!=k)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.k.compareTo(k)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                cur=cur.right;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                cur=cur.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cur==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur.v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 改</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> newVal</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">update</span><span class="params">(key k,value newVal)</span></span>&#123;</span><br><span class="line">        Node cur=root;</span><br><span class="line">        <span class="keyword">while</span> (cur.k!=k)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.k.compareTo(k)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                cur=cur.right;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                cur=cur.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cur==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.v=newVal;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近被spring的源码搞自闭了，有好几天没写这个分类的文章了。&lt;/p&gt;
&lt;h2 id=&quot;主要内容&quot;&gt;&lt;a href=&quot;#主要内容&quot; class=&quot;headerlink&quot; title=&quot;主要内容&quot;&gt;&lt;/a&gt;主要内容&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;Hashmap的一些知识点&lt;/li&gt;
&lt;li&gt;Java实现二叉搜索树
    
    </summary>
    
    
    
      <category term="变强日记" scheme="http://yoursite.com/tags/%E5%8F%98%E5%BC%BA%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>变强日记3</title>
    <link href="http://yoursite.com/2019/11/07/%E5%8F%98%E5%BC%BA%E6%97%A5%E8%AE%B03/"/>
    <id>http://yoursite.com/2019/11/07/变强日记3/</id>
    <published>2019-11-07T12:55:56.000Z</published>
    <updated>2019-11-11T14:13:17.459Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="主要内容">主要内容</span></h2><ol><li>java中的==、equals()和hashCode()</li><li>算法题leetcode[15]:3Sum</li></ol><h2><span id="java中的-equals和hashcode">java中的==、equals()和hashCode()</span></h2><h3><span id="运算符">“==”运算符</span></h3><p>首先来看最基础的<code>==</code>符号，它比较的是变量（栈）内存中存放的对象（堆）的内存地址，用来判断两个对象的地址是否相同，即是否指向同一个对象。<br><strong>简单来说==比较的是，是否指向同一个对象（堆）</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       String str1=<span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">       String str2=<span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line"></span><br><span class="line">       String str3=<span class="string">"efg"</span>;</span><br><span class="line">       String str4=<span class="string">"efg"</span>;</span><br><span class="line">       System.out.println(str1==str2);</span><br><span class="line">       System.out.println(str3==str4);</span><br><span class="line">       <span class="comment">//输出：</span></span><br><span class="line">       <span class="comment">//false</span></span><br><span class="line">       <span class="comment">//true</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>现象解释：<code>str1==str2</code>输出false，是因为str1和str2虽然存储的字符串相同，但是它们各自new了自己单独的对象，而==比较的是指向的对象是否相同，所以输出false。<br>而<code>str3==str4</code>是因为<strong>java中变量池</strong>的存在，定义str3和str4的时候，java回到变量池中寻找是否存在已经定义过的，如果有已经定义了的，那么直接将引用指向它就可以了，不必再重新新建对象了。因为str3和str4指向同一个对象，所以<code>str3==str4</code>为true。</p><h3><span id="equals">equals()</span></h3><p>首先看一段代码我们写了一个Myobj，并new了两个对象，分别使用==和equals()来进行比较<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Myobj obj1=<span class="keyword">new</span> Myobj(<span class="string">"aaa"</span>);</span><br><span class="line">        Myobj obj2=<span class="keyword">new</span> Myobj(<span class="string">"aaa"</span>);</span><br><span class="line">        System.out.println(obj1==obj2);</span><br><span class="line">        System.out.println(obj1.equals(obj2));</span><br><span class="line">        <span class="comment">//输出</span></span><br><span class="line">        <span class="comment">//false</span></span><br><span class="line">        <span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Myobj</span></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Myobj</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>现象解释：</strong><br><code>obj1==obj2</code>输出false，很好理解，因为==比较的是指向的对象是否是同一个，因为obj1和obj2指向了它们各自new的对象，所以为false。<br><code>obj1.equals(obj2)</code>输出false，是因为我们在<code>Myobj</code>没有重写<code>equals()</code>方法,使用的是<code>Object</code>中的<code>equals()</code>方法.<br><code>Object</code>类中的<code>equals()</code>方法的实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看到了<code>Object</code>类中的<code>equals()</code>方法的实现，对<code>obj1.equals(obj2)</code>输出false也很好理解了，因为它本质上和<code>obj1==obj2</code>是一样的。<br><strong>重写equals()方法：</strong><br>如果我们认为name相同的MyObject对象就是equals的的话，我们就需要重写equals()方法了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Myobj obj1=<span class="keyword">new</span> Myobj(<span class="string">"aaa"</span>);</span><br><span class="line">        Myobj obj2=<span class="keyword">new</span> Myobj(<span class="string">"aaa"</span>);</span><br><span class="line">        System.out.println(obj1==obj2);</span><br><span class="line">        System.out.println(obj1.equals(obj2));</span><br><span class="line">        <span class="comment">//输出；</span></span><br><span class="line">        <span class="comment">//false</span></span><br><span class="line">        <span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Myobj</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Myobj</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Myobj obj)</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>.name.equals(obj.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3><span id="hashcode">hashCode()</span></h3><ol><li>hashCode()方法的作用是什么<br>HashCode()方法主要是在哈希表中起作用，如HashSet、HashMap等。单我们向哈希表中添加对象的时候，首先会调用hashCode()方法计算Object的哈希码，根据哈希码的值，确定该对象在哈希表中的位置，如果该位置已经有对象了，那么就调用equals()比较这些对象与Object是否相等，如果相等，则不需要保存object对象，如果不相等，则把对象加入链表中。<br>这也就解释了<strong>equals()相等，则hashCode()必须相等</strong>，如果两个对象equals相等，那么它们在哈希表中应该只出现一次，如果hashCode不相等，那么它们会被散列到哈希表中的不同位置，就不止出现一次了。</li></ol><p><strong>重写hashCode()</strong><br>几个原则：</p><ol><li>equals相等，则hashCode必须相等（重点）</li><li>hashCode不能太简单，否则哈希冲突会很多</li><li>hashCode不能太复杂，否则计算耗时，影响性能</li></ol><p><code>Object</code>类中的hashCode方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p><p>重写hashcode<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Myobj obj1=<span class="keyword">new</span> Myobj(<span class="string">"aaa"</span>,<span class="number">1</span>);</span><br><span class="line">        Myobj obj2=<span class="keyword">new</span> Myobj(<span class="string">"aaa"</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(obj1.equals(obj2));</span><br><span class="line">        System.out.println(obj1.hashCode()==obj2.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Myobj</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Myobj</span><span class="params">(String name,<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">        <span class="keyword">this</span>.id=id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Myobj obj)</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>.name.equals(obj.name)&amp;&amp;<span class="keyword">this</span>.id==obj.id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hash=<span class="number">17</span>;</span><br><span class="line">        <span class="comment">//选取了equals方法中的两个用于比较的域name和id</span></span><br><span class="line">        hash=hash*<span class="number">31</span>+name.hashCode();</span><br><span class="line">        hash=hash*<span class="number">31</span>+id;</span><br><span class="line">        <span class="keyword">return</span> hash;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>《Effective Java》中提出的一种重写hashCode的方法：</p><ol><li>初始化一个整形变量，并赋予一个非零的常数</li><li>选取equals方法中用于比较的所有域，然后针对每个域的属性进行计算（确保原则一）</li><li>将每个域的散列码合并到对象的哈希码中</li></ol><h2><span id="算法题leetcode153sum">算法题leetcode[15]:3Sum</span></h2><p><strong>题目：</strong><br>Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.</p><p>Note:<br>The solution set must not contain duplicate triplets.</p><p>Example:<br>Given array nums = [-1, 0, 1, 2, -1, -4],<br>A solution set is:<br>[<br>  [-1, 0, 1],<br>  [-1, -1, 2]<br>]</p><p><strong>分析：</strong><br>首先对数据进行排序，然后固定也给位置，从两边进行夹逼。</p><p><strong>解法：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result=<span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="comment">//用于存储结果</span></span><br><span class="line">       </span><br><span class="line">        <span class="keyword">if</span>(nums==<span class="keyword">null</span>||nums.length&lt;<span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 首先进行排序</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="comment">//首先国定一个位置，再去寻找另外两个数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length-<span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;nums[i]==nums[i-<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            find(nums,i+<span class="number">1</span>,nums.length-<span class="number">1</span>,nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> begin,<span class="keyword">int</span> end,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l=begin;</span><br><span class="line">        <span class="keyword">int</span> r=end;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">            <span class="keyword">if</span>((nums[l]+nums[r]+target)==<span class="number">0</span>)&#123;</span><br><span class="line">                List&lt;Integer&gt; list=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">                list.add(target);</span><br><span class="line">                list.add(nums[l]);</span><br><span class="line">                list.add(nums[r]);</span><br><span class="line">                result.add(list); <span class="comment">//加入结果集</span></span><br><span class="line">                <span class="keyword">while</span>(l&lt;r&amp;&amp;nums[l]==nums[l+<span class="number">1</span>])&#123;</span><br><span class="line">                    l++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span>(l&lt;r&amp;&amp;nums[r]==nums[r-<span class="number">1</span>])&#123;</span><br><span class="line">                    r--;</span><br><span class="line">                &#125;</span><br><span class="line">                l++;</span><br><span class="line">                r--;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>((nums[l]+nums[r]+target)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;&lt;span id=&quot;主要内容&quot;&gt;主要内容&lt;/span&gt;&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;java中的==、equals()和hashCode()&lt;/li&gt;
&lt;li&gt;算法题leetcode[15]:3Sum&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;&lt;span id=&quot;java中的-equa
      
    
    </summary>
    
    
    
      <category term="变强日记" scheme="http://yoursite.com/tags/%E5%8F%98%E5%BC%BA%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>变强日记2</title>
    <link href="http://yoursite.com/2019/11/06/%E5%8F%98%E5%BC%BA%E6%97%A5%E8%AE%B02/"/>
    <id>http://yoursite.com/2019/11/06/变强日记2/</id>
    <published>2019-11-06T13:36:56.000Z</published>
    <updated>2019-11-06T12:36:38.480Z</updated>
    
    <content type="html"><![CDATA[<p>不得不说，周末要去考软考了，有点小慌张。天气冷了，早上起床好难受啊！！<br><img src="https://s2.ax1x.com/2019/11/06/MiJpGD.png" alt="MiJpGD.png"></p><h2><span id="主要内容">主要内容</span></h2><ol><li>单例模式的实现方式</li><li>滑动窗口算法解leetcode[3]Longest Substring Without Repeating Characters</li></ol><a id="more"></a><h2><span id="单例模式的实现方式">单例模式的实现方式</span></h2><p>我能想到的单例模式的实现方式一共有5中：</p><ol><li>懒汉式</li><li>饿汉式</li><li>双重锁判断机制实现单例</li><li>静态内部类实现</li><li>枚举类实现</li></ol><h3><span id="懒汉式单例模式">懒汉式单例模式</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 类初始化时，不初始化这个对象（延时加载）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造器私有化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法同步，效率低</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">            instance=<span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：</p><ol><li>可以实现延时加载</li><li>线程安全<br>缺点：</li><li>效率不高</li></ol><h3><span id="饿汉式单例模式">饿汉式单例模式</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 类初始化时，就初始化这个对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance=<span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造器私有化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：</p><ol><li>线程安全</li><li>调用效率搞<br>缺点：</li><li>不能实现延时加载</li></ol><h3><span id="双重锁判断机制实现单例">双重锁判断机制实现单例</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 类初始化时，不初始化这个对象，延迟加载</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造器私有化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 双重锁机制，调用效率有所提高</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance=<span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：</p><ol><li>延迟加载</li><li>调用效率较高<br>缺点：</li><li>因为JVM底层的原因，偶尔会出问题</li></ol><h3><span id="静态内部类实现单例模式">静态内部类实现单例模式</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态内部类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonClassInstance</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE=<span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造器私有化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonClassInstance.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：</p><ol><li>线程安全</li><li>调用效率高</li><li>可以实现延迟加载</li></ol><h3><span id="使用枚举类实现单例模式">使用枚举类实现单例模式</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//枚举元素本身就是单例</span></span><br><span class="line">   INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 可以添加自己需要的操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span>&#123;</span><br><span class="line">       </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：</p><ol><li>线程安全 </li><li>调用效率高</li><li>能够天然的放置反射和反序列化调用</li></ol><p>缺点：</p><ol><li>不能实现延迟加载</li></ol><h2><span id="滑动窗口算法解leetcode3longest-substring-without-repeating-characters">滑动窗口算法解leetcode[3]Longest Substring Without Repeating Characters</span></h2><p><strong>题目描述</strong><br>Given a string, find the length of the longest substring without repeating characters.</p><p>Example 1:<br>Input: “abcabcbb”<br>Output: 3<br>Explanation: The answer is “abc”, with the length of 3. </p><p>Example 2:<br>Input: “bbbbb”<br>Output: 1<br>Explanation: The answer is “b”, with the length of 1.</p><p>Example 3:<br>Input: “pwwkew”<br>Output: 3<br>Explanation: The answer is “wke”, with the length of 3.<br>             Note that the answer must be a substring, “pwke” is a subsequence and not a substring.</p><p><strong>解题思路</strong><br>使用两个指针l，r来标识区间[l,r]为滑动窗口。<br>并且使用一个数组来记录窗口内字符出现的次数，整个数组充当了map的角色<br>最初窗口大小是0的，右指针向右扩展，直到右边的字符已经在窗口中出现了，这个时候我们让左指针向右拓展（窗口在缩小）直到窗口内没有重复的字符串。</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] chars=s.toCharArray();</span><br><span class="line">        <span class="comment">//用来记录窗口内部，字符的出现的次数，充当map的角色</span></span><br><span class="line">        <span class="keyword">int</span>[] freq=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>; <span class="comment">//窗口左侧下标</span></span><br><span class="line">        <span class="keyword">int</span> r=-<span class="number">1</span>; <span class="comment">//窗口右侧下标</span></span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;chars.length)&#123;</span><br><span class="line">            <span class="comment">//窗口右侧的元素，纳入窗口，窗口中的元素不会出现重复</span></span><br><span class="line">            <span class="comment">//窗口就向右侧扩张</span></span><br><span class="line">            <span class="keyword">if</span>((r&lt;s.length()-<span class="number">1</span>)&amp;&amp;freq[chars[r+<span class="number">1</span>]]==<span class="number">0</span>)&#123;</span><br><span class="line">                ++r;</span><br><span class="line">                freq[chars[r]]++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//窗口右侧的元素，在窗口中已经出现了，则从左侧收缩窗口</span></span><br><span class="line">                freq[chars[l]]--;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            res=Math.max(res,r-l+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不得不说，周末要去考软考了，有点小慌张。天气冷了，早上起床好难受啊！！&lt;br&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/11/06/MiJpGD.png&quot; alt=&quot;MiJpGD.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;主要内容&quot;&gt;&lt;a href=&quot;#主要内容&quot; class=&quot;headerlink&quot; title=&quot;主要内容&quot;&gt;&lt;/a&gt;主要内容&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;单例模式的实现方式&lt;/li&gt;
&lt;li&gt;滑动窗口算法解leetcode[3]Longest Substring Without Repeating Characters&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
    
      <category term="变强日记" scheme="http://yoursite.com/tags/%E5%8F%98%E5%BC%BA%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>变强日记1</title>
    <link href="http://yoursite.com/2019/11/05/%E5%8F%98%E5%BC%BA%E6%97%A5%E8%AE%B01/"/>
    <id>http://yoursite.com/2019/11/05/变强日记1/</id>
    <published>2019-11-05T13:32:56.000Z</published>
    <updated>2019-11-05T13:32:53.512Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="主要内容">主要内容</span></h2><ol><li>java中的等待通知机制</li><li>动态规划解leetcode10:Regular Expression Matching</li></ol><a id="more"></a><h2><span id="java中的等待通知机制">java中的等待通知机制</span></h2><h3><span id="什么是等待通知机制">什么是等待通知机制</span></h3><p>一个线程因为执行目标动作锁需要的保护条件未满足而被暂停的过程就被成为等待。<br>一个线程更新了系统的状态，使得其它线程所需要的保护条件成立，唤醒那些被暂停的线程的过程被称为通知。</p><h3><span id="waitnotfy方案">wait/notfy方案</span></h3><p>java中提供了<code>Object.wait()/Object.wait(long timeoout)</code>,<code>Object.notify()/Object.notifyAll()</code>可以用来实现等待和通知<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(someObject)&#123;</span><br><span class="line">    <span class="keyword">while</span>(保护条件不成立)&#123;</span><br><span class="line">        someObject.wait();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//执行目标动作</span></span><br><span class="line">    doAction();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(someObject)&#123;</span><br><span class="line">    <span class="comment">//更新保护条件涉及的共享变量</span></span><br><span class="line">    updateSharedState();</span><br><span class="line">    <span class="comment">//通知等待的线程</span></span><br><span class="line">    someObject.notify();</span><br><span class="line">&#125;</span><br><span class="line">```、</span><br><span class="line">该方案存在的问题：</span><br><span class="line"><span class="number">1</span>. 过早唤醒</span><br><span class="line">因为同一个对象上可以有多个wait的线程。假设一组等待/通知线程同步在对象someObject上，初始状态下均不成立，当线程N1更新了共享变量state1使得N1执行notifyAll方法唤醒所有线程，当其它线程的保护条件可能并不成立，这使得线程唤醒后还得睡眠。</span><br><span class="line"><span class="number">2</span>. 信号丢失</span><br><span class="line">如果等待线程在wait之前没有判断保护条件是否成立，那么有这样一种情况，就是通知线程在等待线程进入等待之前就更新了保护条件，使得保护条件成立，等待线程在睡眠后就再也不会收到唤醒通知了。</span><br><span class="line">比如下面这个例子：</span><br></pre></td></tr></table></figure><p>T1:<br>synchronized(sharedMonitor){<br>    updateSomeCondition();//更新保护条件<br>    sharedMonitor.notify();</p><p>}<br>T2:<br>while(someCondition){<br>//Point1:<br>    synchronized(sharedMonitor){<br>      sharedMonitor.wait();<br>   }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">假如T2先执行，当它判断保护条件someCondition成立后，进入Point1时（注意synchronized代码块的位置），线程调度器可能切换到了T1，T1发出唤醒信号。然后线程调度器重新回到point1执行，T2线程进入等待。T2也就错过了唤醒信号，再也不会被唤醒了。所以一定要注意`synchronized`关键字的位置。</span><br><span class="line">3. 欺骗性唤醒。等待线程也可能存在没有其它任何线程执行notify和notifyAll线程的情况下被唤醒。</span><br><span class="line">4. 上下文切换问题。wait/notify的时候可能导致较多的上下文切换</span><br><span class="line"></span><br><span class="line">### 条件变量方案</span><br><span class="line">一种比wait/notfy方案更好的实现方案是使用jdk1.5之后引入的条件变量java.util.concurent.locks.Condition接口。</span><br><span class="line"></span><br><span class="line">`Lock.newCondition()`的返回值就是一个Condition实例。因此调用任何一个显示锁的实例的newCondition方法都可以创建一个相应的Condition接口。Condition.await()/signal()也要求其执行线程持有创建该Condition实例的**显示锁**。每个Condition实例内部都维护乐一个用于存储等待线程的队列。</span><br><span class="line"></span><br><span class="line">假设cond1和cond2是两个不同的Condition实例，一个线程执行Cond1.await()会导致其被暂停，并被存入cond1的等待队列。cond1.signal会使cond1的等待队列中的任意线程被唤醒。调用cond1.signalAll()会使cond1的等待队列中的所有线程被唤醒。而cond2等待队列中的任何一个等待线程都不会受此影响。这样就避免了过早唤醒的问题。</span><br><span class="line">```java</span><br><span class="line">public class Test &#123;</span><br><span class="line">    //显示锁</span><br><span class="line">    private final Lock lock=new ReentrantLock(); </span><br><span class="line">    //条件变量</span><br><span class="line">    private final Condition condition=lock.newCondition();</span><br><span class="line">    </span><br><span class="line">    public void methodA() throws InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            while (保存条件不成立)&#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            //执行目标动作</span><br><span class="line">            doAction();</span><br><span class="line">            </span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void methodB()&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            //更新保护条件</span><br><span class="line">            updateState();</span><br><span class="line">            //唤醒该条件变量上的等待线程</span><br><span class="line">            condition.signal();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该方案很好的解决了过早唤醒问题。并且<code>boolean awaitUntil(Date deadline)</code>可以根据返回值区分是等待超时唤醒的还是被其它线程唤醒的。</p><h3><span id="countdownlatch方案">CountDownLatch方案</span></h3><p>CountDownLatch叫做倒计时协调器。<br>ConutDownLatch内部维护了一个用于表示<strong>未完成的先决操作数量的计数器</strong>。每调用一次countDown（）相应实例的计数器值会减少1（先决条件完成了一个），await()方法相当于一个受保护的方法，其保护条件为计数器的值为0(先决条件全部完成)。<br>因此，当<strong>计数器的值不为0</strong>的时候，CountDownLatch.await()的执行线程会被<strong>暂停</strong>。这些线程就被称为CountDownLatch上的等待线程。CountDownlatch.countDown()相对于一个<strong>通知方法</strong>，它会在<strong>计数器达到0的时候唤醒</strong>相应实例上的等待线程。<br>因为CountDownLatch内部封装了对“全部先决条件的等待与通知的逻辑”，所以客户端代码在调用await,countDown方法都<strong>无需加锁</strong>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用实例，演示了如何用CountDownLatch实现10个线程同时启动</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CountDownLatchTest countDownLatchTest=<span class="keyword">new</span> CountDownLatchTest();</span><br><span class="line">        countDownLatchTest.runThread();</span><br><span class="line">    &#125;</span><br><span class="line">    CountDownLatch countDownLatch=<span class="keyword">new</span> CountDownLatch(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个线程</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Thread <span class="title">createThread</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        Thread thread=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    countDownLatch.await();</span><br><span class="line">                    System.out.println(<span class="string">"thread"</span>+Thread.currentThread().getName()+<span class="string">"准备完毕"</span>+System.currentTimeMillis());</span><br><span class="line">                &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.setName(<span class="string">"thread-"</span>+i);</span><br><span class="line">        <span class="keyword">return</span>  thread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runThread</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ExecutorService executorService= Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                executorService.submit(createThread(i));</span><br><span class="line">                <span class="comment">//待等待的线程数减去一</span></span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>CountDownLatch是无法重用的。</strong></p><h3><span id="cyclicbarrier方案">CyclicBarrier方案</span></h3><p>jdk1.5之后引入了<code>java.util.concurrent.CyclicBarrier</code>类，该类也可以实现等待通知。<br>CyclicBarrier方案让多个线程相互等待，直到达到一个屏障点，并且CyclicBarrier是可重用的。<br>比如让10个线程相互等待，以实现10个线程同时开始执行：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CyclicBarrierTest cyclicBarrierTest=<span class="keyword">new</span> CyclicBarrierTest();</span><br><span class="line">        cyclicBarrierTest.runThread();</span><br><span class="line">    &#125;</span><br><span class="line">    CyclicBarrier cyclicBarrier=<span class="keyword">new</span> CyclicBarrier(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个线程</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Thread <span class="title">createThread</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        Thread thread=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">/*除了最后一个线程，其余的线程都会在此等待，</span></span><br><span class="line"><span class="comment">                直到最后一个线程执行到此，唤醒之前所有等待的线程*/</span></span><br><span class="line">                    cyclicBarrier.await(); </span><br><span class="line">                    System.out.println(<span class="string">"thread"</span>+Thread.currentThread().getName()+<span class="string">"准备完毕"</span>+System.currentTimeMillis());</span><br><span class="line">                &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">catch</span> (BrokenBarrierException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.setName(<span class="string">"thread-"</span>+i);</span><br><span class="line">        <span class="keyword">return</span>  thread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runThread</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ExecutorService executorService= Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                executorService.submit(createThread(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2><span id="动态规划解leetcode10regular-expression-matching">动态规划解leetcode10:Regular Expression Matching</span></h2><p><strong>题目：</strong><br>Given an input string (s) and a pattern (p), implement regular expression matching with support for ‘.’ and ‘<em>‘.<br>‘.’ Matches any single character.<br>‘</em>‘ Matches zero or more of the preceding element.<br>The matching should cover the entire input string (not partial).</p><p>Note:<br>s could be empty and contains only lowercase letters a-z.<br>p could be empty and contains only lowercase letters a-z, and characters like . or *.<br>Example 1:</p><p>Input:<br>s = “aa”<br>p = “a”<br>Output: false<br>Explanation: “a” does not match the entire string “aa”.</p><p><strong>思路：</strong><br>使用一个二维数组来表示匹配结果b[i+1][j+1]表示s[0..i]匹配p[0..j]<br>两个边界条件：</p><ol><li>b[0][0],及两个空串进行匹配，为true</li><li>对于空串的匹配b[i+1][0]的数值必须为False</li></ol><p><strong>解法：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lenA=s.length();</span><br><span class="line">        <span class="keyword">int</span> lenP=p.length();</span><br><span class="line">        <span class="keyword">char</span>[] charsS=s.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] charsP=p.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span>[][] b=<span class="keyword">new</span> <span class="keyword">boolean</span>[lenA+<span class="number">1</span>][lenP+<span class="number">1</span>];</span><br><span class="line">        b[<span class="number">0</span>][<span class="number">0</span>]=<span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lenA;i++)&#123;</span><br><span class="line">            b[i+<span class="number">1</span>][<span class="number">0</span>]=<span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;lenP;j++)&#123;</span><br><span class="line">            b[<span class="number">0</span>][j+<span class="number">1</span>]=j&gt;<span class="number">0</span>&amp;&amp;charsP[j]==<span class="string">'*'</span>&amp;&amp;b[<span class="number">0</span>][j-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lenA;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;lenP;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(charsP[j]!=<span class="string">'*'</span>)&#123;</span><br><span class="line">                    b[i+<span class="number">1</span>][j+<span class="number">1</span>]=b[i][j]&amp;&amp;(<span class="string">'.'</span>==charsP[j]||charsS[i]==charsP[j]);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    b[i+<span class="number">1</span>][j+<span class="number">1</span>]=b[i + <span class="number">1</span>][j - <span class="number">1</span>] &amp;&amp; j &gt; <span class="number">0</span> || b[i + <span class="number">1</span>][j] ||</span><br><span class="line">                    b[i][j + <span class="number">1</span>] &amp;&amp; j &gt; <span class="number">0</span> &amp;&amp; (<span class="string">'.'</span> == charsP[j - <span class="number">1</span>] || charsS[i] == charsP[j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b[lenA][lenP];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;主要内容&quot;&gt;&lt;a href=&quot;#主要内容&quot; class=&quot;headerlink&quot; title=&quot;主要内容&quot;&gt;&lt;/a&gt;主要内容&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;java中的等待通知机制&lt;/li&gt;
&lt;li&gt;动态规划解leetcode10:Regular Expression Matching&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
    
      <category term="变强日记" scheme="http://yoursite.com/tags/%E5%8F%98%E5%BC%BA%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
</feed>
