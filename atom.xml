<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>个人博客</title>
  
  <subtitle>博观而约取 厚积而薄发</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-01-27T08:43:55.500Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>爱写代码的小书童</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JVM之G1和CMS收集器</title>
    <link href="http://yoursite.com/2020/01/27/JVM%E4%B9%8BG1%E5%92%8CCMS%E6%94%B6%E9%9B%86%E5%99%A8/"/>
    <id>http://yoursite.com/2020/01/27/JVM之G1和CMS收集器/</id>
    <published>2020-01-27T08:43:56.000Z</published>
    <updated>2020-01-27T08:43:55.500Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="cms垃圾回收器">CMS垃圾回收器</span></h1><h2><span id="什么是cms垃圾回收器cms回收器的特点">什么是CMS垃圾回收器，CMS回收器的特点</span></h2><p>CMS即Concurrent Mark Sweep，是一款并发的、使用标记-清除算法的针对老年代的垃圾回收器。如果老年代使用CMS垃圾回收器，需要添加虚拟机参数<code>-XX:+UseConcMarkSweepGC</code><br>CMS垃圾回收器GC过程暂停短，适合对时延要求较高的服务，用户线程不允许长时间的停顿的场景。但是容易造成严重的内存碎片化，且对CPU资源非常的敏感，无法处理浮动垃圾，可能出现<code>Concurrent Mode Failure</code>失败而导致Full GC产生。</p><a id="more"></a><h2><span id="cms垃圾回收器的工作流程与原理">CMS垃圾回收器的工作流程与原理</span></h2><p>CMS垃圾回收器的工作需要经历初始标记、并发标记、重新标记、并发清除四个步骤。</p><ol><li>初始标记<br>初始标记的对象为：</li></ol><ul><li>标记老年代中所有GC Roots引用的对象</li><li>老年代中被年轻代中存活的对象引用的对象。</li></ul><p><img src="https://s2.ax1x.com/2020/01/27/1nrd4P.png" alt="1nrd4P.png"><br>由于需要对所有的对象进行标记，为了避免在标记过程中对象状态发生改变，所以需要Stop the world即停止所有用户线程，但是整个标记的过程耗时较短。</p><ol start="2"><li><p>并发标记<br>从初始标记阶段找到GC Roots开始进行Tracing，找到所有的存活对象。<br><img src="https://s2.ax1x.com/2020/01/27/1nsnKg.png" alt="1nsnKg.png"><br>并发标记阶段会与用户线程同时进行，因此会有一些对象的引用状态发生改变。</p></li><li><p>重新标记<br>标记在并发标记阶段引用发生变化的对象，如果发现对象的引用发生变化，则JVM会标记堆的这个区域为Dirty Card。<br><img src="https://s2.ax1x.com/2020/01/27/1nsyRK.png" alt="1nsyRK.png"><br>那些能够从Dirty Card达到的对象也被标记为存活，当标记完成后，这个Dirty Card区域就会消失。<br><img src="https://s2.ax1x.com/2020/01/27/1nsgMD.png" alt="1nsgMD.png"><br>该阶段是一个并发阶段，能够与用户线程同时运行，不会中断它们。</p></li><li><p>并发清除<br>清除那些未被标记的对象回收内存空间。<br><img src="https://s2.ax1x.com/2020/01/27/1nsTRf.png" alt="1nsTRf.png"></p></li></ol><h1><span id="g1垃圾回收器">G1垃圾回收器</span></h1><h2><span id="什么是g1回收器g1回收器的特点">什么是G1回收器，G1回收器的特点</span></h2><p>G1回收器(Garbage First).可以通过<code>-XX+UseG1GC</code>.G1垃圾回收器以关注延迟为目标、服务器短应用的垃圾收集器。G1的设置原则是“首先收集尽可能多的垃圾”，因此G1并不会等内存耗尽或者快耗尽的时候开始垃圾收集，而是在内部采用了启发式算法，在老年代中找出具有高回收收益的分区进行收集。同时G1可以根据用户设置的暂停时间目标自动跳转年轻代和总堆大小，暂停目标越短年轻代空间越小、总空间就越大。</p><h2><span id="g1的内存模型">G1的内存模型</span></h2><p>G1采用自动分区(Region)的思路，将内存划分为一个个相等大小的内存分区，回收时则以分区为单位进行回收，存活的对象复制到另一个空闲分区中。由于都是以相等大小获得分区为单位进行操作，因此G1天然就是一种压缩方案。这些reding最后又被分别标记为Eden，Survivor和old，这里只是逻辑分区不是物理表示<br>。在这之外还有Humongous Regin，巨型对象分区，巨型对象会独占一个或多个连续分区，确定巨型对象分区空间需要扫描整个堆，因此应用程序应该避免生成巨型对象。</p><h2><span id="g1工作的流程">G1工作的流程</span></h2><ol><li><p>RSet的维护<br>RSet即已ji’yi。在串行和并行收集器中，GC通过整个堆扫描，来去顶对象是否处于可达路径中。然而G1为了避免整堆扫描时的Stop the world，它在每个分区记录了一个已记忆集合，内部类似一个方向指针，记录引用分区对象的卡片索引。当要回收该分区时，通过扫描分区的RSet，来确定引用本分区内的对象是否存活，进而确定本分区的对象存活情况。</p></li><li><p>初始标记<br>初始标记负责标记所有能直接可达的根对象(虚拟机栈对象，全局对象，本地方法栈对象)。在初始标记过程之中需要暂停用户线程(Stop the world).G1一般利用年轻代STW时间段完成初始标记。初始标记时并发执行的，直到所有的分区处理完。</p></li><li>并发标记<br>并发标记和应用线程并发执行，每个线程每次只扫描一个分区，从而标记出存活对象图。</li><li>最终标记<br>最终标记是最后一个标记阶段。在该阶段中，G1需要一个暂停的时间，区处理剩下的SATB日志缓冲区和所有更新，找出所有未被访问的存活对象，同时完成存活数据统计。这个阶段也是并行执行的。</li><li>筛选回收<br>该阶段主要进行Rset梳理，启发式算法会根据活跃度和RSet尺寸对分区定义不同等级，同时RSet数理也有助于发现无用的引用。参数-XX:+PrintAdaptiveSizePolicy可以开启打印启发式算法决策细节；整理堆分区，识别所有空闲分区，即发现无存活对象的分区。该分区可在清理阶段直接回收为混合收集周期识别回收收益高(基于释放空间和暂停目标)的老年代分区集合；无需等待下次收集周期。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;CMS垃圾回收器&quot;&gt;&lt;a href=&quot;#CMS垃圾回收器&quot; class=&quot;headerlink&quot; title=&quot;CMS垃圾回收器&quot;&gt;&lt;/a&gt;CMS垃圾回收器&lt;/h1&gt;&lt;h2 id=&quot;什么是CMS垃圾回收器，CMS回收器的特点&quot;&gt;&lt;a href=&quot;#什么是CMS垃圾回收器，CMS回收器的特点&quot; class=&quot;headerlink&quot; title=&quot;什么是CMS垃圾回收器，CMS回收器的特点&quot;&gt;&lt;/a&gt;什么是CMS垃圾回收器，CMS回收器的特点&lt;/h2&gt;&lt;p&gt;CMS即Concurrent Mark Sweep，是一款并发的、使用标记-清除算法的针对老年代的垃圾回收器。如果老年代使用CMS垃圾回收器，需要添加虚拟机参数&lt;code&gt;-XX:+UseConcMarkSweepGC&lt;/code&gt;&lt;br&gt;CMS垃圾回收器GC过程暂停短，适合对时延要求较高的服务，用户线程不允许长时间的停顿的场景。但是容易造成严重的内存碎片化，且对CPU资源非常的敏感，无法处理浮动垃圾，可能出现&lt;code&gt;Concurrent Mode Failure&lt;/code&gt;失败而导致Full GC产生。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM之垃圾回收</title>
    <link href="http://yoursite.com/2020/01/26/JVM%E4%B9%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    <id>http://yoursite.com/2020/01/26/JVM之垃圾回收/</id>
    <published>2020-01-26T13:47:56.000Z</published>
    <updated>2020-01-26T13:51:22.009Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="需要回收的区域">需要回收的区域</span></h2><p>JVM的运行时内存可以分为5个区域：程序计数器，虚拟机栈，本地方法栈，方法区，堆区。其中程序计数器，虚拟机栈，本地方法栈都是与线程同生共死的，因此不要进行垃圾回收。垃圾回收主要关注的堆区和方法区。</p><a id="more"></a><h2><span id="如何判断一个对象是否还存活">如何判断一个对象是否还存活</span></h2><h3><span id="引用计数算法">引用计数算法</span></h3><p>引用计数是垃圾回收器中的早期策略。这种方法，堆中的每个实例都有一个引用计数。当一个对象被创建的时候，就会为给该实例分配一个计数器，这个计数器的初始值为1.当任何其它变量被赋值为这个对象的引用的时候，计数器加1，但当一个对象实例的某个引用超过了生命周期或者被设置为一个新值的时候，对象实例的引用计数器减1.当计数器的值为0的时候，就可以认为其所对应的对象已经“死亡”了。垃圾回收器就可以对其进行回收了。</p><h4><span id="优缺点">优缺点</span></h4><p>优点：引用计数器可以很快的执行，交织再程序运行中。<br>缺点：无法检测出循环引用，循环引用计数器永不为0。</p><h3><span id="可达性分析">可达性分析</span></h3><p>可达性分析算法是从离散数学图论中引入的，程序把所有的引用关系看作一个图，从一个GC ROOT开始，寻找对应的引用节点，找到这个节点以后，继续寻找这个节点的引用节点，当所有的引用节点寻找完毕之后，剩余的节点则被认为是没有被引用到的节点，即“死亡”的对象。</p><p>那么可以被作为GC Roots的对象包括那些呢？</p><ul><li>虚拟机栈中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中引用的对象</li></ul><p>这个算法的思路就是沿着一系列的GC roots作为起点向下搜索，当一个对象不可达，那么就判定为可回收的。</p><p>当然被可达性分析判定为可回收，需要经历两次标记的过程。如果对象在可达性分析后发现不可达，那它会被第一标记并进行一次筛选，筛选的条件就是此对象是否有需要执行的<code>finalize()</code>方法，如果有，那么会调用一次（最多一次）<code>finalize()</code>方法，可以通过<code>finalize()</code>方法来拯救一次被回收的对象。</p><p>两次标记分别是：</p><ol><li>通过GC Roots对象是否可达，如果对象不可达. </li><li>待回收的对象是否需要执行<code>finalize()</code>方法。在<code>finalize()</code>方法中没有于引用链建立关联关系的，将被进行第二次标记。</li></ol><p>只有两次标记都成功的对象，才会被真正的回收。</p><h2><span id="java中的引用">Java中的引用</span></h2><p>在Java引用中，将引用分为强引用、软引用、弱引用、虚引用4种。这四种引用的强度依次减弱。</p><ul><li>强引用：强引用是程序代码种普遍存在的，类似于<code>Object obj=new Object()</code>。只要强引用还存在，垃圾回收器就永远不会回收掉被引用的对象。</li><li>软引用：用来描述一些有用但并非必须的对象。对于软引用关联的对象，在系统将要发生内存溢出异常之前，将会把这些对象列入回收范围之中进行第二次回收。如果这次回收之后还没有足够的内存，才会抛出内存溢出。</li><li>弱引用：也是描述非必须对象的，但是它的强度比软引用要弱，被弱引用关联的对象只能生存到下一次垃圾回收器发生之前。当垃圾回收器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。</li><li>虚引用:虚引用是最弱的一种引用，一个对象是否存在虚引用，完全不会影响其生存时间，也无法通过虚引用来获取一个对象实例。它的作用是能在这个对象被回收器回收时收到一个系统通知。</li></ul><p><strong>无论是引用计数器算法还是可达性分析算法，都是针对于强引用的</strong></p><p>什么是引用？<br>如果reference类型的数据中存储的是数值代表的是另一块内存的起始地址，那么称这块内存代表着一个引用。</p><h2><span id="方法区的垃圾回收">方法区的垃圾回收</span></h2><p>方法区回收的内容主要有两类：一类是废弃的常量，另一类是无用的类。对于废弃的常量可以通过可达性分析来判断是否可以回收。<br>但是无用的类需要同时满足以下几个条件：</p><ul><li>该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例</li><li>加载该类的ClassLoader(类加载器)已经被回收</li><li>该类对应的java.lang.Class对象无法在任何地方被引用，无法在任何地方通过反射来访问该类的方法。</li></ul><h2><span id="堆中的垃圾回收">堆中的垃圾回收</span></h2><p>Java堆中存放着几乎所有的对象实例，也是垃圾回收器工作的主要目标。</p><h3><span id="常用的垃圾回收算法">常用的垃圾回收算法、</span></h3><h4><span id="引用计数器法">引用计数器法</span></h4><p>这个算法在之前已经介绍过来。这种算法实现简单，效率高可以于程序交织运行，但是不能解决循环依赖的问题。因此主流的JVM并没有采用引用计数器法来管理内存。</p><h4><span id="标记-清除算法mark-sweep">标记-清除算法(Mark-Sweep)</span></h4><p>标记清除算法分为两个阶段：分别为标记阶段和清除阶段。<br>标记阶段：<br>采用可达性分析算法来判断对象的存活情况，并对需要清除的对象进行标记。<br>清除阶段：<br>清除阶段扫描整个堆内存，清除掉被标记的对象。</p><p>该算法实现简单，在存活对象较多的情况下效率非常的高，但是因为其直接回收对象不会对内存进行整理，因此会造成内存的碎片。</p><h4><span id="复制算法">复制算法</span></h4><p>复制算法将整个堆内存划分为大小相等的两个部分，每次只使用其中一块。当一块内存用完了，就将还存活的对象赋值到另一块内存中，然后再把已经使用的一半内存之情清理掉。这样就解决了标记-清除算法的产生碎片的问题。</p><p>这种算法实现简单，运行高效且很好的解决了内存碎片的问题。但是降低了内存的利用率，因为同一时间只能有效利用一半的内存。</p><h4><span id="标记-整理mark-compact算法">标记-整理(Mark-compact)算法</span></h4><p>该算法首先会对需要回收的算法进行一次标记，然后将存活的对象移向一段（整理），移动过后，清理掉边界以外的内存。（<strong>先标记再移动最后清除</strong>）</p><p>标记整理算法也解决了标记清除算法的内存碎片问题，但是因为存在对象移动的开销，因此效率较低。</p><h4><span id="分代收集算法generational-collection">分代收集算法（Generational Collection）</span></h4><p>分代收集算法是目前大部分JVM采用的垃圾收集器算法。它的核心思想是根据对象存活的生命周期将内存划分为若干个不同的区域。一般划分为老年代（Tenured Generation）和新生代(Young Generation)，在堆区之外还有一个永久代(Permanet Generation)。</p><p>老年代的特点是每次垃圾回收只有少量的对象需要回收，而新生代的特点是每次垃圾回收时都有大量的对象需要被回收。然后根据不同代的特点来采用合适的收集算法。</p><p>对于新生代，目前主流的是采用<strong>复制算法</strong>，因为新生代中每次都会回收绝大多数的对象，因此需要复制的对象较少。但是不是按照1：1的比例还划分新生代空间的。一般来说将新生代划分为一块较大的Eden空间和两块较大的Survivor空间(8:1:1),每次使用Eden和其中一块Survivor，当进行回收时，将Eden和Survivor中还存活的对象复制到另一个Survivor空间中，然后清理掉Eden和刚才使用过的Survivor空间。</p><p>所有新生成的对象首先存放在年轻代中。年轻代的目标就是尽可能块的收集掉那些生命周期短的对象。回收时，首先将eden区中存活的对象复制到一个survivor0区中，然后清空eden区，当survivor0区满了之后，就会将survivor0区和eden区中存活的对象复制到survivor1区，然后清空eden和这个survivor0区，然后将survivior0区和survivor1区交换。当survivor1区不足以存放eden和survivior0中存活的对象时，就会将存活对象存放到老年代。若是老年代也满了就会触发一次Full GC（Major GC），也就是新生代，老年代都进行回收。新生代中发生的GC也叫做Minor GC，Minor GC发生的频率比较高。</p><p>对于老年代，因为每次需要回收的内存的数量较少，因此一般采用标记整理算法。</p><h2><span id="常见的垃圾回收器">常见的垃圾回收器</span></h2><h3><span id="serial收集器">Serial收集器</span></h3><p>新生代单线程收集器，标记和清理都是单线程，优点是简单高效。采用的是复制算法。是client级别默认的GC方式，可以通过<code>-XX:+UseSerialGC</code>来强制指定。</p><h3><span id="serial-old">Serial Old</span></h3><p>老年代单线程收集器，是Serial收集器的老年代版本。采用的是标记-整理算法。</p><h3><span id="parnew收集器">parNew收集器</span></h3><p>新生代收集器，可以认为是Serial收集器的多线程版本，在多核CPU环境下有着比Serial更好的表现。</p><h3><span id="parallel-scavenge收集器">Parallel Scavenge收集器</span></h3><p>并行收集器，追求高吞吐量，高效利用CPU。采用的是停止-复制算法。适合后台引用等对交互响应要求不高的场景。是Service级别默认采用的GC方式，可用<code>-XX:+UseParallelGC</code>来强制指定，用<code>-XX:ParallelGCThread=4</code>来指定线程数。</p><h3><span id="parallel-old收集器">Parallel Old收集器</span></h3><p>Parallel Scavenge收集器的老年代版本，并行收集器，吞吐量优先。</p><h3><span id="cmsconcurrnet-mark-sweep收集器">CMS（concurrnet mark sweep）收集器</span></h3><p>高并发，低停顿，追求最短GC回收停顿时间，CPU占用比较高，停顿时间短，多和CPU追求高响应时间的选择。采用的是标记-清理算法。</p><h2><span id="gc是生命时候触发的">GC是生命时候触发的</span></h2><p>由于对对象进行了分代处理，因此垃圾回收的区域，时间也不一样。GC有两种类型： Scavenge GC 和 Full GC。</p><h3><span id="scavenge-gc">Scavenge GC</span></h3><p>一般情况下，当新对象生成，并在eden申请空间失败是，就会触发Scavenge GC，对Eden区域进行GC，清除非存活对象，并且把尚且存活的对象移动到Survivor区。然后整理Survivor的两个区。这种GC仅仅是在年轻代的Eden区进行，不会影响到老年代。因为Eden区空间不大，且大部分对象都是从Eden区开始的，因此Eden区的GC非常的频繁。</p><h3><span id="full-gc">Full GC</span></h3><p>对整个堆进行整理。因为Full GC需要对整个堆进行整理。因此比Scavenge GC要慢，因此应该要尽可能减少Full GC的次数。导致Full GC的原因有以下几种：</p><ul><li>老年代写满</li><li>持久代写满</li><li>system.gc()被显式调用</li><li>上一次GC之后堆区各域的分配策略动态变化。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;需要回收的区域&quot;&gt;&lt;a href=&quot;#需要回收的区域&quot; class=&quot;headerlink&quot; title=&quot;需要回收的区域&quot;&gt;&lt;/a&gt;需要回收的区域&lt;/h2&gt;&lt;p&gt;JVM的运行时内存可以分为5个区域：程序计数器，虚拟机栈，本地方法栈，方法区，堆区。其中程序计数器，虚拟机栈，本地方法栈都是与线程同生共死的，因此不要进行垃圾回收。垃圾回收主要关注的堆区和方法区。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM之概述</title>
    <link href="http://yoursite.com/2020/01/25/JVM%E4%B9%8B%E6%A6%82%E8%BF%B0/"/>
    <id>http://yoursite.com/2020/01/25/JVM之概述/</id>
    <published>2020-01-25T08:54:56.000Z</published>
    <updated>2020-01-25T08:49:58.937Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="什么是java虚拟机">什么是java虚拟机？</span></h2><p>虚拟机是一种抽象化的计算机，通过在实际上的计算机上仿真模拟各种计算机功能来实现的。Java虚拟机有自己完善的硬件架构，如处理器、堆栈、寄存器等，还具有相应的指令体系。<strong>JVM屏蔽了与具体操作系统平台相关的信息</strong>，使得Java程序只需要生成在java虚拟机上运行的目标代码，就可以在多种平台上不加修改地运行。做到了一次编译到处运行。<br>在JVM启动之后，它实际上就是一个操作系统中的进程。</p><h2><span id="jvm的体系结构">JVM的体系结构</span></h2><p><img src="https://s2.ax1x.com/2020/01/17/1SuGSU.png" alt="1SuGSU.png"><br><a id="more"></a></p><h3><span id="类装载器">类装载器</span></h3><h4><span id="什么是类加载机制">什么是类加载机制？</span></h4><p>JVM把描述类信息的class文件加载到内存，并对数据进行校验，转换解析和初始化，最终形成可以被虚拟机直接使用的java类型的过程就是JVM的类加载机制。</p><h4><span id="类加载机制的意义是什么">类加载机制的意义是什么？</span></h4><p>在java语言里，类型的加载、连接和初始化都是在运行时通过类加载机制完成的，这种机制虽然会增加性能的开销，但是也成就了java的灵活性。<br>例子：</p><ol><li>用户可以编写一个面向接口的应用程序，可以等到运行时再指定实际的实现类。</li><li>用户可以实现自己的类加载器，让一个本地运行的程序可以通过网络等方式从其它地方加载二进制流作为程序代码的一部分。</li></ol><h4><span id="一个类的生命周期">一个类的生命周期</span></h4><p>一个类从被加载到JVM到卸载出内存需要经历如下过程。</p><ul><li>加载（Loading）<br>通过一个类的全限定名，来获取此类的二进制流。将这个字节流所代表的静态存储结构转化为方法区的运行时数据区。在内存中生成一个代表这个类的java.lang.class对象，作为方法区这个类的各种数据的访问入口。</li><li>验证 (Verification)<br>验证主要确保Class文件二进制流中所包含的信息是否符合虚拟机的要求，是否会危害虚拟机的运行。验证主要包括，文件格式校验，元数据验证，字节码验证等工作。</li><li>准备 (Preparation)<br>准备阶段是正式为类变量（static修饰的变量）分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区进行分配。这里所说的初始值通常来值数据的零值。<br><code>public static int value=123;</code>这还代码在准备阶段后，<code>value</code>的值为0，而不是123.</li><li>解析 (Resolution)<br>解析过程是将虚拟机常量池中的符号引用替换为直接引用的过程。</li></ul><ul><li>符号引用：符号引用以一组符号来描述所引用的符号。</li><li>直接引用：是可以直接指向目标的指针，相对偏移量或者是一个间接定位到目标的句柄。</li></ul><ul><li>初始化 (Initialization)</li><li>使用 (Using)</li><li>卸载 (Unloading)<br>其中验证，准备和解析可以统称为连接（Linking）。</li></ul><p>需要立即对类进行初始化的5种情况：</p><ul><li>遇到new，getstatic,putstatic或invokestatic这四条指令的时候，如果类没有进行初始化，则需要进行初始化。简单来讲就是我们在java代码中，使用new关键字实例化对象的时候，读取或设置一个类的静态字段的时候（被final修饰，已经在编译期把结果放入常量池的静态字段除外），已经调用一个类的静态方法的时候。</li><li>使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有初始化，那么需要先触发其初始化。</li><li>如果初始化一个类的时候，发现它的父类还没有进行过初始化的时候，则需要触发器父类进行初始化。</li><li>当虚拟机启动时，用户需要指定一个执行的主类，虚拟机会先初始化这个主类。</li><li>当使用JDK1.7的动态语言支持时，如果java.lang.invoke.MethodHeanle实例最后的结果为REF_getStatic，REF_putStaic,REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。</li></ul><p>以上五种情况为对类的主动引用。还存在对类的被动引用：</p><ul><li>通过子类去引用父类的静态字段，不会导致子类初始化<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderStudy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//通过子类去引用父类的静态字段</span></span><br><span class="line">        System.out.println(SubClass.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"superClass init"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> val=<span class="number">123</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"subclass init"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">superClass init</span><br><span class="line">123</span><br></pre></td></tr></table></figure></p><ul><li>通过数组定义来引用类，不会触发此类的初始化<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderStudy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//通过数组引用的类不会对类进行初始化。</span></span><br><span class="line">       SuperClass[] arr=<span class="keyword">new</span> SuperClass[<span class="number">10</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"superClass init"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> val=<span class="number">123</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"subclass init"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>没有任何的输出，说明没有对SuperClass类进行初始化。</p><ul><li>常量在编译时会存入调用类的常量池中，因此不会触发定义常量的类的初始化。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderStudy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//通过数组引用的类不会对类进行初始化。</span></span><br><span class="line">        System.out.println(SuperClass.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"superClass init"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> val=<span class="number">123</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"subclass init"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有任何的输出。<br>可见并没有初始化该常量的定义类。</p><h4><span id="类加载器">类加载器</span></h4><p>类加载器的工作就是：“通过一个类的全限定名来获取此类的二进制字节流”<br><strong>比较两个类是否相等，只有在这两个类是由同一个类加载器加载的前提下从才有意义</strong></p><p>一共有四种类加载器：</p><ul><li>启动类加载器（Bootstrap ClassLoader），这个类加载器是使用C++编写的，这个类主要负责将存放在&lt;JAVA_HOME&gt;/lib目录中，或者-Xbootclasspath参数所指定的路径中的。并且是由虚拟机识别的类库加载到虚拟机内存中。</li><li>拓展类加载器（Extension ClassLoader）：这个类加载器负责加载&lt;JAVA_HOME&gt;/lib/ext目录中的，或者被jave.ext.dirs系统变量所指定的路径中的所有类库。开发者可以直接使用类加载器。</li><li>应用类加载器（application Classloader），这个类加载器负责加载用户路径（ClassPath）上所指定的类库。</li><li>自定义类加载器，我们可以继承<code>ClassLoader</code>实现自己的类加载器。</li></ul><h4><span id="双亲委派机制">双亲委派机制</span></h4><p>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此。因此只有当父加载器反馈无法完成这个加载请求时，子加载器才会尝试自己去加载。</p><p>双亲委派机制使得类随着它的加载器具备了一种带有优先级的层次关系。实现了沙箱安全。</p><h3><span id="执行引擎">执行引擎</span></h3><h4><span id="什么是jvm执行引擎">什么是JVM执行引擎</span></h4><p>java编写的代码（.java文件）Java编译器(java compiler)编译为Java字节码(.class)文件。类加载器负责转载编译后的字节码，并加载到运行时数据区中，然后执行引擎执行这些字节码。<br>执行引擎按照字节码指令来执行相应的任务。因为字节码计算机是无法直接运行的，所以需要将其转化为能够被计算机执行的及其语言。这个过程JVM执行引擎有两种方案。一种是解释执行：即一条条读取，解释并执行字节码指令。这种方案加载快，但执行较慢。另一种是即时编译(Just-In-Time):在合适的时候，即时编译器会将整段的字节码编译为本地代码（编译后的本地代码缓存在cache中），然后自己执行本地代码。编译后的代码，比解释执行更加的快。但编译的过程比较耗时。</p><p>因此内置了JIT编译器的JVM都会检查方法的执行频率，如果一个方法的执行频率超过一个特定的值的话，那么这个方法就会被编译成本地代码。</p><p>JVM规范并没有定义执行引擎到底要如何区执行。因此JVM的提供者通过使用不同的技术以及不同的类型的JIT编译器来提高执行引擎的效率，</p><p>大部分的JIT编译器会将字节码转化为一个中间层表达式，然后进行优化，最后再把这种表示转化为本地代码。</p><p>Oracle Hotspot VM使用了一种叫做热点编译器的JIT编译器。它会通过分析代码的调用频数，寻找代码热点，然后会把热点代码编译为本地代码。如果代码不再是热点了，那么就会将本地代码从cache中移除，继续使用解释执行的方案。</p><h3><span id="运行时数据区">运行时数据区</span></h3><p>JVM在执行java程序的时候会它管理的内存分为若干个不同的数据区域，这些区域有着不同的用途。<br>运行时数据区可以分为方法区，堆区，虚拟机栈，本地方法栈，程序计数器。</p><h4><span id="程序计数器">程序计数器</span></h4><p>程序计数器是一块较小的内存空间，可以看作当前线程所执行的字节码的行号指示器。通过修改程序计数器的值，可以实现跳转执行等功能。它是线程私有的。<br>如果线程正在执行一个java方法，这个计数器记录的就是正在执行的虚拟机字节码指令的地址。如果正在执行的是native方法，那么这个计数器则为null。</p><p>此块区域是唯一一个在JVM规范中没有规定的任何OutOfMemoryError情况的区域。</p><h4><span id="java虚拟机栈">Java虚拟机栈</span></h4><p>线程私有的，生命周期和线程相同，虚拟机栈描述的是<strong>Java方法</strong>执行的内存模型。我们知道函数的调用是通过栈来完成的，每个方法在执行的时候都会开辟一个栈帧，方法中的局部变量其实就是存放在栈帧中。<br>在JVM规范中，对此区域规定了两种异常情况：如果线程请求的栈深度超过了虚拟机允许的最大深度，那么就会抛出StackOverflowError异常；如果允许虚拟机栈可以动态拓展时，无法申请到足够的内存，就会抛出OutOfMemoryError异常。</p><h4><span id="本地方法栈">本地方法栈</span></h4><p>本地方法栈所发挥的作用其实和虚拟机栈的作用是非常相似的。只不过本地方法栈描述的是<strong>native方法</strong>执行的内存模型。在虚拟即规范中没有对本地方法栈中方法使用的语言与数据结构做出强制规定，因此具体的虚拟机可以自由的实现本地方法栈。本地方法栈也会抛出StatkcOverflowError和OutOfMemoryError异常。它同样也是线程私有的。</p><h4><span id="方法区">方法区</span></h4><p>方法区是线程共享的，它主要存储已被JVM加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。<br>运行时常量池也是方法区的一部分，它主要存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。</p><h4><span id="堆">堆</span></h4><p>堆是线程共享的。它是JVM中最大的一块内存区域，在虚拟机启动的时候就已经创建了。这块区域的目的就是存放对象实例和数组，几乎所有的对象实例都在这里分配。堆区是垃圾收集管理最主要的区域。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是java虚拟机？&quot;&gt;&lt;a href=&quot;#什么是java虚拟机？&quot; class=&quot;headerlink&quot; title=&quot;什么是java虚拟机？&quot;&gt;&lt;/a&gt;什么是java虚拟机？&lt;/h2&gt;&lt;p&gt;虚拟机是一种抽象化的计算机，通过在实际上的计算机上仿真模拟各种计算机功能来实现的。Java虚拟机有自己完善的硬件架构，如处理器、堆栈、寄存器等，还具有相应的指令体系。&lt;strong&gt;JVM屏蔽了与具体操作系统平台相关的信息&lt;/strong&gt;，使得Java程序只需要生成在java虚拟机上运行的目标代码，就可以在多种平台上不加修改地运行。做到了一次编译到处运行。&lt;br&gt;在JVM启动之后，它实际上就是一个操作系统中的进程。&lt;/p&gt;
&lt;h2 id=&quot;JVM的体系结构&quot;&gt;&lt;a href=&quot;#JVM的体系结构&quot; class=&quot;headerlink&quot; title=&quot;JVM的体系结构&quot;&gt;&lt;/a&gt;JVM的体系结构&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2020/01/17/1SuGSU.png&quot; alt=&quot;1SuGSU.png&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>mybatis源码分析之缓存机制</title>
    <link href="http://yoursite.com/2020/01/23/mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2020/01/23/mybatis源码分析之缓存机制/</id>
    <published>2020-01-23T08:11:56.000Z</published>
    <updated>2020-01-23T08:12:06.444Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="概述">概述</span></h2><p>mybatis提供了缓存机制减轻数据库压力，提高数据库性能。mybatis的缓存分为两级：一级缓存、二级缓存。<br>一级缓存时<code>SqlSession</code>级别的缓存，缓存的数据只在<code>SqlSession</code>内有效。<br>二级缓存时<code>mapper</code>级别的缓存，同一个<code>namespace</code>共用一个缓存，所以对<code>SqlSession</code>是共享的。<br><a id="more"></a><br><img src="https://s2.ax1x.com/2020/01/23/1VSh0s.png" alt="1VSh0s.png"></p><h2><span id="一级缓存">一级缓存</span></h2><p>一级缓存默认是开启状态的。<br><img src="https://s2.ax1x.com/2020/01/23/1VSrkt.png" alt="1VSrkt.png"></p><h3><span id="一级缓存的生命周期">一级缓存的生命周期</span></h3><ul><li>mybatis在开启一个数据库会话的时，会创建一个新的<code>SqlSession</code>对象，<code>SqlSession</code>对象中会持有一个<code>Executor</code>对象，<code>Executor</code>对象中持有一个新的<code>PerpetualCache</code>对象；当会话结束时<code>SqlSession</code>对象及其内部的<code>Executor</code>对象还有<code>perpetualChache</code>对象也会被释放掉。</li><li>在<code>SqlSession</code>调用了<code>close()</code>方法，会释放掉一级缓存<code>PerpetualCache</code>对象，一级缓存将不可使用。</li><li>如果<code>SqlSession</code>调用了<code>clearCache()</code>，会清空<code>PerpetualCache</code>对象中的数据（缓存数据），但是一级缓存仍然是可用的，只是之前的数据被清空了。</li><li><code>SqlSession</code>中执行了任何一个update操作，都会清空<code>perpetualCache</code>对象的数据，但是该对象可以继续使用。</li></ul><h3><span id="如何判断两次查询时完全相同的">如何判断两次查询时完全相同的？</span></h3><p>mybaits认为，对于两次查询，如果以下条件都完全一样，那么就任务它们时完全相同的两次查询。</p><ul><li>传入的statementId</li><li>查询时要求的结果集的结果的范围</li><li>查询传递给JDBC的sql语句字符串</li><li>传递给java.sql.Statement要设置的参数值。<h2><span id="二级缓存">二级缓存</span></h2>mybatis的二级缓存是application级别的缓存，它可以提高数据库查询的效率，以提高应用的性能。<br>二级缓存默认是不开启的。如果需要开启二级缓存，需要进行配置，并且要求返回的pojo必须是可序列化的。<br>如果开启了二级缓存：</li><li>映射语句文件中的所有select语句将会被缓存</li><li>映射语句文件中的所有insert，update和delete语句会刷新缓存。</li><li>缓存会使用默认的LRU算法来回收。</li><li>根据时间表，缓存不会以任何时间顺序来刷新。</li><li>缓存会存储列表集合或对象的1024个引用。</li><li>缓存会被视为可读可写的缓存，意味着对象检索式不共享的，而且可以安全的被调用者修改，不干扰其它调用者或线程所做的潜在修改。</li></ul><h3><span id="如何开启二级缓存">如何开启二级缓存</span></h3><ol><li>首先查询返回的pojo类必须要实现<code>Serializable</code>即可，表示式可序列化的。</li><li>在对应的mapper文件中开启缓存。<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span> <span class="attr">eviction</span>=<span class="string">"LRU"</span> <span class="attr">readOnly</span>=<span class="string">"true"</span> <span class="attr">flushInterval</span>=<span class="string">"6000"</span> <span class="attr">size</span>=<span class="string">"1024"</span>/&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p><code>cache</code>标签有几个属性需要注意：</p><ul><li>eviction:设置缓存的清除策略，默认值为LRU<ul><li><code>LRU</code>:最近最少使用：移除最长时间不被使用的对象。</li><li><code>FIFO</code>：先进先出：按对象进入缓存的顺序来移除 它们</li><li><code>SOFT</code>:软引用：基于垃圾回收器状态和软引用规则移除对象。</li><li><code>WEAK</code>:弱引用：更积极的基于浪迹回收器状态和如弱引用规则移除对象。</li></ul></li><li>flushInterval：刷新间隔，默认清空下为不设置，自会在特定语句时刷新缓存</li><li>size：引用数目，默认是1024</li><li>readOnly：只读属性，设置为只读的比可写的性能更高，避免了对缓存对象的拷贝。</li></ul><ol start="3"><li>在全局配置文件中开启二级缓存<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"cacheEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;mybatis提供了缓存机制减轻数据库压力，提高数据库性能。mybatis的缓存分为两级：一级缓存、二级缓存。&lt;br&gt;一级缓存时&lt;code&gt;SqlSession&lt;/code&gt;级别的缓存，缓存的数据只在&lt;code&gt;SqlSession&lt;/code&gt;内有效。&lt;br&gt;二级缓存时&lt;code&gt;mapper&lt;/code&gt;级别的缓存，同一个&lt;code&gt;namespace&lt;/code&gt;共用一个缓存，所以对&lt;code&gt;SqlSession&lt;/code&gt;是共享的。&lt;br&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="mybatis" scheme="http://yoursite.com/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>mybatis源码分析之插件机制</title>
    <link href="http://yoursite.com/2020/01/22/mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E6%8F%92%E4%BB%B6%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2020/01/22/mybatis源码分析之插件机制/</id>
    <published>2020-01-22T13:24:56.000Z</published>
    <updated>2020-01-22T13:28:42.236Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="概述">概述</span></h2><p>mybatis插件又被称为拦截器，mybaits采用责任链模式，通过动态代理组织多个插件，通过这些插件可以改变mybatis的默认行为。mybatis允许在映射语句执行的某一点进行拦截调用。默认情况下，mybatis使用允许使用插件来拦截方法的调用包括：</p><a id="more"></a><ul><li>Executor是mybatis的内部缓存，它负责调用statementHandler操作数据库，并把结果集通过ResultSetHandler进行自动映射，另外，它还处理了二级缓存的操作。</li><li>StatementHandler是mybatis直接和数据库执行sql脚本的对象，另外它也实现lemybatis的一级缓存。</li><li>ParameterHandler是mybatis实现sql入参设置的对象。</li><li>ResultSetHandler是mybatis把ResultSet结果集映射成POJO的接口对象。</li></ul><h2><span id="拦截器的原理是什么">拦截器的原理是什么</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Executor <span class="title">newExecutor</span><span class="params">(Transaction transaction, ExecutorType executorType)</span> </span>&#123;</span><br><span class="line">   executorType = executorType == <span class="keyword">null</span> ? defaultExecutorType : executorType;</span><br><span class="line">   executorType = executorType == <span class="keyword">null</span> ? ExecutorType.SIMPLE : executorType;</span><br><span class="line">   Executor executor;</span><br><span class="line">   <span class="keyword">if</span> (ExecutorType.BATCH == executorType) &#123;</span><br><span class="line">     executor = <span class="keyword">new</span> BatchExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ExecutorType.REUSE == executorType) &#123;</span><br><span class="line">     executor = <span class="keyword">new</span> ReuseExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     executor = <span class="keyword">new</span> SimpleExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (cacheEnabled) &#123;</span><br><span class="line">     executor = <span class="keyword">new</span> CachingExecutor(executor);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   executor = (Executor) interceptorChain.pluginAll(executor);</span><br><span class="line">   <span class="keyword">return</span> executor;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> ParameterHandler <span class="title">newParameterHandler</span><span class="params">(MappedStatement mappedStatement, Object parameterObject, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">   ParameterHandler parameterHandler = mappedStatement.getLang().createParameterHandler(mappedStatement, parameterObject, boundSql);</span><br><span class="line">   parameterHandler = (ParameterHandler) interceptorChain.pluginAll(parameterHandler);</span><br><span class="line">   <span class="keyword">return</span> parameterHandler;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> StatementHandler <span class="title">newStatementHandler</span><span class="params">(Executor executor, MappedStatement mappedStatement, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">   StatementHandler statementHandler = <span class="keyword">new</span> RoutingStatementHandler(executor, mappedStatement, parameterObject, rowBounds, resultHandler, boundSql);</span><br><span class="line">   statementHandler = (StatementHandler) interceptorChain.pluginAll(statementHandler);</span><br><span class="line">   <span class="keyword">return</span> statementHandler;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> ResultSetHandler <span class="title">newResultSetHandler</span><span class="params">(Executor executor, MappedStatement mappedStatement, RowBounds rowBounds, ParameterHandler parameterHandler,</span></span></span><br><span class="line"><span class="function"><span class="params">     ResultHandler resultHandler, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">   ResultSetHandler resultSetHandler = <span class="keyword">new</span> DefaultResultSetHandler(executor, mappedStatement, parameterHandler, resultHandler, boundSql, rowBounds);</span><br><span class="line">   resultSetHandler = (ResultSetHandler) interceptorChain.pluginAll(resultSetHandler);</span><br><span class="line">   <span class="keyword">return</span> resultSetHandler;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>通过这几段代码我们不难看出，四大接口皆通过调用<code>interceptorChain</code>的<code>pluginAll</code>方法来对对象进行进一步的处理。</p><p>我们查看<code>interceptorChain</code>类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterceptorChain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一个拦截器集合</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">pluginAll</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Interceptor interceptor : interceptors) &#123;</span><br><span class="line">    <span class="comment">//调用所有的插件对target进行进一步的处理</span></span><br><span class="line">      target = interceptor.plugin(target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptor</span><span class="params">(Interceptor interceptor)</span> </span>&#123;</span><br><span class="line">    interceptors.add(interceptor);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;Interceptor&gt; <span class="title">getInterceptors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Collections.unmodifiableList(interceptors);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么对对象进行进一步加工的拦截器的结构又是怎样的呢。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进行拦截是要执行的方法</span></span><br><span class="line">  <span class="function">Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line">    <span class="comment">//用于封装目标对象，可以返回代理对象或者对象本身</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Object <span class="title">plugin</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Plugin.wrap(target, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="comment">//用于获取自定义相关属性</span></span><br><span class="line">  <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// NOP</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2><span id="如何开发一个插件">如何开发一个插件</span></h2><p>一个官方推荐的插件开发方式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Intercepts</span>(&#123;<span class="meta">@Signature</span>(type = Executor.class, method = <span class="string">"query"</span>,</span><br><span class="line">        args = &#123;MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class&#125;)&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Object target = invocation.getTarget(); <span class="comment">//被代理对象</span></span><br><span class="line">        Method method = invocation.getMethod(); <span class="comment">//代理方法</span></span><br><span class="line">        Object[] args = invocation.getArgs(); <span class="comment">//方法参数</span></span><br><span class="line">        <span class="comment">// do something ...... 方法拦截前执行代码块</span></span><br><span class="line">        Object result = invocation.proceed();</span><br><span class="line">        <span class="comment">// do something .......方法拦截后执行代码块</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">plugin</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Plugin.wrap(target, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3><span id="编写一个简单的拦截器">编写一个简单的拦截器</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Intercepts</span>(&#123;<span class="meta">@Signature</span>(type = Executor.class,method = <span class="string">"update"</span>,args = &#123;MappedStatement.class, Object.class&#125;)&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPlugin</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"拦截到了"</span>);</span><br><span class="line">    <span class="keyword">return</span> invocation.proceed();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">plugin</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Plugin.wrap(target,<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时我们在全局配置文件中对我们编写的拦截器进行注册。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugins&gt;</span><br><span class="line">  &lt;plugin interceptor=<span class="string">"example.MyPlugin"</span>/&gt;</span><br><span class="line">&lt;/plugins&gt;</span><br></pre></td></tr></table></figure></p><p>这段代码就会拦截<code>Executor</code>的<code>int update(MappedStatement ms, Object parameter)</code>方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;mybatis插件又被称为拦截器，mybaits采用责任链模式，通过动态代理组织多个插件，通过这些插件可以改变mybatis的默认行为。mybatis允许在映射语句执行的某一点进行拦截调用。默认情况下，mybatis使用允许使用插件来拦截方法的调用包括：&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="mybatis" scheme="http://yoursite.com/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>FutureTask源码分析</title>
    <link href="http://yoursite.com/2020/01/21/FutureTask%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2020/01/21/FutureTask源码分析/</id>
    <published>2020-01-21T08:30:56.000Z</published>
    <updated>2020-01-22T13:25:49.158Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="概述">概述</span></h2><p>Future表示一个任务的生命周期，是一个可取消的异步运算，可以把它看作是一个异步操作的结果的占位符，它将在未来的某个时刻完成，并提供对结果的访问。<br>FutureTask为Future提供了基础实现，如获取任务执行结果何取消任务等。如果尚未完成，获取任务执行结果的线程会被阻塞，一旦执行结束，任务就不能被重启或取消。FutureTask常用来封装Clallable和Runnable，也可以作为一个任务提交到线程池中执行。</p><a id="more"></a><p>FutureTask内部维护了一个由<code>volatule</code>修饰的int型变量-state，待变当前任务的运行状态，state有7种状态。</p><ul><li>NEW:新建</li><li>COMPLETING:完成</li><li>NORMAL:正常运行</li><li>EXCEPTIONAL：异常退出</li><li>CANCELLED：任务取消</li><li>INTERRUPTING：线程中断中。</li><li>INTERRUPTED:线程已中断</li></ul><p><img src="https://s2.ax1x.com/2020/01/20/1iXcB8.png" alt="1iXcB8.png"></p><h2><span id="源码分析">源码分析</span></h2><h3><span id="继承体系">继承体系</span></h3><p><img src="https://s2.ax1x.com/2020/01/20/1iXgHS.png" alt="1iXgHS.png"></p><h3><span id="核心属性">核心属性</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 内部持有的callable任务，运行完毕后置为空*/</span></span><br><span class="line"><span class="keyword">private</span> Callable&lt;V&gt; callable;</span><br><span class="line"><span class="comment">/** 从get()中返回的结果或抛出的异常 */</span></span><br><span class="line"><span class="keyword">private</span> Object outcome; <span class="comment">// non-volatile, protected by state reads/writes</span></span><br><span class="line"><span class="comment">/** 运行callable的线程*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Thread runner;</span><br><span class="line"><span class="comment">/** 使用treiber栈保存等待的线程*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> WaitNode waiters;</span><br></pre></td></tr></table></figure><h3><span id="重要方法分析">重要方法分析</span></h3><h4><span id="fun方法">fun方法</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//新建任务，CAS替换runner（运行Callable的线程）为当前线程</span></span><br><span class="line">       <span class="keyword">if</span> (state != NEW ||</span><br><span class="line">           !UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, runnerOffset,</span><br><span class="line">                                        <span class="keyword">null</span>, Thread.currentThread()))</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           Callable&lt;V&gt; c = callable;</span><br><span class="line">           <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; state == NEW) &#123;</span><br><span class="line">               V result;</span><br><span class="line">               <span class="keyword">boolean</span> ran;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">//调用Callable的call方法，并记录结果</span></span><br><span class="line">                   result = c.call();</span><br><span class="line">                   ran = <span class="keyword">true</span>;</span><br><span class="line">               &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                   result = <span class="keyword">null</span>;</span><br><span class="line">                   ran = <span class="keyword">false</span>;</span><br><span class="line">                   setException(ex);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (ran)<span class="comment">//设置执行结果</span></span><br><span class="line">                   set(result);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="comment">// runner must be non-null until state is settled to</span></span><br><span class="line">           <span class="comment">// prevent concurrent calls to run()</span></span><br><span class="line">           runner = <span class="keyword">null</span>;</span><br><span class="line">           <span class="comment">// state must be re-read after nulling runner to prevent</span></span><br><span class="line">           <span class="comment">// leaked interrupts</span></span><br><span class="line">           <span class="keyword">int</span> s = state;</span><br><span class="line">           <span class="keyword">if</span> (s &gt;= INTERRUPTING)</span><br><span class="line">               handlePossibleCancellationInterrupt(s);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>运行任务，如果任务状态为NEW状态，则利用CAS修改为当前线程，执行完毕后调用<code>set</code>方法设置执行的结果。</p><h4><span id="set方法">set方法</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(V v)</span> </span>&#123;</span><br><span class="line"><span class="comment">//设置为完成态</span></span><br><span class="line">    <span class="keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, NEW, COMPLETING)) &#123;</span><br><span class="line">        <span class="comment">//设置结果</span></span><br><span class="line">        outcome = v;</span><br><span class="line">        <span class="comment">//设置为最终状态</span></span><br><span class="line">        UNSAFE.putOrderedInt(<span class="keyword">this</span>, stateOffset, NORMAL); <span class="comment">// final state</span></span><br><span class="line">        finishCompletion();<span class="comment">//执行结束，唤醒等待结果的线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>set方法主要是修改状态为完成态，获得结果，设置为结束状态。然后调用<code>finishCompletion</code>方法唤醒等待结果的线程。</p><h4><span id="finishcompletion">finishCompletion</span></h4><p>该方法的主要作用就是唤醒所有等待结果的线程来取结果了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finishCompletion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// assert state &gt; COMPLETING;</span></span><br><span class="line">       <span class="keyword">for</span> (WaitNode q; (q = waiters) != <span class="keyword">null</span>;) &#123;</span><br><span class="line">       <span class="comment">//移除等待的线程</span></span><br><span class="line">           <span class="keyword">if</span> (UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, waitersOffset, q, <span class="keyword">null</span>)) &#123;              </span><br><span class="line">               <span class="keyword">for</span> (;;) &#123;<span class="comment">//自旋遍历等待队列</span></span><br><span class="line">                   Thread t = q.thread;</span><br><span class="line">                   <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                       q.thread = <span class="keyword">null</span>;</span><br><span class="line">                       <span class="comment">//唤醒park阻塞的线程</span></span><br><span class="line">                       LockSupport.unpark(t);</span><br><span class="line">                   &#125;</span><br><span class="line">                   WaitNode next = q.next;</span><br><span class="line">                   <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   q.next = <span class="keyword">null</span>; <span class="comment">// unlink to help gc</span></span><br><span class="line">                   q = next;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   <span class="comment">//调用任务完成的回调函数，可拓展</span></span><br><span class="line">       done();</span><br><span class="line">       <span class="comment">//任务执行完毕后将callable设置为null</span></span><br><span class="line">       callable = <span class="keyword">null</span>;        <span class="comment">// to reduce footprint</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><h4><span id="get方法">get方法</span></h4><p>get方法是去获取结果，如果运行还没有结果，那么就会阻塞。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = state;</span><br><span class="line">    <span class="keyword">if</span> (s &lt;= COMPLETING)</span><br><span class="line">    <span class="comment">//任务还未完成，到阻塞队列中去等待</span></span><br><span class="line">        s = awaitDone(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">    <span class="keyword">return</span> report(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个地方调用<code>awaitDone</code>方法</p><h4><span id="report方法"><code>report</code>方法</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">report</span><span class="params">(<span class="keyword">int</span> s)</span> <span class="keyword">throws</span> ExecutionException </span>&#123;</span><br><span class="line">       Object x = outcome;</span><br><span class="line">       <span class="keyword">if</span> (s == NORMAL)</span><br><span class="line">       <span class="comment">//如果是正常结束的，就返回结果</span></span><br><span class="line">           <span class="keyword">return</span> (V)x;</span><br><span class="line">       <span class="keyword">if</span> (s &gt;= CANCELLED)</span><br><span class="line">       <span class="comment">//如果是被取消的，那返回异常</span></span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> CancellationException();</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> ExecutionException((Throwable)x);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4><span id="awaitdone方法">awaitDone方法</span></h4><p><code>awaitDone</code>方法用于等待任务完成，或者因为任务中断或超时而终止。返回任务的完成状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">awaitDone</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//获取任务返回的结果的最后期限</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> deadline = timed ? System.nanoTime() + nanos : <span class="number">0L</span>;</span><br><span class="line">        WaitNode q = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> queued = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            <span class="comment">//如果线程中断，移除等待</span></span><br><span class="line">                removeWaiter(q);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> s = state;</span><br><span class="line">            <span class="keyword">if</span> (s &gt; COMPLETING) &#123;<span class="comment">//如果任务已经完成</span></span><br><span class="line">                <span class="keyword">if</span> (q != <span class="keyword">null</span>)</span><br><span class="line">                <span class="comment">//置空等待节点线程</span></span><br><span class="line">                    q.thread = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">return</span> s;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s == COMPLETING) <span class="comment">// cannot time out yet</span></span><br><span class="line">                Thread.yield();<span class="comment">//线程让出CPU时间</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (q == <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">//将q设置为等待节点</span></span><br><span class="line">                q = <span class="keyword">new</span> WaitNode();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!queued)</span><br><span class="line">            <span class="comment">//cas修改awit</span></span><br><span class="line">                queued = UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, waitersOffset,</span><br><span class="line">                                                     q.next = waiters, q);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (timed) &#123;</span><br><span class="line">                nanos = deadline - System.nanoTime();</span><br><span class="line">                <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                <span class="comment">//如果已经超时，则移除等待节点</span></span><br><span class="line">                    removeWaiter(q);</span><br><span class="line">                    <span class="keyword">return</span> state;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//阻塞当前线程</span></span><br><span class="line">                LockSupport.parkNanos(<span class="keyword">this</span>, nanos);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;Future表示一个任务的生命周期，是一个可取消的异步运算，可以把它看作是一个异步操作的结果的占位符，它将在未来的某个时刻完成，并提供对结果的访问。&lt;br&gt;FutureTask为Future提供了基础实现，如获取任务执行结果何取消任务等。如果尚未完成，获取任务执行结果的线程会被阻塞，一旦执行结束，任务就不能被重启或取消。FutureTask常用来封装Clallable和Runnable，也可以作为一个任务提交到线程池中执行。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="源码" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis源码分析之执行器</title>
    <link href="http://yoursite.com/2020/01/19/MyBatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E6%89%A7%E8%A1%8C%E5%99%A8/"/>
    <id>http://yoursite.com/2020/01/19/MyBatis源码分析之执行器/</id>
    <published>2020-01-19T03:13:56.000Z</published>
    <updated>2020-01-19T03:14:59.109Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="概述">概述</span></h2><p>执行器是Mybatis的核心接口之一，接口层提供的相关数据库操作都是基于<code>Executor</code>的子类实现的。<br><img src="https://s2.ax1x.com/2020/01/18/19CPiQ.png" alt="19CPiQ.png"></p><a id="more"></a><h2><span id="执行器是如何创建的">执行器是如何创建的</span></h2><p>首先祭出Mybatis的基本使用的代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String resource = <span class="string">"example/mybatis-config.xml"</span>;</span><br><span class="line">    <span class="comment">// 加载配置文件 并构建SqlSessionFactory对象</span></span><br><span class="line">    InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">    SqlSessionFactory factory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">    <span class="comment">// 从SqlSessionFactory对象中获取 SqlSession对象</span></span><br><span class="line">    SqlSession sqlSession = factory.openSession();</span><br><span class="line">    <span class="comment">// 执行操作</span></span><br><span class="line">    User user=<span class="keyword">new</span> User();</span><br><span class="line">    user.setId(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    User u= (User)sqlSession.selectOne(<span class="string">"getUser"</span>, user);</span><br></pre></td></tr></table></figure></p><p>在mybatis启动的时候，我们需要通过<code>SqlSessionFactoryBuilder</code>对象，调用其<code>build</code>方法来获取<code>SqlSessionFactory</code>对象。通过<code>SqlSessionFactory</code>对象的<code>openSession</code>方法来获取<code>SqlSession</code>对象。实际上执行器的创建就是在调用<code>openSession</code>方法的时候创建的。</p><p>通过源代码可以发现<code>openSession</code>方法背后实际调用的是<code>openSessionFromDataSource</code>这个方法。其具体实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> SqlSession <span class="title">openSessionFromDataSource</span><span class="params">(ExecutorType execType, TransactionIsolationLevel level, <span class="keyword">boolean</span> autoCommit)</span> </span>&#123;</span><br><span class="line">    Transaction tx = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">/*从包含所有配置信息的configuration中获取Environment对象</span></span><br><span class="line"><span class="comment">    Environment中包含了连接数据库的所有信息，包括driver，url，username，passowrd，TransactionFactory等众多的与数据库连接相关的信息</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">      <span class="keyword">final</span> Environment environment = configuration.getEnvironment();</span><br><span class="line">      </span><br><span class="line">      <span class="comment">/**这段代码的作用就是简单的从Environment中取出TransactionFactory对象*/</span></span><br><span class="line">      <span class="keyword">final</span> TransactionFactory transactionFactory = getTransactionFactoryFromEnvironment(environment);</span><br><span class="line">      <span class="comment">/*调用TransactionFactory的newTransaction获取Transaction对象，Transaction对象其实也非常的简单，它是对数据库连接Connection，DataSource，TransactionIsolationLevel（事务隔离级别），autoCommit（是否自动提交）的封装，内部还有利用connection提交事务，回滚事务等一系列方法。拿到了Transaction对象，就拥有了最基础的数据库操作途径*/</span></span><br><span class="line">      tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);</span><br><span class="line">      <span class="comment">/*newExecutor方法会根据执行器的类型（execType）选择创建不同的执行器，</span></span><br><span class="line"><span class="comment">      newExecutor内部就是简单的判断</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="keyword">final</span> Executor executor = configuration.newExecutor(tx, execType);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">/*拿到用于操作数据库的执行器，包含所有配置信息的Configuration对象等信息后，就可以将这些信息封装成为SqlSession</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> DefaultSqlSession(configuration, executor, autoCommit);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      closeTransaction(tx); <span class="comment">// may have fetched a connection so lets call close()</span></span><br><span class="line">      <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">"Error opening session.  Cause: "</span> + e, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      ErrorContext.instance().reset();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>总结一下整个获取Executor的流程：</p><ol><li>从封装了所有的配置信息中<code>Configuration</code>获取包含连接数据库等信息的<code>Environment</code>对象。将<code>Environment</code>封装得到<code>TransactionFactory</code>。然后将<code>Environment</code>中的与连接数据库之间相关的<code>dataSource</code>(即我们在配置文件中dataSource节点下配置的那些信息)和事务隔离级别，是否自动提交三个信息封装，就得到了<code>Transaction</code>对象，<code>Transaction</code>对象中除了这些信息之外，还包含操作数据库的一些最最基本的操作。</li><li>有了<code>Transaction</code>和执行器类型，就可以通过<code>newExecutor</code>方法创建<code>Executor</code>.<code>newExecutor</code>方法内部就会根据执行器类别的不同，创建不同的执行器。</li></ol><h2><span id="三大执行器在实现上有什么不同">三大执行器在实现上有什么不同</span></h2><h3><span id="简单执行器simpleexecutor">简单执行器SimpleExecutor</span></h3><p>Mybatis默认情况下是使用<code>SimpleExecutor</code>的。</p><p>查询方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">doQuery</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    Configuration configuration = ms.getConfiguration();</span><br><span class="line">    StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//每次执行都会调用prepareStatement创建新的Statement对象</span></span><br><span class="line">    stmt = prepareStatement(handler, ms.getStatementLog());</span><br><span class="line">    <span class="keyword">return</span> handler.query(stmt, resultHandler);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    closeStatement(stmt);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们可以发现<code>SimpleExecutor</code>的一大特点在于其每次执行查询的时候，都会创建一个新的<code>Statement</code>对象。</p><h4><span id="复用执行器reuseexecutor">复用执行器ReuseExecutor</span></h4><p>在<code>ReuseExecutor</code>之中有且仅有一个属性:<br><code>private final Map&lt;String, Statement&gt; statementMap = new HashMap&lt;&gt;();</code><br>它的作用，就是缓存<code>Statement</code>，以便复用<code>Statement</code>.<br>我们通过其<code>doQuery</code>方法来查看其到底是如何进行<code>Statement</code>复用的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">doQuery</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  Configuration configuration = ms.getConfiguration();</span><br><span class="line">  StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">  Statement stmt = prepareStatement(handler, ms.getStatementLog());</span><br><span class="line">  <span class="keyword">return</span> handler.query(stmt, resultHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个方法的实现看似和<code>SimpleExecutor</code>类似，其实玄机在于<code>prepareStatement</code>的实现。具体实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Statement <span class="title">prepareStatement</span><span class="params">(StatementHandler handler, Log statementLog)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  Statement stmt;</span><br><span class="line">  BoundSql boundSql = handler.getBoundSql();</span><br><span class="line">  <span class="comment">//这个地方得到的sql已经是可以直接到数据库中查询的sql了</span></span><br><span class="line">  String sql = boundSql.getSql();</span><br><span class="line">  <span class="keyword">if</span> (hasStatementFor(sql)) &#123; <span class="comment">//从缓存statement的map中查找是否有缓存</span></span><br><span class="line">    stmt = getStatement(sql);<span class="comment">//直接从缓存中获取statement</span></span><br><span class="line">    <span class="comment">//为Transaction设置一个过期时间</span></span><br><span class="line">    applyTransactionTimeout(stmt);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">//没有缓存则获取连接，创建Statement</span></span><br><span class="line">    Connection connection = getConnection(statementLog);</span><br><span class="line">    stmt = handler.prepare(connection, transaction.getTimeout());</span><br><span class="line">    putStatement(sql, stmt);</span><br><span class="line">  &#125;</span><br><span class="line">  handler.parameterize(stmt);</span><br><span class="line">  <span class="keyword">return</span> stmt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从源码中我们可以看出<code>ReuseStatement</code>之所以称为Reuse是因为，其内部拥有一个缓存<code>Statement</code>的map，其中缓存键为待执行的sql。</p><h3><span id="批量执行器batchexecutor">批量执行器BatchExecutor</span></h3><p><code>BatchExecutor</code>内部的属性稍微的多一些；<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//存储匹配的Statement</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Statement&gt; statementList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"> <span class="comment">//存储执行的结果</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> List&lt;BatchResult&gt; batchResultList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"> <span class="comment">//当前正在执行的sql</span></span><br><span class="line"> <span class="keyword">private</span> String currentSql;</span><br><span class="line"> <span class="comment">//当前正在使用的Statement</span></span><br><span class="line"> <span class="keyword">private</span> MappedStatement currentStatement;</span><br></pre></td></tr></table></figure></p><p>我们通过<code>doUpdate</code>方法，来分析其特点。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doUpdate</span><span class="params">(MappedStatement ms, Object parameterObject)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">   <span class="keyword">final</span> Configuration configuration = ms.getConfiguration();</span><br><span class="line">   <span class="keyword">final</span> StatementHandler handler = configuration.newStatementHandler(<span class="keyword">this</span>, ms, parameterObject, RowBounds.DEFAULT, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">   <span class="keyword">final</span> BoundSql boundSql = handler.getBoundSql();</span><br><span class="line">   <span class="keyword">final</span> String sql = boundSql.getSql();</span><br><span class="line">   <span class="keyword">final</span> Statement stmt;</span><br><span class="line">   <span class="keyword">if</span> (sql.equals(currentSql) &amp;&amp; ms.equals(currentStatement)) &#123;</span><br><span class="line">     <span class="comment">//如果当前要执行的sql与之前执行的sql相同，则复用statement</span></span><br><span class="line">     <span class="comment">//注意此时currentSql还未更新，所以currentSql实际是上次执行的sql</span></span><br><span class="line">     <span class="keyword">int</span> last = statementList.size() - <span class="number">1</span>;</span><br><span class="line">     <span class="comment">//获取最后一个statement，复用statement</span></span><br><span class="line">     stmt = statementList.get(last);</span><br><span class="line">     <span class="comment">//设置超时时间</span></span><br><span class="line">     applyTransactionTimeout(stmt);</span><br><span class="line">     <span class="comment">//设置参数</span></span><br><span class="line">     handler.parameterize(stmt);<span class="comment">//fix Issues 322</span></span><br><span class="line">     <span class="comment">//获取批量执行结果对象</span></span><br><span class="line">     BatchResult batchResult = batchResultList.get(last);</span><br><span class="line">     batchResult.addParameterObject(parameterObject);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="comment">//创建新的statement对象</span></span><br><span class="line">     Connection connection = getConnection(ms.getStatementLog());</span><br><span class="line">     stmt = handler.prepare(connection, transaction.getTimeout());</span><br><span class="line">     handler.parameterize(stmt);    <span class="comment">//fix Issues 322</span></span><br><span class="line">     currentSql = sql;</span><br><span class="line">     currentStatement = ms;</span><br><span class="line">     statementList.add(stmt);</span><br><span class="line">     batchResultList.add(<span class="keyword">new</span> BatchResult(ms, sql, parameterObject));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//执行jdbc批量添加sql，并执行</span></span><br><span class="line">   handler.batch(stmt);</span><br><span class="line">   <span class="keyword">return</span> BATCH_UPDATE_RETURN_VALUE;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>通过源代码我们也可以发现，其实BatchExecute内部也可以“复用”statement，前提是当前执行的sql和之前的一致。最后将sql交由jdbc去批量执行。</p><h2><span id="mybatis是如何利用执行器取操作数据的">mybatis是如何利用执行器取操作数据的</span></h2><p>我们以默认的<code>SimpleExecutor</code>执行器为例，来观察mybatis到底是如何执行sql的。</p><p>我们从这行代码出发，观察背后的执行逻辑：<br><code>User u= (User)sqlSession.selectOne(&quot;getUser&quot;, user);</code></p><p><code>selectOne</code>方法其实可以理解为特殊的<code>selectList</code>。<code>selectOne</code>方法实际上也是调用的<code>selectList</code>方法，然后从返回的list中取第一条数据即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">selectList</span><span class="params">(String statement, Object parameter, RowBounds rowBounds)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">/*这里的statement参数的值就是getUser,getMappedStatement方法就是简单的从configuration对象中的一个存储Statement的map中取出对应的MappedStatement。这个MappedStatement对象中，存储了Mapeper.xml中的信息，和对应接口的全路径*/</span></span><br><span class="line">      MappedStatement ms = configuration.getMappedStatement(statement);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">/*调用executor的query方法之前，还需要对参数进行简单的包装，如果参数是list或array或collection就会放到map中，进行说明（标识参数的类型），简单类型就不做任何的处理。然后调用query方法。query方法到底做了什么处理，可以看query的具体实现：</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      </span><br><span class="line">      <span class="keyword">return</span> executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">"Error querying database.  Cause: "</span> + e, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      ErrorContext.instance().reset();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>query方法的具体实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line"><span class="comment">/*这里的BoundSql包括sql（参数替换为？，还不能直接执行），parameterMappings，parameterObject，additionalParameters，metaParameters等数据*/</span></span><br><span class="line">  BoundSql boundSql = ms.getBoundSql(parameterObject);</span><br><span class="line">  <span class="comment">/*计算缓存键*/</span></span><br><span class="line">  CacheKey key = createCacheKey(ms, parameterObject, rowBounds, boundSql);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/*调用了另一个重载方法*/</span></span><br><span class="line">  <span class="keyword">return</span> query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>query的重载方法如下；<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">      <span class="comment">//尝试从MappedStatement中获取缓存Cache</span></span><br><span class="line">    Cache cache = ms.getCache();</span><br><span class="line">    <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;<span class="comment">//缓存不为为空</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*这个方法起清除了CachingExecutor中的TransactionalCacheManager中的Cache*/</span></span><br><span class="line">      flushCacheIfRequired(ms);</span><br><span class="line">      <span class="comment">//如果MappedStatement开启缓存的，且结果处理器为空</span></span><br><span class="line">      <span class="keyword">if</span> (ms.isUseCache() &amp;&amp; resultHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        ensureNoOutParams(ms, boundSql);</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        <span class="comment">//从缓存中获取结果</span></span><br><span class="line">        List&lt;E&gt; list = (List&lt;E&gt;) tcm.getObject(cache, key);</span><br><span class="line">        <span class="keyword">if</span> (list == <span class="keyword">null</span>) &#123;<span class="comment">//结果为空，就会重新去数据库中查询</span></span><br><span class="line">          list = delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">          tcm.putObject(cache, key, list); <span class="comment">// issue #578 and #116</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*去数据库中查询数据的重担就落到delegate.query*/</span></span><br><span class="line">    <span class="keyword">return</span> delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>最终来到了<code>BaseExecutor</code>类中的<code>query</code>方法了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line"><span class="comment">//获取boundSql</span></span><br><span class="line">  BoundSql boundSql = ms.getBoundSql(parameter);</span><br><span class="line">  <span class="comment">//计算缓存键</span></span><br><span class="line">  CacheKey key = createCacheKey(ms, parameter, rowBounds, boundSql);</span><br><span class="line">  <span class="keyword">return</span> query(ms, parameter, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>还是调用了另一个重载的<code>query</code>方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">   ErrorContext.instance().resource(ms.getResource()).activity(<span class="string">"executing a query"</span>).object(ms.getId());</span><br><span class="line">   <span class="keyword">if</span> (closed) &#123;<span class="comment">//确保执行器此时是开启状态</span></span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">"Executor was closed."</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (queryStack == <span class="number">0</span> &amp;&amp; ms.isFlushCacheRequired()) &#123;</span><br><span class="line">   <span class="comment">//如果queryStatck==0且需要清理cache就刷新Cache</span></span><br><span class="line">     clearLocalCache();</span><br><span class="line">   &#125;</span><br><span class="line">   List&lt;E&gt; list;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     queryStack++;</span><br><span class="line">     <span class="comment">//如果结果处理器为null，那么还是尝试去缓存中取一取</span></span><br><span class="line">     list = resultHandler == <span class="keyword">null</span> ? (List&lt;E&gt;) localCache.getObject(key) : <span class="keyword">null</span>;</span><br><span class="line">     <span class="keyword">if</span> (list != <span class="keyword">null</span>) &#123;</span><br><span class="line">       handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;<span class="comment">//没有从缓存中拿到数据，就从数据库中查询</span></span><br><span class="line">       list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">     queryStack--;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (queryStack == <span class="number">0</span>) &#123;</span><br><span class="line">     <span class="keyword">for</span> (DeferredLoad deferredLoad : deferredLoads) &#123;</span><br><span class="line">       deferredLoad.load();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// issue #601</span></span><br><span class="line">     deferredLoads.clear();</span><br><span class="line">     <span class="keyword">if</span> (configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) &#123;</span><br><span class="line">       <span class="comment">// issue #482</span></span><br><span class="line">       clearLocalCache();</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> list;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>我们次这个方法中可以发现，开始还是会尝试取缓存中直接取缓存的数据，如果缓存中没有取到数据，那么就会调用<code>queryFromDatabase</code>方法去数据库中查询。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">queryFromDatabase</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">   List&lt;E&gt; list;</span><br><span class="line">   <span class="comment">//标记当前查询正在进行，对缓存进行占位</span></span><br><span class="line">   localCache.putObject(key, EXECUTION_PLACEHOLDER);</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//最终到数据库中查询是交给这个方法的</span></span><br><span class="line">     list = doQuery(ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">   <span class="comment">//出现异常，清除查询正在进行的标记（取消占位）</span></span><br><span class="line">     localCache.removeObject(key);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//将结果缓存到缓存中去</span></span><br><span class="line">   localCache.putObject(key, list);</span><br><span class="line">   <span class="keyword">if</span> (ms.getStatementType() == StatementType.CALLABLE) &#123;</span><br><span class="line">   <span class="comment">//如果是存储过程，那么就单独在缓存一份参数数据</span></span><br><span class="line">     localOutputParameterCache.putObject(key, parameter);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> list;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>这个方法又将查询的任务委派给了<code>SimpleExecutor</code>类下的<code>doQuery</code>方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">doQuery</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    Configuration configuration = ms.getConfiguration();</span><br><span class="line">    StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">    stmt = prepareStatement(handler, ms.getStatementLog());</span><br><span class="line">    <span class="comment">//查询最终又落到了heanler的query方法上</span></span><br><span class="line">    <span class="keyword">return</span> handler.query(stmt, resultHandler);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    closeStatement(stmt);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(Statement statement, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> delegate.query(statement, resultHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法最后来到了<code>PreparedStatementHandler</code>类下的<code>query</code>方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(Statement statement, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line"><span class="comment">//获取PreparedStatement方法，jdbc的预编译执行就是使用的PareparedStatement</span></span><br><span class="line">  PreparedStatement ps = (PreparedStatement) statement;</span><br><span class="line">  <span class="comment">//这里其实就是jdbc方法了，从数据库中查询了</span></span><br><span class="line">  ps.execute();</span><br><span class="line">  <span class="keyword">return</span> resultSetHandler.handleResultSets(ps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;执行器是Mybatis的核心接口之一，接口层提供的相关数据库操作都是基于&lt;code&gt;Executor&lt;/code&gt;的子类实现的。&lt;br&gt;&lt;img src=&quot;https://s2.ax1x.com/2020/01/18/19CPiQ.png&quot; alt=&quot;19CPiQ.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="mybatis" scheme="http://yoursite.com/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>LinkedTransferQueue源码分析</title>
    <link href="http://yoursite.com/2020/01/18/LinkedTransferQueue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2020/01/18/LinkedTransferQueue源码分析/</id>
    <published>2020-01-18T13:03:56.000Z</published>
    <updated>2020-01-18T13:04:53.289Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="概述">概述</span></h2><p><code>LinkedTransferQueue</code>是单向链表结构的无界阻塞队列。它通过CAS和<code>LockSupport</code>来实现线程安全的。<br>它采用一种预占模式，意思是当消费者线程取元素时，如果队列为空，那就生成一个节点（节点元素为null）入队，然后消费者线程被等待在这个节点上，后面生产者线程入队时发现一个元素为null的节点，就会直接将元素填充到该节点，并唤醒该节点等待的线程，被唤醒的消费者线程取走元素并返回。</p><a id="more"></a><p><code>LinkedTransferQueue</code>在实现上有几个特点：</p><ul><li>双重队列：<code>LinkedTransferQueue</code>的<code>Node</code>存储了一个<code>isData</code>的字段，用来区分该节点代表的是数据还是请求，称为双重队列机制。</li><li>松弛度：为了节省CAS操作的开销，<code>LinkedTransferQueue</code>为了节省CAS的开销，<code>LinkedTransferQueue</code>不会立即取更新head/tail,而是需要等到ehad/tail与最近一个未匹配节点之间的距离超过一个松弛度阈值的时候，才会更新。</li><li>节点自链接：已匹配的节点的next引用会指向自身。如果在遍历时遇到一个自链节点，那就表明当前线程已经滞后于另外一个更新head的兴奋啊从，此时就需要重新获取head来遍历。</li></ul><p><img src="https://s2.ax1x.com/2020/01/18/1pyD7d.png" alt="1pyD7d.png"></p><h2><span id="源码分析">源码分析</span></h2><h3><span id="继承体系">继承体系</span></h3><p><img src="https://s2.ax1x.com/2020/01/18/1pyRc8.png" alt="1pyRc8.png"></p><h3><span id="重要属性">重要属性</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/** 队列头，第一次入列之前为空*/</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 队列尾节点，第一次添加节点之前为空 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 累计到一定的次数再清除无效的node */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> sweepVotes;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** sweepVote的阈值 */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SWEEP_THRESHOLD = <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**当前驱节点正在处理，当前节点再阻塞之前的自旋次数*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FRONT_SPINS   = <span class="number">1</span> &lt;&lt; <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**当前驱节点正在处理，当前节点再阻塞之前的自旋次数*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CHAINED_SPINS = FRONT_SPINS &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NOW   = <span class="number">0</span>; <span class="comment">// for untimed poll, tryTransfer</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ASYNC = <span class="number">1</span>; <span class="comment">// for offer, put, add</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SYNC  = <span class="number">2</span>; <span class="comment">// for transfer, take</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIMED = <span class="number">3</span>; <span class="comment">// for timed poll, tryTransfer</span></span><br></pre></td></tr></table></figure><h3><span id="重要方法解析">重要方法解析</span></h3><h4><span id="xfer方法">xfer方法</span></h4><p>入队/出队方法都是由<code>xfer</code>来实现，所以我们这里只对<code>xfer</code>进行解析<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">xfer</span><span class="params">(E e, <span class="keyword">boolean</span> haveData, <span class="keyword">int</span> how, <span class="keyword">long</span> nanos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (haveData &amp;&amp; (e == <span class="keyword">null</span>))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        Node s = <span class="keyword">null</span>;                        <span class="comment">// the node to append, if needed</span></span><br><span class="line"></span><br><span class="line">        retry:</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;                            <span class="comment">// restart on append race</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (Node h = head, p = h; p != <span class="keyword">null</span>;) &#123; <span class="comment">// find &amp; match first node</span></span><br><span class="line">            <span class="comment">//从head开始一直向后匹配</span></span><br><span class="line">                <span class="keyword">boolean</span> isData = p.isData;</span><br><span class="line">                Object item = p.item;</span><br><span class="line">                <span class="keyword">if</span> (item != p &amp;&amp; (item != <span class="keyword">null</span>) == isData) &#123;<span class="comment">//有效节点</span></span><br><span class="line">                    <span class="keyword">if</span> (isData == haveData)  </span><br><span class="line">                    <span class="comment">//节点与此次操作模式一致，无法匹配</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">if</span> (p.casItem(item, e)) &#123; <span class="comment">//匹配成功，cas修改为指定元素</span></span><br><span class="line">                        <span class="keyword">for</span> (Node q = p; q != h;) &#123;</span><br><span class="line">                            Node n = q.next;  <span class="comment">// update by 2 unless singleton</span></span><br><span class="line">                            <span class="keyword">if</span> (head == h &amp;&amp; casHead(h, n == <span class="keyword">null</span> ? q : n)) &#123;                   <span class="comment">//更新head为匹配节点的next节点</span></span><br><span class="line">                            </span><br><span class="line">                            <span class="comment">//旧head节点指向自身等待回收</span></span><br><span class="line">                                h.forgetNext(); </span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;                 <span class="comment">// advance and retry</span></span><br><span class="line">                            <span class="comment">//cas失败，重新获取head</span></span><br><span class="line">                            <span class="keyword">if</span> ((h = head)   == <span class="keyword">null</span> ||</span><br><span class="line">                                (q = h.next) == <span class="keyword">null</span> || !q.isMatched())</span><br><span class="line"><span class="comment">//如果head的next节点未被匹配，跳出循环，不更新head，即松弛度小于2</span></span><br><span class="line">                                <span class="keyword">break</span>;        <span class="comment">// unless slack &lt; 2</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//唤醒节点上等待的线程</span></span><br><span class="line">                        LockSupport.unpark(p.waiter);</span><br><span class="line">                        <span class="keyword">return</span> LinkedTransferQueue.&lt;E&gt;cast(item);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//匹配失败，继续向后查找节点</span></span><br><span class="line">                Node n = p.next;</span><br><span class="line">                p = (p != n) ? n : (h = head); <span class="comment">// Use head if p offlist</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//未找到匹配节点，吧当前节点假如到队列尾</span></span><br><span class="line">            <span class="keyword">if</span> (how != NOW) &#123;                 <span class="comment">// No matches available</span></span><br><span class="line">                <span class="keyword">if</span> (s == <span class="keyword">null</span>)</span><br><span class="line">                    s = <span class="keyword">new</span> Node(e, haveData);</span><br><span class="line">                <span class="comment">//将新节点s添加到队列尾并返回s的前驱节点</span></span><br><span class="line">                Node pred = tryAppend(s, haveData);</span><br><span class="line">                <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">                <span class="comment">//与其它不同模式线程竞争是失败重新循环</span></span><br><span class="line">                    <span class="keyword">continue</span> retry;           <span class="comment">// lost race vs opposite mode</span></span><br><span class="line">                <span class="keyword">if</span> (how != ASYNC)<span class="comment">//同步操作，等待匹配</span></span><br><span class="line">                    <span class="keyword">return</span> awaitMatch(s, pred, e, (how == TIMED), nanos);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> e; <span class="comment">// not waiting</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p><code>xfer</code>方法的基本执行流程：</p><ol><li>从head开始往后遍历匹配，找到一个节点模式和本次操作不同的未匹配的节点进行匹配。</li><li>匹配成功的节点CAS修改匹配节点的item未给定的元素e</li><li>如果此时所匹配节点向后移动，则cas更新head节点为匹配节点的next节点，旧head节点连接指向自身等待被回收。如果cas失败，并且松弛度大于等于2，旧需要重新获取head。</li><li>匹配成功，唤醒匹配节点p的灯箱线程waiter，返回匹配的item。</li><li>如果在上述操作中没有找到匹配节点，则根据参数<code>how</code>的不同做不同的处理</li></ol><ul><li>NOW:立即返回</li><li>SYNC：通过<code>tryAppend</code>方法插入一个新的节点s到队列尾，然后自旋或阻塞当前线程知道节点被匹配或取消返回。</li><li>ASYNC：通过<code>tryAppend</code>方法插入一个新的节点s到队列尾，异步直接返回</li><li>TIMED：通过<code>tryAppend</code>反复插入一个新系欸但到队列尾，然后通过自旋或阻塞当前线程直到节点被匹配或取消或等待超时时返回。</li></ul><h4><span id="tryappend方法">tryAppend方法</span></h4><p>尝试添加节点s作为尾节点<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">tryAppend</span><span class="params">(Node s, <span class="keyword">boolean</span> haveData)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Node t = tail, p = t;;) &#123;        <span class="comment">// move p to last node and append</span></span><br><span class="line">            Node n, u;                        <span class="comment">// temps for reads of next &amp; tail</span></span><br><span class="line">            <span class="keyword">if</span> (p == <span class="keyword">null</span> &amp;&amp; (p = head) == <span class="keyword">null</span>) &#123; <span class="comment">//链表未初始化</span></span><br><span class="line">                <span class="keyword">if</span> (casHead(<span class="keyword">null</span>, s)) <span class="comment">//将s作为head节点</span></span><br><span class="line">                    <span class="keyword">return</span> s;                 <span class="comment">// initialize</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p.cannotPrecede(haveData))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;                  <span class="comment">// lost race vs opposite mode</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((n = p.next) != <span class="keyword">null</span>)    <span class="comment">// not last; keep traversing</span></span><br><span class="line">                p = p != t &amp;&amp; t != (u = tail) ? (t = u) : <span class="comment">// stale tail</span></span><br><span class="line">                    (p != n) ? n : <span class="keyword">null</span>;      <span class="comment">// restart if off list</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!p.casNext(<span class="keyword">null</span>, s))</span><br><span class="line">                p = p.next;                   <span class="comment">// re-read on CAS failure</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (p != t) &#123;                 <span class="comment">// update if slack now &gt;= 2</span></span><br><span class="line">                    <span class="keyword">while</span> ((tail != t || !casTail(t, s)) &amp;&amp;</span><br><span class="line">                           (t = tail)   != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                           (s = t.next) != <span class="keyword">null</span> &amp;&amp; <span class="comment">// advance and retry</span></span><br><span class="line">                           (s = s.next) != <span class="keyword">null</span> &amp;&amp; s != t);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>该方法添加给定节点s到队列尾并返回s的前继节点，失败时（与其它不同模式线程竞争失败）返回null，没有前继节点返回自身。</p><h4><span id="awaitmatch方法">awaitMatch方法</span></h4><p>自旋/让步/阻塞，直到给定节点s匹配到或a放弃匹配。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">awaitMatch</span><span class="params">(Node s, Node pred, E e, <span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> deadline = timed ? System.nanoTime() + nanos : <span class="number">0L</span>;</span><br><span class="line">        Thread w = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> spins = -<span class="number">1</span>; <span class="comment">// initialized after first item and cancel checks</span></span><br><span class="line">        ThreadLocalRandom randomYields = <span class="keyword">null</span>; <span class="comment">// bound if needed</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Object item = s.item;</span><br><span class="line">            <span class="keyword">if</span> (item != e) &#123;                  <span class="comment">// matched</span></span><br><span class="line">                <span class="comment">// assert item != s;</span></span><br><span class="line">                s.forgetContents();           <span class="comment">// avoid garbage</span></span><br><span class="line">                <span class="keyword">return</span> LinkedTransferQueue.&lt;E&gt;cast(item);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((w.isInterrupted() || (timed &amp;&amp; nanos &lt;= <span class="number">0</span>)) &amp;&amp;</span><br><span class="line">                    s.casItem(e, s)) &#123; <span class="comment">//取消匹配，item指向自身</span></span><br><span class="line">                unsplice(pred, s); <span class="comment">//解除s节点和前继节点的连接</span></span><br><span class="line">                <span class="keyword">return</span> e;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (spins &lt; <span class="number">0</span>) &#123;                  <span class="comment">// establish spins at/near front</span></span><br><span class="line">                <span class="keyword">if</span> ((spins = spinsFor(pred, s.isData)) &gt; <span class="number">0</span>)</span><br><span class="line">                    randomYields = ThreadLocalRandom.current();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (spins &gt; <span class="number">0</span>) &#123;             <span class="comment">// spin</span></span><br><span class="line">                --spins;</span><br><span class="line">                <span class="keyword">if</span> (randomYields.nextInt(CHAINED_SPINS) == <span class="number">0</span>)</span><br><span class="line">                    Thread.yield();           <span class="comment">// occasionally yield</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s.waiter == <span class="keyword">null</span>) &#123;</span><br><span class="line">                s.waiter = w;                 <span class="comment">// request unpark then recheck</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (timed) &#123;</span><br><span class="line">                nanos = deadline - System.nanoTime();</span><br><span class="line">                <span class="keyword">if</span> (nanos &gt; <span class="number">0L</span>)</span><br><span class="line">                    LockSupport.parkNanos(<span class="keyword">this</span>, nanos);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>当前操作作为同步操作时，会调用<code>awaitMatch</code>方法阻塞等待匹配，成功返回匹配节点item，返回失败返回给定参数e。在等待期间如果线程被中断或等待超时，则取消p，并调用<code>upsplice</code>方法解除节点，和其前继节点的链接。</p><h4><span id="unsplice方法">unsplice方法</span></h4><p>解除给定已经被删除/取消节点和前继节点的链接，可能会延迟解除。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">unsplice</span><span class="params">(Node pred, Node s)</span> </span>&#123;</span><br><span class="line">       s.forgetContents(); <span class="comment">// forget unneeded fields</span></span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * See above for rationale. Briefly: if pred still points to</span></span><br><span class="line"><span class="comment">        * s, try to unlink s.  If s cannot be unlinked, because it is</span></span><br><span class="line"><span class="comment">        * trailing node or pred might be unlinked, and neither pred</span></span><br><span class="line"><span class="comment">        * nor s are head or offlist, add to sweepVotes, and if enough</span></span><br><span class="line"><span class="comment">        * votes have accumulated, sweep.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">if</span> (pred != <span class="keyword">null</span> &amp;&amp; pred != s &amp;&amp; pred.next == s) &#123;</span><br><span class="line">           Node n = s.next;</span><br><span class="line">           <span class="keyword">if</span> (n == <span class="keyword">null</span> ||</span><br><span class="line">               (n != s &amp;&amp; pred.casNext(s, n) &amp;&amp; pred.isMatched())) &#123;</span><br><span class="line">               <span class="comment">//解除s节点的链接</span></span><br><span class="line">               <span class="keyword">for</span> (;;) &#123;               <span class="comment">// check if at, or could be, head</span></span><br><span class="line">                   Node h = head;</span><br><span class="line">                   <span class="keyword">if</span> (h == pred || h == s || h == <span class="keyword">null</span>)</span><br><span class="line">                       <span class="keyword">return</span>;          <span class="comment">// at head or list empty</span></span><br><span class="line">                   <span class="keyword">if</span> (!h.isMatched())</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   Node hn = h.next;</span><br><span class="line">                   <span class="keyword">if</span> (hn == <span class="keyword">null</span>)</span><br><span class="line">                       <span class="keyword">return</span>;          <span class="comment">// now empty</span></span><br><span class="line">                   <span class="keyword">if</span> (hn != h &amp;&amp; casHead(h, hn))<span class="comment">//更新head</span></span><br><span class="line">                       h.forgetNext();  <span class="comment">// advance head</span></span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (pred.next != pred &amp;&amp; s.next != s) &#123; <span class="comment">// recheck if offlist</span></span><br><span class="line">                   <span class="keyword">for</span> (;;) &#123;           <span class="comment">// sweep now if enough votes</span></span><br><span class="line">                       <span class="keyword">int</span> v = sweepVotes;</span><br><span class="line">                       <span class="keyword">if</span> (v &lt; SWEEP_THRESHOLD) &#123;</span><br><span class="line">                           <span class="keyword">if</span> (casSweepVotes(v, v + <span class="number">1</span>))</span><br><span class="line">                               <span class="keyword">break</span>;</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="keyword">else</span> <span class="keyword">if</span> (casSweepVotes(v, <span class="number">0</span>)) &#123;</span><br><span class="line">                           sweep();</span><br><span class="line">                           <span class="keyword">break</span>;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><h4><span id="sweep">sweep</span></h4><p>解除从头不遍历时遇到的已经被匹配的节点的链接<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sweep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Node p = head, s, n; p != <span class="keyword">null</span> &amp;&amp; (s = p.next) != <span class="keyword">null</span>; ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!s.isMatched())</span><br><span class="line">                <span class="comment">// Unmatched nodes are never self-linked</span></span><br><span class="line">                p = s;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((n = s.next) == <span class="keyword">null</span>) <span class="comment">// trailing node is pinned</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s == n)    <span class="comment">// stale</span></span><br><span class="line">                <span class="comment">// No need to also check for p == s, since that implies s == n</span></span><br><span class="line">                p = head;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p.casNext(s, n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;&lt;code&gt;LinkedTransferQueue&lt;/code&gt;是单向链表结构的无界阻塞队列。它通过CAS和&lt;code&gt;LockSupport&lt;/code&gt;来实现线程安全的。&lt;br&gt;它采用一种预占模式，意思是当消费者线程取元素时，如果队列为空，那就生成一个节点（节点元素为null）入队，然后消费者线程被等待在这个节点上，后面生产者线程入队时发现一个元素为null的节点，就会直接将元素填充到该节点，并唤醒该节点等待的线程，被唤醒的消费者线程取走元素并返回。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="源码" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>ConcurrentLinkedQueue源码分析</title>
    <link href="http://yoursite.com/2020/01/17/ConcurrentLinkedQueue%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2020/01/17/ConcurrentLinkedQueue源码分析/</id>
    <published>2020-01-17T08:54:56.000Z</published>
    <updated>2020-01-17T08:55:14.421Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="概述">概述</span></h2><p><code>ConcurrentLinkedQueue</code>是一个单向链表结构的无界并发队列。通过CAS来实现并发安全。内存一致性遵循对<code>ConcurrentLinkedQueue</code>的插入插入操作先行于访问会或移除操作。</p><a id="more"></a><h2><span id="源码分析">源码分析</span></h2><h3><span id="继承体系">继承体系</span></h3><p><img src="https://s2.ax1x.com/2020/01/17/lzPOQP.png" alt="lzPOQP.png"></p><h3><span id="重要属性">重要属性</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;E&gt; head;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;E&gt; tail;</span><br></pre></td></tr></table></figure><p><code>ConcurrentLinkedQueue</code>中只有两个属性。</p><h3><span id="重要方法分析">重要方法分析</span></h3><h4><span id="offer方法">offer方法</span></h4><p><code>offer</code>方法用于向队列尾部添加节点。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">       checkNotNull(e);</span><br><span class="line">       <span class="comment">//创建新的节点</span></span><br><span class="line">       <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (Node&lt;E&gt; t = tail, p = t;;) &#123;<span class="comment">//自旋</span></span><br><span class="line">           Node&lt;E&gt; q = p.next; <span class="comment">//p实际上指向尾节点</span></span><br><span class="line">           <span class="keyword">if</span> (q == <span class="keyword">null</span>) &#123; <span class="comment">//尾节点下一个为null</span></span><br><span class="line">               <span class="comment">// p is last node</span></span><br><span class="line">               <span class="keyword">if</span> (p.casNext(<span class="keyword">null</span>, newNode)) &#123; <span class="comment">//CAS插入</span></span><br><span class="line">                   <span class="comment">// Successful CAS is the linearization point</span></span><br><span class="line">                   <span class="comment">// for e to become an element of this queue,</span></span><br><span class="line">                   <span class="comment">// and for newNode to become "live".</span></span><br><span class="line">                   <span class="keyword">if</span> (p != t) <span class="comment">//tail之后至少有两个节点才修改tail</span></span><br><span class="line">                       casTail(t, newNode);  <span class="comment">// CAS替换尾节点</span></span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">// Lost CAS race to another thread; re-read next</span></span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (p == q)<span class="comment">//p节点指向自身，说明p是自链节点</span></span><br><span class="line">               <span class="comment">// We have fallen off list.  If tail is unchanged, it</span></span><br><span class="line">               <span class="comment">// will also be off-list, in which case we need to</span></span><br><span class="line">               <span class="comment">// jump to head, from which all live nodes are always</span></span><br><span class="line">               <span class="comment">// reachable.  Else the new tail is a better bet.</span></span><br><span class="line">               <span class="comment">//如果tail节点被其它线程修改，此时需要从head节点开始向</span></span><br><span class="line">               <span class="comment">//后遍历，因为从head开始可达所有的live节点</span></span><br><span class="line">               p = (t != (t = tail)) ? t : head;</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">               <span class="comment">// Check for tail updates after two hops.</span></span><br><span class="line">               <span class="comment">//继续向后查找，如果tail节点变化，重新获取tail。</span></span><br><span class="line">               p = (p != t &amp;&amp; t != (t = tail)) ? t : q;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>整个方法的执行流程如下：</p><ol><li>从<code>tail</code>节点先后自旋查找next为null的节点，也就是最后一个节点（因为tail节点并不是每次都更新，所以我们取到tail节点可能并不是最后一个节点）</li><li>通过CAS插入新增节点</li></ol><p>为什么<code>tail</code>可能不是指向最后一个节点呢？<br>因为其实并不是每次操作都会更新<code>head/tail</code>节点。而是使用了一个松弛阈值，具体的体现是在<code>if (p != t)</code>（p初始是等于<code>tail</code>的，p伴随着每次查找都会后移）。如果向后查找了一次以上，再加上新增的节点，说明<code>tail</code>之后有两个（或以上）的节点了，才会通过CAS更新<code>tail</code></p><h4><span id="poll方法">poll方法</span></h4><p><code>poll</code>方法移除队列中的头节点并返回。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       restartFromHead:</span><br><span class="line">       <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">       <span class="comment">//从head开始先后查找第一个live节点</span></span><br><span class="line">           <span class="keyword">for</span> (Node&lt;E&gt; h = head, p = h, q;;) &#123;</span><br><span class="line">               E item = p.item;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (item != <span class="keyword">null</span> &amp;&amp; p.casItem(item, <span class="keyword">null</span>)) &#123;</span><br><span class="line">               <span class="comment">//找到第一个不为null的节点，通过CAS设置item为null</span></span><br><span class="line">                   <span class="comment">// Successful CAS is the linearization point</span></span><br><span class="line">                   <span class="comment">// for item to be removed from this queue.</span></span><br><span class="line">                   <span class="keyword">if</span> (p != h) <span class="comment">// 跳两个以上的节点才修改head</span></span><br><span class="line">                       updateHead(h, ((q = p.next) != <span class="keyword">null</span>) ? q : p);</span><br><span class="line">                   <span class="keyword">return</span> item;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> ((q = p.next) == <span class="keyword">null</span>) &#123; <span class="comment">//队列已空</span></span><br><span class="line">                   updateHead(h, p);<span class="comment">//CAS修改head为p</span></span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> (p == q) <span class="comment">//p为自链节点，重新获取head循环</span></span><br><span class="line">                   <span class="comment">//跳转到restartFromHead继续循环</span></span><br><span class="line">                   <span class="keyword">continue</span> restartFromHead; </span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">                   p = q; <span class="comment">//先后查找</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>这个方法的流程：<br>从head开始向后查找第一个live(item不为null的节点)节点。通过CAS修改节点的live为null。返回当前的节点的item。这个地方也是跳两个以上节点时才会更新<code>head</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;&lt;code&gt;ConcurrentLinkedQueue&lt;/code&gt;是一个单向链表结构的无界并发队列。通过CAS来实现并发安全。内存一致性遵循对&lt;code&gt;ConcurrentLinkedQueue&lt;/code&gt;的插入插入操作先行于访问会或移除操作。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="源码" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>ThreadPoolExecutor源码分析</title>
    <link href="http://yoursite.com/2020/01/17/ThreadPoolExecutor%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2020/01/17/ThreadPoolExecutor源码分析/</id>
    <published>2020-01-17T08:54:56.000Z</published>
    <updated>2020-01-20T03:24:01.633Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="概述">概述</span></h2><p>任务是一组逻辑工作单元，而线程则是是任务异步执行的机制。通过线程池就可以简化线程的管理工作。<br>ThreadPoolExecutor是线程池的核心实现。线程池中预先提供了指定数量的可重用的线程，使用线程池避免了线程创建和终止的开销，节省了系统的资源。并且线程池维护了一些基础的数据统计，方便了线程的监控和管理。</p><a id="more"></a><h2><span id="线程池的基本使用">线程池的基本使用</span></h2><h3><span id="参数解释">参数解释</span></h3><p>线程池的创建的需要指定非常的参数，我们需要理解每个参数的含义.我们就以参数最多的构造器为例，来解释每个参数的含义。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor(<span class="keyword">int</span> corePoolSize,</span><br><span class="line">                   <span class="keyword">int</span> maximumPoolSize,</span><br><span class="line">                   <span class="keyword">long</span> keepAliveTime,</span><br><span class="line">                   TimeUnit unit,</span><br><span class="line">                   BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                   ThreadFactory threadFactory,</span><br><span class="line">                   RejectedExecutionHandler handler)</span><br></pre></td></tr></table></figure></p><p><code>corePoolSize</code> 核心线程数。<br><code>maximumPoolSize</code>最大线程数。<br>这里需要注意：当一个新的任务提交给线程池之后：</p><ul><li>如果当前运行线程的数量小于核心线程数，无论有无空闲的线程，都换创建新的线程。</li><li>如果当前运行的线程数大于核心线程数，小于最大线程数，只有当等待队列满之后，才会新建线程。</li><li>如果等待队列已满，且线程数已达到最大线程数，那么就会根据指定的拒绝策略进行处理了。</li></ul><p><code>keepAliveTime</code>线程最大空闲时间：如果当前线程池中多于核心线程数的线程如果超过最大空闲时间就会被终止。</p><p><code>unit:TimeUnit</code>时间单位。<br><code>workQueue</code>线程等待队列。<br><code>threadFactory</code>线程创建工厂。<br><code>RejectedExecutionHandler</code>:拒绝策略。当线程池已经关闭或者已经达到饱和状态，新提交的任务会被拒绝。一共有4种拒绝策略：</p><ul><li><code>AbortPolicy</code>:默认策略，在需要拒绝任务时，抛出<code>RejectedExecutionException</code></li><li><code>CallerRunsPolicy</code>:直接在execute方法的调用线程种运行被拒绝的任务，如果线程池已经关闭，任务将被丢弃。</li><li><code>DiscardPolicy</code>：直接丢弃任务</li><li><code>DiscardOldestPolicy</code>:丢弃队列中等待时间最长的任务，并执行当前提交的任务，如果线程池被关闭，任务将被丢弃。</li><li>我们也可以自己继承<code>RejectedExcutionHandler</code>自定义自己的拒绝策略，拒绝策略的运行需要指定线程池和队列的容量。</li></ul><h3><span id="生命周期">生命周期</span></h3><p>线程池一共有5种状态：</p><ul><li>Running：可以接收新的任务和队列任务</li><li>shutdown：不接受新的任务，但是会运行队列任务。</li><li>stop：不接受新的任务，也不会运行队列任务，并且中断正在运行的任务。</li><li>tidying：所有任务都已经终止，<code>workCount</code>为0，当前池状态为tidying时会运行运行<code>terminated()</code>方法</li><li>terminated，<code>terminated()</code>方法执行完毕。</li></ul><p><img src="https://s2.ax1x.com/2020/01/19/1C7IpT.png" alt="1C7IpT.png"></p><h2><span id="源码分析">源码分析</span></h2><p><img src="https://s2.ax1x.com/2020/01/19/1CHiBd.png" alt="1CHiBd.png"></p><h3><span id="重要属性">重要属性</span></h3><p><code>ThreadPoolExecutor</code>内部有一个非常重要的内部类<code>Worker</code>，它继承自AQS实现了<code>Runnable</code>接口,实现了不可重入的互斥锁。在线程池种持有一个Work集合，一个worker对应一个工作想，当线程池启动时，对应的worker会执行池种的任务，执行任务完毕后会从阻塞列表中获取一个新的任务继续执行。</p><p><code>Worker</code>内部维护了三个变量，用于记录每个工作线程的工作状态。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 工作线程 */</span></span><br><span class="line"><span class="keyword">final</span> Thread thread;</span><br><span class="line"><span class="comment">/** 初始运行任务 */</span></span><br><span class="line">Runnable firstTask;</span><br><span class="line"><span class="comment">/**任务完成计数*/</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">long</span> completedTasks;</span><br></pre></td></tr></table></figure></p><p>内部的属性：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*当核心参数数已满，新增任务的存储队列*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*线程池运行期间的锁*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*工作池线程*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> HashSet&lt;Worker&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*awaitTermination的等待队列*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition termination = mainLock.newCondition();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*最大线程池数量*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> largestPoolSize;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*已完成的任务数*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> completedTaskCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*线程创建工厂*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> ThreadFactory threadFactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*拒绝处理器*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> RejectedExecutionHandler handler;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*最大闲置时间*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> keepAliveTime;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*是否允许核心线程超时*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> allowCoreThreadTimeOut;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*核心线程数*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> corePoolSize;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*最大线程数*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> maximumPoolSize;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*拒绝策略，默认的拒绝策略为AbortPolicy，即直接抛出异常*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> RejectedExecutionHandler defaultHandler =</span><br><span class="line">    <span class="keyword">new</span> AbortPolicy();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*针对shutdown和shutdownNow的运行权限许可*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> RuntimePermission shutdownPerm =</span><br><span class="line">    <span class="keyword">new</span> RuntimePermission(<span class="string">"modifyThread"</span>);</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*高3位标识线程池的运行状态，低29位表示线程池中的任务数*/</span>    </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br></pre></td></tr></table></figure></p><h3><span id="重要方法解析">重要方法解析</span></h3><h4><span id="execute方法">execute方法</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">       <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">       <span class="comment">//线程池中的线程数小于核心线程数</span></span><br><span class="line">       <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">           <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))<span class="comment">//添加到工作线程集合</span></span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           c = ctl.get();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//线程正在运行，添加到等待队列</span></span><br><span class="line">       <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">           <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">           <span class="comment">//如果池的状态shotdown，移除任务，执行拒绝策略</span></span><br><span class="line">           <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">               reject(command);<span class="comment">//执行拒绝策略</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)<span class="comment">//工作线程位空，添加新的工作线程</span></span><br><span class="line">               addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))<span class="comment">//再次尝试添加任务</span></span><br><span class="line">       <span class="comment">//再次尝试还是失败，就会根据拒绝策略进行处理了</span></span><br><span class="line">           reject(command);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>提交一个任务到线程池，任务不一定会立即执行。提交的任务可以在一个新的线程中执行，也可能在已存在线程中执行。如果由于池关闭或池容量已经饱和导致任务无法提交，那么就根据拒绝策略来处理提交过来的任务。</p><ol><li>如果正在运行的线程数少于<code>corePoolSize</code>,那么就会通过<code>addWorker</code>方法尝试开启一个新的线程并把提交的任务作为它的<code>firstTask</code>运行，<code>addWorker</code>会检查<code>ctl</code>的状态来判断是否可以添加新的线程。</li><li>如果<code>addWorker</code>执行失败（返回false），那么就会把任务添加到等待队列。这里需要对<code>ctl</code>进行双重检查。</li><li>如果不能任务不能入队，那么就会再次尝试增加一个新的线程，如果添加失败，就意味着池关闭或已经饱和，这个时候就会根据拒绝策略来进行处理。</li></ol><h4><span id="addworker方法">addWorker方法</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; <span class="comment">//自旋，判断可以添加节点的前提条件</span></span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);<span class="comment">//线程运行的状态码</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查线程池的状态</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">               firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">               ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;<span class="comment">//检查工作线程数是否饱和</span></span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);<span class="comment">//获取工作线程数</span></span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">            <span class="comment">//可以添加新的线程，更新ctl中关于新线程的表示</span></span><br><span class="line">            <span class="comment">//跳出自旋</span></span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            c = ctl.get();  <span class="comment">// 更新ctl失败，重新读取ctl</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">    Worker w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//创建新的工作线程</span></span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            mainLock.lock();<span class="comment">//加锁，准备添加新的工作线程</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">                <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">                <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">                <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line"></span><br><span class="line">                <span class="comment">//重新加成sunState</span></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                    workers.add(w);<span class="comment">//添加工作线程</span></span><br><span class="line">                    <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;<span class="comment">//更新最大池容量</span></span><br><span class="line">                    workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                t.start();<span class="comment">//添加成功，启动线程</span></span><br><span class="line">                workerStarted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">        <span class="comment">//添加失败，回滚操作</span></span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="runworker方法">runWorker方法</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">        Thread wt = Thread.currentThread();</span><br><span class="line">        Runnable task = w.firstTask;</span><br><span class="line">        w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">        w.unlock(); <span class="comment">// 允许中断</span></span><br><span class="line">        <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//如果work的firstTask为null，就调用getTask从队列中取任务</span></span><br><span class="line">            <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                w.lock();<span class="comment">//加锁</span></span><br><span class="line">                <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                     (Thread.interrupted() &amp;&amp;</span><br><span class="line">                      runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                    !wt.isInterrupted())</span><br><span class="line">                    <span class="comment">//中断线程</span></span><br><span class="line">                    wt.interrupt();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//执行任务的前逻辑</span></span><br><span class="line">                    beforeExecute(wt, task);</span><br><span class="line">                    Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        task.run();<span class="comment">//执行任务</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                        thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                        thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                        thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//执行任务后逻辑，自定义任务</span></span><br><span class="line">                        afterExecute(task, thrown);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    task = <span class="keyword">null</span>;</span><br><span class="line">                    w.completedTasks++; <span class="comment">//完成的任务数加一</span></span><br><span class="line">                    w.unlock(); <span class="comment">//解锁</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//处理工作线程退出逻辑</span></span><br><span class="line">            processWorkerExit(w, completedAbruptly);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>runWorker</code>是工作线程运行的核心方法，循环从队列中获取任务并执行。工作线程启动后，会首先运行内部持有的任务<code>firstTask</code>.如果<code>firstTask</code>为null，那么就会循环调用<code>getTask</code>方法从队列中获取任务执行。在任务执行前后可以调用<code>beforeExecute</code>和<code>afterWxecute</code>处理执行前后的逻辑。如果线程池的状态正在停止，那么需要确保线程被中断，否则需要确保线程没有被中断。</p><h4><span id="gettask方法">getTask方法</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);<span class="comment">//获取runState</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">        <span class="comment">//线程池已经关闭或等待队列为null</span></span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> wc = workerCountOf(c);<span class="comment">//获取工作线程的数wokerCount</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Are workers subject to culling?</span></span><br><span class="line">        <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">            &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))<span class="comment">//修改ctl工作线程数减一</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Runnable r = timed ?</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                workQueue.take();<span class="comment">//出队，直到得带元素可用</span></span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            timedOut = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">            timedOut = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="processworkerexit方法">processWorkerExit方法</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processWorkerExit</span><span class="params">(Worker w, <span class="keyword">boolean</span> completedAbruptly)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (completedAbruptly) <span class="comment">// If abrupt, then workerCount wasn't adjusted</span></span><br><span class="line">       <span class="comment">//如果任务线程被中断，则工作线程数量减一</span></span><br><span class="line">           decrementWorkerCount();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">       mainLock.lock(); <span class="comment">//加锁</span></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">//更新完成任务数</span></span><br><span class="line">           completedTaskCount += w.completedTasks;</span><br><span class="line">           <span class="comment">//移除工作线程</span></span><br><span class="line">           workers.remove(w);</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           mainLock.unlock();<span class="comment">//解锁</span></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       tryTerminate();<span class="comment">//尝试终止线程池</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">       <span class="keyword">if</span> (runStateLessThan(c, STOP)) &#123;<span class="comment">//线程池尚未完全停止</span></span><br><span class="line">           <span class="keyword">if</span> (!completedAbruptly) &#123;<span class="comment">//工作线程非异常退出</span></span><br><span class="line">           <span class="comment">//获取当前核心线程数</span></span><br><span class="line">               <span class="keyword">int</span> min = allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize;</span><br><span class="line">               <span class="keyword">if</span> (min == <span class="number">0</span> &amp;&amp; ! workQueue.isEmpty())</span><br><span class="line">               <span class="comment">//如果允许空闲工作线程等待任务，且任务队列不为空，则min为1</span></span><br><span class="line">                   min = <span class="number">1</span>;</span><br><span class="line">               <span class="keyword">if</span> (workerCountOf(c) &gt;= min)</span><br><span class="line">                   <span class="keyword">return</span>; <span class="comment">// replacement not needed</span></span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//继续尝试添加新的工作线程</span></span><br><span class="line">           addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>工作线程处理完所有的任务之后，调用池方法处理工作线程退出逻辑，为已经死亡的工作线程执行相关的清除操作。此方法会从线程池中内的工作线程集合中移除当前线程，并会尝试终止线程池。<br>在下面这几种情况下，可能会替换当前工作线程：</p><ol><li>用户任务执行异常导致线程退出</li><li>工作线程数少于<code>corePoolSize</code></li><li>等待队列不为空，但是没有工作线程</li></ol><h4><span id="tryterminate方法">tryTerminate方法</span></h4><p>该方法的主要作用就是尝试终止线程池。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">tryTerminate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">           <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">           <span class="keyword">if</span> (isRunning(c) ||</span><br><span class="line">               runStateAtLeast(c, TIDYING) ||</span><br><span class="line">               (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           <span class="keyword">if</span> (workerCountOf(c) != <span class="number">0</span>) &#123; <span class="comment">// Eligible to terminate</span></span><br><span class="line">               interruptIdleWorkers(ONLY_ONE);<span class="comment">//中断空闲线程</span></span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">           mainLock.lock();</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//线程池已经关闭，等待队列为空，并且工作线程等于0，更新池状态为TINDYING</span></span><br><span class="line">               <span class="keyword">if</span> (ctl.compareAndSet(c, ctlOf(TIDYING, <span class="number">0</span>))) &#123;</span><br><span class="line">                   <span class="keyword">try</span> &#123;</span><br><span class="line">                   </span><br><span class="line">                   <span class="comment">//线程池终止操作，需要自定义实现</span></span><br><span class="line">                       terminated();</span><br><span class="line">                   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                       ctl.set(ctlOf(TERMINATED, <span class="number">0</span>));</span><br><span class="line">                       <span class="comment">//唤醒等待池结束的线程</span></span><br><span class="line">                       termination.signalAll();</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">return</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">               mainLock.unlock();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// else retry on failed CAS</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>该方法用于尝试终止线程池，<code>shutDown</code>,<code>shutdownNoe</code>,<code>remove</code>中局势通过此方法来终止线程池的。此方法必须在人恶化可能导致终止的行为之后被调用。一如减少工作线程数，移除队列中的任务，或者是在工作线程运行完毕后处理工作线程退出逻辑方法<code>processWorkerExit</code>。</p><p><a href="https://www.jianshu.com/p/7be43712ef21" target="_blank" rel="noopener">https://www.jianshu.com/p/7be43712ef21</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;任务是一组逻辑工作单元，而线程则是是任务异步执行的机制。通过线程池就可以简化线程的管理工作。&lt;br&gt;ThreadPoolExecutor是线程池的核心实现。线程池中预先提供了指定数量的可重用的线程，使用线程池避免了线程创建和终止的开销，节省了系统的资源。并且线程池维护了一些基础的数据统计，方便了线程的监控和管理。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="源码" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>ConcurrentSkipListMap源码分析</title>
    <link href="http://yoursite.com/2020/01/16/ConcurrentSkipListMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2020/01/16/ConcurrentSkipListMap源码分析/</id>
    <published>2020-01-16T12:31:56.000Z</published>
    <updated>2020-01-16T12:32:14.766Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="概述">概述</span></h2><p><code>ConcurrentSkipListMap</code>是一个线程安全的有序的哈希表，并发安全主要由CAS来实现。内部的使用了跳表这种数据结构。<code>ConcurrentSkipListSet</code>的底层是基于<code>ConcurrentSkipListMap</code>实现的。</p><a id="more"></a><h2><span id="跳表skip-list">跳表（Skip List）</span></h2><p>跳表可以做到比较稳定的插入，查询与删除。理论插入查询删除的算法时间复杂度为O(logN).<br>跳表其实是从链表之上改进而来的。我们知道在链表中查询，插入的时间复杂度都为O(n).如果我们可以在多个节点之间跳跃，就可以提高效率。</p><p>链表的结构如下；<br><img src="https://s2.ax1x.com/2020/01/16/ljDHVf.png" alt="ljDHVf.png"><br>改进后得到：<br><img src="https://s2.ax1x.com/2020/01/16/ljrddf.png" alt="ljrddf.png"><br>如果层次更多的话，那么结构如下；<br><img src="https://s2.ax1x.com/2020/01/16/ljrcyn.png" alt="ljrcyn.png"></p><p>跳表的查询：<br>假如我们要查询11.从最上面一层出发，发现11大于5小于13，那么确定了大致区间。进入第二层，发现11大于9小于13，区间缩小。进入第三层，依次查找，最终找到11这个节点。<br><img src="https://s2.ax1x.com/2020/01/16/ljslmq.png" alt="ljslmq.png"></p><p>插入与查询的过程也非常的类似，首先找到在最底层合适的位置，然后再随机是否向上拓展。</p><p>删除同样也需要查找，然后再从下至上依次删除。</p><h2><span id="concurrentskiplistmap源码分析">ConcurrentSkipListMap源码分析</span></h2><h3><span id="重要属性">重要属性</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 跳表最底一层的链表的头节点。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object BASE_HEADER = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 跳表最高层的头节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> HeadIndex&lt;K,V&gt; head;</span><br></pre></td></tr></table></figure><p><code>ConcurrentSkipListMap</code>的跳表实现：<br><img src="https://s2.ax1x.com/2020/01/16/lj6TSg.png" alt="lj6TSg.png"></p><p>数据存储由三个内部类实现：<br><code>Node</code>:存储键值对， 单向链表节点。<br><code>Index</code>:跳表中的索引节点，包含了向右的指针和向下的指针，和节点。<br><code>HeadIndex</code>：跳表的头，继承至Index，包含了层次信息。</p><h3><span id="重要方法">重要方法</span></h3><h4><span id="put方法">put方法</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>)<span class="comment">//不支持null键</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">return</span> doPut(key, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从<code>put</code>方法中，我们可以知道<code>ConcurrentSkipListMap</code>不支持null键。</p><p>实际的put工作由<code>doPut</code>方法完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">doPut</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">       Node&lt;K,V&gt; z;             <span class="comment">// added node</span></span><br><span class="line">       <span class="keyword">if</span> (key == <span class="keyword">null</span>) <span class="comment">//不支持空键</span></span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">       Comparator&lt;? <span class="keyword">super</span> K&gt; cmp = comparator;</span><br><span class="line">       outer: <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">       <span class="comment">//找到指定key节点的前驱节点</span></span><br><span class="line">           <span class="keyword">for</span> (Node&lt;K,V&gt; b = findPredecessor(key, cmp), n = b.next;;) &#123;</span><br><span class="line">               <span class="keyword">if</span> (n != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   Object v; <span class="keyword">int</span> c;</span><br><span class="line">                   Node&lt;K,V&gt; f = n.next;</span><br><span class="line">                   <span class="keyword">if</span> (n != b.next)               <span class="comment">// inconsistent read</span></span><br><span class="line">                       <span class="comment">//读不一致，跳出整个循环</span></span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   <span class="keyword">if</span> ((v = n.value) == <span class="keyword">null</span>) &#123;   <span class="comment">// n is deleted</span></span><br><span class="line">                       n.helpDelete(b, f);<span class="comment">//帮助清楚已删除的节点</span></span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">if</span> (b.value == <span class="keyword">null</span> || v == n) <span class="comment">// b is deleted</span></span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   <span class="keyword">if</span> ((c = cpr(cmp, key, n.key)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                   <span class="comment">//当前key大于n.key，继续向后查找</span></span><br><span class="line">                       b = n;</span><br><span class="line">                       n = f;</span><br><span class="line">                       <span class="keyword">continue</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                       <span class="comment">//更新value，返回更新前的值</span></span><br><span class="line">                       <span class="keyword">if</span> (onlyIfAbsent || n.casValue(v, value)) &#123;</span><br><span class="line">                           <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) V vv = (V)v;</span><br><span class="line">                           <span class="keyword">return</span> vv;</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="keyword">break</span>; <span class="comment">// restart if lost race to replace value</span></span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="comment">// else c &lt; 0; fall through</span></span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="comment">//新建一个节点，插入的哦b和b.next之间</span></span><br><span class="line">               z = <span class="keyword">new</span> Node&lt;K,V&gt;(key, value, n);</span><br><span class="line">               <span class="keyword">if</span> (!b.casNext(n, z))</span><br><span class="line">                   <span class="keyword">break</span>;         <span class="comment">// restart if lost race to append to b</span></span><br><span class="line">               <span class="keyword">break</span> outer;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> rnd = ThreadLocalRandom.nextSecondarySeed();</span><br><span class="line">       <span class="comment">//使用随机数来决定是否更新层级</span></span><br><span class="line">       <span class="keyword">if</span> ((rnd &amp; <span class="number">0x80000001</span>) == <span class="number">0</span>) &#123; <span class="comment">// test highest and lowest bits</span></span><br><span class="line">           <span class="keyword">int</span> level = <span class="number">1</span>, max;</span><br><span class="line">           <span class="comment">//计算跳表的level</span></span><br><span class="line">           <span class="keyword">while</span> (((rnd &gt;&gt;&gt;= <span class="number">1</span>) &amp; <span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">               ++level;</span><br><span class="line">           Index&lt;K,V&gt; idx = <span class="keyword">null</span>;</span><br><span class="line">           HeadIndex&lt;K,V&gt; h = head;</span><br><span class="line">           <span class="comment">//构建index的逻辑</span></span><br><span class="line">           <span class="keyword">if</span> (level &lt;= (max = h.level)) &#123; <span class="comment">//不需要增加层级</span></span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= level; ++i)</span><br><span class="line">                   idx = <span class="keyword">new</span> Index&lt;K,V&gt;(z, idx, <span class="keyword">null</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> &#123; <span class="comment">// try to grow by one level 需要增加新层级</span></span><br><span class="line">               level = max + <span class="number">1</span>; <span class="comment">// hold in array and later pick the one to use</span></span><br><span class="line">               <span class="comment">//构建一个长度为level+1的index数组</span></span><br><span class="line">               <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)Index&lt;K,V&gt;[] idxs =</span><br><span class="line">                   (Index&lt;K,V&gt;[])<span class="keyword">new</span> Index&lt;?,?&gt;[level+<span class="number">1</span>];</span><br><span class="line">               <span class="comment">//从下至上构建HeadIndex</span></span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= level; ++i)</span><br><span class="line">                   idxs[i] = idx = <span class="keyword">new</span> Index&lt;K,V&gt;(z, idx, <span class="keyword">null</span>);</span><br><span class="line">               <span class="keyword">for</span> (;;) &#123; <span class="comment">//自旋</span></span><br><span class="line">                   h = head;</span><br><span class="line">                   <span class="comment">//保存head之前的层级</span></span><br><span class="line">                   <span class="keyword">int</span> oldLevel = h.level;</span><br><span class="line">                   <span class="keyword">if</span> (level &lt;= oldLevel) <span class="comment">// lost race to add level</span></span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   HeadIndex&lt;K,V&gt; newh = h;</span><br><span class="line">                   Node&lt;K,V&gt; oldbase = h.node;</span><br><span class="line">                   <span class="keyword">for</span> (<span class="keyword">int</span> j = oldLevel+<span class="number">1</span>; j &lt;= level; ++j)</span><br><span class="line">                       newh = <span class="keyword">new</span> HeadIndex&lt;K,V&gt;(oldbase, newh, idxs[j], j);</span><br><span class="line">                   <span class="keyword">if</span> (casHead(h, newh)) &#123;</span><br><span class="line">                       h = newh;</span><br><span class="line">                       idx = idxs[level = oldLevel];</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// find insertion points and splice in 插入index</span></span><br><span class="line">           splice: <span class="keyword">for</span> (<span class="keyword">int</span> insertionLevel = level;;) &#123;</span><br><span class="line">               <span class="keyword">int</span> j = h.level;</span><br><span class="line">               <span class="keyword">for</span> (Index&lt;K,V&gt; q = h, r = q.right, t = idx;;) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (q == <span class="keyword">null</span> || t == <span class="keyword">null</span>)</span><br><span class="line">                       <span class="keyword">break</span> splice;</span><br><span class="line">                   <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">                       Node&lt;K,V&gt; n = r.node;</span><br><span class="line">                       <span class="comment">// compare before deletion check avoids needing recheck</span></span><br><span class="line">                       <span class="keyword">int</span> c = cpr(cmp, key, n.key);</span><br><span class="line">                       <span class="keyword">if</span> (n.value == <span class="keyword">null</span>) &#123;</span><br><span class="line">                           <span class="keyword">if</span> (!q.unlink(r))</span><br><span class="line">                               <span class="keyword">break</span>;</span><br><span class="line">                           r = q.right;</span><br><span class="line">                           <span class="keyword">continue</span>;</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="keyword">if</span> (c &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                           q = r;</span><br><span class="line">                           r = r.right;</span><br><span class="line">                           <span class="keyword">continue</span>;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">if</span> (j == insertionLevel) &#123;</span><br><span class="line">                       <span class="keyword">if</span> (!q.link(r, t))</span><br><span class="line">                           <span class="keyword">break</span>; <span class="comment">// restart</span></span><br><span class="line">                       <span class="keyword">if</span> (t.node.value == <span class="keyword">null</span>) &#123;</span><br><span class="line">                           findNode(key);</span><br><span class="line">                           <span class="keyword">break</span> splice;</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="keyword">if</span> (--insertionLevel == <span class="number">0</span>)</span><br><span class="line">                           <span class="keyword">break</span> splice;</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">if</span> (--j &gt;= insertionLevel &amp;&amp; j &lt; level)</span><br><span class="line">                       t = t.down;</span><br><span class="line">                   q = q.down;</span><br><span class="line">                   r = q.right;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这个方法的实现非常的复杂。但大致可以分为两个步骤；</p><ol><li>通过自旋查找索引位置，更新或插入给定的节点元素。在遍历查找的过程中，也会帮助清楚已经删除的节点。具体的流程如下：</li></ol><ul><li>首先通过<code>findPredecessor</code>方法，从最底一层找到key节点的前驱节点b，从这个节点开始先后查找合适位置插入。</li><li>如果在查找的过程中，发现了已删除的节点，那么会调用<code>helpDelete</code>方法帮助清除节点。</li></ul><ol start="2"><li>通过随机的方式，确定是否更新跳表层级。随机的过程大致如下：首先生成一个随机数<code>rnd</code>,如果<code>rnd</code>为正偶数，那么就会进行下一步的判断，计算<code>rnd</code>从第2位开始有多少个连续的1，如果连续1的数量小于等于旧表层级，则不需要增加跳表层级，只需要更新<code>index</code>,否则旧需要更新跳表层级。</li></ol><h4><span id="remove方法">remove方法</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> doRemove(key, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>remove</code>实际上是调用了<code>doRemove</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">doRemove</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">       Comparator&lt;? <span class="keyword">super</span> K&gt; cmp = comparator;</span><br><span class="line">       outer: <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">       <span class="comment">//找到指定key的前驱节点</span></span><br><span class="line">           <span class="keyword">for</span> (Node&lt;K,V&gt; b = findPredecessor(key, cmp), n = b.next;;) &#123;</span><br><span class="line">               Object v; <span class="keyword">int</span> c;</span><br><span class="line">               <span class="keyword">if</span> (n == <span class="keyword">null</span>)</span><br><span class="line">                   <span class="keyword">break</span> outer;</span><br><span class="line">               Node&lt;K,V&gt; f = n.next;</span><br><span class="line">               <span class="keyword">if</span> (n != b.next)                    <span class="comment">// inconsistent read</span></span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               <span class="keyword">if</span> ((v = n.value) == <span class="keyword">null</span>) &#123;        <span class="comment">// n is deleted</span></span><br><span class="line">                   n.helpDelete(b, f); <span class="comment">//帮助清除，已经删除的节点</span></span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (b.value == <span class="keyword">null</span> || v == n)      <span class="comment">// b is deleted</span></span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               <span class="keyword">if</span> ((c = cpr(cmp, key, n.key)) &lt; <span class="number">0</span>)</span><br><span class="line">                   <span class="keyword">break</span> outer;</span><br><span class="line">               <span class="keyword">if</span> (c &gt; <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="comment">//继续向右寻找</span></span><br><span class="line">                   b = n;</span><br><span class="line">                   n = f;</span><br><span class="line">                   <span class="keyword">continue</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (value != <span class="keyword">null</span> &amp;&amp; !value.equals(v))</span><br><span class="line">                   <span class="keyword">break</span> outer;</span><br><span class="line">               <span class="keyword">if</span> (!n.casValue(v, <span class="keyword">null</span>)) <span class="comment">//找打了指定的节点将value置null</span></span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">                   <span class="comment">//添加删除标识，彻底从链表上删除</span></span><br><span class="line">               <span class="keyword">if</span> (!n.appendMarker(f) || !b.casNext(n, f))</span><br><span class="line">                   findNode(key);                  <span class="comment">// retry via findNode</span></span><br><span class="line">               <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">//删除n节点对应的index</span></span><br><span class="line">                   findPredecessor(key, cmp);      <span class="comment">// clean index</span></span><br><span class="line">                   <span class="keyword">if</span> (head.right == <span class="keyword">null</span>)</span><br><span class="line">                   <span class="comment">//减少跳表的层级</span></span><br><span class="line">                       tryReduceLevel();</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) V vv = (V)v;</span><br><span class="line">               <span class="keyword">return</span> vv; <span class="comment">//返回对应的value</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>整个方法的流程大致如下：</p><ol><li>首先找到需要删除节点的前系欸但，如果在查找的过程中发现已经删除的节点，那么旧帮助清除节点</li><li>子啊找打需要删除的节点时，不会理解移除它，而是会通过CAS添加一个删除标识，然后再利用CAS来解除链接，如果途中CAS执行失败，那么就会调用<code>findNode</code>来删除有删除标记的节点。</li><li>最后检查<code>head.right</code>如果已经被移除了，那么就会调用<code>tryReduceLevel</code>方法尝试对跳表进行降级操作（只有层级大于三才可以降级）。</li></ol><h4><span id="get方法">get方法</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> doGet(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以发现，实际完成get操作的是<code>doGet</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">doGet</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        Comparator&lt;? <span class="keyword">super</span> K&gt; cmp = comparator;</span><br><span class="line">        outer: <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//从最底层查找指定key节点的前驱节点</span></span><br><span class="line">            <span class="keyword">for</span> (Node&lt;K,V&gt; b = findPredecessor(key, cmp), n = b.next;;) &#123;</span><br><span class="line">                Object v; <span class="keyword">int</span> c;</span><br><span class="line">                <span class="keyword">if</span> (n == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">break</span> outer;</span><br><span class="line">                Node&lt;K,V&gt; f = n.next;</span><br><span class="line">                <span class="keyword">if</span> (n != b.next)                <span class="comment">// inconsistent read</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> ((v = n.value) == <span class="keyword">null</span>) &#123;    <span class="comment">// n is deleted</span></span><br><span class="line">                <span class="comment">//节点n已经被删除了，帮助清除已经删除的节点</span></span><br><span class="line">                    n.helpDelete(b, f);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (b.value == <span class="keyword">null</span> || v == n)  <span class="comment">// b is deleted</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> ((c = cpr(cmp, key, n.key)) == <span class="number">0</span>) &#123;<span class="comment">//检查k是否相等</span></span><br><span class="line">                    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) V vv = (V)v;</span><br><span class="line">                    <span class="keyword">return</span> vv;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (c &lt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span> outer;</span><br><span class="line">                <span class="comment">//未找到合适节点，继续向后查找</span></span><br><span class="line">                b = n;</span><br><span class="line">                n = f;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;&lt;code&gt;ConcurrentSkipListMap&lt;/code&gt;是一个线程安全的有序的哈希表，并发安全主要由CAS来实现。内部的使用了跳表这种数据结构。&lt;code&gt;ConcurrentSkipListSet&lt;/code&gt;的底层是基于&lt;code&gt;ConcurrentSkipListMap&lt;/code&gt;实现的。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="源码" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Spring事务基础</title>
    <link href="http://yoursite.com/2020/01/15/Spring%E4%BA%8B%E5%8A%A1%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2020/01/15/Spring事务基础/</id>
    <published>2020-01-15T13:35:56.000Z</published>
    <updated>2020-01-16T02:57:44.004Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="事务的acid">事务的ACID</span></h2><ul><li>Atomicity原子性：事务是一个原子操作，由一些列动作组成，事务的原子性确保动作要么全部完成，要么都不完成。</li><li>Consistency一致性：一旦事务完成，系统必须确保它锁建模的业务处于一致的状态，而不是部分完成或部分失败。</li><li>Isolation隔离性：可能有许多事务会同时处理相同的数据，因此每个事务都应该与其它事务隔离开来，防止数据破坏。</li><li>Durability持久性：一旦事务完成，无论系统发生什么故障，它的结果都不应该受到影响，这样就能从任何系统崩溃中恢复过来，通常情况下，事务的结果会被持久化到存储器中。</li></ul><a id="more"></a><h2><span id="spring事务的核心接口">Spring事务的核心接口</span></h2><p><img src="https://s2.ax1x.com/2020/01/15/lOHA2t.png" alt="lOHA2t.png"><br>Spring并不直接管理事务，而是提供多种事务管理器，它将事务管理委托给持久化框架。</p><h2><span id="事务的属性">事务的属性</span></h2><p>事务的属性是：传播行为，隔离规则，回滚规则，是否只读，事务超时。</p><h3><span id="事务的传播行为">事务的传播行为</span></h3><p>当一个事务方法嗲调用另一个事务方法的时候，必须指定事务应该如何传播。<br>Spring定义了七种传播行为：</p><ul><li>PROPAGATION_REQUIRED:表示当前方法必须运行在事务中，如果当前事务存在，方法将会在该事务中运行。否则，会启动一个新的事务。</li><li>PROPAGATION_SUPPORTS:表示当前方法不需要事务上下文，但是如果存在当前事务的话，那么该方法会在这个事务中运行。</li><li>PROPAGATION_MANDATORY:表示该方法必须在事务中运行，如果当前事务不存在的话，则会抛出一个异常。</li><li>PROPAGATION_REQUIRED_NEW:表示当前方法必须运行在它自己的事务中。一个新事务将被启动。如果存在当前事务，那么该方法执行期间，当前事务会被挂起。</li><li>PROPAGATION_NOT_SUPPORTED:表示该方法不应该运行在事务中，如果存在当前事务，在该方法运行期间，当前事务将被挂起。</li><li>PROPAGATION_NEVER:当前方法不应该运行在事务上下文环节中。如果当前正有一个事务在运行，则会抛出异常。</li><li>PROPAGATION_NESTED:表示当前已经存在一个事务，那么该方法将会在嵌套事务中运行。嵌套的事务可以独立于当前事务进行单独地提交或回滚。</li></ul><h2><span id="spring的隔离级别">Spring的隔离级别</span></h2><ul><li>DEFAULT:默认的隔离级别，使用数据库默认的事务隔离级别。</li><li>未提交读：允许读取未提交的读，可能导致脏读，不可重复读，幻读。</li><li>已提交读：允许读取已提交读，可能导致不可重复读，幻读。</li><li>可重复读：不能更新另一个事务修改但未提交的数据，可能引起幻读。</li><li>串行化：序列执行效率低。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;事务的ACID&quot;&gt;&lt;a href=&quot;#事务的ACID&quot; class=&quot;headerlink&quot; title=&quot;事务的ACID&quot;&gt;&lt;/a&gt;事务的ACID&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Atomicity原子性：事务是一个原子操作，由一些列动作组成，事务的原子性确保动作要么全部完成，要么都不完成。&lt;/li&gt;
&lt;li&gt;Consistency一致性：一旦事务完成，系统必须确保它锁建模的业务处于一致的状态，而不是部分完成或部分失败。&lt;/li&gt;
&lt;li&gt;Isolation隔离性：可能有许多事务会同时处理相同的数据，因此每个事务都应该与其它事务隔离开来，防止数据破坏。&lt;/li&gt;
&lt;li&gt;Durability持久性：一旦事务完成，无论系统发生什么故障，它的结果都不应该受到影响，这样就能从任何系统崩溃中恢复过来，通常情况下，事务的结果会被持久化到存储器中。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>CopyOnWriteArrayList,CopyOnWriteArraySet源码分析</title>
    <link href="http://yoursite.com/2020/01/15/CopyOnWriteArrayList,CopyOnWriteArraySet%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2020/01/15/CopyOnWriteArrayList,CopyOnWriteArraySet源码分析/</id>
    <published>2020-01-15T03:21:56.000Z</published>
    <updated>2020-01-15T03:32:50.347Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="概述">概述</span></h2><p><code>CopyOnWriteArrayList</code>是一个线程安全的<code>ArrayList</code>，通过内部的<code>volatile</code>数组和显示锁ReentrantLock来实现线程安全。<code>CopyOnWriteArraySet</code>的底层也是基于<code>CopyOnWriteArrayList</code>实现的。<code>CopyOnWriteArrayList</code>更适合于读多写少的环节。</p><a id="more"></a><h2><span id="copyonwritearraylist源码分析">CopyOnWriteArrayList源码分析</span></h2><h3><span id="核心属性">核心属性</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** The lock protecting all mutators */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">transient</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="comment">/** 用于存储元素的volatile修饰的内部数组 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Object[] array;</span><br></pre></td></tr></table></figure><p>它的内部属性也非常的简单,值得注意的是array是通过volatile修饰的。</p><h3><span id="重要方法分析">重要方法分析</span></h3><h4><span id="add方法">add方法</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();<span class="comment">//加锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//拿到原数组</span></span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        <span class="comment">//将原数组拷贝到原长度+1的新数组中</span></span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//将元素加入</span></span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        <span class="comment">//用新数组替代原数组</span></span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//解锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这段代码我们可以看出<code>CopyOnWriteArrayList</code>每次添加元素都是直接创建一个长度为原数组长度加一的新数组，然后将该旧数组的数据复制到新数组中。然后将待添加的元素添加到新数组的最后一个位置。最后将旧数组用新数组替换掉。</p><h3><span id="get">get</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> get(getArray(), index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> E <span class="title">get</span><span class="params">(Object[] a, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (E) a[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>get方法非常的简单，不过我们需要注意一点<strong>get方法并没有做同步</strong>。</p><p>通过看了add和get两个方法的实现。我们可以发现add是使用了同步的，而get没有使用同步。在这个地方我的理解是：get之所以不需要同步，这是因为get的读取，本质上是“快照读”。add方法z每次都要复制一份，因为这样写操作不会影响读的。</p><p>至于为什么add要加锁，这个也非常好理解，因为如果不加锁的话，会出现更新丢失。</p><h2><span id="copyonwritearrayset源码分析">CopyOnWriteArraySet源码分析</span></h2><h3><span id="核心属性">核心属性</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> CopyOnWriteArrayList&lt;E&gt; al;</span><br></pre></td></tr></table></figure><p><code>CopyOnWriteArraySet</code>内部其实只有一个<code>CopyOnWriteArrayList</code>.</p><h3><span id="重要方法">重要方法</span></h3><h4><span id="add方法">add方法</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> al.addIfAbsent(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addIfAbsent</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    Object[] snapshot = getArray();</span><br><span class="line">    <span class="comment">//如果数组中已经存在e，则返回false，否则调用addIfAbsent</span></span><br><span class="line">    <span class="keyword">return</span> indexOf(e, snapshot, <span class="number">0</span>, snapshot.length) &gt;= <span class="number">0</span> ? <span class="keyword">false</span> :</span><br><span class="line">        addIfAbsent(e, snapshot);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addIfAbsent</span><span class="params">(E e, Object[] snapshot)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();<span class="comment">//加锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] current = getArray();<span class="comment">//拿到当前的数组</span></span><br><span class="line">        <span class="keyword">int</span> len = current.length;</span><br><span class="line">        <span class="keyword">if</span> (snapshot != current) &#123;</span><br><span class="line">            <span class="comment">// Optimize for lost race to another addXXX operation</span></span><br><span class="line">            <span class="keyword">int</span> common = Math.min(snapshot.length, len);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; common; i++)</span><br><span class="line">                <span class="keyword">if</span> (current[i] != snapshot[i] &amp;&amp; eq(e, current[i]))</span><br><span class="line">                <span class="comment">//在添加过程中有其它线程插入的元素</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (indexOf(e, current, common, len) &gt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(current, len + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//将当前元素加入到了新数组的最后一个位置</span></span><br><span class="line">        newElements[len] = e; </span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//作用就是在数组中查找是否o已经存在，包括null</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o, Object[] elements,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">int</span> index, <span class="keyword">int</span> fence)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//如果o为空，遍历找到数组中第一个同样为空的位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; fence; i++)</span><br><span class="line">            <span class="keyword">if</span> (elements[i] == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//如果o不为空，则找到与之相等的元素的位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; fence; i++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elements[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//数组中没有该元素，返回-1</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个插入过程：</p><ul><li>调用<code>indexOf</code>方法，查看快照数组中是否已经有该元素了（包括null），如果已经有该元素了，那么返回false，否则进行调用<code>addIfAbsent</code>添加元素</li><li><code>addIfAbsent</code>方法全程加锁。首先将之前的快照与当前数组快照进行比较，如果当前数组快照相较于之前数组快照已经发送了改变，那么说明已经有线程完成了添加，那么当前线程竞争失败，直接返回false（为了避免之前线程更新丢失）。如果没有改变。那么就复制一个长度是原数组长度加一的数组，然后将元素添加到尾部，更新数组。</li></ul><p>通过源码我们可以知道，<code>CopyOnWriteArraySet</code>允许加入null。并且<code>CopyOnWriteArraySet</code>保证元素不重复，就是简简单单的遍历查找一遍。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;&lt;code&gt;CopyOnWriteArrayList&lt;/code&gt;是一个线程安全的&lt;code&gt;ArrayList&lt;/code&gt;，通过内部的&lt;code&gt;volatile&lt;/code&gt;数组和显示锁ReentrantLock来实现线程安全。&lt;code&gt;CopyOnWriteArraySet&lt;/code&gt;的底层也是基于&lt;code&gt;CopyOnWriteArrayList&lt;/code&gt;实现的。&lt;code&gt;CopyOnWriteArrayList&lt;/code&gt;更适合于读多写少的环节。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="源码" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ的消息确认机制</title>
    <link href="http://yoursite.com/2020/01/14/RabbitMQ%E7%9A%84%E6%B6%88%E6%81%AF%E7%A1%AE%E8%AE%A4%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2020/01/14/RabbitMQ的消息确认机制/</id>
    <published>2020-01-14T13:46:56.000Z</published>
    <updated>2020-01-14T13:46:36.985Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="简介">简介</span></h2><p>RabbitMQ中提供了消息确认的机制，通过消息确认机制可以确保我们的消息可靠的送达到用户的手中。即便消息丢失掉，我们也可以通过重发来确保消息送达。<br>RabbitMQ提供了两种消息确认的机制：</p><ul><li>通过AMQP事务机制来实现消息确认，这是通过AMQP协议来实现的。</li><li>通过将channel设置为confirm模式来实现</li></ul><a id="more"></a><h2><span id="amqp事务">AMQP事务</span></h2><p>在编程中与AMQP事务相关的主要有三个方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">txSelect(); <span class="comment">//将channel设置为transaction模式</span></span><br><span class="line">txCommit(); <span class="comment">//提交事务</span></span><br><span class="line">txRollback(); <span class="comment">//回滚事务</span></span><br></pre></td></tr></table></figure></p><p>它的代码实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//消息生产者的实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Send</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME=<span class="string">"queue_transition"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Connection connection = ConnectionUtils.getConnection();</span><br><span class="line">        <span class="keyword">final</span> Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将当前channel设置为transition</span></span><br><span class="line">        channel.txSelect();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            channel.basicPublish(<span class="string">""</span>,QUEUE_NAME,<span class="keyword">null</span>,<span class="string">"消息内容"</span>.getBytes());</span><br><span class="line">            <span class="comment">//提交事务</span></span><br><span class="line">            channel.txCommit();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"事务归滚"</span>);</span><br><span class="line">            <span class="comment">//回滚事务</span></span><br><span class="line">            channel.txRollback();</span><br><span class="line">        &#125;</span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>消息消费者的实现和普通的消息消费者没有区别。</p><p>消息发送的过程大致如下：</p><ul><li>client发送tx.select</li><li>broker发送tx.select-ok</li><li>client发送消息到broker</li><li>client发送tx.commit</li><li>broker发送tx.commit-ok</li></ul><p>如果在发送消息的时候发生了一次，进行了回滚，那么整个流程如下：</p><ul><li>client发送tx.select</li><li>broker发送tx.select-ok</li><li>client发送消息到broker</li><li>client发送tx.rollback</li><li>broker发送tx.rollback-ok</li></ul><p>因为在消息发送到队列之前就回滚了，所以接收端也不会收到消息了。当我们发现事务回滚了的时候，就可以进行相应的补救措施。</p><h2><span id="confirm模式">Confirm模式</span></h2><p>使用AMQP事务来实现消息的确认会极大的损失性能。我们可以使用Confirm模式这种性能更高的做法。<br>Confirm可以分为两个方面，一方面是消息的生产者的confirm模式，一方面是消息消费者的confirm模式。消息消费者的confirm模式即手动消息确认和自动消息确认。</p><p>消息消费者的消息确认：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 手动确认消息</span></span><br><span class="line">channel.basicAck(envelope.getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭自动确认</span></span><br><span class="line"><span class="keyword">boolean</span> autoAck = <span class="keyword">false</span>;</span><br><span class="line">channel.basicConsume(QUEUE_NAME, autoAck, consumer);</span><br></pre></td></tr></table></figure></p><p>消息发送的原理图如下；<br><img src="https://s2.ax1x.com/2020/01/14/lqO4mT.png" alt="lqO4mT.png"></p><p>channel要么设置为confirm模式，要么设置为事务模式。<br>在消息生产者的信道上设置为confirm模式，一但信道进入confirm模式，那么在该信道上发送的所有的消息都会被指派一个唯一的ID，一但消息被投递到所有匹配的队列之后，Broker就会发送一个确认给消息生产者。<br>Confirm模式的一大好处在于，它是异步的，发送了消息之后可以在等待确认的同时继续发送另一条消息。</p><h3><span id="普通confirm模式">普通Confirm模式</span></h3><p>消息发送者的实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Send</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME=<span class="string">"confirm_queue"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException, InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Connection connection = ConnectionUtils.getConnection();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将channel设置为confirm模式</span></span><br><span class="line">        channel.confirmSelect();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line"></span><br><span class="line">            channel.basicPublish(<span class="string">""</span>,QUEUE_NAME, MessageProperties.PERSISTENT_BASIC,(<span class="string">"第"</span>+i+<span class="string">"条消息"</span>).getBytes());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(channel.waitForConfirms())&#123;</span><br><span class="line">                System.out.println(<span class="string">"消息发送成功"</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//消息发送失败的处理</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>消息接收者的实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recv</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>  <span class="keyword">final</span> String QUEUE_NAME=<span class="string">"confirm_queue"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Connection connection = ConnectionUtils.getConnection();</span><br><span class="line">        <span class="keyword">final</span> Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> DefaultConsumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                System.out.println(<span class="keyword">new</span> String(body, <span class="string">"utf-8"</span>));</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        channel.basicConsume(QUEUE_NAME,<span class="keyword">true</span>,consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3><span id="批量confirm模式">批量Confirm模式</span></h3><p>消息生产者的不同之处：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">channel.confirmSelect();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line"></span><br><span class="line">    channel.basicPublish(<span class="string">""</span>,QUEUE_NAME, MessageProperties.PERSISTENT_BASIC,(<span class="string">"第"</span>+i+<span class="string">"条消息"</span>).getBytes());</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//发送一批消息之后，才进行确认</span></span><br><span class="line"><span class="keyword">if</span>(channel.waitForConfirms())&#123;</span><br><span class="line">    System.out.println(<span class="string">"消息发送成功"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//消息发送失败的处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们也可以在消息发送者中对每条消息进行监听处理：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">channel.addConfirmListener(<span class="keyword">new</span> ConfirmListener() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleAck</span><span class="params">(<span class="keyword">long</span> l, <span class="keyword">boolean</span> b)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"消息"</span>+l+<span class="string">"投递成功"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleNack</span><span class="params">(<span class="keyword">long</span> l, <span class="keyword">boolean</span> b)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"消息"</span>+l+<span class="string">"投递失败"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h3><span id="异步confirm模式">异步Confirm模式</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Send</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME=<span class="string">"confirm_queue"</span>;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">static</span> SortedSet&lt;Long&gt; confirmSet= Collections.synchronizedSortedSet(<span class="keyword">new</span> TreeSet&lt;Long&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException, InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Connection connection = ConnectionUtils.getConnection();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将channel设置为confirm模式</span></span><br><span class="line">        channel.confirmSelect();</span><br><span class="line">        channel.addConfirmListener(<span class="keyword">new</span> ConfirmListener() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleAck</span><span class="params">(<span class="keyword">long</span> deliveryTag, <span class="keyword">boolean</span> multiple)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (multiple) &#123;</span><br><span class="line">                    confirmSet.headSet(deliveryTag + <span class="number">1L</span>).clear();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    confirmSet.remove(deliveryTag);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleNack</span><span class="params">(<span class="keyword">long</span> deliveryTag, <span class="keyword">boolean</span> multiple)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (multiple) &#123;</span><br><span class="line">                    confirmSet.headSet(deliveryTag + <span class="number">1L</span>).clear();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    confirmSet.remove(deliveryTag);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> no = channel.getNextPublishSeqNo();</span><br><span class="line"></span><br><span class="line">            channel.basicPublish(<span class="string">""</span>,QUEUE_NAME, MessageProperties.PERSISTENT_BASIC,(<span class="string">"第"</span>+i+<span class="string">"条消息"</span>).getBytes());</span><br><span class="line"></span><br><span class="line">            confirmSet.add(no);</span><br><span class="line">        &#125;</span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;RabbitMQ中提供了消息确认的机制，通过消息确认机制可以确保我们的消息可靠的送达到用户的手中。即便消息丢失掉，我们也可以通过重发来确保消息送达。&lt;br&gt;RabbitMQ提供了两种消息确认的机制：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过AMQP事务机制来实现消息确认，这是通过AMQP协议来实现的。&lt;/li&gt;
&lt;li&gt;通过将channel设置为confirm模式来实现&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="RabbitMQ" scheme="http://yoursite.com/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>ConcurrentHashMap源码分析</title>
    <link href="http://yoursite.com/2020/01/14/ConcurrentHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2020/01/14/ConcurrentHashMap源码分析/</id>
    <published>2020-01-14T11:55:56.000Z</published>
    <updated>2020-01-14T11:55:53.856Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="概述">概述</span></h2><p>ConcurrentHashmap是一个支持并发检索和并发更新的线程安全的HashMap,它是不支持空key和value的。ConcurrentHashMap在JDK1.7之前使用的Lock和Segment（分段锁）来实现并发安全的，JDK1.8改用CAS和synchronized来实现的。我们这次主要分析JDK1.8中的实现方式。</p><a id="more"></a><h2><span id="简单使用">简单使用</span></h2><p>ConcurrentHashMap在使用上和我们平时常用的HashMap差异不是很大。只不过一个支持并发操作，一个不支持并发操作而已。<br>下面我们就写一个非常非常简单的例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ConcurrentHashMap&lt;Integer,Integer&gt; map=<span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    System.out.println(map.get(<span class="number">1</span>));</span><br><span class="line">&#125;`</span><br></pre></td></tr></table></figure></p><p>下面我们就针对这个例子，分析一下其内部实现。</p><h2><span id="源码分析">源码分析</span></h2><h3><span id="数据结构">数据结构</span></h3><p><img src="https://s2.ax1x.com/2020/01/14/lbaPOJ.png" alt="lbaPOJ.png"><br>从图中我们可以看出有许多种的节点类。那么我们下面就分别解释一波这些节点类。<br><img src="https://s2.ax1x.com/2020/01/14/lba3TI.png" alt="lba3TI.png"></p><p><code>Node&lt;K,V&gt;</code>这个节点类是最基础的，它存储了键值对（值使用了volatile关键字确保可见性），hash值，下一个节点的引用。</p><p><code>TreeNode&lt;K,V&gt;</code>，这个节点类表示红黑树节点，当链表的长度大于等于8，且数组的长度大于64的时候，就会将链表节点转换为红黑树节点，然后将这些红黑树节点放到TreeBin对象中，由TreeBin对象来完成对红黑树的封装。</p><p><code>TreeBin&lt;K,V&gt;</code>,封装了红黑树根节点。</p><p><code>ForwardingNode&lt;K, V&gt;</code>,在节点转移的时候，用于连接两个table的节点类。它的内部包含一个nextTable指针，指向下一个table。这个节点仅仅作为占位节点表示当前节点已经被移动。</p><p><code>ReservationNode&lt;K,V&gt;</code>这个也是一个占位节点，表示当前节点已经被占用。</p><h3><span id="重要属性">重要属性</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*最大容量*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*默认容量*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*数组的最大容量*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*默认的最大并发数，为了兼容1.7*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CONCURRENCY_LEVEL = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*负载因子*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*链表转红黑树的阈值*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*红黑树转链表的阈值*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*转红黑树时，数组容量的最小要求*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*扩容的最小转移节点数*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TRANSFER_STRIDE = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*sizeCtl中记录stamp的位数*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> RESIZE_STAMP_BITS = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*帮助扩容时的最大线程数*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_RESIZERS = (<span class="number">1</span> &lt;&lt; (<span class="number">32</span> - RESIZE_STAMP_BITS)) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*size在sizeCtl中的偏移量*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESIZE_STAMP_SHIFT = <span class="number">32</span> - RESIZE_STAMP_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*存放节点的数组*/</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*一个过度表，只会在扩容的时候使用*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*基础计数器值*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">long</span> baseCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*控制table初始化和扩容操作*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> sizeCtl;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*节点转移时，下一个需要转移的table索引*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> transferIndex;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*元素变化时用于控制自旋*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> cellsBusy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*保存table中每个节点的元素个数作*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> CounterCell[] counterCells;</span><br></pre></td></tr></table></figure><h3><span id="重要方法源码分析">重要方法源码分析</span></h3><h4><span id="put方法">put方法</span></h4><p>put方法，实际上是调用了<code>V putVal(K key, V value, boolean onlyIfAbsent)</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>V putVal(K key, V value, boolean onlyIfAbsent)</code>的具体实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//从这个地方可以看出是不支持空值和空键的。</span></span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="comment">//计算hash值</span></span><br><span class="line">        <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">        <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123; <span class="comment">//自旋</span></span><br><span class="line">            Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">            <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">                <span class="comment">//还未初始化，进行初始化</span></span><br><span class="line">                tab = initTable();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//索引i的位置为空，直接插入</span></span><br><span class="line">                <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                             <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                             <span class="comment">//CAS插入节点，成功了的话就直接返回</span></span><br><span class="line">                    <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            <span class="comment">//当前节点正在进行移动状态，帮助移动</span></span><br><span class="line">                tab = helpTransfer(tab, f);</span><br><span class="line">            <span class="keyword">else</span> &#123;<span class="comment">//hash冲突的处理</span></span><br><span class="line">                V oldVal = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">synchronized</span> (f) &#123; <span class="comment">//进行加锁操作</span></span><br><span class="line">                    <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">//f.hash&gt;=0说明f是链表的头</span></span><br><span class="line">                <span class="comment">//用于记录链表的节点数，后面以此来判断是否转为红黑树</span></span><br><span class="line">                            binCount = <span class="number">1</span>; </span><br><span class="line">                            <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                                K ek;</span><br><span class="line">                                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                    ((ek = e.key) == key ||</span><br><span class="line">                                     (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                    oldVal = e.val;</span><br><span class="line">                                    <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                        e.val = value;</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                Node&lt;K,V&gt; pred = e;</span><br><span class="line">                                <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                <span class="comment">//将当前节点插入到链表尾部</span></span><br><span class="line">                                    pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                              value, <span class="keyword">null</span>);</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//当前位置已经采用红黑树</span></span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                            Node&lt;K,V&gt; p;</span><br><span class="line">                            binCount = <span class="number">2</span>;</span><br><span class="line">                            <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                           value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                oldVal = p.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    p.val = value;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                        <span class="comment">//链表长度已经达到阈值了，需要转换为红黑树了</span></span><br><span class="line">                        treeifyBin(tab, i);</span><br><span class="line">                    <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                        <span class="keyword">return</span> oldVal;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//更新元素的数量</span></span><br><span class="line">        addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>下面我们就梳理一下，整个put操作的整个流程：</p><ul><li>计算key的hash值，并根据hash值计算索引i</li><li>如果但其哈希表还未初始化就调用<code>initTable()</code>进行初始化</li><li>如果索引i的位置为空，那么就直接CAS将当前节点放入该位置即可。</li><li>如果当前节点的hash值为-1，即当前节点处于移动状态，那么就调用<code>helpTransfer(tab, f)</code>帮助扩容</li><li>如果不满足上述两种情况，那么使用synchronized进行加锁后，进行hash冲突处理。<ul><li>如果位置i是个链表，那么就遍历整个链表，如果在遍历的过程中，<strong>发现了某个节点的hash值与当前key的哈希值相同，那么就覆盖该节点，并停止遍历</strong>。如果到了链表尾部了，那么就创建一个新的节点加入链表尾部。</li><li>如果位置i上为<code>TreeBin</code>。说明这个位置是红黑树，那么就调用<code>putTreeVal</code>方法，要么覆盖某个节点，要么创建一个新节点加入。</li></ul></li><li>插入完毕之后，如果是链表的话会检查链表的长度，如果达到链表转红黑树的阈值的话，会进行链表转红黑树的操作</li><li>最后调用<code>addCount</code>方法，更新元素的数量</li></ul><p>把整个流程看下来，我们发现在整个流程中，还有几个方法起到了非常重要的作用。<br>它们分别是<code>initTable()</code>,<code>helpTransfer(tab, f)</code>，<code>treeifyBin(tab, i);</code>，<code>addCount(1L, binCount);</code>下面我们就仔细分析一波这些方法。</p><h4><span id="inittable方法">initTable方法</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;<span class="comment">//自旋，直到初始化完成</span></span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)<span class="comment">//其它线程在初始化或转移时，让出CPU</span></span><br><span class="line">            Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="comment">//设置sizectl为-1，表示当前线程正在初始化</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                    <span class="comment">//初始化</span></span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    <span class="comment">//设置扩容阈值（0.75*n）</span></span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//将sizeCtl设置为0.75*n</span></span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在初始化过程中，首先会判断是否有线程正在初始化，如果正在初始化，那么就让出CPU时间片，自旋等待创建成功。如果没有线程正在初始化，那么该线程就会开始初始化。</p><p>那么是如和判断是否有其它线程正在初始化，和保障自己在创建过程中其它线程不会创建呢？<br>这个时候<code>sizeCtl</code>起到了非常重要的作用，一个线程开始初始化就会将<code>sizeCtl</code>设置为-1，这样其它线程就可以以此判断已经有线程在初始化了。初始化完成之后，会将<code>sizeCtl</code>设置为0.75*n。</p><h4><span id="helptransfer方法">helpTransfer方法</span></h4><p>这个方法的作用是帮助其它线程进行转移操作<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] nextTab; <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="keyword">if</span> (tab != <span class="keyword">null</span> &amp;&amp; (f <span class="keyword">instanceof</span> ForwardingNode) &amp;&amp;</span><br><span class="line">        (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//计算操作栈校验码</span></span><br><span class="line">        <span class="keyword">int</span> rs = resizeStamp(tab.length);</span><br><span class="line">        <span class="keyword">while</span> (nextTab == nextTable &amp;&amp; table == tab &amp;&amp;</span><br><span class="line">               (sc = sizeCtl) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                sc == rs + MAX_RESIZERS || transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//不需要转移，跳出</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>)) &#123;<span class="comment">/*CAS</span></span><br><span class="line"><span class="comment">            更新帮助转移的线程数*/</span></span><br><span class="line">                <span class="comment">//调用transfer进行真正的转移</span></span><br><span class="line">                transfer(tab, nextTab);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nextTab;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> table;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4><span id="transfer方法">transfer方法</span></h4><p>transfer方法的作用，主要是转移或复制节点到新的table<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = tab.length, stride;</span><br><span class="line">        <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">            stride = MIN_TRANSFER_STRIDE; <span class="comment">// subdivide range</span></span><br><span class="line">        <span class="keyword">if</span> (nextTab == <span class="keyword">null</span>) &#123;            <span class="comment">// initiating</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                <span class="comment">//建立一个比长两倍的nextTab</span></span><br><span class="line">                Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">                nextTab = nt;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;      <span class="comment">// try to cope with OOME</span></span><br><span class="line">                sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            nextTable = nextTab;</span><br><span class="line">            transferIndex = n; <span class="comment">//初始化table的最后一个索引</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> nextn = nextTab.length;</span><br><span class="line">        <span class="comment">/*初始化ForwardingNode节点，它持有nextTab的引用，每处理完后，</span></span><br><span class="line"><span class="comment">        用该节点进行占位，表示该位置已经处理*/</span></span><br><span class="line">        ForwardingNode&lt;K,V&gt; fwd = <span class="keyword">new</span> ForwardingNode&lt;K,V&gt;(nextTab);</span><br><span class="line">        <span class="keyword">boolean</span> advance = <span class="keyword">true</span>; <span class="comment">//节点是否已经处理</span></span><br><span class="line">        <span class="keyword">boolean</span> finishing = <span class="keyword">false</span>; <span class="comment">// to ensure sweep before committing nextTab</span></span><br><span class="line">        <span class="comment">//i：当前处理的node的索引，bound表示需要处理节点的索引边界</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, bound = <span class="number">0</span>;;) &#123;</span><br><span class="line">            Node&lt;K,V&gt; f; <span class="keyword">int</span> fh;</span><br><span class="line">            <span class="keyword">while</span> (advance) &#123;</span><br><span class="line">            <span class="comment">/*nextIndex：下一个需要处理的节点索引，</span></span><br><span class="line"><span class="comment">            nextBound下一个需要处理节点的边界*/</span></span><br><span class="line">                <span class="keyword">int</span> nextIndex, nextBound;</span><br><span class="line">                <span class="keyword">if</span> (--i &gt;= bound || finishing)</span><br><span class="line">                    advance = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//节点已全部转移</span></span><br><span class="line">                    i = -<span class="number">1</span>;</span><br><span class="line">                    advance = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/*更新transferIndex（初始值为最后一个节点的索引）表示</span></span><br><span class="line"><span class="comment">                从transferIndex开始，后面的节点的转移任务已经被领取了</span></span><br><span class="line"><span class="comment">                在这个地方更新transferIndex的值(transferIndex-stride)</span></span><br><span class="line"><span class="comment">                同时更新索引的边界</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt</span><br><span class="line">                         (<span class="keyword">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class="line">                          nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                       nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line">                    bound = nextBound;</span><br><span class="line">                    i = nextIndex - <span class="number">1</span>;</span><br><span class="line">                    advance = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">                <span class="keyword">int</span> sc;</span><br><span class="line">                <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">                <span class="comment">//已经完成转移，更新相关属性</span></span><br><span class="line">                    nextTable = <span class="keyword">null</span>;</span><br><span class="line">                    table = nextTab;</span><br><span class="line">                    <span class="comment">//更新扩容阈值</span></span><br><span class="line">                    sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//当前线程任务完成，sizectl-1.每个线程的任务完成之后都是如此</span></span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;               </span><br><span class="line">                <span class="comment">//判断是否 还有其它线程在执行</span></span><br><span class="line">                    <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                        <span class="keyword">return</span>;<span class="comment">//还有线程在执行，直接返回</span></span><br><span class="line">                    <span class="comment">//否则，再检查一遍，说明当前线程就是最后一个完成</span></span><br><span class="line">                    <span class="comment">//任务的线程了，它需要做一次检查</span></span><br><span class="line">                    finishing = advance = <span class="keyword">true</span>;</span><br><span class="line">                    i = n; <span class="comment">// recheck before commit</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">//当前位置为null，直接替换为ForwardingNode，表明该位置已经被处理</span></span><br><span class="line">                advance = casTabAt(tab, i, <span class="keyword">null</span>, fwd);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            <span class="comment">//如果这个位置已经被处理过了，那么跳过该位置</span></span><br><span class="line">                advance = <span class="keyword">true</span>; <span class="comment">// already processed</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//对当前位置的节点进行真正的转移</span></span><br><span class="line">                <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line"><span class="comment">//处理当前拿到的节点，构建两个node：ln原位置，hn：i+1位置</span></span><br><span class="line">                        Node&lt;K,V&gt; ln, hn;</span><br><span class="line">                        <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">//入轨哦当前为链表节点</span></span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">//fh&amp;n将链表中的元素分为两部分</span></span><br><span class="line">                            <span class="keyword">int</span> runBit = fh &amp; n;</span><br><span class="line">                            Node&lt;K,V&gt; lastRun = f;</span><br><span class="line">                            <span class="comment">//从索引i查找到最后一个有效节点</span></span><br><span class="line">                            <span class="keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="keyword">null</span>; p = p.next) &#123;</span><br><span class="line">                                <span class="keyword">int</span> b = p.hash &amp; n;</span><br><span class="line">                                <span class="keyword">if</span> (b != runBit) &#123;</span><br><span class="line">                                    runBit = b;</span><br><span class="line">                                    lastRun = p;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (runBit == <span class="number">0</span>) &#123;</span><br><span class="line">                                ln = lastRun;</span><br><span class="line">                                hn = <span class="keyword">null</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                hn = lastRun;</span><br><span class="line">                                ln = <span class="keyword">null</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">                                <span class="keyword">int</span> ph = p.hash; K pk = p.key; V pv = p.val;</span><br><span class="line">                                <span class="comment">//将链表分解为两部分</span></span><br><span class="line">                                <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>)</span><br><span class="line">                                <span class="comment">//在原位置</span></span><br><span class="line">                                    ln = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                <span class="comment">//在i+1位置</span></span><br><span class="line">                                    hn = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">//放入nextTable的指定的位置</span></span><br><span class="line">                            setTabAt(nextTab, i, ln);</span><br><span class="line">                            setTabAt(nextTab, i + n, hn);</span><br><span class="line">                            <span class="comment">//在table位置上插入forwardNode节点，表示该位置已经处理</span></span><br><span class="line">                            setTabAt(tab, i, fwd);</span><br><span class="line">                            advance = <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        <span class="comment">//如果是红黑树，同样也进行拆分为两部分</span></span><br><span class="line">                            TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                            TreeNode&lt;K,V&gt; lo = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                            TreeNode&lt;K,V&gt; hi = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                            <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">                            <span class="keyword">for</span> (Node&lt;K,V&gt; e = t.first; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                                <span class="keyword">int</span> h = e.hash;</span><br><span class="line">                                TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> TreeNode&lt;K,V&gt;</span><br><span class="line">                                    (h, e.key, e.val, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">if</span> ((h &amp; n) == <span class="number">0</span>) &#123;</span><br><span class="line">                                    <span class="keyword">if</span> ((p.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                                        lo = p;</span><br><span class="line">                                    <span class="keyword">else</span></span><br><span class="line">                                        loTail.next = p;</span><br><span class="line">                                    loTail = p;</span><br><span class="line">                                    ++lc;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">else</span> &#123;</span><br><span class="line">                                    <span class="keyword">if</span> ((p.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                                        hi = p;</span><br><span class="line">                                    <span class="keyword">else</span></span><br><span class="line">                                        hiTail.next = p;</span><br><span class="line">                                    hiTail = p;</span><br><span class="line">                                    ++hc;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">//如果扩容后，已经不需要tree结构了，那么反向转换为链表结构</span></span><br><span class="line">                            ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class="line">                                (hc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(lo) : t;</span><br><span class="line">                            hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">                                (lc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hi) : t;</span><br><span class="line">                            setTabAt(nextTab, i, ln);</span><br><span class="line">                            setTabAt(nextTab, i + n, hn);</span><br><span class="line">                            setTabAt(tab, i, fwd);</span><br><span class="line">                            advance = <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>因为ConcurrentHashMap的扩容，实际上是新建了一个table，因此扩容最主要的任务就是将旧table中的节点转移到新的table中。</p><p>在以下三种情况下，是需要进行转移的：</p><ol><li>对table进行扩容的时候</li><li>在调用<code>addCount</code>方法更新元素的数量的时候，发现元素的数量已经达到扩容的阈值的时候。</li><li>在进行put操作的时候，发现需要加入的位置的节点正在进行转移的时候，那么当前线程会帮助扩容。</li></ol><p>在整个转移的过程中，有两个比较重要的地方，其中一个是<code>transferIndex</code>,它的初始值是最后一个节点，它的含义是：从<code>transferIndex</code>到最后一个节点的转移任务已经被领取。<br>还有一个是<code>forwardNode</code>节点，它用于标记已经处理过的位置。</p><h4><span id="addcount方法">addCount方法</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addCount</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">int</span> check)</span> </span>&#123;</span><br><span class="line">        CounterCell[] as; <span class="keyword">long</span> b, s;</span><br><span class="line">        <span class="keyword">if</span> ((as = counterCells) != <span class="keyword">null</span> ||</span><br><span class="line">            !U.compareAndSwapLong(<span class="keyword">this</span>, BASECOUNT, b = baseCount, s = b + x)) &#123;</span><br><span class="line">            CounterCell a; <span class="keyword">long</span> v; <span class="keyword">int</span> m;</span><br><span class="line">            <span class="keyword">boolean</span> uncontended = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (as == <span class="keyword">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">                (a = as[ThreadLocalRandom.getProbe() &amp; m]) == <span class="keyword">null</span> ||</span><br><span class="line">                !(uncontended =</span><br><span class="line">                  U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123;</span><br><span class="line">                  <span class="comment">//在线程争用资源是，使用fullAddCount计算更新元素</span></span><br><span class="line">                fullAddCount(x, uncontended);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (check &lt;= <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">                <span class="comment">//计算元素的总数，用于之后的扩容</span></span><br><span class="line">            s = sumCount();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (check &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//检查扩容</span></span><br><span class="line">            Node&lt;K,V&gt;[] tab, nt; <span class="keyword">int</span> n, sc;</span><br><span class="line">            <span class="keyword">while</span> (s &gt;= (<span class="keyword">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                   (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                <span class="keyword">int</span> rs = resizeStamp(n);</span><br><span class="line">                <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//其它线程正在进行扩容</span></span><br><span class="line">                    <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                        sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||</span><br><span class="line">                        transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                        transfer(tab, nt);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc,</span><br><span class="line">                                             (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                    transfer(tab, <span class="keyword">null</span>);</span><br><span class="line">                s = sumCount();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4><span id="treeifybin">treeifyBin</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; b; <span class="keyword">int</span> n, sc;</span><br><span class="line">        <span class="keyword">if</span> (tab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//当数组还未超过64的时候，优先使用数组扩容，否则将链表转为红黑树</span></span><br><span class="line">            <span class="keyword">if</span> ((n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">            <span class="comment">//两倍扩容</span></span><br><span class="line">                tryPresize(n &lt;&lt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((b = tabAt(tab, index)) != <span class="keyword">null</span> &amp;&amp; b.hash &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (b) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (tabAt(tab, index) == b) &#123;</span><br><span class="line">                    <span class="comment">//hd为头节点</span></span><br><span class="line">                        TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="comment">//遍历转换节点</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = b; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                            TreeNode&lt;K,V&gt; p =</span><br><span class="line">                                <span class="keyword">new</span> TreeNode&lt;K,V&gt;(e.hash, e.key, e.val,</span><br><span class="line">                                                  <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                            <span class="keyword">if</span> ((p.prev = tl) == <span class="keyword">null</span>)</span><br><span class="line">                                hd = p;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                tl.next = p;</span><br><span class="line">                            tl = p;</span><br><span class="line">                        &#125;</span><br><span class="line">                        setTabAt(tab, index, <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hd));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4><span id="get方法">get方法</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="keyword">int</span> n, eh; K ek;</span><br><span class="line">    <span class="comment">//计算hash值</span></span><br><span class="line">    <span class="keyword">int</span> h = spread(key.hashCode());</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> (p = e.find(h, key)) != <span class="keyword">null</span> ? p.val : <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>get方法的实现与hashmap的实现差不多，就不赘述了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;ConcurrentHashmap是一个支持并发检索和并发更新的线程安全的HashMap,它是不支持空key和value的。ConcurrentHashMap在JDK1.7之前使用的Lock和Segment（分段锁）来实现并发安全的，JDK1.8改用CAS和synchronized来实现的。我们这次主要分析JDK1.8中的实现方式。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="源码" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ的工作模式</title>
    <link href="http://yoursite.com/2020/01/13/RabbitMQ%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/01/13/RabbitMQ的工作模式/</id>
    <published>2020-01-13T12:11:56.000Z</published>
    <updated>2020-01-13T12:11:22.854Z</updated>
    
    <content type="html"><![CDATA[<p>RabbitMQ常用的有6种工作模式，它们分别是简单模式，work模式，发布订阅模式，路由模式，Topic模式。下面就分别解释一下这些工作模式的特点和实现方式。<br><a id="more"></a></p><h2><span id="简单模式">简单模式</span></h2><p><img src="https://s2.ax1x.com/2020/01/13/lHiZhF.png" alt="lHiZhF.png"><br>简单模式的构成由一个消息生产者，一个消息消费者和一个队列组成。</p><p>它的代码实现如下：<br>消息生产者的实现方式<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Send</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String queueName=<span class="string">"simple_queue"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里使用了我们自己编写的一个获取连接的工具类</span></span><br><span class="line">        <span class="keyword">final</span> Connection connection = ConnectionUtils.getConnection();</span><br><span class="line">        <span class="comment">//从连接中拿到一个通道对象</span></span><br><span class="line">        <span class="keyword">final</span> Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//声明一个队列</span></span><br><span class="line">        channel.queueDeclare(queueName,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//向队列中发送消息</span></span><br><span class="line">        channel.basicPublish(<span class="string">""</span>,queueName,<span class="keyword">null</span>,<span class="string">"hello world"</span>.getBytes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭通道和连接</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>消息消费者的实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Resv</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String queueName=<span class="string">"simple_queue"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Connection connection = ConnectionUtils.getConnection();</span><br><span class="line">        <span class="keyword">final</span> Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个消费者</span></span><br><span class="line">        <span class="keyword">final</span> DefaultConsumer consumer = <span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"收到了消息"</span>+<span class="keyword">new</span> String(body));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//第一参数是队列名称，第二个参数指开启自动应答，第三个为消费者</span></span><br><span class="line">        channel.basicConsume(queueName,<span class="keyword">true</span>,consumer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2><span id="work模式">work模式</span></h2><p><img src="https://s2.ax1x.com/2020/01/13/lHVvt0.png" alt="lHVvt0.png"><br>一个消息生产者多个消息消费者，每个消费者获取到的消息都是唯一的。</p><p>消息生产者的实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Send</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String queueName=<span class="string">"simple_queue"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Connection connection = ConnectionUtils.getConnection();</span><br><span class="line">        <span class="comment">//从连接中拿到一个通道对象</span></span><br><span class="line">        <span class="keyword">final</span> Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//声明一个队列</span></span><br><span class="line">        channel.queueDeclare(queueName,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            <span class="comment">//向队列中发送消息</span></span><br><span class="line">            channel.basicPublish(<span class="string">""</span>,queueName,<span class="keyword">null</span>,(i+<span class="string">" hello world"</span>).getBytes());</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭通道和连接</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>两个消息消费者的实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Resv</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String queueName=<span class="string">"simple_queue"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Connection connection = ConnectionUtils.getConnection();</span><br><span class="line">        <span class="keyword">final</span> Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个消费者</span></span><br><span class="line">        <span class="keyword">final</span> DefaultConsumer consumer = <span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"接收者1收到了消息"</span>+<span class="keyword">new</span> String(body));</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(queueName,<span class="keyword">true</span>,consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Resv2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String queueName=<span class="string">"simple_queue"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Connection connection = ConnectionUtils.getConnection();</span><br><span class="line">        <span class="keyword">final</span> Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个消费者</span></span><br><span class="line">        <span class="keyword">final</span> DefaultConsumer consumer = <span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"接收者2收到了消息"</span>+<span class="keyword">new</span> String(body));</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(queueName,<span class="keyword">true</span>,consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果在消息消费者处理消息的时候，消息消费者下线了，那么以上这种模式就会导致消息丢失。我们可以通过消息应当机制来处理这种问题。<br>带有手动消息确认机制的消息消费者的实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Resv</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String queueName=<span class="string">"simple_queue"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Connection connection = ConnectionUtils.getConnection();</span><br><span class="line">        <span class="keyword">final</span> Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        channel.basicQos(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个消费者</span></span><br><span class="line">        <span class="keyword">final</span> DefaultConsumer consumer = <span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"接收者1收到了消息"</span>+<span class="keyword">new</span> String(body));</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//手动发送回执，完成任务之后，手动确认消息</span></span><br><span class="line">                channel.basicAck(envelope.getDeliveryTag(),<span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//第二个参数为false，关闭自动应当</span></span><br><span class="line">        channel.basicConsume(queueName,<span class="keyword">false</span>,consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2><span id="订阅模式">订阅模式</span></h2><p><img src="https://s2.ax1x.com/2020/01/13/lHegII.png" alt="lHegII.png"><br>发布订阅模式，拥有一个消息生产者，交换器，多个消息队列。<br>消息生产者的实现代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Send</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME=<span class="string">"test_exchange_fanout"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Connection connection = ConnectionUtils.getConnection();</span><br><span class="line">        <span class="keyword">final</span> Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义一个交换机，fanout为交换类型，代表不处理路由键</span></span><br><span class="line">        <span class="comment">//fanout交换类型，会把消息推送到所有的队列中去</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME,<span class="string">"fanout"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            <span class="comment">//将消息推送到交换机上，再由交换机将消息转发到相应的消息队列中去，交换机不具备存储能力</span></span><br><span class="line">            channel.basicPublish(EXCHANGE_NAME,<span class="string">""</span>,<span class="keyword">null</span>,(i+<span class="string">" 消息"</span>).getBytes());</span><br><span class="line">        &#125;</span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>消息消费者的代码实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recv1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME=<span class="string">"test_queue1"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME=<span class="string">"test_exchange_fanout"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Connection connection = ConnectionUtils.getConnection();</span><br><span class="line">        <span class="keyword">final</span> Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">//声明队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将队列绑定到，交换机上</span></span><br><span class="line">        channel.queueBind(QUEUE_NAME,EXCHANGE_NAME,<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">        channel.basicQos(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">final</span> DefaultConsumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"收到消息"</span> + <span class="keyword">new</span> String(body, <span class="string">"utf-8"</span>));</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    channel.basicAck(envelope.getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//第二个参数关闭自动应答</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME,<span class="keyword">false</span>,consumer);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>另一个消息消费者的代码(除了声明了另一个队列之外，没有任何的特别之处)：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recv2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME=<span class="string">"test_queue2"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME=<span class="string">"test_exchange_fanout"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Connection connection = ConnectionUtils.getConnection();</span><br><span class="line">        <span class="keyword">final</span> Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">//声明队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//绑定到转发器</span></span><br><span class="line">        channel.queueBind(QUEUE_NAME,EXCHANGE_NAME,<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">        channel.basicQos(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">final</span> DefaultConsumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"收到消息"</span> + <span class="keyword">new</span> String(body, <span class="string">"utf-8"</span>));</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    channel.basicAck(envelope.getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//第二个参数关闭自动应答</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME,<span class="keyword">false</span>,consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2><span id="路由模式">路由模式</span></h2><p><img src="https://s2.ax1x.com/2020/01/13/lHB4pV.png" alt="lHB4pV.png"><br>路由模式和发布订阅模式非常的类似，只不过路由模式的交换器会处理路由键。<br>消息生产者的实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Send</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME=<span class="string">"test_exchange_direct"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Connection connection = ConnectionUtils.getConnection();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Channel channel = connection.createChannel();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//交换机的工作模式设置为direct模式，它会处理路由键</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME,<span class="string">"direct"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            <span class="comment">//路由键为info</span></span><br><span class="line">            channel.basicPublish(EXCHANGE_NAME,<span class="string">"info"</span>,<span class="keyword">null</span>,(i+<span class="string">"info消息"</span>).getBytes());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>消息接收者的实现如下；<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接收者1</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recv</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME=<span class="string">"test_exchange_direct"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME=<span class="string">"test_queue_direct_1"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Connection connection = ConnectionUtils.getConnection();</span><br><span class="line">        <span class="keyword">final</span> Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//该队列指接收路由键为error的</span></span><br><span class="line">        channel.queueBind(QUEUE_NAME,EXCHANGE_NAME,<span class="string">"error"</span>);</span><br><span class="line">        </span><br><span class="line">        channel.basicQos(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">final</span> DefaultConsumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"收到消息"</span> + <span class="keyword">new</span> String(body, <span class="string">"utf-8"</span>));</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    channel.basicAck(envelope.getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//第二个参数关闭自动应答</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME,<span class="keyword">false</span>,consumer);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接收者2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recv2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME=<span class="string">"test_exchange_direct"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME=<span class="string">"test_queue_direct_2"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Connection connection = ConnectionUtils.getConnection();</span><br><span class="line">        <span class="keyword">final</span> Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//该队列会接收以下三种路由键的</span></span><br><span class="line">        channel.queueBind(QUEUE_NAME,EXCHANGE_NAME,<span class="string">"error"</span>);</span><br><span class="line">        channel.queueBind(QUEUE_NAME,EXCHANGE_NAME,<span class="string">"info"</span>);</span><br><span class="line">        channel.queueBind(QUEUE_NAME,EXCHANGE_NAME,<span class="string">"warning"</span>);</span><br><span class="line"></span><br><span class="line">        channel.basicQos(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> DefaultConsumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"收到消息"</span> + <span class="keyword">new</span> String(body, <span class="string">"utf-8"</span>));</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    channel.basicAck(envelope.getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//第二个参数关闭自动应答</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME,<span class="keyword">false</span>,consumer);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2><span id="topic模式">Topic模式</span></h2><p><img src="https://s2.ax1x.com/2020/01/13/lHrp80.png" alt="lHrp80.png"><br>Topic会根据路由键和模式的匹配来决定，将消息发送到哪个队列中去。</p><p>消息生产者的实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Send</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_ANME=<span class="string">"test_exchange_topic"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Connection connection = ConnectionUtils.getConnection();</span><br><span class="line">        <span class="keyword">final</span> Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将交换机设置为topic模式</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_ANME,<span class="string">"topic"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            channel.basicPublish(EXCHANGE_ANME,<span class="string">"goods"</span>,<span class="keyword">null</span>,(i+<span class="string">"消息"</span>).getBytes());</span><br><span class="line">        &#125;</span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>消息消费者的实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//消息消费者A</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recv</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME=<span class="string">"test_exchange_topic"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME=<span class="string">"test_queue_topic_1"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Connection connection = ConnectionUtils.getConnection();</span><br><span class="line">        <span class="keyword">final</span> Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//‘*’表示子匹配一个词，而‘#’表示匹配多个词，词之间使用“.‘分隔</span></span><br><span class="line">        channel.queueBind(QUEUE_NAME,EXCHANGE_NAME,<span class="string">"goods.*"</span>);</span><br><span class="line">        channel.basicQos(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">final</span> DefaultConsumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"收到消息"</span> + <span class="keyword">new</span> String(body, <span class="string">"utf-8"</span>));</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    channel.basicAck(envelope.getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//第二个参数关闭自动应答</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME,<span class="keyword">false</span>,consumer);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//消息消费者B</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recv2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME=<span class="string">"test_exchange_topic"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME=<span class="string">"test_queue_topic_2"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Connection connection = ConnectionUtils.getConnection();</span><br><span class="line">        <span class="keyword">final</span> Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        channel.queueBind(QUEUE_NAME,EXCHANGE_NAME,<span class="string">"goods.add"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        channel.basicQos(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> DefaultConsumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"收到消息"</span> + <span class="keyword">new</span> String(body, <span class="string">"utf-8"</span>));</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    channel.basicAck(envelope.getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//第二个参数关闭自动应答</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME,<span class="keyword">false</span>,consumer);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;RabbitMQ常用的有6种工作模式，它们分别是简单模式，work模式，发布订阅模式，路由模式，Topic模式。下面就分别解释一下这些工作模式的特点和实现方式。&lt;br&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="RabbitMQ" scheme="http://yoursite.com/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>mybatis源码分析一</title>
    <link href="http://yoursite.com/2020/01/13/mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B8%80/"/>
    <id>http://yoursite.com/2020/01/13/mybatis源码分析一/</id>
    <published>2020-01-13T08:13:56.000Z</published>
    <updated>2020-01-13T08:14:11.953Z</updated>
    
    <content type="html"><![CDATA[<p>我们从最简单的一段代码开始，分析清楚mybatis的大致工作流程。然后再从代码细节上分析mybatis的一些特性。</p><h2><span id="基础代码示例">基础代码示例</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">    String resource = <span class="string">"example/mybatis-config.xml"</span>;</span><br><span class="line">    <span class="comment">// 加载配置文件 并构建SqlSessionFactory对象</span></span><br><span class="line">    InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">    SqlSessionFactory factory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">    <span class="comment">// 从SqlSessionFactory对象中获取 SqlSession对象</span></span><br><span class="line">    SqlSession sqlSession = factory.openSession();</span><br><span class="line">    <span class="comment">// 执行操作</span></span><br><span class="line">    User user=<span class="keyword">new</span> User();</span><br><span class="line">    user.setId(<span class="number">1</span>);</span><br><span class="line">    Object u= (User)sqlSession.selectOne(<span class="string">"getUser"</span>, user);</span><br><span class="line">    System.out.println(u.toString());</span><br><span class="line">    <span class="comment">// 关闭SqlSession</span></span><br><span class="line">    sqlSession.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>其中User类其实就是一个只有id，username，password的pojo。我就不粘贴代码了。<br>mybatis当然少不了对应的sql代码了。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"</span></span><br><span class="line"><span class="meta">  "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"example.Dao.UserMapper"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getUser"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span> <span class="attr">resultType</span>=<span class="string">"example.Pojo.User"</span>&gt;</span></span><br><span class="line">        select * from user where id= #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>还有任何框架都少不了的配置。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN"</span></span><br><span class="line"><span class="meta">  "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/mybatis_study?useUnicode=true"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"example/UserMapper.xml"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>代码都粘贴出来了，下面我们就以这段代码为例分析，mybatis的执行流程。</p><h2><span id="执行流程分析">执行流程分析</span></h2><h3><span id="sqlsessionfactory的创建过程">SqlSessionFactory的创建过程</span></h3><p>第一行有效的代码是这个<code>InputStream inputStream = Resources.getResourceAsStream(resource);</code>这个地方，<code>Resources</code>是一个工具类，它的作用就是方便我们加载各种资源文件的。至于它的内部是如何实现的，这都不重要。总之，这行代码所做的工作就是简简单单的加载我们的配置文件。</p><p>我们的重头戏其实是这行代码<code>SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(inputStream);</code><br>我们把这行代码分成两部分分析，第一部分就是<code>new SqlSessionFactoryBuilder()</code>,这个不需要怎么解释，这一部分的作用就是创建一个<code>SqlSessionFactoryBuilder</code>对象，第二部分就是调用了该对象的<code>SqlSessionFactory build(Reader reader)</code>方法，这个方法非常的重要，这个方法实际上最终调用的是另一个重载方法,它的具体实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">build</span><span class="params">(Reader reader, String environment, Properties properties)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     XMLConfigBuilder parser = <span class="keyword">new</span> XMLConfigBuilder(reader, environment, properties);</span><br><span class="line">     <span class="keyword">return</span> build(parser.parse());</span><br><span class="line">   &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">     <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">"Error building SqlSession."</span>, e);</span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">     ErrorContext.instance().reset();</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">       reader.close();</span><br><span class="line">     &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">       <span class="comment">// Intentionally ignore. Prefer previous error.</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>这段代码，如果我们不考虑其它东西的话，这段代码其实就做了三件事情，利用我们传入的配置文件的<code>reader</code>（后面两个参数调用的时候传的是null），创建了一个<code>XMLConfigBuilder</code>对象，然后调用该对象的<code>parse()</code>方法，拿到了一个<code>Configuration</code>对象，利用这个<code>Configuration</code>对象,使用<code>build(Configuration cofig)</code>方法，创建了<code>SqlSessionFactory</code>对象,然后将<code>SqlSessionFactory</code>对象返回。</p><p>下面我们就分别解释这三个步骤到底干了什么。</p><ul><li>第一步：创建<code>XMLConfigBuilder</code>对象。<br>虽然看起来简单的new了一下该对象就创建好了.实际上还是比较复杂的.各种重载的构造器层层调用，最终来到了这个构造器。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">XMLConfigBuilder</span><span class="params">(XPathParser parser, String environment, Properties props)</span> </span>&#123;</span><br><span class="line"><span class="comment">//创建一个空的Configuration对象，实例化了XMLConfigBuilder对象</span></span><br><span class="line">  <span class="keyword">super</span>(<span class="keyword">new</span> Configuration());</span><br><span class="line">  ErrorContext.instance().resource(<span class="string">"SQL Mapper Configuration"</span>);</span><br><span class="line">  <span class="comment">//对属性各种赋值</span></span><br><span class="line">  <span class="comment">//我们配置时分离的Properties文件中的信息，就是在这里进入到mybatis的</span></span><br><span class="line">  <span class="keyword">this</span>.configuration.setVariables(props);</span><br><span class="line">  <span class="keyword">this</span>.parsed = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">this</span>.environment = environment;</span><br><span class="line">  <span class="comment">//parser就是用来解析XML文件的，在之前的构造器中，已经将配置文件的inputStream设置到该对象中去了</span></span><br><span class="line">  <span class="keyword">this</span>.parser = parser;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>既然这个构造器所做的事情基本都是给属性赋值，那么我们就得好好分析一波，<code>XMLConfigBuilder</code>到底有哪些属性，它们的作用是什么。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面三个是继承自父类BaseBuilder中的属性</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 存储基础配置信息的一个对象</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Configuration configuration; </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 故名思意，就是存储各种类型的别名的一个对象</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> TypeAliasRegistry typeAliasRegistry;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 存储各种类型的类型处理器的对象</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> TypeHandlerRegistry typeHandlerRegistry;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 标记该配置文件是否已经解析过</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> parsed;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 解析器模块，配置文件就由它进行解析</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> XPathParser parser;</span><br><span class="line">    <span class="keyword">private</span> String environment;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 默认反射工厂实现</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReflectorFactory localReflectorFactory = <span class="keyword">new</span> DefaultReflectorFactory();</span><br></pre></td></tr></table></figure></p><ul><li>第二步：使用<code>XMLConfigBuilder</code>对象的，<code>Configuration parse()</code>方法，获取到<code>Configuration</code>对象。<br>该方法的实现如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Configuration <span class="title">parse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (parsed) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"Each XMLConfigBuilder can only be used once."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  parsed = <span class="keyword">true</span>;<span class="comment">//将该配置文件标记为已解析</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//对配置文件中的configuration节点下的所有属性进行解析，并将解析到的信息</span></span><br><span class="line">  <span class="comment">//XMLConfigBuilder对象的configuration属性中。</span></span><br><span class="line">  parseConfiguration(parser.evalNode(<span class="string">"/configuration"</span>));</span><br><span class="line">  <span class="comment">//将填充好各种值的configuration返回</span></span><br><span class="line">  <span class="keyword">return</span> configuration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>看完这段代码，我们可以知道，第二部其实就是去解析配置文件中的<code>configuration</code>节点下的信息，去初始化<code>XMLConfigBuilder</code>对象中的<code>configuration</code>属性，然后将初始化完毕的<code>configuration</code>返回即可。</p><ul><li>第三步：利用刚才得到的充满各种配置信息的<code>configuration</code>作为参数，调用<code>SqlSessionFactory build(Configuration config)</code>方法，来构建<code>SqlSessionFactory</code>对象</li></ul><p>它首先是调用了这个方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">build</span><span class="params">(Configuration config)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> DefaultSqlSessionFactory(config);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个方法实例化了一个<code>SqlSessionFactory</code>接口的实现类<code>DefaultSqlSessionFactory</code>.<br>具体的实例化过程如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DefaultSqlSessionFactory</span><span class="params">(Configuration configuration)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.configuration = configuration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>非常的简单，只不过是将<code>configuration</code>传递到了<code>DefaultSqlSessionFactory</code>对象。<br>到此我们已经成功的创建了<code>SqlSessionFactory</code>对象。<br>不过到这里，我们好像忽略了一个非常重要的环节，我们的UserMapperx.xml文件在解析配置文件的<code>configuration</code>节点的时候，是如何处理的呢？</p><h3><span id="创建sqlsessionfactory时是如何处理mapperxml的呢">创建SqlSessionFactory时是如何处理Mapper.xml的呢？</span></h3><p>想要知道我们的Mapper.xml文件是如何处理的，首先要找到是在哪个地方处理的。<br>在我们之前分析<code>SqlSessionFactory</code>的创建过程时，我们就分析到<code>XMLConfigBuilder</code>的<code>Configuration parse()</code>方法，这个方法中就进行了配置文件的解析。那么处理Mapper.xml文件也应该是从这个地方开始的。<br>在<code>Configuration parse()</code>中调用了一个重要的方法<code>void parseConfiguration(XNode root)</code>,它的具体实现如下；<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseConfiguration</span><span class="params">(XNode root)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="comment">//issue #117 read properties first</span></span><br><span class="line">     propertiesElement(root.evalNode(<span class="string">"properties"</span>));</span><br><span class="line">     Properties settings = settingsAsProperties(root.evalNode(<span class="string">"settings"</span>));</span><br><span class="line">     loadCustomVfs(settings);</span><br><span class="line">     loadCustomLogImpl(settings);</span><br><span class="line">     typeAliasesElement(root.evalNode(<span class="string">"typeAliases"</span>));</span><br><span class="line">     pluginElement(root.evalNode(<span class="string">"plugins"</span>));</span><br><span class="line">     objectFactoryElement(root.evalNode(<span class="string">"objectFactory"</span>));</span><br><span class="line">     objectWrapperFactoryElement(root.evalNode(<span class="string">"objectWrapperFactory"</span>));</span><br><span class="line">     reflectorFactoryElement(root.evalNode(<span class="string">"reflectorFactory"</span>));</span><br><span class="line">     settingsElement(settings);</span><br><span class="line">     <span class="comment">// read it after objectFactory and objectWrapperFactory issue #631</span></span><br><span class="line">     environmentsElement(root.evalNode(<span class="string">"environments"</span>));</span><br><span class="line">     databaseIdProviderElement(root.evalNode(<span class="string">"databaseIdProvider"</span>));</span><br><span class="line">     typeHandlerElement(root.evalNode(<span class="string">"typeHandlers"</span>));</span><br><span class="line">     </span><br><span class="line">     <span class="comment">//在这个地方处理的mappers</span></span><br><span class="line">     mapperElement(root.evalNode(<span class="string">"mappers"</span>));</span><br><span class="line">   &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"Error parsing SQL Mapper Configuration. Cause: "</span> + e, e);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>我们查看处理<code>mappers</code>的具体的地方：它的实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mapperElement</span><span class="params">(XNode parent)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (XNode child : parent.getChildren()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"package"</span>.equals(child.getName())) &#123;</span><br><span class="line">          String mapperPackage = child.getStringAttribute(<span class="string">"name"</span>);</span><br><span class="line">          configuration.addMappers(mapperPackage);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          String resource = child.getStringAttribute(<span class="string">"resource"</span>);</span><br><span class="line">          String url = child.getStringAttribute(<span class="string">"url"</span>);</span><br><span class="line">          String mapperClass = child.getStringAttribute(<span class="string">"class"</span>);</span><br><span class="line">          <span class="keyword">if</span> (resource != <span class="keyword">null</span> &amp;&amp; url == <span class="keyword">null</span> &amp;&amp; mapperClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ErrorContext.instance().resource(resource);</span><br><span class="line">            InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">            XMLMapperBuilder mapperParser = <span class="keyword">new</span> XMLMapperBuilder(inputStream, configuration, resource, configuration.getSqlFragments());</span><br><span class="line">            mapperParser.parse();</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (resource == <span class="keyword">null</span> &amp;&amp; url != <span class="keyword">null</span> &amp;&amp; mapperClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ErrorContext.instance().resource(url);</span><br><span class="line">            InputStream inputStream = Resources.getUrlAsStream(url);</span><br><span class="line">            XMLMapperBuilder mapperParser = <span class="keyword">new</span> XMLMapperBuilder(inputStream, configuration, url, configuration.getSqlFragments());</span><br><span class="line">            mapperParser.parse();</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (resource == <span class="keyword">null</span> &amp;&amp; url == <span class="keyword">null</span> &amp;&amp; mapperClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Class&lt;?&gt; mapperInterface = Resources.classForName(mapperClass);</span><br><span class="line">            configuration.addMapper(mapperInterface);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"A mapper element may only specify a url, resource or class, but not more than one."</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>这个方法看起来非常的复杂，但我们至少可以得到一点信息：<br>mapper配置有三种写法：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">url</span>=<span class="string">""</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">""</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">""</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>这个方法看起来非常的复杂，但是它也不过是做三件事情，拿到mapper文件，创建<code>XMLMapperBuilder</code>对象，解析mapper文件。</p><ul><li><p>第一步：根据配置的信息，获取每个节点所指定的mapper文件<br>以mapper的一种配置为例：<br><code>InputStream inputStream = Resources.getResourceAsStream(resource);</code><br>它还是利用了用来加载各种资源文件的强大的<code>Resources</code>工具类。</p></li><li><p>第二步：创建<code>XMLMapperBuilder</code>对象。<br><code>XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, resource, configuration.getSqlFragments());</code><br>创建<code>XMLMapperBuilder</code>的过程，基本上就是实例化，然后将参数中的各种值注入。</p></li><li><p>第三步：解析对应的mapper节点<br><code>mapperParser.parse();</code></p></li></ul><p>这个方法的具体实现如下；<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!configuration.isResourceLoaded(resource)) &#123; <span class="comment">//如果没有解析过</span></span><br><span class="line">      <span class="comment">//解析每个mapper节点中的信息</span></span><br><span class="line">    configurationElement(parser.evalNode(<span class="string">"/mapper"</span>));</span><br><span class="line">    <span class="comment">//将当前文件加入已解析文件集合</span></span><br><span class="line">    configuration.addLoadedResource(resource);</span><br><span class="line">    <span class="comment">//将mapper和命名空间进行绑定</span></span><br><span class="line">    <span class="comment">//本质就是将命名空间所对应的类和mapper文件都加入configuration中</span></span><br><span class="line">    bindMapperForNamespace();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  parsePendingResultMaps();</span><br><span class="line">  parsePendingCacheRefs();</span><br><span class="line">  parsePendingStatements();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个部分涉及到的细节非常的多，如果你熟悉mybatis中mapper的写法你就会知道，mapper中的标签非常的多写法也比较复杂，所有这部分的源码其实也非常的复杂，因此这部分我准备之后专门分析一波。</p><h3><span id="sqlsession的创建过程">SqlSession的创建过程</span></h3><p>经过前面的努力，我们已经拿到了<code>SqlSessionFactory</code>对象。现在就需要创建<code>SqlSession</code>对象了。这个过程，由这行代码来完成。<br><code>SqlSession sqlSession = factory.openSession();</code><br>它的具体实现如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SqlSession <span class="title">openSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> openSessionFromDataSource(configuration.getDefaultExecutorType(), <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个方法中涉及到一个非常重要的方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> SqlSession <span class="title">openSessionFromDataSource</span><span class="params">(ExecutorType execType, TransactionIsolationLevel level, <span class="keyword">boolean</span> autoCommit)</span> </span>&#123;</span><br><span class="line">  Transaction tx = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Environment environment = configuration.getEnvironment();</span><br><span class="line">    <span class="keyword">final</span> TransactionFactory transactionFactory = getTransactionFactoryFromEnvironment(environment);</span><br><span class="line">    tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);</span><br><span class="line">    <span class="comment">//创建执行器</span></span><br><span class="line">    <span class="keyword">final</span> Executor executor = configuration.newExecutor(tx, execType);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DefaultSqlSession(configuration, executor, autoCommit);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    closeTransaction(tx); <span class="comment">// may have fetched a connection so lets call close()</span></span><br><span class="line">    <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">"Error opening session.  Cause: "</span> + e, e);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    ErrorContext.instance().reset();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个方法比较关键的地方就是拿到事务对象，创建执行器。<br>创建执行器的具体实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Executor <span class="title">newExecutor</span><span class="params">(Transaction transaction, ExecutorType executorType)</span> </span>&#123;</span><br><span class="line">  executorType = executorType == <span class="keyword">null</span> ? defaultExecutorType : executorType;</span><br><span class="line">  executorType = executorType == <span class="keyword">null</span> ? ExecutorType.SIMPLE : executorType;</span><br><span class="line">  Executor executor;</span><br><span class="line">  <span class="keyword">if</span> (ExecutorType.BATCH == executorType) &#123;</span><br><span class="line">    executor = <span class="keyword">new</span> BatchExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ExecutorType.REUSE == executorType) &#123;</span><br><span class="line">    executor = <span class="keyword">new</span> ReuseExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    executor = <span class="keyword">new</span> SimpleExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (cacheEnabled) &#123;</span><br><span class="line">    executor = <span class="keyword">new</span> CachingExecutor(executor);</span><br><span class="line">  &#125;</span><br><span class="line">  executor = (Executor) interceptorChain.pluginAll(executor);</span><br><span class="line">  <span class="keyword">return</span> executor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>观察这个方法，我们首先能够得到的信息就是执行器有三种类型。它们分别是：<br>ExecutorType.SIMPLE：这个类型不做任何其它的事情，它为每个语句创建一个PreparedStatement<br>ExecutorType.REUSE：这种类型会重复使用PreparedStatements。<br>ExecutorType.BATCH：这个类型这个类型批量更新，且必要地区别开其中的select 语句，确保动作易于理解。</p><p>我们就以ExecutorType.SIMPLE类型为例，来看一些，创建执行器的时候，到底做了什么事情。<br><code>executor = new SimpleExecutor(this, transaction);</code><br>这行代码实质上是调用了<code>SimpleExecutor</code>的父类<code>BaseExecutor</code>的构造方法。<br>其具体实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">BaseExecutor</span><span class="params">(Configuration configuration, Transaction transaction)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.transaction = transaction;</span><br><span class="line">  <span class="keyword">this</span>.deferredLoads = <span class="keyword">new</span> ConcurrentLinkedQueue&lt;&gt;();</span><br><span class="line">  <span class="keyword">this</span>.localCache = <span class="keyword">new</span> PerpetualCache(<span class="string">"LocalCache"</span>);</span><br><span class="line">  <span class="keyword">this</span>.localOutputParameterCache = <span class="keyword">new</span> PerpetualCache(<span class="string">"LocalOutputParameterCache"</span>);</span><br><span class="line">  <span class="keyword">this</span>.closed = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">this</span>.configuration = configuration;</span><br><span class="line">  <span class="keyword">this</span>.wrapper = <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在构造函数中完成了一些重要属性的注入。其中比较关键的就是<code>transaction</code>属性，这个对象包括了获取数据库连接，提交，回滚等一系列直接操作数据库的方法。<br>这个接口如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Transaction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Retrieve inner database connection.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> DataBase connection</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Commit inner database connection.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Rollback inner database connection.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">rollback</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Close inner database connection.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Get transaction timeout if set.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">Integer <span class="title">getTimeout</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们回到刚才分析的<code>SqlSession openSessionFromDataSource(ExecutorType execType, TransactionIsolationLevel level, boolean autoCommit)</code>.<br>拿到构造器，就可创建<code>SqlSession</code>.<br>具体实现是这行代码：<br><code>return new DefaultSqlSession(configuration, executor, autoCommit);</code><br>调用的构造器的具体实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DefaultSqlSession</span><span class="params">(Configuration configuration, Executor executor, <span class="keyword">boolean</span> autoCommit)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.configuration = configuration;</span><br><span class="line">  <span class="keyword">this</span>.executor = executor;</span><br><span class="line">  <span class="keyword">this</span>.dirty = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">this</span>.autoCommit = autoCommit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们可以看出，将配置信息与执行器封装起来，就得到了<code>SqlSession</code></p><h3><span id="sqlsession是如何操作数据库的">SqlSession是如何操作数据库的</span></h3><p>我们以查询为例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object u= (User)sqlSession.selectOne(<span class="string">"getUser"</span>, user);</span><br></pre></td></tr></table></figure></p><p>具体的实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">selectOne</span><span class="params">(String statement, Object parameter)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Popular vote was to return null on 0 results and throw exception on too many.</span></span><br><span class="line">  List&lt;T&gt; list = <span class="keyword">this</span>.selectList(statement, parameter);</span><br><span class="line">  <span class="keyword">if</span> (list.size() == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (list.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> TooManyResultsException(<span class="string">"Expected one result (or null) to be returned by selectOne(), but found: "</span> + list.size());</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从这段代码，可以看出这段代码起主要作用的就是<code>List&lt;T&gt; list = this.selectList(statement, parameter);</code>这段代码，其余代码都是用于处理返回值的。</p><p>那么下面我们就分析一波<code>selectList(statement, parameter)</code>的具体实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">selectList</span><span class="params">(String statement, Object parameter)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.selectList(statement, parameter, RowBounds.DEFAULT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最终调用了这个重载实现</span></span><br><span class="line">  <span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">selectList</span><span class="params">(String statement, Object parameter, RowBounds rowBounds)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">/*MappedStatement就是对sql语句和相关配置信息的封装，</span></span><br><span class="line"><span class="comment">      基本上执行一个sql所需的信息，MappedStatement中都有*/</span></span><br><span class="line">    MappedStatement ms = configuration.getMappedStatement(statement);</span><br><span class="line">    <span class="keyword">return</span> executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">"Error querying database.  Cause: "</span> + e, e);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    ErrorContext.instance().reset();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这段代码，首先拿到封装了执行该sql的所有信息的<code>MappedStatement</code>对象，然后就调用执行器执行sql。<br>不过，在调用执行器之前，它还对我们的传入的参数进行处理，处理参数的代码是<code>wrapCollection(parameter)</code><br>处理参数的逻辑也非常的简单，基本上就是对复杂参数类型的一种标记。对普通的对象不进行处理。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">wrapCollection</span><span class="params">(<span class="keyword">final</span> Object object)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (object <span class="keyword">instanceof</span> Collection) &#123;</span><br><span class="line">    StrictMap&lt;Object&gt; map = <span class="keyword">new</span> StrictMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">"collection"</span>, object);</span><br><span class="line">    <span class="keyword">if</span> (object <span class="keyword">instanceof</span> List) &#123;</span><br><span class="line">      map.put(<span class="string">"list"</span>, object);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> map;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (object != <span class="keyword">null</span> &amp;&amp; object.getClass().isArray()) &#123;</span><br><span class="line">    StrictMap&lt;Object&gt; map = <span class="keyword">new</span> StrictMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">"array"</span>, object);</span><br><span class="line">    <span class="keyword">return</span> map;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>所有的准备工作，都准备好了之后，就是执行器去执行查询了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line"><span class="comment">//可以理解为对sql信息的进一步处理，更加接近jdbc</span></span><br><span class="line">  BoundSql boundSql = ms.getBoundSql(parameter);</span><br><span class="line">  <span class="comment">//计算缓存的key</span></span><br><span class="line">  CacheKey key = createCacheKey(ms, parameter, rowBounds, boundSql);</span><br><span class="line">  <span class="keyword">return</span> query(ms, parameter, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接下来调用了这个方法</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="comment">//尝试从缓存中读取</span></span><br><span class="line">  Cache cache = ms.getCache();</span><br><span class="line">  <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;</span><br><span class="line">    flushCacheIfRequired(ms);</span><br><span class="line">    <span class="keyword">if</span> (ms.isUseCache() &amp;&amp; resultHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">      ensureNoOutParams(ms, boundSql);</span><br><span class="line">      <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">      List&lt;E&gt; list = (List&lt;E&gt;) tcm.getObject(cache, key);</span><br><span class="line">      <span class="keyword">if</span> (list == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//缓存中，查询结果为空，就继续查询</span></span><br><span class="line">        list = delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">        tcm.putObject(cache, key, list); <span class="comment">// issue #578 and #116</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果没有缓存，或缓存无效的话，会调用这个方法，从数据库中查询</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  ErrorContext.instance().resource(ms.getResource()).activity(<span class="string">"executing a query"</span>).object(ms.getId());</span><br><span class="line">  <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">"Executor was closed."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (queryStack == <span class="number">0</span> &amp;&amp; ms.isFlushCacheRequired()) &#123;</span><br><span class="line">    clearLocalCache();</span><br><span class="line">  &#125;</span><br><span class="line">  List&lt;E&gt; list;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    queryStack++;</span><br><span class="line">    list = resultHandler == <span class="keyword">null</span> ? (List&lt;E&gt;) localCache.getObject(key) : <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (list != <span class="keyword">null</span>) &#123;</span><br><span class="line">      handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//去数据库中查询</span></span><br><span class="line">      list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    queryStack--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (queryStack == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (DeferredLoad deferredLoad : deferredLoads) &#123;</span><br><span class="line">      deferredLoad.load();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// issue #601</span></span><br><span class="line">    deferredLoads.clear();</span><br><span class="line">    <span class="keyword">if</span> (configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) &#123;</span><br><span class="line">      <span class="comment">// issue #482</span></span><br><span class="line">      clearLocalCache();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从数据库中查询的实现</span></span><br><span class="line">  <span class="keyword">private</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">queryFromDatabase</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  List&lt;E&gt; list;</span><br><span class="line">  localCache.putObject(key, EXECUTION_PLACEHOLDER);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">//进行查询</span></span><br><span class="line">    list = doQuery(ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    localCache.removeObject(key);</span><br><span class="line">  &#125;</span><br><span class="line">  localCache.putObject(key, list);</span><br><span class="line">  <span class="keyword">if</span> (ms.getStatementType() == StatementType.CALLABLE) &#123;</span><br><span class="line">    localOutputParameterCache.putObject(key, parameter);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">doQuery</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">//获取configuration对象</span></span><br><span class="line">    Configuration configuration = ms.getConfiguration();</span><br><span class="line">    StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">    stmt = prepareStatement(handler, ms.getStatementLog());</span><br><span class="line">    <span class="keyword">return</span> handler.query(stmt, resultHandler);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    closeStatement(stmt);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(Statement statement, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  PreparedStatement ps = (PreparedStatement) statement;</span><br><span class="line">  ps.execute();</span><br><span class="line">  <span class="keyword">return</span> resultSetHandler.handleResultSets(ps);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(Statement statement, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  <span class="comment">//这里的sql就是可以执行的sql了</span></span><br><span class="line">  String sql = boundSql.getSql();</span><br><span class="line">  </span><br><span class="line">  statement.execute(sql);</span><br><span class="line">  <span class="comment">//对查询的结果集进行处理</span></span><br><span class="line">  <span class="keyword">return</span> resultSetHandler.handleResultSets(statement);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这部分也非常的复杂，以后专门研究一波，在写个博客吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们从最简单的一段代码开始，分析清楚mybatis的大致工作流程。然后再从代码细节上分析mybatis的一些特性。&lt;/p&gt;
&lt;h2 id=&quot;基础代码示例&quot;&gt;&lt;a href=&quot;#基础代码示例&quot; class=&quot;headerlink&quot; title=&quot;基础代码示例&quot;&gt;&lt;/a&gt;基础代码示例&lt;/h2&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;test&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; IOException&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    String resource = &lt;span class=&quot;string&quot;&gt;&quot;example/mybatis-config.xml&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 加载配置文件 并构建SqlSessionFactory对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    InputStream inputStream = Resources.getResourceAsStream(resource);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    SqlSessionFactory factory = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; SqlSessionFactoryBuilder().build(inputStream);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 从SqlSessionFactory对象中获取 SqlSession对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    SqlSession sqlSession = factory.openSession();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 执行操作&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    User user=&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; User();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    user.setId(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Object u= (User)sqlSession.selectOne(&lt;span class=&quot;string&quot;&gt;&quot;getUser&quot;&lt;/span&gt;, user);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    System.out.println(u.toString());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 关闭SqlSession&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    sqlSession.close();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="源码" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="mybatis" scheme="http://yoursite.com/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>CyclicBarrier源码分析</title>
    <link href="http://yoursite.com/2020/01/13/CyclicBarrier%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2020/01/13/CyclicBarrier源码分析/</id>
    <published>2020-01-13T03:29:56.000Z</published>
    <updated>2020-01-13T03:31:01.401Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="概述">概述</span></h2><p>CyclicBarrier是一个同步辅助类，它允许一组线程相互等待，直到达到某个公共屏障点。并且在释放等待线程之后，CyclicBarrier是可以重复使用的。<br><a id="more"></a></p><h2><span id="简单使用">简单使用</span></h2><p>下面这段代码利用了CyclicBarrier来使得线程创建后相互等待，直到所有的线程都准备好，以此来使多个线程同时执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CyclicBarrierTest cyclicBarrierTest=<span class="keyword">new</span> CyclicBarrierTest();</span><br><span class="line">        cyclicBarrierTest.runThread();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//有10个线程需要相互等待</span></span><br><span class="line">    CyclicBarrier cyclicBarrier=<span class="keyword">new</span> CyclicBarrier(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个线程</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Thread <span class="title">createThread</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        Thread thread=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//线程在此相互等待，直到所有线程都准备好</span></span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                    System.out.println(<span class="string">"thread"</span>+Thread.currentThread().getName()+<span class="string">"准备完毕"</span>+System.currentTimeMillis());</span><br><span class="line">                &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">catch</span> (BrokenBarrierException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.setName(<span class="string">"thread-"</span>+i);</span><br><span class="line">        <span class="keyword">return</span>  thread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runThread</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ExecutorService executorService= Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                executorService.submit(createThread(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="源码分析">源码分析</span></h2><h3><span id="核心属性">核心属性</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Generation</span> </span>&#123;</span><br><span class="line">    <span class="comment">//是否被销毁</span></span><br><span class="line">    <span class="keyword">boolean</span> broken = <span class="keyword">false</span>;<span class="comment">//false代表没被销毁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** The lock for guarding barrier entry ,守护入口的锁*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="comment">/** Condition to wait on until tripped，等待条件 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition trip = lock.newCondition();</span><br><span class="line"><span class="comment">/** The number of parties，要屏障的线程数 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> parties;</span><br><span class="line"><span class="comment">/* The command to run when tripped ，当线程都到待barrier，需要运行的内容*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Runnable barrierCommand;</span><br><span class="line"><span class="comment">/** The current generation ,记录当前barrier状态的对象*/</span></span><br><span class="line"><span class="keyword">private</span> Generation generation = <span class="keyword">new</span> Generation();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Number of parties still waiting. Counts down from parties to 0</span></span><br><span class="line"><span class="comment"> * on each generation.  It is reset to parties on each new</span></span><br><span class="line"><span class="comment"> * generation or when broken.</span></span><br><span class="line"><span class="comment"> *当前等待barrier到达的线程的数量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> count;</span><br></pre></td></tr></table></figure><h3><span id="重要方法分析">重要方法分析</span></h3><h4><span id="await方法">await方法</span></h4><p><code>int await()</code>方法的具体实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dowait(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (TimeoutException toe) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(toe); <span class="comment">// cannot happen</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从这个方法可以看出，实际上起作用的就是<code>dowait(false, 0L);</code>.<br>那我们来看一下<code>dowait(false, 0L);</code>的具体实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dowait</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, BrokenBarrierException,</span></span><br><span class="line"><span class="function">               TimeoutException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        <span class="comment">//获取锁，整段代码都使用该锁进行同步</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取当前的generation</span></span><br><span class="line">            <span class="keyword">final</span> Generation g = generation;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (g.broken)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">                breakBarrier(); <span class="comment">//如果线程被中断，就会终止Barrier，唤醒所有的等待线程</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//count就是我们实例化CyclicBarrier时传入的值</span></span><br><span class="line">            <span class="comment">//此时index代表当前是最后几个等待的线程</span></span><br><span class="line">            <span class="keyword">int</span> index = --count;</span><br><span class="line">            <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;  <span class="comment">// tripped</span></span><br><span class="line">                <span class="comment">//如过当前线程是最后一个等待的线程</span></span><br><span class="line">                <span class="comment">//它都已经调用await，说明所有线程都已经到达</span></span><br><span class="line">                <span class="comment">//屏障点了，可以唤醒所有线程了</span></span><br><span class="line">                <span class="keyword">boolean</span> ranAction = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//如果有barrierCommand，就运行它</span></span><br><span class="line">                    <span class="keyword">final</span> Runnable command = barrierCommand;</span><br><span class="line">                    <span class="keyword">if</span> (command != <span class="keyword">null</span>)</span><br><span class="line">                        command.run();</span><br><span class="line">                    ranAction = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="comment">//更新Barrier状态，并唤醒所有线程</span></span><br><span class="line">                    nextGeneration();</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!ranAction)</span><br><span class="line">                        breakBarrier();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// loop until tripped, broken, interrupted, or timed out</span></span><br><span class="line">            <span class="comment">//自旋等待，直到所有线程都到达屏障点</span></span><br><span class="line">            <span class="comment">//或者发生中断</span></span><br><span class="line">            <span class="comment">//或者generation被销毁</span></span><br><span class="line">            <span class="comment">//或者超时</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!timed)</span><br><span class="line">                        trip.await(); <span class="comment">//在此利用lock的Condition阻塞，当前线程</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0L</span>)</span><br><span class="line">                        nanos = trip.awaitNanos(nanos);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123;</span><br><span class="line">                        breakBarrier();</span><br><span class="line">                        <span class="keyword">throw</span> ie;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// We're about to finish waiting even if we had not</span></span><br><span class="line">                        <span class="comment">// been interrupted, so this interrupt is deemed to</span></span><br><span class="line">                        <span class="comment">// "belong" to subsequent execution.</span></span><br><span class="line">                        Thread.currentThread().interrupt();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (g.broken)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (g != generation)</span><br><span class="line">                    <span class="keyword">return</span> index;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                    breakBarrier(); <span class="comment">//超时就销毁当前Barrier</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>在这个方法中，还有几个比较重要的方法。<br>用于销毁Barrier的<code>void breakBarrier()</code>方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">breakBarrier</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//将当前gengeration标记为弃用状态</span></span><br><span class="line">    generation.broken = <span class="keyword">true</span>;</span><br><span class="line">    count = parties;<span class="comment">//将等待barrier的线程数量，恢复到之前的值</span></span><br><span class="line">    trip.signalAll(); <span class="comment">//唤醒锁上的Condition上等待的所有线程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>用于重置CyclicBarrier和唤醒所有等待线程的<code>void nextGeneration()</code>方法实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">nextGeneration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// signal completion of last generation</span></span><br><span class="line">    trip.signalAll(); <span class="comment">//唤醒所有的等待线程</span></span><br><span class="line">    <span class="comment">// set up next generation</span></span><br><span class="line">    count = parties;<span class="comment">//将等待线程数复原，以便CyclicBarrier下次重复使用</span></span><br><span class="line">    generation = <span class="keyword">new</span> Generation(); <span class="comment">//复原generation</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>整体看下来，这个CyclicBarrier的实现还是比较简单，我们在实例化CyclicBarrier的时候就指定了一个需要相互等待的线程数。每当一个线程调用await方法的时候，都会去判断，自己是不是最后一个线程，如果自己是最后一个线程，那么说明其它线程都在阻塞等待自己，那么就去唤醒所有等待的线程。如果自己不是最后一个线程，那么就需要去等待其它的线程，那么就去自旋，或者阻塞。</p><p>在整个源码中比较重要的一点就是CyclicBarrier内部利用了一个ReentrantLock利用它来对代码块加锁，让线程在它的Condition上阻塞。<br>每个CyclicBarrier内部都维护了一个Generation对象，它主要是记录当前CyclicBarrier的状态，即是否被弃用。因为CyclicBarrier是可以重复使用的，因此在所有线程都到达屏障点的时候，会调用<code>nextGeneration()</code>来重置整个CyclicBarrier，方便下次使用。</p><p>还需要注意的是，CyclicBarrier是会响应中断，一旦发生中断，就会重置CyclicBarrier，并唤醒等待的线程。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;CyclicBarrier是一个同步辅助类，它允许一组线程相互等待，直到达到某个公共屏障点。并且在释放等待线程之后，CyclicBarrier是可以重复使用的。&lt;br&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="源码" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>CountDownLatch源码分析</title>
    <link href="http://yoursite.com/2020/01/12/CountDownLatch%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2020/01/12/CountDownLatch源码分析/</id>
    <published>2020-01-12T06:57:56.000Z</published>
    <updated>2020-01-12T06:57:20.978Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="概述">概述</span></h2><p>CountDownLatch允许一个或多个线程等待直到在其他线程中执行的一组操作完成的同步辅助。简单来说，就是CountDownLatch内部维护了一个计数器，每个线程完成自己的操作之后都会将计数器减一，然后会在计数器的值变为0之前一直阻塞，直到计数器的值变为0.<br><a id="more"></a></p><h2><span id="简单使用">简单使用</span></h2><p>这个例子主要演示了，如何利用CountDownLatch去协调多个线程同时开始运行。这个时候的CountDownLatch中的计数器的现实含义是等待创建的线程个数，每个线程在开始任务之前都会调用await()方法阻塞，直到所有线程都创建好，每当一个线程创建好后，都会提交调用countDown()方法将计数器的值减一(代表待创建的线程数减一)。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Test countDownLatchTest=<span class="keyword">new</span> Test();</span><br><span class="line">    countDownLatchTest.runThread();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//计数器为10，代表有10个线程等待创建</span></span><br><span class="line">CountDownLatch countDownLatch=<span class="keyword">new</span> CountDownLatch(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个线程</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Thread <span class="title">createThread</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    Thread thread=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//在此等待，直到计数器变为0</span></span><br><span class="line">                countDownLatch.await();</span><br><span class="line">                System.out.println(<span class="string">"thread"</span>+Thread.currentThread().getName()+<span class="string">"准备完毕"</span>+System.currentTimeMillis());</span><br><span class="line">            &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    thread.setName(<span class="string">"thread-"</span>+i);</span><br><span class="line">    <span class="keyword">return</span>  thread;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runThread</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ExecutorService executorService= Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            executorService.submit(createThread(i));</span><br><span class="line">            <span class="comment">//一个线程创建好了，待创建的线程数减一</span></span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面我们就以这个例子，来解释源码：</p><h2><span id="源码分析">源码分析</span></h2><h3><span id="继承体系">继承体系</span></h3><p><img src="https://s2.ax1x.com/2020/01/12/loAkrt.png" alt="loAkrt.png"></p><p>从锁的分类上来讲，CountDownLatch其实是一个”共享锁“。还有一个需要注意的是CountDownLath是响应中断的，如果线程在对锁进行操作的期间发生了中断，会直接抛出InterruptedException。</p><h3><span id="源码分析">源码分析</span></h3><h4><span id="计数器的本质是什么">计数器的本质是什么？</span></h4><p>刚才我们也提到了，CountDownLatch中一个非常重要的东西就是计数器。那么我们首先需要分析的就是源码中哪个部分充当了计数器的角色。<br>我们通过构造方法来查看：<br>我们的代码<code>CountDownLatch countDownLatch=new CountDownLatch(10);</code>背后实际上是调用了下面这个方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"count &lt; 0"</span>);</span><br><span class="line">    <span class="keyword">this</span>.sync = <span class="keyword">new</span> Sync(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>而这个Sync的实例化又做了什么工作呢？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Sync(<span class="keyword">int</span> count) &#123;</span><br><span class="line">    setState(count); <span class="comment">//就是修改了AQS中的state值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在已经解决了我们的第一个问题，实际上AQS中的state充当了计数器。</p><h4><span id="await方法">await方法</span></h4><ol><li><p>await方法实际上是调用了sync的一个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>sync的<code>void acquireSharedInterruptibly(int arg)</code>的实现如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">    <span class="comment">//如果线程中断了，则抛异常。</span></span><br><span class="line">    <span class="comment">//证明了之前所说的CountDownLatch是会响应中断的</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果没有中断，就会调用<code>tryAcquireShared(arg)</code><br>它的实现非常的简单，如果state为0，就返回1，否则返回-1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果state不为0，就会返回-1，if条件成立，就会调用<code>doAcquireSharedInterruptibly(arg)</code><br>这个方法的实现，稍微复杂一点，但这个方法也不陌生了，它的功能就是把该线程加入等待队列中并阻塞，但是在入队之后，不一定会立即park阻塞，它会判断自己是否是第二个节点，如果是就会再次尝试获取。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor(); <span class="comment">//获取当前节点的前驱节点</span></span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;<span class="comment">//前一个节点是头节点</span></span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg); <span class="comment">//去看一看state是否为0，步骤3分析过</span></span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//如果state目前为0，就出队</span></span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="comment">//进入阻塞队列阻塞，如果发生中断，则抛异常</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><p>CountDownLatch的await方法比其它几个锁的实现简单得多。不过需要注意的一点就是CountDownLatch是会响应中断的，这一点在源码中也有多处体现。</p><h4><span id="countdown方法">countDown方法</span></h4><ol><li><p>countDown方法实际上是调用sync中的一个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>boolean releaseShared(int arg)</code>的具体实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>tryReleaseShared(arg)</code>方法的具体实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">           <span class="comment">// Decrement count; signal when transition to zero</span></span><br><span class="line">           <span class="keyword">for</span> (;;) &#123;<span class="comment">//自旋</span></span><br><span class="line">               <span class="keyword">int</span> c = getState();</span><br><span class="line">               <span class="keyword">if</span> (c == <span class="number">0</span>)<span class="comment">//计数器已经都是0了，当然会释放失败咯</span></span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">               <span class="keyword">int</span> nextc = c-<span class="number">1</span>;<span class="comment">//释放后，计数器减一</span></span><br><span class="line">               <span class="keyword">if</span> (compareAndSetState(c, nextc))<span class="comment">//CAS修改计数器</span></span><br><span class="line">                   <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></li></ol><p>这个方法就是去尝试直接修改state的值。如果state的修改成功，且修改后的state值为0，就会返回true。就会执行<code>doReleaseShared();</code>方法。</p><ol start="4"><li><code>doReleaseShared();</code>的实现如下，它的作用就是state为0的时候，去唤醒等待队列中的线程。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Ensure that a release propagates, even if there are other</span></span><br><span class="line"><span class="comment">     * in-progress acquires/releases.  This proceeds in the usual</span></span><br><span class="line"><span class="comment">     * way of trying to unparkSuccessor of head if it needs</span></span><br><span class="line"><span class="comment">     * signal. But if it does not, status is set to PROPAGATE to</span></span><br><span class="line"><span class="comment">     * ensure that upon release, propagation continues.</span></span><br><span class="line"><span class="comment">     * Additionally, we must loop in case a new node is added</span></span><br><span class="line"><span class="comment">     * while we are doing this. Also, unlike other uses of</span></span><br><span class="line"><span class="comment">     * unparkSuccessor, we need to know if CAS to reset status</span></span><br><span class="line"><span class="comment">     * fails, if so rechecking.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; <span class="comment">//自旋</span></span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>现在基本源码已经分析完毕了，只要理解了AQS和CountDownLatch的计数器到底是什么，就能够很好的理解CountDownLatch的原理了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;CountDownLatch允许一个或多个线程等待直到在其他线程中执行的一组操作完成的同步辅助。简单来说，就是CountDownLatch内部维护了一个计数器，每个线程完成自己的操作之后都会将计数器减一，然后会在计数器的值变为0之前一直阻塞，直到计数器的值变为0.&lt;br&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="源码" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>ReentrantReadWriteLock源码分析</title>
    <link href="http://yoursite.com/2020/01/11/ReentrantReadWriteLock%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2020/01/11/ReentrantReadWriteLock源码分析/</id>
    <published>2020-01-11T07:03:56.000Z</published>
    <updated>2020-01-11T07:10:27.381Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="概述">概述</span></h2><p>ReentrantReadWriteLock维护了一对相关的锁，它们分别是共享readLock和独占writeLock。关于共享读锁和排他写锁的概念其实很好理解。所谓共享读锁就是一个线程读的时候，其它线程也可以来读（共享），但是不能来写。排他写锁是指一个线程在写的时候，其它线程不能来写或读（排他）。除了这个特点之外，ReentrantReadWriteLock还有一个特点就是可重入的。它和ReentrantLock一样都是支持Condition的。而且ReentrantReadWerite还支持锁降级，即允许将写锁降级为读锁。<br><a id="more"></a></p><h2><span id="简单使用">简单使用</span></h2><p>最最基础的用法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ReentrantReadWriteLock lock=<span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    lock.readLock().lock();</span><br><span class="line">    <span class="comment">//需要加读锁的操作</span></span><br><span class="line">    lock.readLock().unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span></span>&#123;</span><br><span class="line">    lock.writeLock().lock();</span><br><span class="line">    <span class="comment">//需要加写锁的操作</span></span><br><span class="line">    lock.writeLock().unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ReentrantReadWriteLock无非就是这几种情况，读读共享，写写互斥，读写互斥，写读互斥。</p><p>下面我们就以这个最基础的用法，来分析一下其内部的原理</p><h2><span id="源码分析">源码分析</span></h2><h3><span id="继承体系">继承体系</span></h3><p><img src="https://s2.ax1x.com/2020/01/11/l5kuct.md.png" alt="l5kuct.md.png"></p><h3><span id="共享读锁的实现原理分析">共享读锁的实现原理分析</span></h3><h4><span id="lock方法">lock方法</span></h4><ol><li><p>首先进入调用具体的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.acquireShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>然后调用了这个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>其中<code>int tryAcquireShared(int unused)</code>的具体实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">           <span class="comment">/*</span></span><br><span class="line"><span class="comment">            * Walkthrough:</span></span><br><span class="line"><span class="comment">            * 1. If write lock held by another thread, fail.</span></span><br><span class="line"><span class="comment">            * 2. Otherwise, this thread is eligible for</span></span><br><span class="line"><span class="comment">            *    lock wrt state, so ask if it should block</span></span><br><span class="line"><span class="comment">            *    because of queue policy. If not, try</span></span><br><span class="line"><span class="comment">            *    to grant by CASing state and updating count.</span></span><br><span class="line"><span class="comment">            *    Note that step does not check for reentrant</span></span><br><span class="line"><span class="comment">            *    acquires, which is postponed to full version</span></span><br><span class="line"><span class="comment">            *    to avoid having to check hold count in</span></span><br><span class="line"><span class="comment">            *    the more typical non-reentrant case.</span></span><br><span class="line"><span class="comment">            * 3. If step 2 fails either because thread</span></span><br><span class="line"><span class="comment">            *    apparently not eligible or CAS fails or count</span></span><br><span class="line"><span class="comment">            *    saturated, chain to version with full retry loop.</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           Thread current = Thread.currentThread();</span><br><span class="line">           <span class="keyword">int</span> c = getState();</span><br><span class="line">           <span class="comment">//持有写锁的线程可以获取读锁，如果获取锁的线程不是当前线程，则返回-1</span></span><br><span class="line">           <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">               getExclusiveOwnerThread() != current)</span><br><span class="line">               <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">           <span class="keyword">int</span> r = sharedCount(c);<span class="comment">//获取共享读锁的数量</span></span><br><span class="line">           <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp;</span><br><span class="line">               r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">               compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">               <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="comment">//如果首次获取锁，则初始化firstReader和firstReaderHoldCount</span></span><br><span class="line">                   firstReader = current;</span><br><span class="line">                   firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">               &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">               <span class="comment">//如果当前线程是首次获取读锁的线程</span></span><br><span class="line">                   firstReaderHoldCount++;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">//更新HoldCounter</span></span><br><span class="line">                   HoldCounter rh = cachedHoldCounter;</span><br><span class="line">                   <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                       cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">                   <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                       readHolds.set(rh);</span><br><span class="line">                   rh.count++;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></p><p>整个函数的工作流程如下：</p><ul><li>如果写锁已经被持有了，但是持有写锁的不是当前写出，那么就直接返回-1（体现写锁的排他性）.</li><li>如果在尝试获取锁是不需要阻塞等待（由锁的公平性决定），并且读锁的共享计数小于最大值，那么就直接通过CAS更新读锁数量，获取读锁。</li><li>如果第二步执行失败了，那么就会调用<code>fullTryAcquireShared(current)</code></li></ul><p><code>fullTryAcquireShared(current)</code>的具体实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullTryAcquireShared</span><span class="params">(Thread current)</span> </span>&#123;</span><br><span class="line">           <span class="comment">/*</span></span><br><span class="line"><span class="comment">            * This code is in part redundant with that in</span></span><br><span class="line"><span class="comment">            * tryAcquireShared but is simpler overall by not</span></span><br><span class="line"><span class="comment">            * complicating tryAcquireShared with interactions between</span></span><br><span class="line"><span class="comment">            * retries and lazily reading hold counts.</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           HoldCounter rh = <span class="keyword">null</span>;</span><br><span class="line">           <span class="keyword">for</span> (;;) &#123; <span class="comment">//自旋</span></span><br><span class="line">               <span class="keyword">int</span> c = getState();</span><br><span class="line">               <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span>) &#123; <span class="comment">//写锁已经被持有了</span></span><br><span class="line">                   <span class="keyword">if</span> (getExclusiveOwnerThread() != current) <span class="comment">//持有写锁的不是单线程</span></span><br><span class="line">                       <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">//其它线程持有读锁后，就不能在获取写锁了</span></span><br><span class="line">                   <span class="comment">// else we hold the exclusive lock; blocking here</span></span><br><span class="line">                   <span class="comment">// would cause deadlock.</span></span><br><span class="line">               &#125; <span class="keyword">else</span> <span class="keyword">if</span> (readerShouldBlock()) &#123;<span class="comment">//由公平性决定需要阻塞</span></span><br><span class="line">                   <span class="comment">// Make sure we're not acquiring read lock reentrantly</span></span><br><span class="line">                   <span class="keyword">if</span> (firstReader == current) &#123; </span><br><span class="line">                       <span class="comment">// assert firstReaderHoldCount &gt; 0;</span></span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="comment">//更新锁计数（可重入的体现）</span></span><br><span class="line">                       <span class="keyword">if</span> (rh == <span class="keyword">null</span>) &#123;</span><br><span class="line">                           rh = cachedHoldCounter;</span><br><span class="line">                           <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current)) &#123;</span><br><span class="line">                               rh = readHolds.get();</span><br><span class="line">                               <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                               <span class="comment">//如果当前线程的持有读锁数为0，那么就没必要使用计数器，直接移除</span></span><br><span class="line">                                   readHolds.remove();</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                           <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (sharedCount(c) == MAX_COUNT) <span class="comment">//如果读锁的数量超过最大值了</span></span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">               <span class="keyword">if</span> (compareAndSetState(c, c + SHARED_UNIT)) &#123; <span class="comment">//CAS更新读锁数量</span></span><br><span class="line">                   <span class="keyword">if</span> (sharedCount(c) == <span class="number">0</span>) &#123;</span><br><span class="line">                   <span class="comment">//首次获取读锁</span></span><br><span class="line">                       firstReader = current;</span><br><span class="line">                       firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">                   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                   <span class="comment">//当前线程是首次获取读锁的线程，直接更新持有数</span></span><br><span class="line">                       firstReaderHoldCount++;</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="comment">//当前线程是后来共享读锁的线程</span></span><br><span class="line">                       <span class="keyword">if</span> (rh == <span class="keyword">null</span>)</span><br><span class="line">                           rh = cachedHoldCounter;</span><br><span class="line">                       <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                           rh = readHolds.get();<span class="comment">//更新为当前线程的计数器 </span></span><br><span class="line">                       <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                           readHolds.set(rh);</span><br><span class="line">                       rh.count++;</span><br><span class="line">                       cachedHoldCounter = rh; <span class="comment">// cache for release</span></span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></p><p>可以看出其实<code>int fullTryAcquireShared(Thread current)</code>也每什么特别，它的代码和<code>int tryAcquireShared(int unused)</code>差不多。只不过是增加了自旋重试，和“持有读锁数的延迟读取”</p><ol start="3"><li>我们回到<code>void acquireShared(int arg)</code>方法，如果<code>tryAcquireShared(arg)</code>获取读锁失败后，它调用的<code>doAcquireShared(arg)</code>又做了什么呢？<br>它的具体实现如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> Node node = addWaiter(Node.SHARED); <span class="comment">//添加一个共享模式的Node到等待队列尾部</span></span><br><span class="line">       <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>; <span class="comment">//获取前驱节点</span></span><br><span class="line">           <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">               <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">               <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">               <span class="comment">//如果前驱节点，尝试获取资源</span></span><br><span class="line">                   <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                   <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                   <span class="comment">//获取成功，更新等待队列，并唤醒下一个等待的节点</span></span><br><span class="line">                       setHeadAndPropagate(node, r);</span><br><span class="line">                       p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                       <span class="keyword">if</span> (interrupted)</span><br><span class="line">                           selfInterrupt();</span><br><span class="line">                       failed = <span class="keyword">false</span>;</span><br><span class="line">                       <span class="keyword">return</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; <span class="comment">//检查获取失败后是否可以阻塞</span></span><br><span class="line">                   parkAndCheckInterrupt())</span><br><span class="line">                   interrupted = <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (failed)</span><br><span class="line">               cancelAcquire(node);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ol><p>其实整个获取共享读锁的源码看下来，我们可以发现，AQS框架下，获取锁一般的流程就是首先尝试去直接获取，如果获取不到了，那么尝试自旋获取，如果还是获取不到，那么就去等待队列排队，排队的时候，如果发现自己是第二个那么就再次尝试获取锁，如果还是没获取到，那么就老老实实的在等待队列中park阻塞等待了。</p><p>我们通过源码，也可发现AQS框架下的锁，其实如果线程之间对锁的争用很低的时候，大多数时候直接就能拿到锁，几乎不需要排队，阻塞之类的，性能非常之高。</p><h4><span id="unlock方法">unlock方法</span></h4><ol><li><p>第一步还是调用具体的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>具体的实现如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>首先来看<code>tryReleaseShared(arg)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">          Thread current = Thread.currentThread();</span><br><span class="line">          <span class="keyword">if</span> (firstReader == current) &#123; <span class="comment">//如过当前线程是第一获取到读锁的线程</span></span><br><span class="line">              <span class="comment">// assert firstReaderHoldCount &gt; 0;</span></span><br><span class="line">              <span class="comment">//直接更新线程持有数</span></span><br><span class="line">              <span class="keyword">if</span> (firstReaderHoldCount == <span class="number">1</span>)</span><br><span class="line">                  firstReader = <span class="keyword">null</span>;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                  firstReaderHoldCount--;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              HoldCounter rh = cachedHoldCounter;</span><br><span class="line">              <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                  rh = readHolds.get(); <span class="comment">//获取当前线程的计数器</span></span><br><span class="line">              <span class="keyword">int</span> count = rh.count;</span><br><span class="line">              <span class="keyword">if</span> (count &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">                  readHolds.remove();</span><br><span class="line">                  <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">                      <span class="keyword">throw</span> unmatchedUnlockException();</span><br><span class="line">              &#125;</span><br><span class="line">              --rh.count;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">for</span> (;;) &#123; <span class="comment">//自旋</span></span><br><span class="line">              <span class="keyword">int</span> c = getState();</span><br><span class="line">              <span class="keyword">int</span> nextc = c - SHARED_UNIT;</span><br><span class="line">              <span class="keyword">if</span> (compareAndSetState(c, nextc)) <span class="comment">//更新state</span></span><br><span class="line">                  <span class="comment">// Releasing the read lock has no effect on readers,</span></span><br><span class="line">                  <span class="comment">// but it may allow waiting writers to proceed if</span></span><br><span class="line">                  <span class="comment">// both read and write locks are now free.</span></span><br><span class="line">                  <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></li></ol><p>我们从<code>tryReleaseShared(arg)</code>的实现中可以看出，它的主要是去更新锁计数器和state。如果state为0的话，就返回true，否则就返回false。</p><ol start="3"><li>我们回过头看，如果<code>tryReleaseShared(arg)</code>返回true，即锁释放后state为0了，那么它会执行<code>doReleaseShared();</code>方法，它的具体实现如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * Ensure that a release propagates, even if there are other</span></span><br><span class="line"><span class="comment">        * in-progress acquires/releases.  This proceeds in the usual</span></span><br><span class="line"><span class="comment">        * way of trying to unparkSuccessor of head if it needs</span></span><br><span class="line"><span class="comment">        * signal. But if it does not, status is set to PROPAGATE to</span></span><br><span class="line"><span class="comment">        * ensure that upon release, propagation continues.</span></span><br><span class="line"><span class="comment">        * Additionally, we must loop in case a new node is added</span></span><br><span class="line"><span class="comment">        * while we are doing this. Also, unlike other uses of</span></span><br><span class="line"><span class="comment">        * unparkSuccessor, we need to know if CAS to reset status</span></span><br><span class="line"><span class="comment">        * fails, if so rechecking.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">           Node h = head;</span><br><span class="line">           <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">               <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">               <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                       <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                   unparkSuccessor(h);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                        !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                   <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ol><p>这个方法的作用就是唤醒等待队列中线程，现在资源已经空闲了，等待的线程可以唤醒来获取锁了。</p><h3><span id="排他写锁的实现原理分析">排他写锁的实现原理分析</span></h3><p>排他写锁的实现原理其实和ReentrantLock一致。我们只看几处和共享读锁不同的地方。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//公平锁实现</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp; <span class="comment">//判断当前线程是否还有前节点</span></span><br><span class="line">                    compareAndSetState(<span class="number">0</span>, acquires)) &#123;<span class="comment">//CAS修改state</span></span><br><span class="line">                    <span class="comment">//获取锁成功，设置锁的持有线程为当前线程</span></span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<span class="comment">//该线程之前已经拿到锁</span></span><br><span class="line">                <span class="keyword">int</span> nextc = c + acquires; <span class="comment">//重入的体现</span></span><br><span class="line">                <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">                setState(nextc); <span class="comment">//更新State</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p><p>其实非公平锁的实现也差不多，只不过少了<code>!hasQueuedPredecessors()</code>它不会去判断当前线程是否还有前驱节点，直接就开始获取锁了。</p><p>unlock方法也差不多我就不赘述了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;ReentrantReadWriteLock维护了一对相关的锁，它们分别是共享readLock和独占writeLock。关于共享读锁和排他写锁的概念其实很好理解。所谓共享读锁就是一个线程读的时候，其它线程也可以来读（共享），但是不能来写。排他写锁是指一个线程在写的时候，其它线程不能来写或读（排他）。除了这个特点之外，ReentrantReadWriteLock还有一个特点就是可重入的。它和ReentrantLock一样都是支持Condition的。而且ReentrantReadWerite还支持锁降级，即允许将写锁降级为读锁。&lt;br&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="源码" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
</feed>
